/*! For license information please see editor.js.LICENSE.txt */
!function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.EDITOR = t() : e.EDITOR = t()
}(self, (function() {
    return (()=>{
        var e = {
            1903: (e,t,n)=>{
                "use strict";
                n.d(t, {
                    X: ()=>i
                });
                var r = n(2212);
                class i extends r.Loader {
                    load(e, t, n, i) {
                        const a = new r.FileLoader(this.manager);
                        a.setPath(this.path),
                        a.setResponseType("text"),
                        a.load(e, (n=>{
                            try {
                                t(this.parse(n))
                            } catch (t) {
                                i ? i(t) : console.error(t),
                                this.manager.itemError(e)
                            }
                        }
                        ), n, i)
                    }
                    parse(e) {
                        e = e.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
                        let t = null
                          , n = null;
                        const i = new r.Vector3(0,0,0)
                          , a = new r.Vector3(1,1,1)
                          , o = e.split(/[\n\r]+/g);
                        let s = null
                          , l = 0;
                        for (let e = 0, r = o.length; e < r; e++) {
                            const r = o[e].trim()
                              , c = r.split(/\s/g);
                            switch (c[0]) {
                            case "TITLE":
                                t = r.substring(7, r.length - 1);
                                break;
                            case "LUT_3D_SIZE":
                                const e = c[1];
                                n = parseFloat(e),
                                s = new Uint8Array(n * n * n * 3);
                                break;
                            case "DOMAIN_MIN":
                                i.x = parseFloat(c[1]),
                                i.y = parseFloat(c[2]),
                                i.z = parseFloat(c[3]);
                                break;
                            case "DOMAIN_MAX":
                                a.x = parseFloat(c[1]),
                                a.y = parseFloat(c[2]),
                                a.z = parseFloat(c[3]);
                                break;
                            default:
                                const o = parseFloat(c[0])
                                  , u = parseFloat(c[1])
                                  , h = parseFloat(c[2]);
                                if (o > 1 || o < 0 || u > 1 || u < 0 || h > 1 || h < 0)
                                    throw new Error("LUTCubeLoader : Non normalized values not supported.");
                                s[l + 0] = 255 * o,
                                s[l + 1] = 255 * u,
                                s[l + 2] = 255 * h,
                                l += 3
                            }
                        }
                        const c = new r.DataTexture;
                        c.image.data = s,
                        c.image.width = n,
                        c.image.height = n * n,
                        c.format = r.RGBFormat,
                        c.type = r.UnsignedByteType,
                        c.magFilter = r.LinearFilter,
                        c.wrapS = r.ClampToEdgeWrapping,
                        c.wrapT = r.ClampToEdgeWrapping,
                        c.generateMipmaps = !1;
                        const u = new r.DataTexture3D;
                        return u.image.data = s,
                        u.image.width = n,
                        u.image.height = n,
                        u.image.depth = n,
                        u.format = r.RGBFormat,
                        u.type = r.UnsignedByteType,
                        u.magFilter = r.LinearFilter,
                        u.wrapS = r.ClampToEdgeWrapping,
                        u.wrapT = r.ClampToEdgeWrapping,
                        u.wrapR = r.ClampToEdgeWrapping,
                        u.generateMipmaps = !1,
                        {
                            title: t,
                            size: n,
                            domainMin: i,
                            domainMax: a,
                            texture: c,
                            texture3D: u
                        }
                    }
                }
            }
            ,
            6194: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    default: ()=>_,
                    Easing: ()=>i,
                    Group: ()=>o,
                    Interpolation: ()=>s,
                    Sequence: ()=>l,
                    Tween: ()=>u,
                    VERSION: ()=>h,
                    add: ()=>g,
                    getAll: ()=>f,
                    nextId: ()=>d,
                    now: ()=>a,
                    remove: ()=>v,
                    removeAll: ()=>m,
                    update: ()=>y
                });
                var r, i = {
                    Linear: {
                        None: function(e) {
                            return e
                        }
                    },
                    Quadratic: {
                        In: function(e) {
                            return e * e
                        },
                        Out: function(e) {
                            return e * (2 - e)
                        },
                        InOut: function(e) {
                            return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                        }
                    },
                    Cubic: {
                        In: function(e) {
                            return e * e * e
                        },
                        Out: function(e) {
                            return --e * e * e + 1
                        },
                        InOut: function(e) {
                            return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                        }
                    },
                    Quartic: {
                        In: function(e) {
                            return e * e * e * e
                        },
                        Out: function(e) {
                            return 1 - --e * e * e * e
                        },
                        InOut: function(e) {
                            return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                        }
                    },
                    Quintic: {
                        In: function(e) {
                            return e * e * e * e * e
                        },
                        Out: function(e) {
                            return --e * e * e * e * e + 1
                        },
                        InOut: function(e) {
                            return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                        }
                    },
                    Sinusoidal: {
                        In: function(e) {
                            return 1 - Math.cos(e * Math.PI / 2)
                        },
                        Out: function(e) {
                            return Math.sin(e * Math.PI / 2)
                        },
                        InOut: function(e) {
                            return .5 * (1 - Math.cos(Math.PI * e))
                        }
                    },
                    Exponential: {
                        In: function(e) {
                            return 0 === e ? 0 : Math.pow(1024, e - 1)
                        },
                        Out: function(e) {
                            return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                        },
                        InOut: function(e) {
                            return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                        }
                    },
                    Circular: {
                        In: function(e) {
                            return 1 - Math.sqrt(1 - e * e)
                        },
                        Out: function(e) {
                            return Math.sqrt(1 - --e * e)
                        },
                        InOut: function(e) {
                            return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                        }
                    },
                    Elastic: {
                        In: function(e) {
                            return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
                        },
                        Out: function(e) {
                            return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
                        },
                        InOut: function(e) {
                            return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
                        }
                    },
                    Back: {
                        In: function(e) {
                            var t = 1.70158;
                            return e * e * ((t + 1) * e - t)
                        },
                        Out: function(e) {
                            var t = 1.70158;
                            return --e * e * ((t + 1) * e + t) + 1
                        },
                        InOut: function(e) {
                            var t = 2.5949095;
                            return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
                        }
                    },
                    Bounce: {
                        In: function(e) {
                            return 1 - i.Bounce.Out(1 - e)
                        },
                        Out: function(e) {
                            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                        },
                        InOut: function(e) {
                            return e < .5 ? .5 * i.Bounce.In(2 * e) : .5 * i.Bounce.Out(2 * e - 1) + .5
                        }
                    }
                }, a = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function() {
                    var e = process.hrtime();
                    return 1e3 * e[0] + e[1] / 1e6
                }
                : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function() {
                    return (new Date).getTime()
                }
                , o = function() {
                    function e() {
                        this._tweens = {},
                        this._tweensAddedDuringUpdate = {}
                    }
                    return e.prototype.getAll = function() {
                        var e = this;
                        return Object.keys(this._tweens).map((function(t) {
                            return e._tweens[t]
                        }
                        ))
                    }
                    ,
                    e.prototype.removeAll = function() {
                        this._tweens = {}
                    }
                    ,
                    e.prototype.add = function(e) {
                        this._tweens[e.getId()] = e,
                        this._tweensAddedDuringUpdate[e.getId()] = e
                    }
                    ,
                    e.prototype.remove = function(e) {
                        delete this._tweens[e.getId()],
                        delete this._tweensAddedDuringUpdate[e.getId()]
                    }
                    ,
                    e.prototype.update = function(e, t) {
                        void 0 === e && (e = a()),
                        void 0 === t && (t = !1);
                        var n = Object.keys(this._tweens);
                        if (0 === n.length)
                            return !1;
                        for (; n.length > 0; ) {
                            this._tweensAddedDuringUpdate = {};
                            for (var r = 0; r < n.length; r++) {
                                var i = this._tweens[n[r]]
                                  , o = !t;
                                i && !1 === i.update(e, o) && !t && delete this._tweens[n[r]]
                            }
                            n = Object.keys(this._tweensAddedDuringUpdate)
                        }
                        return !0
                    }
                    ,
                    e
                }(), s = {
                    Linear: function(e, t) {
                        var n = e.length - 1
                          , r = n * t
                          , i = Math.floor(r)
                          , a = s.Utils.Linear;
                        return t < 0 ? a(e[0], e[1], r) : t > 1 ? a(e[n], e[n - 1], n - r) : a(e[i], e[i + 1 > n ? n : i + 1], r - i)
                    },
                    Bezier: function(e, t) {
                        for (var n = 0, r = e.length - 1, i = Math.pow, a = s.Utils.Bernstein, o = 0; o <= r; o++)
                            n += i(1 - t, r - o) * i(t, o) * e[o] * a(r, o);
                        return n
                    },
                    CatmullRom: function(e, t) {
                        var n = e.length - 1
                          , r = n * t
                          , i = Math.floor(r)
                          , a = s.Utils.CatmullRom;
                        return e[0] === e[n] ? (t < 0 && (i = Math.floor(r = n * (1 + t))),
                        a(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i)) : t < 0 ? e[0] - (a(e[0], e[0], e[1], e[1], -r) - e[0]) : t > 1 ? e[n] - (a(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : a(e[i ? i - 1 : 0], e[i], e[n < i + 1 ? n : i + 1], e[n < i + 2 ? n : i + 2], r - i)
                    },
                    Utils: {
                        Linear: function(e, t, n) {
                            return (t - e) * n + e
                        },
                        Bernstein: function(e, t) {
                            var n = s.Utils.Factorial;
                            return n(e) / n(t) / n(e - t)
                        },
                        Factorial: (r = [1],
                        function(e) {
                            var t = 1;
                            if (r[e])
                                return r[e];
                            for (var n = e; n > 1; n--)
                                t *= n;
                            return r[e] = t,
                            t
                        }
                        ),
                        CatmullRom: function(e, t, n, r, i) {
                            var a = .5 * (n - e)
                              , o = .5 * (r - t)
                              , s = i * i;
                            return (2 * t - 2 * n + a + o) * (i * s) + (-3 * t + 3 * n - 2 * a - o) * s + a * i + t
                        }
                    }
                }, l = function() {
                    function e() {}
                    return e.nextId = function() {
                        return e._nextId++
                    }
                    ,
                    e._nextId = 0,
                    e
                }(), c = new o, u = function() {
                    function e(e, t) {
                        void 0 === t && (t = c),
                        this._object = e,
                        this._group = t,
                        this._isPaused = !1,
                        this._pauseStart = 0,
                        this._valuesStart = {},
                        this._valuesEnd = {},
                        this._valuesStartRepeat = {},
                        this._duration = 1e3,
                        this._initialRepeat = 0,
                        this._repeat = 0,
                        this._yoyo = !1,
                        this._isPlaying = !1,
                        this._reversed = !1,
                        this._delayTime = 0,
                        this._startTime = 0,
                        this._easingFunction = i.Linear.None,
                        this._interpolationFunction = s.Linear,
                        this._chainedTweens = [],
                        this._onStartCallbackFired = !1,
                        this._id = l.nextId(),
                        this._isChainStopped = !1,
                        this._goToEnd = !1
                    }
                    return e.prototype.getId = function() {
                        return this._id
                    }
                    ,
                    e.prototype.isPlaying = function() {
                        return this._isPlaying
                    }
                    ,
                    e.prototype.isPaused = function() {
                        return this._isPaused
                    }
                    ,
                    e.prototype.to = function(e, t) {
                        return this._valuesEnd = Object.create(e),
                        void 0 !== t && (this._duration = t),
                        this
                    }
                    ,
                    e.prototype.duration = function(e) {
                        return this._duration = e,
                        this
                    }
                    ,
                    e.prototype.start = function(e) {
                        if (this._isPlaying)
                            return this;
                        if (this._group && this._group.add(this),
                        this._repeat = this._initialRepeat,
                        this._reversed)
                            for (var t in this._reversed = !1,
                            this._valuesStartRepeat)
                                this._swapEndStartRepeatValues(t),
                                this._valuesStart[t] = this._valuesStartRepeat[t];
                        return this._isPlaying = !0,
                        this._isPaused = !1,
                        this._onStartCallbackFired = !1,
                        this._isChainStopped = !1,
                        this._startTime = void 0 !== e ? "string" == typeof e ? a() + parseFloat(e) : e : a(),
                        this._startTime += this._delayTime,
                        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat),
                        this
                    }
                    ,
                    e.prototype._setupProperties = function(e, t, n, r) {
                        for (var i in n) {
                            var a = e[i]
                              , o = Array.isArray(a)
                              , s = o ? "array" : typeof a
                              , l = !o && Array.isArray(n[i]);
                            if ("undefined" !== s && "function" !== s) {
                                if (l) {
                                    var c = n[i];
                                    if (0 === c.length)
                                        continue;
                                    c = c.map(this._handleRelativeValue.bind(this, a)),
                                    n[i] = [a].concat(c)
                                }
                                if ("object" !== s && !o || !a || l)
                                    void 0 === t[i] && (t[i] = a),
                                    o || (t[i] *= 1),
                                    r[i] = l ? n[i].slice().reverse() : t[i] || 0;
                                else {
                                    for (var u in t[i] = o ? [] : {},
                                    a)
                                        t[i][u] = a[u];
                                    r[i] = o ? [] : {},
                                    this._setupProperties(a, t[i], n[i], r[i])
                                }
                            }
                        }
                    }
                    ,
                    e.prototype.stop = function() {
                        return this._isChainStopped || (this._isChainStopped = !0,
                        this.stopChainedTweens()),
                        this._isPlaying ? (this._group && this._group.remove(this),
                        this._isPlaying = !1,
                        this._isPaused = !1,
                        this._onStopCallback && this._onStopCallback(this._object),
                        this) : this
                    }
                    ,
                    e.prototype.end = function() {
                        return this._goToEnd = !0,
                        this.update(1 / 0),
                        this
                    }
                    ,
                    e.prototype.pause = function(e) {
                        return void 0 === e && (e = a()),
                        this._isPaused || !this._isPlaying || (this._isPaused = !0,
                        this._pauseStart = e,
                        this._group && this._group.remove(this)),
                        this
                    }
                    ,
                    e.prototype.resume = function(e) {
                        return void 0 === e && (e = a()),
                        this._isPaused && this._isPlaying ? (this._isPaused = !1,
                        this._startTime += e - this._pauseStart,
                        this._pauseStart = 0,
                        this._group && this._group.add(this),
                        this) : this
                    }
                    ,
                    e.prototype.stopChainedTweens = function() {
                        for (var e = 0, t = this._chainedTweens.length; e < t; e++)
                            this._chainedTweens[e].stop();
                        return this
                    }
                    ,
                    e.prototype.group = function(e) {
                        return this._group = e,
                        this
                    }
                    ,
                    e.prototype.delay = function(e) {
                        return this._delayTime = e,
                        this
                    }
                    ,
                    e.prototype.repeat = function(e) {
                        return this._initialRepeat = e,
                        this._repeat = e,
                        this
                    }
                    ,
                    e.prototype.repeatDelay = function(e) {
                        return this._repeatDelayTime = e,
                        this
                    }
                    ,
                    e.prototype.yoyo = function(e) {
                        return this._yoyo = e,
                        this
                    }
                    ,
                    e.prototype.easing = function(e) {
                        return this._easingFunction = e,
                        this
                    }
                    ,
                    e.prototype.interpolation = function(e) {
                        return this._interpolationFunction = e,
                        this
                    }
                    ,
                    e.prototype.chain = function() {
                        for (var e = [], t = 0; t < arguments.length; t++)
                            e[t] = arguments[t];
                        return this._chainedTweens = e,
                        this
                    }
                    ,
                    e.prototype.onStart = function(e) {
                        return this._onStartCallback = e,
                        this
                    }
                    ,
                    e.prototype.onUpdate = function(e) {
                        return this._onUpdateCallback = e,
                        this
                    }
                    ,
                    e.prototype.onRepeat = function(e) {
                        return this._onRepeatCallback = e,
                        this
                    }
                    ,
                    e.prototype.onComplete = function(e) {
                        return this._onCompleteCallback = e,
                        this
                    }
                    ,
                    e.prototype.onStop = function(e) {
                        return this._onStopCallback = e,
                        this
                    }
                    ,
                    e.prototype.update = function(e, t) {
                        if (void 0 === e && (e = a()),
                        void 0 === t && (t = !0),
                        this._isPaused)
                            return !0;
                        var n, r, i = this._startTime + this._duration;
                        if (!this._goToEnd && !this._isPlaying) {
                            if (e > i)
                                return !1;
                            t && this.start(e)
                        }
                        if (this._goToEnd = !1,
                        e < this._startTime)
                            return !0;
                        !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object),
                        this._onStartCallbackFired = !0),
                        r = (e - this._startTime) / this._duration,
                        r = 0 === this._duration || r > 1 ? 1 : r;
                        var o = this._easingFunction(r);
                        if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, o),
                        this._onUpdateCallback && this._onUpdateCallback(this._object, r),
                        1 === r) {
                            if (this._repeat > 0) {
                                for (n in isFinite(this._repeat) && this._repeat--,
                                this._valuesStartRepeat)
                                    this._yoyo || "string" != typeof this._valuesEnd[n] || (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])),
                                    this._yoyo && this._swapEndStartRepeatValues(n),
                                    this._valuesStart[n] = this._valuesStartRepeat[n];
                                return this._yoyo && (this._reversed = !this._reversed),
                                void 0 !== this._repeatDelayTime ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime,
                                this._onRepeatCallback && this._onRepeatCallback(this._object),
                                !0
                            }
                            this._onCompleteCallback && this._onCompleteCallback(this._object);
                            for (var s = 0, l = this._chainedTweens.length; s < l; s++)
                                this._chainedTweens[s].start(this._startTime + this._duration);
                            return this._isPlaying = !1,
                            !1
                        }
                        return !0
                    }
                    ,
                    e.prototype._updateProperties = function(e, t, n, r) {
                        for (var i in n)
                            if (void 0 !== t[i]) {
                                var a = t[i] || 0
                                  , o = n[i]
                                  , s = Array.isArray(e[i])
                                  , l = Array.isArray(o);
                                !s && l ? e[i] = this._interpolationFunction(o, r) : "object" == typeof o && o ? this._updateProperties(e[i], a, o, r) : "number" == typeof (o = this._handleRelativeValue(a, o)) && (e[i] = a + (o - a) * r)
                            }
                    }
                    ,
                    e.prototype._handleRelativeValue = function(e, t) {
                        return "string" != typeof t ? t : "+" === t.charAt(0) || "-" === t.charAt(0) ? e + parseFloat(t) : parseFloat(t)
                    }
                    ,
                    e.prototype._swapEndStartRepeatValues = function(e) {
                        var t = this._valuesStartRepeat[e]
                          , n = this._valuesEnd[e];
                        this._valuesStartRepeat[e] = "string" == typeof n ? this._valuesStartRepeat[e] + parseFloat(n) : this._valuesEnd[e],
                        this._valuesEnd[e] = t
                    }
                    ,
                    e
                }(), h = "18.6.4", d = l.nextId, p = c, f = p.getAll.bind(p), m = p.removeAll.bind(p), g = p.add.bind(p), v = p.remove.bind(p), y = p.update.bind(p);
                const _ = {
                    Easing: i,
                    Group: o,
                    Interpolation: s,
                    now: a,
                    Sequence: l,
                    nextId: d,
                    Tween: u,
                    VERSION: h,
                    getAll: f,
                    removeAll: m,
                    add: g,
                    remove: v,
                    update: y
                }
            }
            ,
            452: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(8269),
                n(8214),
                n(888),
                n(5109),
                function() {
                    var e = r
                      , t = e.lib.BlockCipher
                      , n = e.algo
                      , i = []
                      , a = []
                      , o = []
                      , s = []
                      , l = []
                      , c = []
                      , u = []
                      , h = []
                      , d = []
                      , p = [];
                    !function() {
                        for (var e = [], t = 0; t < 256; t++)
                            e[t] = t < 128 ? t << 1 : t << 1 ^ 283;
                        var n = 0
                          , r = 0;
                        for (t = 0; t < 256; t++) {
                            var f = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4;
                            f = f >>> 8 ^ 255 & f ^ 99,
                            i[n] = f,
                            a[f] = n;
                            var m = e[n]
                              , g = e[m]
                              , v = e[g]
                              , y = 257 * e[f] ^ 16843008 * f;
                            o[n] = y << 24 | y >>> 8,
                            s[n] = y << 16 | y >>> 16,
                            l[n] = y << 8 | y >>> 24,
                            c[n] = y,
                            y = 16843009 * v ^ 65537 * g ^ 257 * m ^ 16843008 * n,
                            u[f] = y << 24 | y >>> 8,
                            h[f] = y << 16 | y >>> 16,
                            d[f] = y << 8 | y >>> 24,
                            p[f] = y,
                            n ? (n = m ^ e[e[e[v ^ m]]],
                            r ^= e[e[r]]) : n = r = 1
                        }
                    }();
                    var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
                      , m = n.AES = t.extend({
                        _doReset: function() {
                            if (!this._nRounds || this._keyPriorReset !== this._key) {
                                for (var e = this._keyPriorReset = this._key, t = e.words, n = e.sigBytes / 4, r = 4 * ((this._nRounds = n + 6) + 1), a = this._keySchedule = [], o = 0; o < r; o++)
                                    o < n ? a[o] = t[o] : (c = a[o - 1],
                                    o % n ? n > 6 && o % n == 4 && (c = i[c >>> 24] << 24 | i[c >>> 16 & 255] << 16 | i[c >>> 8 & 255] << 8 | i[255 & c]) : (c = i[(c = c << 8 | c >>> 24) >>> 24] << 24 | i[c >>> 16 & 255] << 16 | i[c >>> 8 & 255] << 8 | i[255 & c],
                                    c ^= f[o / n | 0] << 24),
                                    a[o] = a[o - n] ^ c);
                                for (var s = this._invKeySchedule = [], l = 0; l < r; l++) {
                                    if (o = r - l,
                                    l % 4)
                                        var c = a[o];
                                    else
                                        c = a[o - 4];
                                    s[l] = l < 4 || o <= 4 ? c : u[i[c >>> 24]] ^ h[i[c >>> 16 & 255]] ^ d[i[c >>> 8 & 255]] ^ p[i[255 & c]]
                                }
                            }
                        },
                        encryptBlock: function(e, t) {
                            this._doCryptBlock(e, t, this._keySchedule, o, s, l, c, i)
                        },
                        decryptBlock: function(e, t) {
                            var n = e[t + 1];
                            e[t + 1] = e[t + 3],
                            e[t + 3] = n,
                            this._doCryptBlock(e, t, this._invKeySchedule, u, h, d, p, a),
                            n = e[t + 1],
                            e[t + 1] = e[t + 3],
                            e[t + 3] = n
                        },
                        _doCryptBlock: function(e, t, n, r, i, a, o, s) {
                            for (var l = this._nRounds, c = e[t] ^ n[0], u = e[t + 1] ^ n[1], h = e[t + 2] ^ n[2], d = e[t + 3] ^ n[3], p = 4, f = 1; f < l; f++) {
                                var m = r[c >>> 24] ^ i[u >>> 16 & 255] ^ a[h >>> 8 & 255] ^ o[255 & d] ^ n[p++]
                                  , g = r[u >>> 24] ^ i[h >>> 16 & 255] ^ a[d >>> 8 & 255] ^ o[255 & c] ^ n[p++]
                                  , v = r[h >>> 24] ^ i[d >>> 16 & 255] ^ a[c >>> 8 & 255] ^ o[255 & u] ^ n[p++]
                                  , y = r[d >>> 24] ^ i[c >>> 16 & 255] ^ a[u >>> 8 & 255] ^ o[255 & h] ^ n[p++];
                                c = m,
                                u = g,
                                h = v,
                                d = y
                            }
                            m = (s[c >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[h >>> 8 & 255] << 8 | s[255 & d]) ^ n[p++],
                            g = (s[u >>> 24] << 24 | s[h >>> 16 & 255] << 16 | s[d >>> 8 & 255] << 8 | s[255 & c]) ^ n[p++],
                            v = (s[h >>> 24] << 24 | s[d >>> 16 & 255] << 16 | s[c >>> 8 & 255] << 8 | s[255 & u]) ^ n[p++],
                            y = (s[d >>> 24] << 24 | s[c >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & h]) ^ n[p++],
                            e[t] = m,
                            e[t + 1] = g,
                            e[t + 2] = v,
                            e[t + 3] = y
                        },
                        keySize: 8
                    });
                    e.AES = t._createHelper(m)
                }(),
                r.AES)
            },
            5109: function(e, t, n) {
                var r, i, a, o, s, l, c, u, h, d, p, f, m, g, v, y, _, x, b;
                e.exports = (r = n(8249),
                n(888),
                void (r.lib.Cipher || (i = r,
                a = i.lib,
                o = a.Base,
                s = a.WordArray,
                l = a.BufferedBlockAlgorithm,
                c = i.enc,
                c.Utf8,
                u = c.Base64,
                h = i.algo.EvpKDF,
                d = a.Cipher = l.extend({
                    cfg: o.extend(),
                    createEncryptor: function(e, t) {
                        return this.create(this._ENC_XFORM_MODE, e, t)
                    },
                    createDecryptor: function(e, t) {
                        return this.create(this._DEC_XFORM_MODE, e, t)
                    },
                    init: function(e, t, n) {
                        this.cfg = this.cfg.extend(n),
                        this._xformMode = e,
                        this._key = t,
                        this.reset()
                    },
                    reset: function() {
                        l.reset.call(this),
                        this._doReset()
                    },
                    process: function(e) {
                        return this._append(e),
                        this._process()
                    },
                    finalize: function(e) {
                        return e && this._append(e),
                        this._doFinalize()
                    },
                    keySize: 4,
                    ivSize: 4,
                    _ENC_XFORM_MODE: 1,
                    _DEC_XFORM_MODE: 2,
                    _createHelper: function() {
                        function e(e) {
                            return "string" == typeof e ? b : _
                        }
                        return function(t) {
                            return {
                                encrypt: function(n, r, i) {
                                    return e(r).encrypt(t, n, r, i)
                                },
                                decrypt: function(n, r, i) {
                                    return e(r).decrypt(t, n, r, i)
                                }
                            }
                        }
                    }()
                }),
                a.StreamCipher = d.extend({
                    _doFinalize: function() {
                        return this._process(!0)
                    },
                    blockSize: 1
                }),
                p = i.mode = {},
                f = a.BlockCipherMode = o.extend({
                    createEncryptor: function(e, t) {
                        return this.Encryptor.create(e, t)
                    },
                    createDecryptor: function(e, t) {
                        return this.Decryptor.create(e, t)
                    },
                    init: function(e, t) {
                        this._cipher = e,
                        this._iv = t
                    }
                }),
                m = p.CBC = function() {
                    var e = f.extend();
                    function t(e, t, n) {
                        var r, i = this._iv;
                        i ? (r = i,
                        this._iv = void 0) : r = this._prevBlock;
                        for (var a = 0; a < n; a++)
                            e[t + a] ^= r[a]
                    }
                    return e.Encryptor = e.extend({
                        processBlock: function(e, n) {
                            var r = this._cipher
                              , i = r.blockSize;
                            t.call(this, e, n, i),
                            r.encryptBlock(e, n),
                            this._prevBlock = e.slice(n, n + i)
                        }
                    }),
                    e.Decryptor = e.extend({
                        processBlock: function(e, n) {
                            var r = this._cipher
                              , i = r.blockSize
                              , a = e.slice(n, n + i);
                            r.decryptBlock(e, n),
                            t.call(this, e, n, i),
                            this._prevBlock = a
                        }
                    }),
                    e
                }(),
                g = (i.pad = {}).Pkcs7 = {
                    pad: function(e, t) {
                        for (var n = 4 * t, r = n - e.sigBytes % n, i = r << 24 | r << 16 | r << 8 | r, a = [], o = 0; o < r; o += 4)
                            a.push(i);
                        var l = s.create(a, r);
                        e.concat(l)
                    },
                    unpad: function(e) {
                        var t = 255 & e.words[e.sigBytes - 1 >>> 2];
                        e.sigBytes -= t
                    }
                },
                a.BlockCipher = d.extend({
                    cfg: d.cfg.extend({
                        mode: m,
                        padding: g
                    }),
                    reset: function() {
                        var e;
                        d.reset.call(this);
                        var t = this.cfg
                          , n = t.iv
                          , r = t.mode;
                        this._xformMode == this._ENC_XFORM_MODE ? e = r.createEncryptor : (e = r.createDecryptor,
                        this._minBufferSize = 1),
                        this._mode && this._mode.__creator == e ? this._mode.init(this, n && n.words) : (this._mode = e.call(r, this, n && n.words),
                        this._mode.__creator = e)
                    },
                    _doProcessBlock: function(e, t) {
                        this._mode.processBlock(e, t)
                    },
                    _doFinalize: function() {
                        var e, t = this.cfg.padding;
                        return this._xformMode == this._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize),
                        e = this._process(!0)) : (e = this._process(!0),
                        t.unpad(e)),
                        e
                    },
                    blockSize: 4
                }),
                v = a.CipherParams = o.extend({
                    init: function(e) {
                        this.mixIn(e)
                    },
                    toString: function(e) {
                        return (e || this.formatter).stringify(this)
                    }
                }),
                y = (i.format = {}).OpenSSL = {
                    stringify: function(e) {
                        var t = e.ciphertext
                          , n = e.salt;
                        return (n ? s.create([1398893684, 1701076831]).concat(n).concat(t) : t).toString(u)
                    },
                    parse: function(e) {
                        var t, n = u.parse(e), r = n.words;
                        return 1398893684 == r[0] && 1701076831 == r[1] && (t = s.create(r.slice(2, 4)),
                        r.splice(0, 4),
                        n.sigBytes -= 16),
                        v.create({
                            ciphertext: n,
                            salt: t
                        })
                    }
                },
                _ = a.SerializableCipher = o.extend({
                    cfg: o.extend({
                        format: y
                    }),
                    encrypt: function(e, t, n, r) {
                        r = this.cfg.extend(r);
                        var i = e.createEncryptor(n, r)
                          , a = i.finalize(t)
                          , o = i.cfg;
                        return v.create({
                            ciphertext: a,
                            key: n,
                            iv: o.iv,
                            algorithm: e,
                            mode: o.mode,
                            padding: o.padding,
                            blockSize: e.blockSize,
                            formatter: r.format
                        })
                    },
                    decrypt: function(e, t, n, r) {
                        return r = this.cfg.extend(r),
                        t = this._parse(t, r.format),
                        e.createDecryptor(n, r).finalize(t.ciphertext)
                    },
                    _parse: function(e, t) {
                        return "string" == typeof e ? t.parse(e, this) : e
                    }
                }),
                x = (i.kdf = {}).OpenSSL = {
                    execute: function(e, t, n, r) {
                        r || (r = s.random(8));
                        var i = h.create({
                            keySize: t + n
                        }).compute(e, r)
                          , a = s.create(i.words.slice(t), 4 * n);
                        return i.sigBytes = 4 * t,
                        v.create({
                            key: i,
                            iv: a,
                            salt: r
                        })
                    }
                },
                b = a.PasswordBasedCipher = _.extend({
                    cfg: _.cfg.extend({
                        kdf: x
                    }),
                    encrypt: function(e, t, n, r) {
                        var i = (r = this.cfg.extend(r)).kdf.execute(n, e.keySize, e.ivSize);
                        r.iv = i.iv;
                        var a = _.encrypt.call(this, e, t, i.key, r);
                        return a.mixIn(i),
                        a
                    },
                    decrypt: function(e, t, n, r) {
                        r = this.cfg.extend(r),
                        t = this._parse(t, r.format);
                        var i = r.kdf.execute(n, e.keySize, e.ivSize, t.salt);
                        return r.iv = i.iv,
                        _.decrypt.call(this, e, t, i.key, r)
                    }
                }))))
            },
            8249: function(e, t, n) {
                var r;
                e.exports = (r = r || function(e, t) {
                    var r;
                    if ("undefined" != typeof window && window.crypto && (r = window.crypto),
                    "undefined" != typeof self && self.crypto && (r = self.crypto),
                    "undefined" != typeof globalThis && globalThis.crypto && (r = globalThis.crypto),
                    !r && "undefined" != typeof window && window.msCrypto && (r = window.msCrypto),
                    !r && void 0 !== n.g && n.g.crypto && (r = n.g.crypto),
                    !r)
                        try {
                            r = n(2480)
                        } catch (e) {}
                    var i = function() {
                        if (r) {
                            if ("function" == typeof r.getRandomValues)
                                try {
                                    return r.getRandomValues(new Uint32Array(1))[0]
                                } catch (e) {}
                            if ("function" == typeof r.randomBytes)
                                try {
                                    return r.randomBytes(4).readInt32LE()
                                } catch (e) {}
                        }
                        throw new Error("Native crypto module could not be used to get secure random number.")
                    }
                      , a = Object.create || function() {
                        function e() {}
                        return function(t) {
                            var n;
                            return e.prototype = t,
                            n = new e,
                            e.prototype = null,
                            n
                        }
                    }()
                      , o = {}
                      , s = o.lib = {}
                      , l = s.Base = {
                        extend: function(e) {
                            var t = a(this);
                            return e && t.mixIn(e),
                            t.hasOwnProperty("init") && this.init !== t.init || (t.init = function() {
                                t.$super.init.apply(this, arguments)
                            }
                            ),
                            t.init.prototype = t,
                            t.$super = this,
                            t
                        },
                        create: function() {
                            var e = this.extend();
                            return e.init.apply(e, arguments),
                            e
                        },
                        init: function() {},
                        mixIn: function(e) {
                            for (var t in e)
                                e.hasOwnProperty(t) && (this[t] = e[t]);
                            e.hasOwnProperty("toString") && (this.toString = e.toString)
                        },
                        clone: function() {
                            return this.init.prototype.extend(this)
                        }
                    }
                      , c = s.WordArray = l.extend({
                        init: function(e, t) {
                            e = this.words = e || [],
                            this.sigBytes = null != t ? t : 4 * e.length
                        },
                        toString: function(e) {
                            return (e || h).stringify(this)
                        },
                        concat: function(e) {
                            var t = this.words
                              , n = e.words
                              , r = this.sigBytes
                              , i = e.sigBytes;
                            if (this.clamp(),
                            r % 4)
                                for (var a = 0; a < i; a++) {
                                    var o = n[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                                    t[r + a >>> 2] |= o << 24 - (r + a) % 4 * 8
                                }
                            else
                                for (var s = 0; s < i; s += 4)
                                    t[r + s >>> 2] = n[s >>> 2];
                            return this.sigBytes += i,
                            this
                        },
                        clamp: function() {
                            var t = this.words
                              , n = this.sigBytes;
                            t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8,
                            t.length = e.ceil(n / 4)
                        },
                        clone: function() {
                            var e = l.clone.call(this);
                            return e.words = this.words.slice(0),
                            e
                        },
                        random: function(e) {
                            for (var t = [], n = 0; n < e; n += 4)
                                t.push(i());
                            return new c.init(t,e)
                        }
                    })
                      , u = o.enc = {}
                      , h = u.Hex = {
                        stringify: function(e) {
                            for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i++) {
                                var a = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                r.push((a >>> 4).toString(16)),
                                r.push((15 & a).toString(16))
                            }
                            return r.join("")
                        },
                        parse: function(e) {
                            for (var t = e.length, n = [], r = 0; r < t; r += 2)
                                n[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4;
                            return new c.init(n,t / 2)
                        }
                    }
                      , d = u.Latin1 = {
                        stringify: function(e) {
                            for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i++) {
                                var a = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                r.push(String.fromCharCode(a))
                            }
                            return r.join("")
                        },
                        parse: function(e) {
                            for (var t = e.length, n = [], r = 0; r < t; r++)
                                n[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8;
                            return new c.init(n,t)
                        }
                    }
                      , p = u.Utf8 = {
                        stringify: function(e) {
                            try {
                                return decodeURIComponent(escape(d.stringify(e)))
                            } catch (e) {
                                throw new Error("Malformed UTF-8 data")
                            }
                        },
                        parse: function(e) {
                            return d.parse(unescape(encodeURIComponent(e)))
                        }
                    }
                      , f = s.BufferedBlockAlgorithm = l.extend({
                        reset: function() {
                            this._data = new c.init,
                            this._nDataBytes = 0
                        },
                        _append: function(e) {
                            "string" == typeof e && (e = p.parse(e)),
                            this._data.concat(e),
                            this._nDataBytes += e.sigBytes
                        },
                        _process: function(t) {
                            var n, r = this._data, i = r.words, a = r.sigBytes, o = this.blockSize, s = a / (4 * o), l = (s = t ? e.ceil(s) : e.max((0 | s) - this._minBufferSize, 0)) * o, u = e.min(4 * l, a);
                            if (l) {
                                for (var h = 0; h < l; h += o)
                                    this._doProcessBlock(i, h);
                                n = i.splice(0, l),
                                r.sigBytes -= u
                            }
                            return new c.init(n,u)
                        },
                        clone: function() {
                            var e = l.clone.call(this);
                            return e._data = this._data.clone(),
                            e
                        },
                        _minBufferSize: 0
                    })
                      , m = (s.Hasher = f.extend({
                        cfg: l.extend(),
                        init: function(e) {
                            this.cfg = this.cfg.extend(e),
                            this.reset()
                        },
                        reset: function() {
                            f.reset.call(this),
                            this._doReset()
                        },
                        update: function(e) {
                            return this._append(e),
                            this._process(),
                            this
                        },
                        finalize: function(e) {
                            return e && this._append(e),
                            this._doFinalize()
                        },
                        blockSize: 16,
                        _createHelper: function(e) {
                            return function(t, n) {
                                return new e.init(n).finalize(t)
                            }
                        },
                        _createHmacHelper: function(e) {
                            return function(t, n) {
                                return new m.HMAC.init(e,n).finalize(t)
                            }
                        }
                    }),
                    o.algo = {});
                    return o
                }(Math),
                r)
            },
            8269: function(e, t, n) {
                var r, i, a;
                e.exports = (r = n(8249),
                a = (i = r).lib.WordArray,
                i.enc.Base64 = {
                    stringify: function(e) {
                        var t = e.words
                          , n = e.sigBytes
                          , r = this._map;
                        e.clamp();
                        for (var i = [], a = 0; a < n; a += 3)
                            for (var o = (t[a >>> 2] >>> 24 - a % 4 * 8 & 255) << 16 | (t[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255) << 8 | t[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255, s = 0; s < 4 && a + .75 * s < n; s++)
                                i.push(r.charAt(o >>> 6 * (3 - s) & 63));
                        var l = r.charAt(64);
                        if (l)
                            for (; i.length % 4; )
                                i.push(l);
                        return i.join("")
                    },
                    parse: function(e) {
                        var t = e.length
                          , n = this._map
                          , r = this._reverseMap;
                        if (!r) {
                            r = this._reverseMap = [];
                            for (var i = 0; i < n.length; i++)
                                r[n.charCodeAt(i)] = i
                        }
                        var o = n.charAt(64);
                        if (o) {
                            var s = e.indexOf(o);
                            -1 !== s && (t = s)
                        }
                        return function(e, t, n) {
                            for (var r = [], i = 0, o = 0; o < t; o++)
                                if (o % 4) {
                                    var s = n[e.charCodeAt(o - 1)] << o % 4 * 2 | n[e.charCodeAt(o)] >>> 6 - o % 4 * 2;
                                    r[i >>> 2] |= s << 24 - i % 4 * 8,
                                    i++
                                }
                            return a.create(r, i)
                        }(e, t, r)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                },
                r.enc.Base64)
            },
            3786: function(e, t, n) {
                var r, i, a;
                e.exports = (r = n(8249),
                a = (i = r).lib.WordArray,
                i.enc.Base64url = {
                    stringify: function(e, t=!0) {
                        var n = e.words
                          , r = e.sigBytes
                          , i = t ? this._safe_map : this._map;
                        e.clamp();
                        for (var a = [], o = 0; o < r; o += 3)
                            for (var s = (n[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (n[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | n[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, l = 0; l < 4 && o + .75 * l < r; l++)
                                a.push(i.charAt(s >>> 6 * (3 - l) & 63));
                        var c = i.charAt(64);
                        if (c)
                            for (; a.length % 4; )
                                a.push(c);
                        return a.join("")
                    },
                    parse: function(e, t=!0) {
                        var n = e.length
                          , r = t ? this._safe_map : this._map
                          , i = this._reverseMap;
                        if (!i) {
                            i = this._reverseMap = [];
                            for (var o = 0; o < r.length; o++)
                                i[r.charCodeAt(o)] = o
                        }
                        var s = r.charAt(64);
                        if (s) {
                            var l = e.indexOf(s);
                            -1 !== l && (n = l)
                        }
                        return function(e, t, n) {
                            for (var r = [], i = 0, o = 0; o < t; o++)
                                if (o % 4) {
                                    var s = n[e.charCodeAt(o - 1)] << o % 4 * 2 | n[e.charCodeAt(o)] >>> 6 - o % 4 * 2;
                                    r[i >>> 2] |= s << 24 - i % 4 * 8,
                                    i++
                                }
                            return a.create(r, i)
                        }(e, n, i)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                },
                r.enc.Base64url)
            },
            298: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                function() {
                    var e = r
                      , t = e.lib.WordArray
                      , n = e.enc;
                    function i(e) {
                        return e << 8 & 4278255360 | e >>> 8 & 16711935
                    }
                    n.Utf16 = n.Utf16BE = {
                        stringify: function(e) {
                            for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i += 2) {
                                var a = t[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                                r.push(String.fromCharCode(a))
                            }
                            return r.join("")
                        },
                        parse: function(e) {
                            for (var n = e.length, r = [], i = 0; i < n; i++)
                                r[i >>> 1] |= e.charCodeAt(i) << 16 - i % 2 * 16;
                            return t.create(r, 2 * n)
                        }
                    },
                    n.Utf16LE = {
                        stringify: function(e) {
                            for (var t = e.words, n = e.sigBytes, r = [], a = 0; a < n; a += 2) {
                                var o = i(t[a >>> 2] >>> 16 - a % 4 * 8 & 65535);
                                r.push(String.fromCharCode(o))
                            }
                            return r.join("")
                        },
                        parse: function(e) {
                            for (var n = e.length, r = [], a = 0; a < n; a++)
                                r[a >>> 1] |= i(e.charCodeAt(a) << 16 - a % 2 * 16);
                            return t.create(r, 2 * n)
                        }
                    }
                }(),
                r.enc.Utf16)
            },
            888: function(e, t, n) {
                var r, i, a, o, s, l, c, u;
                e.exports = (u = n(8249),
                n(2783),
                n(9824),
                a = (i = (r = u).lib).Base,
                o = i.WordArray,
                l = (s = r.algo).MD5,
                c = s.EvpKDF = a.extend({
                    cfg: a.extend({
                        keySize: 4,
                        hasher: l,
                        iterations: 1
                    }),
                    init: function(e) {
                        this.cfg = this.cfg.extend(e)
                    },
                    compute: function(e, t) {
                        for (var n, r = this.cfg, i = r.hasher.create(), a = o.create(), s = a.words, l = r.keySize, c = r.iterations; s.length < l; ) {
                            n && i.update(n),
                            n = i.update(e).finalize(t),
                            i.reset();
                            for (var u = 1; u < c; u++)
                                n = i.finalize(n),
                                i.reset();
                            a.concat(n)
                        }
                        return a.sigBytes = 4 * l,
                        a
                    }
                }),
                r.EvpKDF = function(e, t, n) {
                    return c.create(n).compute(e, t)
                }
                ,
                u.EvpKDF)
            },
            2209: function(e, t, n) {
                var r, i, a, o;
                e.exports = (o = n(8249),
                n(5109),
                i = (r = o).lib.CipherParams,
                a = r.enc.Hex,
                r.format.Hex = {
                    stringify: function(e) {
                        return e.ciphertext.toString(a)
                    },
                    parse: function(e) {
                        var t = a.parse(e);
                        return i.create({
                            ciphertext: t
                        })
                    }
                },
                o.format.Hex)
            },
            9824: function(e, t, n) {
                var r, i, a;
                e.exports = (i = (r = n(8249)).lib.Base,
                a = r.enc.Utf8,
                void (r.algo.HMAC = i.extend({
                    init: function(e, t) {
                        e = this._hasher = new e.init,
                        "string" == typeof t && (t = a.parse(t));
                        var n = e.blockSize
                          , r = 4 * n;
                        t.sigBytes > r && (t = e.finalize(t)),
                        t.clamp();
                        for (var i = this._oKey = t.clone(), o = this._iKey = t.clone(), s = i.words, l = o.words, c = 0; c < n; c++)
                            s[c] ^= 1549556828,
                            l[c] ^= 909522486;
                        i.sigBytes = o.sigBytes = r,
                        this.reset()
                    },
                    reset: function() {
                        var e = this._hasher;
                        e.reset(),
                        e.update(this._iKey)
                    },
                    update: function(e) {
                        return this._hasher.update(e),
                        this
                    },
                    finalize: function(e) {
                        var t = this._hasher
                          , n = t.finalize(e);
                        return t.reset(),
                        t.finalize(this._oKey.clone().concat(n))
                    }
                })))
            },
            1354: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(4938),
                n(4433),
                n(298),
                n(8269),
                n(3786),
                n(8214),
                n(2783),
                n(2153),
                n(7792),
                n(34),
                n(7460),
                n(3327),
                n(706),
                n(9824),
                n(2112),
                n(888),
                n(5109),
                n(8568),
                n(4242),
                n(9968),
                n(7660),
                n(1148),
                n(3615),
                n(2807),
                n(1077),
                n(6475),
                n(6991),
                n(2209),
                n(452),
                n(4253),
                n(1857),
                n(4454),
                n(3974),
                r)
            },
            4433: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                function() {
                    if ("function" == typeof ArrayBuffer) {
                        var e = r.lib.WordArray
                          , t = e.init
                          , n = e.init = function(e) {
                            if (e instanceof ArrayBuffer && (e = new Uint8Array(e)),
                            (e instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array) && (e = new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),
                            e instanceof Uint8Array) {
                                for (var n = e.byteLength, r = [], i = 0; i < n; i++)
                                    r[i >>> 2] |= e[i] << 24 - i % 4 * 8;
                                t.call(this, r, n)
                            } else
                                t.apply(this, arguments)
                        }
                        ;
                        n.prototype = e
                    }
                }(),
                r.lib.WordArray)
            },
            8214: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                function(e) {
                    var t = r
                      , n = t.lib
                      , i = n.WordArray
                      , a = n.Hasher
                      , o = t.algo
                      , s = [];
                    !function() {
                        for (var t = 0; t < 64; t++)
                            s[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0
                    }();
                    var l = o.MD5 = a.extend({
                        _doReset: function() {
                            this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878])
                        },
                        _doProcessBlock: function(e, t) {
                            for (var n = 0; n < 16; n++) {
                                var r = t + n
                                  , i = e[r];
                                e[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
                            }
                            var a = this._hash.words
                              , o = e[t + 0]
                              , l = e[t + 1]
                              , p = e[t + 2]
                              , f = e[t + 3]
                              , m = e[t + 4]
                              , g = e[t + 5]
                              , v = e[t + 6]
                              , y = e[t + 7]
                              , _ = e[t + 8]
                              , x = e[t + 9]
                              , b = e[t + 10]
                              , w = e[t + 11]
                              , M = e[t + 12]
                              , S = e[t + 13]
                              , T = e[t + 14]
                              , E = e[t + 15]
                              , A = a[0]
                              , C = a[1]
                              , P = a[2]
                              , R = a[3];
                            A = c(A, C, P, R, o, 7, s[0]),
                            R = c(R, A, C, P, l, 12, s[1]),
                            P = c(P, R, A, C, p, 17, s[2]),
                            C = c(C, P, R, A, f, 22, s[3]),
                            A = c(A, C, P, R, m, 7, s[4]),
                            R = c(R, A, C, P, g, 12, s[5]),
                            P = c(P, R, A, C, v, 17, s[6]),
                            C = c(C, P, R, A, y, 22, s[7]),
                            A = c(A, C, P, R, _, 7, s[8]),
                            R = c(R, A, C, P, x, 12, s[9]),
                            P = c(P, R, A, C, b, 17, s[10]),
                            C = c(C, P, R, A, w, 22, s[11]),
                            A = c(A, C, P, R, M, 7, s[12]),
                            R = c(R, A, C, P, S, 12, s[13]),
                            P = c(P, R, A, C, T, 17, s[14]),
                            A = u(A, C = c(C, P, R, A, E, 22, s[15]), P, R, l, 5, s[16]),
                            R = u(R, A, C, P, v, 9, s[17]),
                            P = u(P, R, A, C, w, 14, s[18]),
                            C = u(C, P, R, A, o, 20, s[19]),
                            A = u(A, C, P, R, g, 5, s[20]),
                            R = u(R, A, C, P, b, 9, s[21]),
                            P = u(P, R, A, C, E, 14, s[22]),
                            C = u(C, P, R, A, m, 20, s[23]),
                            A = u(A, C, P, R, x, 5, s[24]),
                            R = u(R, A, C, P, T, 9, s[25]),
                            P = u(P, R, A, C, f, 14, s[26]),
                            C = u(C, P, R, A, _, 20, s[27]),
                            A = u(A, C, P, R, S, 5, s[28]),
                            R = u(R, A, C, P, p, 9, s[29]),
                            P = u(P, R, A, C, y, 14, s[30]),
                            A = h(A, C = u(C, P, R, A, M, 20, s[31]), P, R, g, 4, s[32]),
                            R = h(R, A, C, P, _, 11, s[33]),
                            P = h(P, R, A, C, w, 16, s[34]),
                            C = h(C, P, R, A, T, 23, s[35]),
                            A = h(A, C, P, R, l, 4, s[36]),
                            R = h(R, A, C, P, m, 11, s[37]),
                            P = h(P, R, A, C, y, 16, s[38]),
                            C = h(C, P, R, A, b, 23, s[39]),
                            A = h(A, C, P, R, S, 4, s[40]),
                            R = h(R, A, C, P, o, 11, s[41]),
                            P = h(P, R, A, C, f, 16, s[42]),
                            C = h(C, P, R, A, v, 23, s[43]),
                            A = h(A, C, P, R, x, 4, s[44]),
                            R = h(R, A, C, P, M, 11, s[45]),
                            P = h(P, R, A, C, E, 16, s[46]),
                            A = d(A, C = h(C, P, R, A, p, 23, s[47]), P, R, o, 6, s[48]),
                            R = d(R, A, C, P, y, 10, s[49]),
                            P = d(P, R, A, C, T, 15, s[50]),
                            C = d(C, P, R, A, g, 21, s[51]),
                            A = d(A, C, P, R, M, 6, s[52]),
                            R = d(R, A, C, P, f, 10, s[53]),
                            P = d(P, R, A, C, b, 15, s[54]),
                            C = d(C, P, R, A, l, 21, s[55]),
                            A = d(A, C, P, R, _, 6, s[56]),
                            R = d(R, A, C, P, E, 10, s[57]),
                            P = d(P, R, A, C, v, 15, s[58]),
                            C = d(C, P, R, A, S, 21, s[59]),
                            A = d(A, C, P, R, m, 6, s[60]),
                            R = d(R, A, C, P, w, 10, s[61]),
                            P = d(P, R, A, C, p, 15, s[62]),
                            C = d(C, P, R, A, x, 21, s[63]),
                            a[0] = a[0] + A | 0,
                            a[1] = a[1] + C | 0,
                            a[2] = a[2] + P | 0,
                            a[3] = a[3] + R | 0
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , n = t.words
                              , r = 8 * this._nDataBytes
                              , i = 8 * t.sigBytes;
                            n[i >>> 5] |= 128 << 24 - i % 32;
                            var a = e.floor(r / 4294967296)
                              , o = r;
                            n[15 + (i + 64 >>> 9 << 4)] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                            n[14 + (i + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                            t.sigBytes = 4 * (n.length + 1),
                            this._process();
                            for (var s = this._hash, l = s.words, c = 0; c < 4; c++) {
                                var u = l[c];
                                l[c] = 16711935 & (u << 8 | u >>> 24) | 4278255360 & (u << 24 | u >>> 8)
                            }
                            return s
                        },
                        clone: function() {
                            var e = a.clone.call(this);
                            return e._hash = this._hash.clone(),
                            e
                        }
                    });
                    function c(e, t, n, r, i, a, o) {
                        var s = e + (t & n | ~t & r) + i + o;
                        return (s << a | s >>> 32 - a) + t
                    }
                    function u(e, t, n, r, i, a, o) {
                        var s = e + (t & r | n & ~r) + i + o;
                        return (s << a | s >>> 32 - a) + t
                    }
                    function h(e, t, n, r, i, a, o) {
                        var s = e + (t ^ n ^ r) + i + o;
                        return (s << a | s >>> 32 - a) + t
                    }
                    function d(e, t, n, r, i, a, o) {
                        var s = e + (n ^ (t | ~r)) + i + o;
                        return (s << a | s >>> 32 - a) + t
                    }
                    t.MD5 = a._createHelper(l),
                    t.HmacMD5 = a._createHmacHelper(l)
                }(Math),
                r.MD5)
            },
            8568: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.mode.CFB = function() {
                    var e = r.lib.BlockCipherMode.extend();
                    function t(e, t, n, r) {
                        var i, a = this._iv;
                        a ? (i = a.slice(0),
                        this._iv = void 0) : i = this._prevBlock,
                        r.encryptBlock(i, 0);
                        for (var o = 0; o < n; o++)
                            e[t + o] ^= i[o]
                    }
                    return e.Encryptor = e.extend({
                        processBlock: function(e, n) {
                            var r = this._cipher
                              , i = r.blockSize;
                            t.call(this, e, n, i, r),
                            this._prevBlock = e.slice(n, n + i)
                        }
                    }),
                    e.Decryptor = e.extend({
                        processBlock: function(e, n) {
                            var r = this._cipher
                              , i = r.blockSize
                              , a = e.slice(n, n + i);
                            t.call(this, e, n, i, r),
                            this._prevBlock = a
                        }
                    }),
                    e
                }(),
                r.mode.CFB)
            },
            9968: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.mode.CTRGladman = function() {
                    var e = r.lib.BlockCipherMode.extend();
                    function t(e) {
                        if (255 == (e >> 24 & 255)) {
                            var t = e >> 16 & 255
                              , n = e >> 8 & 255
                              , r = 255 & e;
                            255 === t ? (t = 0,
                            255 === n ? (n = 0,
                            255 === r ? r = 0 : ++r) : ++n) : ++t,
                            e = 0,
                            e += t << 16,
                            e += n << 8,
                            e += r
                        } else
                            e += 1 << 24;
                        return e
                    }
                    var n = e.Encryptor = e.extend({
                        processBlock: function(e, n) {
                            var r = this._cipher
                              , i = r.blockSize
                              , a = this._iv
                              , o = this._counter;
                            a && (o = this._counter = a.slice(0),
                            this._iv = void 0),
                            function(e) {
                                0 === (e[0] = t(e[0])) && (e[1] = t(e[1]))
                            }(o);
                            var s = o.slice(0);
                            r.encryptBlock(s, 0);
                            for (var l = 0; l < i; l++)
                                e[n + l] ^= s[l]
                        }
                    });
                    return e.Decryptor = n,
                    e
                }(),
                r.mode.CTRGladman)
            },
            4242: function(e, t, n) {
                var r, i, a;
                e.exports = (a = n(8249),
                n(5109),
                a.mode.CTR = (i = (r = a.lib.BlockCipherMode.extend()).Encryptor = r.extend({
                    processBlock: function(e, t) {
                        var n = this._cipher
                          , r = n.blockSize
                          , i = this._iv
                          , a = this._counter;
                        i && (a = this._counter = i.slice(0),
                        this._iv = void 0);
                        var o = a.slice(0);
                        n.encryptBlock(o, 0),
                        a[r - 1] = a[r - 1] + 1 | 0;
                        for (var s = 0; s < r; s++)
                            e[t + s] ^= o[s]
                    }
                }),
                r.Decryptor = i,
                r),
                a.mode.CTR)
            },
            1148: function(e, t, n) {
                var r, i;
                e.exports = (i = n(8249),
                n(5109),
                i.mode.ECB = ((r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({
                    processBlock: function(e, t) {
                        this._cipher.encryptBlock(e, t)
                    }
                }),
                r.Decryptor = r.extend({
                    processBlock: function(e, t) {
                        this._cipher.decryptBlock(e, t)
                    }
                }),
                r),
                i.mode.ECB)
            },
            7660: function(e, t, n) {
                var r, i, a;
                e.exports = (a = n(8249),
                n(5109),
                a.mode.OFB = (i = (r = a.lib.BlockCipherMode.extend()).Encryptor = r.extend({
                    processBlock: function(e, t) {
                        var n = this._cipher
                          , r = n.blockSize
                          , i = this._iv
                          , a = this._keystream;
                        i && (a = this._keystream = i.slice(0),
                        this._iv = void 0),
                        n.encryptBlock(a, 0);
                        for (var o = 0; o < r; o++)
                            e[t + o] ^= a[o]
                    }
                }),
                r.Decryptor = i,
                r),
                a.mode.OFB)
            },
            3615: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.pad.AnsiX923 = {
                    pad: function(e, t) {
                        var n = e.sigBytes
                          , r = 4 * t
                          , i = r - n % r
                          , a = n + i - 1;
                        e.clamp(),
                        e.words[a >>> 2] |= i << 24 - a % 4 * 8,
                        e.sigBytes += i
                    },
                    unpad: function(e) {
                        var t = 255 & e.words[e.sigBytes - 1 >>> 2];
                        e.sigBytes -= t
                    }
                },
                r.pad.Ansix923)
            },
            2807: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.pad.Iso10126 = {
                    pad: function(e, t) {
                        var n = 4 * t
                          , i = n - e.sigBytes % n;
                        e.concat(r.lib.WordArray.random(i - 1)).concat(r.lib.WordArray.create([i << 24], 1))
                    },
                    unpad: function(e) {
                        var t = 255 & e.words[e.sigBytes - 1 >>> 2];
                        e.sigBytes -= t
                    }
                },
                r.pad.Iso10126)
            },
            1077: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.pad.Iso97971 = {
                    pad: function(e, t) {
                        e.concat(r.lib.WordArray.create([2147483648], 1)),
                        r.pad.ZeroPadding.pad(e, t)
                    },
                    unpad: function(e) {
                        r.pad.ZeroPadding.unpad(e),
                        e.sigBytes--
                    }
                },
                r.pad.Iso97971)
            },
            6991: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.pad.NoPadding = {
                    pad: function() {},
                    unpad: function() {}
                },
                r.pad.NoPadding)
            },
            6475: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(5109),
                r.pad.ZeroPadding = {
                    pad: function(e, t) {
                        var n = 4 * t;
                        e.clamp(),
                        e.sigBytes += n - (e.sigBytes % n || n)
                    },
                    unpad: function(e) {
                        var t = e.words
                          , n = e.sigBytes - 1;
                        for (n = e.sigBytes - 1; n >= 0; n--)
                            if (t[n >>> 2] >>> 24 - n % 4 * 8 & 255) {
                                e.sigBytes = n + 1;
                                break
                            }
                    }
                },
                r.pad.ZeroPadding)
            },
            2112: function(e, t, n) {
                var r, i, a, o, s, l, c, u, h;
                e.exports = (h = n(8249),
                n(2783),
                n(9824),
                a = (i = (r = h).lib).Base,
                o = i.WordArray,
                l = (s = r.algo).SHA1,
                c = s.HMAC,
                u = s.PBKDF2 = a.extend({
                    cfg: a.extend({
                        keySize: 4,
                        hasher: l,
                        iterations: 1
                    }),
                    init: function(e) {
                        this.cfg = this.cfg.extend(e)
                    },
                    compute: function(e, t) {
                        for (var n = this.cfg, r = c.create(n.hasher, e), i = o.create(), a = o.create([1]), s = i.words, l = a.words, u = n.keySize, h = n.iterations; s.length < u; ) {
                            var d = r.update(t).finalize(a);
                            r.reset();
                            for (var p = d.words, f = p.length, m = d, g = 1; g < h; g++) {
                                m = r.finalize(m),
                                r.reset();
                                for (var v = m.words, y = 0; y < f; y++)
                                    p[y] ^= v[y]
                            }
                            i.concat(d),
                            l[0]++
                        }
                        return i.sigBytes = 4 * u,
                        i
                    }
                }),
                r.PBKDF2 = function(e, t, n) {
                    return u.create(n).compute(e, t)
                }
                ,
                h.PBKDF2)
            },
            3974: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(8269),
                n(8214),
                n(888),
                n(5109),
                function() {
                    var e = r
                      , t = e.lib.StreamCipher
                      , n = e.algo
                      , i = []
                      , a = []
                      , o = []
                      , s = n.RabbitLegacy = t.extend({
                        _doReset: function() {
                            var e = this._key.words
                              , t = this.cfg.iv
                              , n = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16]
                              , r = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]];
                            this._b = 0;
                            for (var i = 0; i < 4; i++)
                                l.call(this);
                            for (i = 0; i < 8; i++)
                                r[i] ^= n[i + 4 & 7];
                            if (t) {
                                var a = t.words
                                  , o = a[0]
                                  , s = a[1]
                                  , c = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                                  , u = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                                  , h = c >>> 16 | 4294901760 & u
                                  , d = u << 16 | 65535 & c;
                                for (r[0] ^= c,
                                r[1] ^= h,
                                r[2] ^= u,
                                r[3] ^= d,
                                r[4] ^= c,
                                r[5] ^= h,
                                r[6] ^= u,
                                r[7] ^= d,
                                i = 0; i < 4; i++)
                                    l.call(this)
                            }
                        },
                        _doProcessBlock: function(e, t) {
                            var n = this._X;
                            l.call(this),
                            i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16,
                            i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16,
                            i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16,
                            i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;
                            for (var r = 0; r < 4; r++)
                                i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8),
                                e[t + r] ^= i[r]
                        },
                        blockSize: 4,
                        ivSize: 2
                    });
                    function l() {
                        for (var e = this._X, t = this._C, n = 0; n < 8; n++)
                            a[n] = t[n];
                        for (t[0] = t[0] + 1295307597 + this._b | 0,
                        t[1] = t[1] + 3545052371 + (t[0] >>> 0 < a[0] >>> 0 ? 1 : 0) | 0,
                        t[2] = t[2] + 886263092 + (t[1] >>> 0 < a[1] >>> 0 ? 1 : 0) | 0,
                        t[3] = t[3] + 1295307597 + (t[2] >>> 0 < a[2] >>> 0 ? 1 : 0) | 0,
                        t[4] = t[4] + 3545052371 + (t[3] >>> 0 < a[3] >>> 0 ? 1 : 0) | 0,
                        t[5] = t[5] + 886263092 + (t[4] >>> 0 < a[4] >>> 0 ? 1 : 0) | 0,
                        t[6] = t[6] + 1295307597 + (t[5] >>> 0 < a[5] >>> 0 ? 1 : 0) | 0,
                        t[7] = t[7] + 3545052371 + (t[6] >>> 0 < a[6] >>> 0 ? 1 : 0) | 0,
                        this._b = t[7] >>> 0 < a[7] >>> 0 ? 1 : 0,
                        n = 0; n < 8; n++) {
                            var r = e[n] + t[n]
                              , i = 65535 & r
                              , s = r >>> 16
                              , l = ((i * i >>> 17) + i * s >>> 15) + s * s
                              , c = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                            o[n] = l ^ c
                        }
                        e[0] = o[0] + (o[7] << 16 | o[7] >>> 16) + (o[6] << 16 | o[6] >>> 16) | 0,
                        e[1] = o[1] + (o[0] << 8 | o[0] >>> 24) + o[7] | 0,
                        e[2] = o[2] + (o[1] << 16 | o[1] >>> 16) + (o[0] << 16 | o[0] >>> 16) | 0,
                        e[3] = o[3] + (o[2] << 8 | o[2] >>> 24) + o[1] | 0,
                        e[4] = o[4] + (o[3] << 16 | o[3] >>> 16) + (o[2] << 16 | o[2] >>> 16) | 0,
                        e[5] = o[5] + (o[4] << 8 | o[4] >>> 24) + o[3] | 0,
                        e[6] = o[6] + (o[5] << 16 | o[5] >>> 16) + (o[4] << 16 | o[4] >>> 16) | 0,
                        e[7] = o[7] + (o[6] << 8 | o[6] >>> 24) + o[5] | 0
                    }
                    e.RabbitLegacy = t._createHelper(s)
                }(),
                r.RabbitLegacy)
            },
            4454: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(8269),
                n(8214),
                n(888),
                n(5109),
                function() {
                    var e = r
                      , t = e.lib.StreamCipher
                      , n = e.algo
                      , i = []
                      , a = []
                      , o = []
                      , s = n.Rabbit = t.extend({
                        _doReset: function() {
                            for (var e = this._key.words, t = this.cfg.iv, n = 0; n < 4; n++)
                                e[n] = 16711935 & (e[n] << 8 | e[n] >>> 24) | 4278255360 & (e[n] << 24 | e[n] >>> 8);
                            var r = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16]
                              , i = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]];
                            for (this._b = 0,
                            n = 0; n < 4; n++)
                                l.call(this);
                            for (n = 0; n < 8; n++)
                                i[n] ^= r[n + 4 & 7];
                            if (t) {
                                var a = t.words
                                  , o = a[0]
                                  , s = a[1]
                                  , c = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                                  , u = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                                  , h = c >>> 16 | 4294901760 & u
                                  , d = u << 16 | 65535 & c;
                                for (i[0] ^= c,
                                i[1] ^= h,
                                i[2] ^= u,
                                i[3] ^= d,
                                i[4] ^= c,
                                i[5] ^= h,
                                i[6] ^= u,
                                i[7] ^= d,
                                n = 0; n < 4; n++)
                                    l.call(this)
                            }
                        },
                        _doProcessBlock: function(e, t) {
                            var n = this._X;
                            l.call(this),
                            i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16,
                            i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16,
                            i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16,
                            i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;
                            for (var r = 0; r < 4; r++)
                                i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8),
                                e[t + r] ^= i[r]
                        },
                        blockSize: 4,
                        ivSize: 2
                    });
                    function l() {
                        for (var e = this._X, t = this._C, n = 0; n < 8; n++)
                            a[n] = t[n];
                        for (t[0] = t[0] + 1295307597 + this._b | 0,
                        t[1] = t[1] + 3545052371 + (t[0] >>> 0 < a[0] >>> 0 ? 1 : 0) | 0,
                        t[2] = t[2] + 886263092 + (t[1] >>> 0 < a[1] >>> 0 ? 1 : 0) | 0,
                        t[3] = t[3] + 1295307597 + (t[2] >>> 0 < a[2] >>> 0 ? 1 : 0) | 0,
                        t[4] = t[4] + 3545052371 + (t[3] >>> 0 < a[3] >>> 0 ? 1 : 0) | 0,
                        t[5] = t[5] + 886263092 + (t[4] >>> 0 < a[4] >>> 0 ? 1 : 0) | 0,
                        t[6] = t[6] + 1295307597 + (t[5] >>> 0 < a[5] >>> 0 ? 1 : 0) | 0,
                        t[7] = t[7] + 3545052371 + (t[6] >>> 0 < a[6] >>> 0 ? 1 : 0) | 0,
                        this._b = t[7] >>> 0 < a[7] >>> 0 ? 1 : 0,
                        n = 0; n < 8; n++) {
                            var r = e[n] + t[n]
                              , i = 65535 & r
                              , s = r >>> 16
                              , l = ((i * i >>> 17) + i * s >>> 15) + s * s
                              , c = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                            o[n] = l ^ c
                        }
                        e[0] = o[0] + (o[7] << 16 | o[7] >>> 16) + (o[6] << 16 | o[6] >>> 16) | 0,
                        e[1] = o[1] + (o[0] << 8 | o[0] >>> 24) + o[7] | 0,
                        e[2] = o[2] + (o[1] << 16 | o[1] >>> 16) + (o[0] << 16 | o[0] >>> 16) | 0,
                        e[3] = o[3] + (o[2] << 8 | o[2] >>> 24) + o[1] | 0,
                        e[4] = o[4] + (o[3] << 16 | o[3] >>> 16) + (o[2] << 16 | o[2] >>> 16) | 0,
                        e[5] = o[5] + (o[4] << 8 | o[4] >>> 24) + o[3] | 0,
                        e[6] = o[6] + (o[5] << 16 | o[5] >>> 16) + (o[4] << 16 | o[4] >>> 16) | 0,
                        e[7] = o[7] + (o[6] << 8 | o[6] >>> 24) + o[5] | 0
                    }
                    e.Rabbit = t._createHelper(s)
                }(),
                r.Rabbit)
            },
            1857: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(8269),
                n(8214),
                n(888),
                n(5109),
                function() {
                    var e = r
                      , t = e.lib.StreamCipher
                      , n = e.algo
                      , i = n.RC4 = t.extend({
                        _doReset: function() {
                            for (var e = this._key, t = e.words, n = e.sigBytes, r = this._S = [], i = 0; i < 256; i++)
                                r[i] = i;
                            i = 0;
                            for (var a = 0; i < 256; i++) {
                                var o = i % n
                                  , s = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                                a = (a + r[i] + s) % 256;
                                var l = r[i];
                                r[i] = r[a],
                                r[a] = l
                            }
                            this._i = this._j = 0
                        },
                        _doProcessBlock: function(e, t) {
                            e[t] ^= a.call(this)
                        },
                        keySize: 8,
                        ivSize: 0
                    });
                    function a() {
                        for (var e = this._S, t = this._i, n = this._j, r = 0, i = 0; i < 4; i++) {
                            n = (n + e[t = (t + 1) % 256]) % 256;
                            var a = e[t];
                            e[t] = e[n],
                            e[n] = a,
                            r |= e[(e[t] + e[n]) % 256] << 24 - 8 * i
                        }
                        return this._i = t,
                        this._j = n,
                        r
                    }
                    e.RC4 = t._createHelper(i);
                    var o = n.RC4Drop = i.extend({
                        cfg: i.cfg.extend({
                            drop: 192
                        }),
                        _doReset: function() {
                            i._doReset.call(this);
                            for (var e = this.cfg.drop; e > 0; e--)
                                a.call(this)
                        }
                    });
                    e.RC4Drop = t._createHelper(o)
                }(),
                r.RC4)
            },
            706: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                function(e) {
                    var t = r
                      , n = t.lib
                      , i = n.WordArray
                      , a = n.Hasher
                      , o = t.algo
                      , s = i.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13])
                      , l = i.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11])
                      , c = i.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6])
                      , u = i.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11])
                      , h = i.create([0, 1518500249, 1859775393, 2400959708, 2840853838])
                      , d = i.create([1352829926, 1548603684, 1836072691, 2053994217, 0])
                      , p = o.RIPEMD160 = a.extend({
                        _doReset: function() {
                            this._hash = i.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                        },
                        _doProcessBlock: function(e, t) {
                            for (var n = 0; n < 16; n++) {
                                var r = t + n
                                  , i = e[r];
                                e[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
                            }
                            var a, o, p, x, b, w, M, S, T, E, A, C = this._hash.words, P = h.words, R = d.words, L = s.words, D = l.words, O = c.words, F = u.words;
                            for (w = a = C[0],
                            M = o = C[1],
                            S = p = C[2],
                            T = x = C[3],
                            E = b = C[4],
                            n = 0; n < 80; n += 1)
                                A = a + e[t + L[n]] | 0,
                                A += n < 16 ? f(o, p, x) + P[0] : n < 32 ? m(o, p, x) + P[1] : n < 48 ? g(o, p, x) + P[2] : n < 64 ? v(o, p, x) + P[3] : y(o, p, x) + P[4],
                                A = (A = _(A |= 0, O[n])) + b | 0,
                                a = b,
                                b = x,
                                x = _(p, 10),
                                p = o,
                                o = A,
                                A = w + e[t + D[n]] | 0,
                                A += n < 16 ? y(M, S, T) + R[0] : n < 32 ? v(M, S, T) + R[1] : n < 48 ? g(M, S, T) + R[2] : n < 64 ? m(M, S, T) + R[3] : f(M, S, T) + R[4],
                                A = (A = _(A |= 0, F[n])) + E | 0,
                                w = E,
                                E = T,
                                T = _(S, 10),
                                S = M,
                                M = A;
                            A = C[1] + p + T | 0,
                            C[1] = C[2] + x + E | 0,
                            C[2] = C[3] + b + w | 0,
                            C[3] = C[4] + a + M | 0,
                            C[4] = C[0] + o + S | 0,
                            C[0] = A
                        },
                        _doFinalize: function() {
                            var e = this._data
                              , t = e.words
                              , n = 8 * this._nDataBytes
                              , r = 8 * e.sigBytes;
                            t[r >>> 5] |= 128 << 24 - r % 32,
                            t[14 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8),
                            e.sigBytes = 4 * (t.length + 1),
                            this._process();
                            for (var i = this._hash, a = i.words, o = 0; o < 5; o++) {
                                var s = a[o];
                                a[o] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                            }
                            return i
                        },
                        clone: function() {
                            var e = a.clone.call(this);
                            return e._hash = this._hash.clone(),
                            e
                        }
                    });
                    function f(e, t, n) {
                        return e ^ t ^ n
                    }
                    function m(e, t, n) {
                        return e & t | ~e & n
                    }
                    function g(e, t, n) {
                        return (e | ~t) ^ n
                    }
                    function v(e, t, n) {
                        return e & n | t & ~n
                    }
                    function y(e, t, n) {
                        return e ^ (t | ~n)
                    }
                    function _(e, t) {
                        return e << t | e >>> 32 - t
                    }
                    t.RIPEMD160 = a._createHelper(p),
                    t.HmacRIPEMD160 = a._createHmacHelper(p)
                }(Math),
                r.RIPEMD160)
            },
            2783: function(e, t, n) {
                var r, i, a, o, s, l, c, u;
                e.exports = (i = (r = u = n(8249)).lib,
                a = i.WordArray,
                o = i.Hasher,
                s = r.algo,
                l = [],
                c = s.SHA1 = o.extend({
                    _doReset: function() {
                        this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                    },
                    _doProcessBlock: function(e, t) {
                        for (var n = this._hash.words, r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], c = 0; c < 80; c++) {
                            if (c < 16)
                                l[c] = 0 | e[t + c];
                            else {
                                var u = l[c - 3] ^ l[c - 8] ^ l[c - 14] ^ l[c - 16];
                                l[c] = u << 1 | u >>> 31
                            }
                            var h = (r << 5 | r >>> 27) + s + l[c];
                            h += c < 20 ? 1518500249 + (i & a | ~i & o) : c < 40 ? 1859775393 + (i ^ a ^ o) : c < 60 ? (i & a | i & o | a & o) - 1894007588 : (i ^ a ^ o) - 899497514,
                            s = o,
                            o = a,
                            a = i << 30 | i >>> 2,
                            i = r,
                            r = h
                        }
                        n[0] = n[0] + r | 0,
                        n[1] = n[1] + i | 0,
                        n[2] = n[2] + a | 0,
                        n[3] = n[3] + o | 0,
                        n[4] = n[4] + s | 0
                    },
                    _doFinalize: function() {
                        var e = this._data
                          , t = e.words
                          , n = 8 * this._nDataBytes
                          , r = 8 * e.sigBytes;
                        return t[r >>> 5] |= 128 << 24 - r % 32,
                        t[14 + (r + 64 >>> 9 << 4)] = Math.floor(n / 4294967296),
                        t[15 + (r + 64 >>> 9 << 4)] = n,
                        e.sigBytes = 4 * t.length,
                        this._process(),
                        this._hash
                    },
                    clone: function() {
                        var e = o.clone.call(this);
                        return e._hash = this._hash.clone(),
                        e
                    }
                }),
                r.SHA1 = o._createHelper(c),
                r.HmacSHA1 = o._createHmacHelper(c),
                u.SHA1)
            },
            7792: function(e, t, n) {
                var r, i, a, o, s, l;
                e.exports = (l = n(8249),
                n(2153),
                i = (r = l).lib.WordArray,
                a = r.algo,
                o = a.SHA256,
                s = a.SHA224 = o.extend({
                    _doReset: function() {
                        this._hash = new i.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                    },
                    _doFinalize: function() {
                        var e = o._doFinalize.call(this);
                        return e.sigBytes -= 4,
                        e
                    }
                }),
                r.SHA224 = o._createHelper(s),
                r.HmacSHA224 = o._createHmacHelper(s),
                l.SHA224)
            },
            2153: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                function(e) {
                    var t = r
                      , n = t.lib
                      , i = n.WordArray
                      , a = n.Hasher
                      , o = t.algo
                      , s = []
                      , l = [];
                    !function() {
                        function t(t) {
                            for (var n = e.sqrt(t), r = 2; r <= n; r++)
                                if (!(t % r))
                                    return !1;
                            return !0
                        }
                        function n(e) {
                            return 4294967296 * (e - (0 | e)) | 0
                        }
                        for (var r = 2, i = 0; i < 64; )
                            t(r) && (i < 8 && (s[i] = n(e.pow(r, .5))),
                            l[i] = n(e.pow(r, 1 / 3)),
                            i++),
                            r++
                    }();
                    var c = []
                      , u = o.SHA256 = a.extend({
                        _doReset: function() {
                            this._hash = new i.init(s.slice(0))
                        },
                        _doProcessBlock: function(e, t) {
                            for (var n = this._hash.words, r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], u = n[5], h = n[6], d = n[7], p = 0; p < 64; p++) {
                                if (p < 16)
                                    c[p] = 0 | e[t + p];
                                else {
                                    var f = c[p - 15]
                                      , m = (f << 25 | f >>> 7) ^ (f << 14 | f >>> 18) ^ f >>> 3
                                      , g = c[p - 2]
                                      , v = (g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10;
                                    c[p] = m + c[p - 7] + v + c[p - 16]
                                }
                                var y = r & i ^ r & a ^ i & a
                                  , _ = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22)
                                  , x = d + ((s << 26 | s >>> 6) ^ (s << 21 | s >>> 11) ^ (s << 7 | s >>> 25)) + (s & u ^ ~s & h) + l[p] + c[p];
                                d = h,
                                h = u,
                                u = s,
                                s = o + x | 0,
                                o = a,
                                a = i,
                                i = r,
                                r = x + (_ + y) | 0
                            }
                            n[0] = n[0] + r | 0,
                            n[1] = n[1] + i | 0,
                            n[2] = n[2] + a | 0,
                            n[3] = n[3] + o | 0,
                            n[4] = n[4] + s | 0,
                            n[5] = n[5] + u | 0,
                            n[6] = n[6] + h | 0,
                            n[7] = n[7] + d | 0
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , n = t.words
                              , r = 8 * this._nDataBytes
                              , i = 8 * t.sigBytes;
                            return n[i >>> 5] |= 128 << 24 - i % 32,
                            n[14 + (i + 64 >>> 9 << 4)] = e.floor(r / 4294967296),
                            n[15 + (i + 64 >>> 9 << 4)] = r,
                            t.sigBytes = 4 * n.length,
                            this._process(),
                            this._hash
                        },
                        clone: function() {
                            var e = a.clone.call(this);
                            return e._hash = this._hash.clone(),
                            e
                        }
                    });
                    t.SHA256 = a._createHelper(u),
                    t.HmacSHA256 = a._createHmacHelper(u)
                }(Math),
                r.SHA256)
            },
            3327: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(4938),
                function(e) {
                    var t = r
                      , n = t.lib
                      , i = n.WordArray
                      , a = n.Hasher
                      , o = t.x64.Word
                      , s = t.algo
                      , l = []
                      , c = []
                      , u = [];
                    !function() {
                        for (var e = 1, t = 0, n = 0; n < 24; n++) {
                            l[e + 5 * t] = (n + 1) * (n + 2) / 2 % 64;
                            var r = (2 * e + 3 * t) % 5;
                            e = t % 5,
                            t = r
                        }
                        for (e = 0; e < 5; e++)
                            for (t = 0; t < 5; t++)
                                c[e + 5 * t] = t + (2 * e + 3 * t) % 5 * 5;
                        for (var i = 1, a = 0; a < 24; a++) {
                            for (var s = 0, h = 0, d = 0; d < 7; d++) {
                                if (1 & i) {
                                    var p = (1 << d) - 1;
                                    p < 32 ? h ^= 1 << p : s ^= 1 << p - 32
                                }
                                128 & i ? i = i << 1 ^ 113 : i <<= 1
                            }
                            u[a] = o.create(s, h)
                        }
                    }();
                    var h = [];
                    !function() {
                        for (var e = 0; e < 25; e++)
                            h[e] = o.create()
                    }();
                    var d = s.SHA3 = a.extend({
                        cfg: a.cfg.extend({
                            outputLength: 512
                        }),
                        _doReset: function() {
                            for (var e = this._state = [], t = 0; t < 25; t++)
                                e[t] = new o.init;
                            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                        },
                        _doProcessBlock: function(e, t) {
                            for (var n = this._state, r = this.blockSize / 2, i = 0; i < r; i++) {
                                var a = e[t + 2 * i]
                                  , o = e[t + 2 * i + 1];
                                a = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                                (C = n[i]).high ^= o,
                                C.low ^= a
                            }
                            for (var s = 0; s < 24; s++) {
                                for (var d = 0; d < 5; d++) {
                                    for (var p = 0, f = 0, m = 0; m < 5; m++)
                                        p ^= (C = n[d + 5 * m]).high,
                                        f ^= C.low;
                                    var g = h[d];
                                    g.high = p,
                                    g.low = f
                                }
                                for (d = 0; d < 5; d++) {
                                    var v = h[(d + 4) % 5]
                                      , y = h[(d + 1) % 5]
                                      , _ = y.high
                                      , x = y.low;
                                    for (p = v.high ^ (_ << 1 | x >>> 31),
                                    f = v.low ^ (x << 1 | _ >>> 31),
                                    m = 0; m < 5; m++)
                                        (C = n[d + 5 * m]).high ^= p,
                                        C.low ^= f
                                }
                                for (var b = 1; b < 25; b++) {
                                    var w = (C = n[b]).high
                                      , M = C.low
                                      , S = l[b];
                                    S < 32 ? (p = w << S | M >>> 32 - S,
                                    f = M << S | w >>> 32 - S) : (p = M << S - 32 | w >>> 64 - S,
                                    f = w << S - 32 | M >>> 64 - S);
                                    var T = h[c[b]];
                                    T.high = p,
                                    T.low = f
                                }
                                var E = h[0]
                                  , A = n[0];
                                for (E.high = A.high,
                                E.low = A.low,
                                d = 0; d < 5; d++)
                                    for (m = 0; m < 5; m++) {
                                        var C = n[b = d + 5 * m]
                                          , P = h[b]
                                          , R = h[(d + 1) % 5 + 5 * m]
                                          , L = h[(d + 2) % 5 + 5 * m];
                                        C.high = P.high ^ ~R.high & L.high,
                                        C.low = P.low ^ ~R.low & L.low
                                    }
                                C = n[0];
                                var D = u[s];
                                C.high ^= D.high,
                                C.low ^= D.low
                            }
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , n = t.words
                              , r = (this._nDataBytes,
                            8 * t.sigBytes)
                              , a = 32 * this.blockSize;
                            n[r >>> 5] |= 1 << 24 - r % 32,
                            n[(e.ceil((r + 1) / a) * a >>> 5) - 1] |= 128,
                            t.sigBytes = 4 * n.length,
                            this._process();
                            for (var o = this._state, s = this.cfg.outputLength / 8, l = s / 8, c = [], u = 0; u < l; u++) {
                                var h = o[u]
                                  , d = h.high
                                  , p = h.low;
                                d = 16711935 & (d << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8),
                                p = 16711935 & (p << 8 | p >>> 24) | 4278255360 & (p << 24 | p >>> 8),
                                c.push(p),
                                c.push(d)
                            }
                            return new i.init(c,s)
                        },
                        clone: function() {
                            for (var e = a.clone.call(this), t = e._state = this._state.slice(0), n = 0; n < 25; n++)
                                t[n] = t[n].clone();
                            return e
                        }
                    });
                    t.SHA3 = a._createHelper(d),
                    t.HmacSHA3 = a._createHmacHelper(d)
                }(Math),
                r.SHA3)
            },
            7460: function(e, t, n) {
                var r, i, a, o, s, l, c, u;
                e.exports = (u = n(8249),
                n(4938),
                n(34),
                i = (r = u).x64,
                a = i.Word,
                o = i.WordArray,
                s = r.algo,
                l = s.SHA512,
                c = s.SHA384 = l.extend({
                    _doReset: function() {
                        this._hash = new o.init([new a.init(3418070365,3238371032), new a.init(1654270250,914150663), new a.init(2438529370,812702999), new a.init(355462360,4144912697), new a.init(1731405415,4290775857), new a.init(2394180231,1750603025), new a.init(3675008525,1694076839), new a.init(1203062813,3204075428)])
                    },
                    _doFinalize: function() {
                        var e = l._doFinalize.call(this);
                        return e.sigBytes -= 16,
                        e
                    }
                }),
                r.SHA384 = l._createHelper(c),
                r.HmacSHA384 = l._createHmacHelper(c),
                u.SHA384)
            },
            34: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(4938),
                function() {
                    var e = r
                      , t = e.lib.Hasher
                      , n = e.x64
                      , i = n.Word
                      , a = n.WordArray
                      , o = e.algo;
                    function s() {
                        return i.create.apply(i, arguments)
                    }
                    var l = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)]
                      , c = [];
                    !function() {
                        for (var e = 0; e < 80; e++)
                            c[e] = s()
                    }();
                    var u = o.SHA512 = t.extend({
                        _doReset: function() {
                            this._hash = new a.init([new i.init(1779033703,4089235720), new i.init(3144134277,2227873595), new i.init(1013904242,4271175723), new i.init(2773480762,1595750129), new i.init(1359893119,2917565137), new i.init(2600822924,725511199), new i.init(528734635,4215389547), new i.init(1541459225,327033209)])
                        },
                        _doProcessBlock: function(e, t) {
                            for (var n = this._hash.words, r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], u = n[5], h = n[6], d = n[7], p = r.high, f = r.low, m = i.high, g = i.low, v = a.high, y = a.low, _ = o.high, x = o.low, b = s.high, w = s.low, M = u.high, S = u.low, T = h.high, E = h.low, A = d.high, C = d.low, P = p, R = f, L = m, D = g, O = v, F = y, I = _, N = x, B = b, k = w, z = M, U = S, H = T, G = E, j = A, V = C, W = 0; W < 80; W++) {
                                var q, X, Y = c[W];
                                if (W < 16)
                                    X = Y.high = 0 | e[t + 2 * W],
                                    q = Y.low = 0 | e[t + 2 * W + 1];
                                else {
                                    var Z = c[W - 15]
                                      , J = Z.high
                                      , K = Z.low
                                      , Q = (J >>> 1 | K << 31) ^ (J >>> 8 | K << 24) ^ J >>> 7
                                      , $ = (K >>> 1 | J << 31) ^ (K >>> 8 | J << 24) ^ (K >>> 7 | J << 25)
                                      , ee = c[W - 2]
                                      , te = ee.high
                                      , ne = ee.low
                                      , re = (te >>> 19 | ne << 13) ^ (te << 3 | ne >>> 29) ^ te >>> 6
                                      , ie = (ne >>> 19 | te << 13) ^ (ne << 3 | te >>> 29) ^ (ne >>> 6 | te << 26)
                                      , ae = c[W - 7]
                                      , oe = ae.high
                                      , se = ae.low
                                      , le = c[W - 16]
                                      , ce = le.high
                                      , ue = le.low;
                                    X = (X = (X = Q + oe + ((q = $ + se) >>> 0 < $ >>> 0 ? 1 : 0)) + re + ((q += ie) >>> 0 < ie >>> 0 ? 1 : 0)) + ce + ((q += ue) >>> 0 < ue >>> 0 ? 1 : 0),
                                    Y.high = X,
                                    Y.low = q
                                }
                                var he, de = B & z ^ ~B & H, pe = k & U ^ ~k & G, fe = P & L ^ P & O ^ L & O, me = R & D ^ R & F ^ D & F, ge = (P >>> 28 | R << 4) ^ (P << 30 | R >>> 2) ^ (P << 25 | R >>> 7), ve = (R >>> 28 | P << 4) ^ (R << 30 | P >>> 2) ^ (R << 25 | P >>> 7), ye = (B >>> 14 | k << 18) ^ (B >>> 18 | k << 14) ^ (B << 23 | k >>> 9), _e = (k >>> 14 | B << 18) ^ (k >>> 18 | B << 14) ^ (k << 23 | B >>> 9), xe = l[W], be = xe.high, we = xe.low, Me = j + ye + ((he = V + _e) >>> 0 < V >>> 0 ? 1 : 0), Se = ve + me;
                                j = H,
                                V = G,
                                H = z,
                                G = U,
                                z = B,
                                U = k,
                                B = I + (Me = (Me = (Me = Me + de + ((he += pe) >>> 0 < pe >>> 0 ? 1 : 0)) + be + ((he += we) >>> 0 < we >>> 0 ? 1 : 0)) + X + ((he += q) >>> 0 < q >>> 0 ? 1 : 0)) + ((k = N + he | 0) >>> 0 < N >>> 0 ? 1 : 0) | 0,
                                I = O,
                                N = F,
                                O = L,
                                F = D,
                                L = P,
                                D = R,
                                P = Me + (ge + fe + (Se >>> 0 < ve >>> 0 ? 1 : 0)) + ((R = he + Se | 0) >>> 0 < he >>> 0 ? 1 : 0) | 0
                            }
                            f = r.low = f + R,
                            r.high = p + P + (f >>> 0 < R >>> 0 ? 1 : 0),
                            g = i.low = g + D,
                            i.high = m + L + (g >>> 0 < D >>> 0 ? 1 : 0),
                            y = a.low = y + F,
                            a.high = v + O + (y >>> 0 < F >>> 0 ? 1 : 0),
                            x = o.low = x + N,
                            o.high = _ + I + (x >>> 0 < N >>> 0 ? 1 : 0),
                            w = s.low = w + k,
                            s.high = b + B + (w >>> 0 < k >>> 0 ? 1 : 0),
                            S = u.low = S + U,
                            u.high = M + z + (S >>> 0 < U >>> 0 ? 1 : 0),
                            E = h.low = E + G,
                            h.high = T + H + (E >>> 0 < G >>> 0 ? 1 : 0),
                            C = d.low = C + V,
                            d.high = A + j + (C >>> 0 < V >>> 0 ? 1 : 0)
                        },
                        _doFinalize: function() {
                            var e = this._data
                              , t = e.words
                              , n = 8 * this._nDataBytes
                              , r = 8 * e.sigBytes;
                            return t[r >>> 5] |= 128 << 24 - r % 32,
                            t[30 + (r + 128 >>> 10 << 5)] = Math.floor(n / 4294967296),
                            t[31 + (r + 128 >>> 10 << 5)] = n,
                            e.sigBytes = 4 * t.length,
                            this._process(),
                            this._hash.toX32()
                        },
                        clone: function() {
                            var e = t.clone.call(this);
                            return e._hash = this._hash.clone(),
                            e
                        },
                        blockSize: 32
                    });
                    e.SHA512 = t._createHelper(u),
                    e.HmacSHA512 = t._createHmacHelper(u)
                }(),
                r.SHA512)
            },
            4253: function(e, t, n) {
                var r;
                e.exports = (r = n(8249),
                n(8269),
                n(8214),
                n(888),
                n(5109),
                function() {
                    var e = r
                      , t = e.lib
                      , n = t.WordArray
                      , i = t.BlockCipher
                      , a = e.algo
                      , o = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
                      , s = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
                      , l = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]
                      , c = [{
                        0: 8421888,
                        268435456: 32768,
                        536870912: 8421378,
                        805306368: 2,
                        1073741824: 512,
                        1342177280: 8421890,
                        1610612736: 8389122,
                        1879048192: 8388608,
                        2147483648: 514,
                        2415919104: 8389120,
                        2684354560: 33280,
                        2952790016: 8421376,
                        3221225472: 32770,
                        3489660928: 8388610,
                        3758096384: 0,
                        4026531840: 33282,
                        134217728: 0,
                        402653184: 8421890,
                        671088640: 33282,
                        939524096: 32768,
                        1207959552: 8421888,
                        1476395008: 512,
                        1744830464: 8421378,
                        2013265920: 2,
                        2281701376: 8389120,
                        2550136832: 33280,
                        2818572288: 8421376,
                        3087007744: 8389122,
                        3355443200: 8388610,
                        3623878656: 32770,
                        3892314112: 514,
                        4160749568: 8388608,
                        1: 32768,
                        268435457: 2,
                        536870913: 8421888,
                        805306369: 8388608,
                        1073741825: 8421378,
                        1342177281: 33280,
                        1610612737: 512,
                        1879048193: 8389122,
                        2147483649: 8421890,
                        2415919105: 8421376,
                        2684354561: 8388610,
                        2952790017: 33282,
                        3221225473: 514,
                        3489660929: 8389120,
                        3758096385: 32770,
                        4026531841: 0,
                        134217729: 8421890,
                        402653185: 8421376,
                        671088641: 8388608,
                        939524097: 512,
                        1207959553: 32768,
                        1476395009: 8388610,
                        1744830465: 2,
                        2013265921: 33282,
                        2281701377: 32770,
                        2550136833: 8389122,
                        2818572289: 514,
                        3087007745: 8421888,
                        3355443201: 8389120,
                        3623878657: 0,
                        3892314113: 33280,
                        4160749569: 8421378
                    }, {
                        0: 1074282512,
                        16777216: 16384,
                        33554432: 524288,
                        50331648: 1074266128,
                        67108864: 1073741840,
                        83886080: 1074282496,
                        100663296: 1073758208,
                        117440512: 16,
                        134217728: 540672,
                        150994944: 1073758224,
                        167772160: 1073741824,
                        184549376: 540688,
                        201326592: 524304,
                        218103808: 0,
                        234881024: 16400,
                        251658240: 1074266112,
                        8388608: 1073758208,
                        25165824: 540688,
                        41943040: 16,
                        58720256: 1073758224,
                        75497472: 1074282512,
                        92274688: 1073741824,
                        109051904: 524288,
                        125829120: 1074266128,
                        142606336: 524304,
                        159383552: 0,
                        176160768: 16384,
                        192937984: 1074266112,
                        209715200: 1073741840,
                        226492416: 540672,
                        243269632: 1074282496,
                        260046848: 16400,
                        268435456: 0,
                        285212672: 1074266128,
                        301989888: 1073758224,
                        318767104: 1074282496,
                        335544320: 1074266112,
                        352321536: 16,
                        369098752: 540688,
                        385875968: 16384,
                        402653184: 16400,
                        419430400: 524288,
                        436207616: 524304,
                        452984832: 1073741840,
                        469762048: 540672,
                        486539264: 1073758208,
                        503316480: 1073741824,
                        520093696: 1074282512,
                        276824064: 540688,
                        293601280: 524288,
                        310378496: 1074266112,
                        327155712: 16384,
                        343932928: 1073758208,
                        360710144: 1074282512,
                        377487360: 16,
                        394264576: 1073741824,
                        411041792: 1074282496,
                        427819008: 1073741840,
                        444596224: 1073758224,
                        461373440: 524304,
                        478150656: 0,
                        494927872: 16400,
                        511705088: 1074266128,
                        528482304: 540672
                    }, {
                        0: 260,
                        1048576: 0,
                        2097152: 67109120,
                        3145728: 65796,
                        4194304: 65540,
                        5242880: 67108868,
                        6291456: 67174660,
                        7340032: 67174400,
                        8388608: 67108864,
                        9437184: 67174656,
                        10485760: 65792,
                        11534336: 67174404,
                        12582912: 67109124,
                        13631488: 65536,
                        14680064: 4,
                        15728640: 256,
                        524288: 67174656,
                        1572864: 67174404,
                        2621440: 0,
                        3670016: 67109120,
                        4718592: 67108868,
                        5767168: 65536,
                        6815744: 65540,
                        7864320: 260,
                        8912896: 4,
                        9961472: 256,
                        11010048: 67174400,
                        12058624: 65796,
                        13107200: 65792,
                        14155776: 67109124,
                        15204352: 67174660,
                        16252928: 67108864,
                        16777216: 67174656,
                        17825792: 65540,
                        18874368: 65536,
                        19922944: 67109120,
                        20971520: 256,
                        22020096: 67174660,
                        23068672: 67108868,
                        24117248: 0,
                        25165824: 67109124,
                        26214400: 67108864,
                        27262976: 4,
                        28311552: 65792,
                        29360128: 67174400,
                        30408704: 260,
                        31457280: 65796,
                        32505856: 67174404,
                        17301504: 67108864,
                        18350080: 260,
                        19398656: 67174656,
                        20447232: 0,
                        21495808: 65540,
                        22544384: 67109120,
                        23592960: 256,
                        24641536: 67174404,
                        25690112: 65536,
                        26738688: 67174660,
                        27787264: 65796,
                        28835840: 67108868,
                        29884416: 67109124,
                        30932992: 67174400,
                        31981568: 4,
                        33030144: 65792
                    }, {
                        0: 2151682048,
                        65536: 2147487808,
                        131072: 4198464,
                        196608: 2151677952,
                        262144: 0,
                        327680: 4198400,
                        393216: 2147483712,
                        458752: 4194368,
                        524288: 2147483648,
                        589824: 4194304,
                        655360: 64,
                        720896: 2147487744,
                        786432: 2151678016,
                        851968: 4160,
                        917504: 4096,
                        983040: 2151682112,
                        32768: 2147487808,
                        98304: 64,
                        163840: 2151678016,
                        229376: 2147487744,
                        294912: 4198400,
                        360448: 2151682112,
                        425984: 0,
                        491520: 2151677952,
                        557056: 4096,
                        622592: 2151682048,
                        688128: 4194304,
                        753664: 4160,
                        819200: 2147483648,
                        884736: 4194368,
                        950272: 4198464,
                        1015808: 2147483712,
                        1048576: 4194368,
                        1114112: 4198400,
                        1179648: 2147483712,
                        1245184: 0,
                        1310720: 4160,
                        1376256: 2151678016,
                        1441792: 2151682048,
                        1507328: 2147487808,
                        1572864: 2151682112,
                        1638400: 2147483648,
                        1703936: 2151677952,
                        1769472: 4198464,
                        1835008: 2147487744,
                        1900544: 4194304,
                        1966080: 64,
                        2031616: 4096,
                        1081344: 2151677952,
                        1146880: 2151682112,
                        1212416: 0,
                        1277952: 4198400,
                        1343488: 4194368,
                        1409024: 2147483648,
                        1474560: 2147487808,
                        1540096: 64,
                        1605632: 2147483712,
                        1671168: 4096,
                        1736704: 2147487744,
                        1802240: 2151678016,
                        1867776: 4160,
                        1933312: 2151682048,
                        1998848: 4194304,
                        2064384: 4198464
                    }, {
                        0: 128,
                        4096: 17039360,
                        8192: 262144,
                        12288: 536870912,
                        16384: 537133184,
                        20480: 16777344,
                        24576: 553648256,
                        28672: 262272,
                        32768: 16777216,
                        36864: 537133056,
                        40960: 536871040,
                        45056: 553910400,
                        49152: 553910272,
                        53248: 0,
                        57344: 17039488,
                        61440: 553648128,
                        2048: 17039488,
                        6144: 553648256,
                        10240: 128,
                        14336: 17039360,
                        18432: 262144,
                        22528: 537133184,
                        26624: 553910272,
                        30720: 536870912,
                        34816: 537133056,
                        38912: 0,
                        43008: 553910400,
                        47104: 16777344,
                        51200: 536871040,
                        55296: 553648128,
                        59392: 16777216,
                        63488: 262272,
                        65536: 262144,
                        69632: 128,
                        73728: 536870912,
                        77824: 553648256,
                        81920: 16777344,
                        86016: 553910272,
                        90112: 537133184,
                        94208: 16777216,
                        98304: 553910400,
                        102400: 553648128,
                        106496: 17039360,
                        110592: 537133056,
                        114688: 262272,
                        118784: 536871040,
                        122880: 0,
                        126976: 17039488,
                        67584: 553648256,
                        71680: 16777216,
                        75776: 17039360,
                        79872: 537133184,
                        83968: 536870912,
                        88064: 17039488,
                        92160: 128,
                        96256: 553910272,
                        100352: 262272,
                        104448: 553910400,
                        108544: 0,
                        112640: 553648128,
                        116736: 16777344,
                        120832: 262144,
                        124928: 537133056,
                        129024: 536871040
                    }, {
                        0: 268435464,
                        256: 8192,
                        512: 270532608,
                        768: 270540808,
                        1024: 268443648,
                        1280: 2097152,
                        1536: 2097160,
                        1792: 268435456,
                        2048: 0,
                        2304: 268443656,
                        2560: 2105344,
                        2816: 8,
                        3072: 270532616,
                        3328: 2105352,
                        3584: 8200,
                        3840: 270540800,
                        128: 270532608,
                        384: 270540808,
                        640: 8,
                        896: 2097152,
                        1152: 2105352,
                        1408: 268435464,
                        1664: 268443648,
                        1920: 8200,
                        2176: 2097160,
                        2432: 8192,
                        2688: 268443656,
                        2944: 270532616,
                        3200: 0,
                        3456: 270540800,
                        3712: 2105344,
                        3968: 268435456,
                        4096: 268443648,
                        4352: 270532616,
                        4608: 270540808,
                        4864: 8200,
                        5120: 2097152,
                        5376: 268435456,
                        5632: 268435464,
                        5888: 2105344,
                        6144: 2105352,
                        6400: 0,
                        6656: 8,
                        6912: 270532608,
                        7168: 8192,
                        7424: 268443656,
                        7680: 270540800,
                        7936: 2097160,
                        4224: 8,
                        4480: 2105344,
                        4736: 2097152,
                        4992: 268435464,
                        5248: 268443648,
                        5504: 8200,
                        5760: 270540808,
                        6016: 270532608,
                        6272: 270540800,
                        6528: 270532616,
                        6784: 8192,
                        7040: 2105352,
                        7296: 2097160,
                        7552: 0,
                        7808: 268435456,
                        8064: 268443656
                    }, {
                        0: 1048576,
                        16: 33555457,
                        32: 1024,
                        48: 1049601,
                        64: 34604033,
                        80: 0,
                        96: 1,
                        112: 34603009,
                        128: 33555456,
                        144: 1048577,
                        160: 33554433,
                        176: 34604032,
                        192: 34603008,
                        208: 1025,
                        224: 1049600,
                        240: 33554432,
                        8: 34603009,
                        24: 0,
                        40: 33555457,
                        56: 34604032,
                        72: 1048576,
                        88: 33554433,
                        104: 33554432,
                        120: 1025,
                        136: 1049601,
                        152: 33555456,
                        168: 34603008,
                        184: 1048577,
                        200: 1024,
                        216: 34604033,
                        232: 1,
                        248: 1049600,
                        256: 33554432,
                        272: 1048576,
                        288: 33555457,
                        304: 34603009,
                        320: 1048577,
                        336: 33555456,
                        352: 34604032,
                        368: 1049601,
                        384: 1025,
                        400: 34604033,
                        416: 1049600,
                        432: 1,
                        448: 0,
                        464: 34603008,
                        480: 33554433,
                        496: 1024,
                        264: 1049600,
                        280: 33555457,
                        296: 34603009,
                        312: 1,
                        328: 33554432,
                        344: 1048576,
                        360: 1025,
                        376: 34604032,
                        392: 33554433,
                        408: 34603008,
                        424: 0,
                        440: 34604033,
                        456: 1049601,
                        472: 1024,
                        488: 33555456,
                        504: 1048577
                    }, {
                        0: 134219808,
                        1: 131072,
                        2: 134217728,
                        3: 32,
                        4: 131104,
                        5: 134350880,
                        6: 134350848,
                        7: 2048,
                        8: 134348800,
                        9: 134219776,
                        10: 133120,
                        11: 134348832,
                        12: 2080,
                        13: 0,
                        14: 134217760,
                        15: 133152,
                        2147483648: 2048,
                        2147483649: 134350880,
                        2147483650: 134219808,
                        2147483651: 134217728,
                        2147483652: 134348800,
                        2147483653: 133120,
                        2147483654: 133152,
                        2147483655: 32,
                        2147483656: 134217760,
                        2147483657: 2080,
                        2147483658: 131104,
                        2147483659: 134350848,
                        2147483660: 0,
                        2147483661: 134348832,
                        2147483662: 134219776,
                        2147483663: 131072,
                        16: 133152,
                        17: 134350848,
                        18: 32,
                        19: 2048,
                        20: 134219776,
                        21: 134217760,
                        22: 134348832,
                        23: 131072,
                        24: 0,
                        25: 131104,
                        26: 134348800,
                        27: 134219808,
                        28: 134350880,
                        29: 133120,
                        30: 2080,
                        31: 134217728,
                        2147483664: 131072,
                        2147483665: 2048,
                        2147483666: 134348832,
                        2147483667: 133152,
                        2147483668: 32,
                        2147483669: 134348800,
                        2147483670: 134217728,
                        2147483671: 134219808,
                        2147483672: 134350880,
                        2147483673: 134217760,
                        2147483674: 134219776,
                        2147483675: 0,
                        2147483676: 133120,
                        2147483677: 2080,
                        2147483678: 131104,
                        2147483679: 134350848
                    }]
                      , u = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]
                      , h = a.DES = i.extend({
                        _doReset: function() {
                            for (var e = this._key.words, t = [], n = 0; n < 56; n++) {
                                var r = o[n] - 1;
                                t[n] = e[r >>> 5] >>> 31 - r % 32 & 1
                            }
                            for (var i = this._subKeys = [], a = 0; a < 16; a++) {
                                var c = i[a] = []
                                  , u = l[a];
                                for (n = 0; n < 24; n++)
                                    c[n / 6 | 0] |= t[(s[n] - 1 + u) % 28] << 31 - n % 6,
                                    c[4 + (n / 6 | 0)] |= t[28 + (s[n + 24] - 1 + u) % 28] << 31 - n % 6;
                                for (c[0] = c[0] << 1 | c[0] >>> 31,
                                n = 1; n < 7; n++)
                                    c[n] = c[n] >>> 4 * (n - 1) + 3;
                                c[7] = c[7] << 5 | c[7] >>> 27
                            }
                            var h = this._invSubKeys = [];
                            for (n = 0; n < 16; n++)
                                h[n] = i[15 - n]
                        },
                        encryptBlock: function(e, t) {
                            this._doCryptBlock(e, t, this._subKeys)
                        },
                        decryptBlock: function(e, t) {
                            this._doCryptBlock(e, t, this._invSubKeys)
                        },
                        _doCryptBlock: function(e, t, n) {
                            this._lBlock = e[t],
                            this._rBlock = e[t + 1],
                            d.call(this, 4, 252645135),
                            d.call(this, 16, 65535),
                            p.call(this, 2, 858993459),
                            p.call(this, 8, 16711935),
                            d.call(this, 1, 1431655765);
                            for (var r = 0; r < 16; r++) {
                                for (var i = n[r], a = this._lBlock, o = this._rBlock, s = 0, l = 0; l < 8; l++)
                                    s |= c[l][((o ^ i[l]) & u[l]) >>> 0];
                                this._lBlock = o,
                                this._rBlock = a ^ s
                            }
                            var h = this._lBlock;
                            this._lBlock = this._rBlock,
                            this._rBlock = h,
                            d.call(this, 1, 1431655765),
                            p.call(this, 8, 16711935),
                            p.call(this, 2, 858993459),
                            d.call(this, 16, 65535),
                            d.call(this, 4, 252645135),
                            e[t] = this._lBlock,
                            e[t + 1] = this._rBlock
                        },
                        keySize: 2,
                        ivSize: 2,
                        blockSize: 2
                    });
                    function d(e, t) {
                        var n = (this._lBlock >>> e ^ this._rBlock) & t;
                        this._rBlock ^= n,
                        this._lBlock ^= n << e
                    }
                    function p(e, t) {
                        var n = (this._rBlock >>> e ^ this._lBlock) & t;
                        this._lBlock ^= n,
                        this._rBlock ^= n << e
                    }
                    e.DES = i._createHelper(h);
                    var f = a.TripleDES = i.extend({
                        _doReset: function() {
                            var e = this._key.words;
                            if (2 !== e.length && 4 !== e.length && e.length < 6)
                                throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                            var t = e.slice(0, 2)
                              , r = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4)
                              , i = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6);
                            this._des1 = h.createEncryptor(n.create(t)),
                            this._des2 = h.createEncryptor(n.create(r)),
                            this._des3 = h.createEncryptor(n.create(i))
                        },
                        encryptBlock: function(e, t) {
                            this._des1.encryptBlock(e, t),
                            this._des2.decryptBlock(e, t),
                            this._des3.encryptBlock(e, t)
                        },
                        decryptBlock: function(e, t) {
                            this._des3.decryptBlock(e, t),
                            this._des2.encryptBlock(e, t),
                            this._des1.decryptBlock(e, t)
                        },
                        keySize: 6,
                        ivSize: 2,
                        blockSize: 2
                    });
                    e.TripleDES = i._createHelper(f)
                }(),
                r.TripleDES)
            },
            4938: function(e, t, n) {
                var r, i, a, o, s, l;
                e.exports = (r = n(8249),
                a = (i = r).lib,
                o = a.Base,
                s = a.WordArray,
                (l = i.x64 = {}).Word = o.extend({
                    init: function(e, t) {
                        this.high = e,
                        this.low = t
                    }
                }),
                l.WordArray = o.extend({
                    init: function(e, t) {
                        e = this.words = e || [],
                        this.sigBytes = null != t ? t : 8 * e.length
                    },
                    toX32: function() {
                        for (var e = this.words, t = e.length, n = [], r = 0; r < t; r++) {
                            var i = e[r];
                            n.push(i.high),
                            n.push(i.low)
                        }
                        return s.create(n, this.sigBytes)
                    },
                    clone: function() {
                        for (var e = o.clone.call(this), t = e.words = this.words.slice(0), n = t.length, r = 0; r < n; r++)
                            t[r] = t[r].clone();
                        return e
                    }
                }),
                r)
            },
            4376: (e,t,n)=>{
                "use strict";
                function r(e, t) {
                    var n = e.__state.conversionName.toString()
                      , r = Math.round(e.r)
                      , i = Math.round(e.g)
                      , a = Math.round(e.b)
                      , o = e.a
                      , s = Math.round(e.h)
                      , l = e.s.toFixed(1)
                      , c = e.v.toFixed(1);
                    if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                        for (var u = e.hex.toString(16); u.length < 6; )
                            u = "0" + u;
                        return "#" + u
                    }
                    return "CSS_RGB" === n ? "rgb(" + r + "," + i + "," + a + ")" : "CSS_RGBA" === n ? "rgba(" + r + "," + i + "," + a + "," + o + ")" : "HEX" === n ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === n ? "[" + r + "," + i + "," + a + "]" : "RGBA_ARRAY" === n ? "[" + r + "," + i + "," + a + "," + o + "]" : "RGB_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + a + "}" : "RGBA_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + a + ",a:" + o + "}" : "HSV_OBJ" === n ? "{h:" + s + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === n ? "{h:" + s + ",s:" + l + ",v:" + c + ",a:" + o + "}" : "unknown format"
                }
                n.r(t),
                n.d(t, {
                    color: ()=>ue,
                    controllers: ()=>he,
                    dom: ()=>de,
                    gui: ()=>pe,
                    GUI: ()=>fe,
                    default: ()=>me
                });
                var i = Array.prototype.forEach
                  , a = Array.prototype.slice
                  , o = {
                    BREAK: {},
                    extend: function(e) {
                        return this.each(a.call(arguments, 1), (function(t) {
                            (this.isObject(t) ? Object.keys(t) : []).forEach(function(n) {
                                this.isUndefined(t[n]) || (e[n] = t[n])
                            }
                            .bind(this))
                        }
                        ), this),
                        e
                    },
                    defaults: function(e) {
                        return this.each(a.call(arguments, 1), (function(t) {
                            (this.isObject(t) ? Object.keys(t) : []).forEach(function(n) {
                                this.isUndefined(e[n]) && (e[n] = t[n])
                            }
                            .bind(this))
                        }
                        ), this),
                        e
                    },
                    compose: function() {
                        var e = a.call(arguments);
                        return function() {
                            for (var t = a.call(arguments), n = e.length - 1; n >= 0; n--)
                                t = [e[n].apply(this, t)];
                            return t[0]
                        }
                    },
                    each: function(e, t, n) {
                        if (e)
                            if (i && e.forEach && e.forEach === i)
                                e.forEach(t, n);
                            else if (e.length === e.length + 0) {
                                var r, a = void 0;
                                for (a = 0,
                                r = e.length; a < r; a++)
                                    if (a in e && t.call(n, e[a], a) === this.BREAK)
                                        return
                            } else
                                for (var o in e)
                                    if (t.call(n, e[o], o) === this.BREAK)
                                        return
                    },
                    defer: function(e) {
                        setTimeout(e, 0)
                    },
                    debounce: function(e, t, n) {
                        var r = void 0;
                        return function() {
                            var i = this
                              , a = arguments;
                            function o() {
                                r = null,
                                n || e.apply(i, a)
                            }
                            var s = n || !r;
                            clearTimeout(r),
                            r = setTimeout(o, t),
                            s && e.apply(i, a)
                        }
                    },
                    toArray: function(e) {
                        return e.toArray ? e.toArray() : a.call(e)
                    },
                    isUndefined: function(e) {
                        return void 0 === e
                    },
                    isNull: function(e) {
                        return null === e
                    },
                    isNaN: function(e) {
                        function t(t) {
                            return e.apply(this, arguments)
                        }
                        return t.toString = function() {
                            return e.toString()
                        }
                        ,
                        t
                    }((function(e) {
                        return isNaN(e)
                    }
                    )),
                    isArray: Array.isArray || function(e) {
                        return e.constructor === Array
                    }
                    ,
                    isObject: function(e) {
                        return e === Object(e)
                    },
                    isNumber: function(e) {
                        return e === e + 0
                    },
                    isString: function(e) {
                        return e === e + ""
                    },
                    isBoolean: function(e) {
                        return !1 === e || !0 === e
                    },
                    isFunction: function(e) {
                        return e instanceof Function
                    }
                }
                  , s = [{
                    litmus: o.isString,
                    conversions: {
                        THREE_CHAR_HEX: {
                            read: function(e) {
                                var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                                return null !== t && {
                                    space: "HEX",
                                    hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0)
                                }
                            },
                            write: r
                        },
                        SIX_CHAR_HEX: {
                            read: function(e) {
                                var t = e.match(/^#([A-F0-9]{6})$/i);
                                return null !== t && {
                                    space: "HEX",
                                    hex: parseInt("0x" + t[1].toString(), 0)
                                }
                            },
                            write: r
                        },
                        CSS_RGB: {
                            read: function(e) {
                                var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                return null !== t && {
                                    space: "RGB",
                                    r: parseFloat(t[1]),
                                    g: parseFloat(t[2]),
                                    b: parseFloat(t[3])
                                }
                            },
                            write: r
                        },
                        CSS_RGBA: {
                            read: function(e) {
                                var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                return null !== t && {
                                    space: "RGB",
                                    r: parseFloat(t[1]),
                                    g: parseFloat(t[2]),
                                    b: parseFloat(t[3]),
                                    a: parseFloat(t[4])
                                }
                            },
                            write: r
                        }
                    }
                }, {
                    litmus: o.isNumber,
                    conversions: {
                        HEX: {
                            read: function(e) {
                                return {
                                    space: "HEX",
                                    hex: e,
                                    conversionName: "HEX"
                                }
                            },
                            write: function(e) {
                                return e.hex
                            }
                        }
                    }
                }, {
                    litmus: o.isArray,
                    conversions: {
                        RGB_ARRAY: {
                            read: function(e) {
                                return 3 === e.length && {
                                    space: "RGB",
                                    r: e[0],
                                    g: e[1],
                                    b: e[2]
                                }
                            },
                            write: function(e) {
                                return [e.r, e.g, e.b]
                            }
                        },
                        RGBA_ARRAY: {
                            read: function(e) {
                                return 4 === e.length && {
                                    space: "RGB",
                                    r: e[0],
                                    g: e[1],
                                    b: e[2],
                                    a: e[3]
                                }
                            },
                            write: function(e) {
                                return [e.r, e.g, e.b, e.a]
                            }
                        }
                    }
                }, {
                    litmus: o.isObject,
                    conversions: {
                        RGBA_OBJ: {
                            read: function(e) {
                                return !!(o.isNumber(e.r) && o.isNumber(e.g) && o.isNumber(e.b) && o.isNumber(e.a)) && {
                                    space: "RGB",
                                    r: e.r,
                                    g: e.g,
                                    b: e.b,
                                    a: e.a
                                }
                            },
                            write: function(e) {
                                return {
                                    r: e.r,
                                    g: e.g,
                                    b: e.b,
                                    a: e.a
                                }
                            }
                        },
                        RGB_OBJ: {
                            read: function(e) {
                                return !!(o.isNumber(e.r) && o.isNumber(e.g) && o.isNumber(e.b)) && {
                                    space: "RGB",
                                    r: e.r,
                                    g: e.g,
                                    b: e.b
                                }
                            },
                            write: function(e) {
                                return {
                                    r: e.r,
                                    g: e.g,
                                    b: e.b
                                }
                            }
                        },
                        HSVA_OBJ: {
                            read: function(e) {
                                return !!(o.isNumber(e.h) && o.isNumber(e.s) && o.isNumber(e.v) && o.isNumber(e.a)) && {
                                    space: "HSV",
                                    h: e.h,
                                    s: e.s,
                                    v: e.v,
                                    a: e.a
                                }
                            },
                            write: function(e) {
                                return {
                                    h: e.h,
                                    s: e.s,
                                    v: e.v,
                                    a: e.a
                                }
                            }
                        },
                        HSV_OBJ: {
                            read: function(e) {
                                return !!(o.isNumber(e.h) && o.isNumber(e.s) && o.isNumber(e.v)) && {
                                    space: "HSV",
                                    h: e.h,
                                    s: e.s,
                                    v: e.v
                                }
                            },
                            write: function(e) {
                                return {
                                    h: e.h,
                                    s: e.s,
                                    v: e.v
                                }
                            }
                        }
                    }
                }]
                  , l = void 0
                  , c = void 0
                  , u = function() {
                    c = !1;
                    var e = arguments.length > 1 ? o.toArray(arguments) : arguments[0];
                    return o.each(s, (function(t) {
                        if (t.litmus(e))
                            return o.each(t.conversions, (function(t, n) {
                                if (l = t.read(e),
                                !1 === c && !1 !== l)
                                    return c = l,
                                    l.conversionName = n,
                                    l.conversion = t,
                                    o.BREAK
                            }
                            )),
                            o.BREAK
                    }
                    )),
                    c
                }
                  , h = void 0
                  , d = {
                    hsv_to_rgb: function(e, t, n) {
                        var r = Math.floor(e / 60) % 6
                          , i = e / 60 - Math.floor(e / 60)
                          , a = n * (1 - t)
                          , o = n * (1 - i * t)
                          , s = n * (1 - (1 - i) * t)
                          , l = [[n, s, a], [o, n, a], [a, n, s], [a, o, n], [s, a, n], [n, a, o]][r];
                        return {
                            r: 255 * l[0],
                            g: 255 * l[1],
                            b: 255 * l[2]
                        }
                    },
                    rgb_to_hsv: function(e, t, n) {
                        var r = Math.min(e, t, n)
                          , i = Math.max(e, t, n)
                          , a = i - r
                          , o = void 0;
                        return 0 === i ? {
                            h: NaN,
                            s: 0,
                            v: 0
                        } : (o = e === i ? (t - n) / a : t === i ? 2 + (n - e) / a : 4 + (e - t) / a,
                        (o /= 6) < 0 && (o += 1),
                        {
                            h: 360 * o,
                            s: a / i,
                            v: i / 255
                        })
                    },
                    rgb_to_hex: function(e, t, n) {
                        var r = this.hex_with_component(0, 2, e);
                        return r = this.hex_with_component(r, 1, t),
                        this.hex_with_component(r, 0, n)
                    },
                    component_from_hex: function(e, t) {
                        return e >> 8 * t & 255
                    },
                    hex_with_component: function(e, t, n) {
                        return n << (h = 8 * t) | e & ~(255 << h)
                    }
                }
                  , p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                  , f = function(e, t) {
                    if (!(e instanceof t))
                        throw new TypeError("Cannot call a class as a function")
                }
                  , m = function() {
                    function e(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.enumerable = r.enumerable || !1,
                            r.configurable = !0,
                            "value"in r && (r.writable = !0),
                            Object.defineProperty(e, r.key, r)
                        }
                    }
                    return function(t, n, r) {
                        return n && e(t.prototype, n),
                        r && e(t, r),
                        t
                    }
                }()
                  , g = function e(t, n, r) {
                    null === t && (t = Function.prototype);
                    var i = Object.getOwnPropertyDescriptor(t, n);
                    if (void 0 === i) {
                        var a = Object.getPrototypeOf(t);
                        return null === a ? void 0 : e(a, n, r)
                    }
                    if ("value"in i)
                        return i.value;
                    var o = i.get;
                    return void 0 !== o ? o.call(r) : void 0
                }
                  , v = function(e, t) {
                    if ("function" != typeof t && null !== t)
                        throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }),
                    t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }
                  , y = function(e, t) {
                    if (!e)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != typeof t && "function" != typeof t ? e : t
                }
                  , _ = function() {
                    function e() {
                        if (f(this, e),
                        this.__state = u.apply(this, arguments),
                        !1 === this.__state)
                            throw new Error("Failed to interpret color arguments");
                        this.__state.a = this.__state.a || 1
                    }
                    return m(e, [{
                        key: "toString",
                        value: function() {
                            return r(this)
                        }
                    }, {
                        key: "toHexString",
                        value: function() {
                            return r(this, !0)
                        }
                    }, {
                        key: "toOriginal",
                        value: function() {
                            return this.__state.conversion.write(this)
                        }
                    }]),
                    e
                }();
                function x(e, t, n) {
                    Object.defineProperty(e, t, {
                        get: function() {
                            return "RGB" === this.__state.space || _.recalculateRGB(this, t, n),
                            this.__state[t]
                        },
                        set: function(e) {
                            "RGB" !== this.__state.space && (_.recalculateRGB(this, t, n),
                            this.__state.space = "RGB"),
                            this.__state[t] = e
                        }
                    })
                }
                function b(e, t) {
                    Object.defineProperty(e, t, {
                        get: function() {
                            return "HSV" === this.__state.space || _.recalculateHSV(this),
                            this.__state[t]
                        },
                        set: function(e) {
                            "HSV" !== this.__state.space && (_.recalculateHSV(this),
                            this.__state.space = "HSV"),
                            this.__state[t] = e
                        }
                    })
                }
                _.recalculateRGB = function(e, t, n) {
                    if ("HEX" === e.__state.space)
                        e.__state[t] = d.component_from_hex(e.__state.hex, n);
                    else {
                        if ("HSV" !== e.__state.space)
                            throw new Error("Corrupted color state");
                        o.extend(e.__state, d.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v))
                    }
                }
                ,
                _.recalculateHSV = function(e) {
                    var t = d.rgb_to_hsv(e.r, e.g, e.b);
                    o.extend(e.__state, {
                        s: t.s,
                        v: t.v
                    }),
                    o.isNaN(t.h) ? o.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h
                }
                ,
                _.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"],
                x(_.prototype, "r", 2),
                x(_.prototype, "g", 1),
                x(_.prototype, "b", 0),
                b(_.prototype, "h"),
                b(_.prototype, "s"),
                b(_.prototype, "v"),
                Object.defineProperty(_.prototype, "a", {
                    get: function() {
                        return this.__state.a
                    },
                    set: function(e) {
                        this.__state.a = e
                    }
                }),
                Object.defineProperty(_.prototype, "hex", {
                    get: function() {
                        return "HEX" !== this.__state.space && (this.__state.hex = d.rgb_to_hex(this.r, this.g, this.b),
                        this.__state.space = "HEX"),
                        this.__state.hex
                    },
                    set: function(e) {
                        this.__state.space = "HEX",
                        this.__state.hex = e
                    }
                });
                var w = function() {
                    function e(t, n) {
                        f(this, e),
                        this.initialValue = t[n],
                        this.domElement = document.createElement("div"),
                        this.object = t,
                        this.property = n,
                        this.__onChange = void 0,
                        this.__onFinishChange = void 0
                    }
                    return m(e, [{
                        key: "onChange",
                        value: function(e) {
                            return this.__onChange = e,
                            this
                        }
                    }, {
                        key: "onFinishChange",
                        value: function(e) {
                            return this.__onFinishChange = e,
                            this
                        }
                    }, {
                        key: "setValue",
                        value: function(e) {
                            return this.object[this.property] = e,
                            this.__onChange && this.__onChange.call(this, e),
                            this.updateDisplay(),
                            this
                        }
                    }, {
                        key: "getValue",
                        value: function() {
                            return this.object[this.property]
                        }
                    }, {
                        key: "updateDisplay",
                        value: function() {
                            return this
                        }
                    }, {
                        key: "isModified",
                        value: function() {
                            return this.initialValue !== this.getValue()
                        }
                    }]),
                    e
                }()
                  , M = {};
                o.each({
                    HTMLEvents: ["change"],
                    MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
                    KeyboardEvents: ["keydown"]
                }, (function(e, t) {
                    o.each(e, (function(e) {
                        M[e] = t
                    }
                    ))
                }
                ));
                var S = /(\d+(\.\d+)?)px/;
                function T(e) {
                    if ("0" === e || o.isUndefined(e))
                        return 0;
                    var t = e.match(S);
                    return o.isNull(t) ? 0 : parseFloat(t[1])
                }
                var E = {
                    makeSelectable: function(e, t) {
                        void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function() {
                            return !1
                        }
                        : function() {}
                        ,
                        e.style.MozUserSelect = t ? "auto" : "none",
                        e.style.KhtmlUserSelect = t ? "auto" : "none",
                        e.unselectable = t ? "on" : "off")
                    },
                    makeFullscreen: function(e, t, n) {
                        var r = n
                          , i = t;
                        o.isUndefined(i) && (i = !0),
                        o.isUndefined(r) && (r = !0),
                        e.style.position = "absolute",
                        i && (e.style.left = 0,
                        e.style.right = 0),
                        r && (e.style.top = 0,
                        e.style.bottom = 0)
                    },
                    fakeEvent: function(e, t, n, r) {
                        var i = n || {}
                          , a = M[t];
                        if (!a)
                            throw new Error("Event type " + t + " not supported.");
                        var s = document.createEvent(a);
                        switch (a) {
                        case "MouseEvents":
                            var l = i.x || i.clientX || 0
                              , c = i.y || i.clientY || 0;
                            s.initMouseEvent(t, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, l, c, !1, !1, !1, !1, 0, null);
                            break;
                        case "KeyboardEvents":
                            var u = s.initKeyboardEvent || s.initKeyEvent;
                            o.defaults(i, {
                                cancelable: !0,
                                ctrlKey: !1,
                                altKey: !1,
                                shiftKey: !1,
                                metaKey: !1,
                                keyCode: void 0,
                                charCode: void 0
                            }),
                            u(t, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
                            break;
                        default:
                            s.initEvent(t, i.bubbles || !1, i.cancelable || !0)
                        }
                        o.defaults(s, r),
                        e.dispatchEvent(s)
                    },
                    bind: function(e, t, n, r) {
                        var i = r || !1;
                        return e.addEventListener ? e.addEventListener(t, n, i) : e.attachEvent && e.attachEvent("on" + t, n),
                        E
                    },
                    unbind: function(e, t, n, r) {
                        var i = r || !1;
                        return e.removeEventListener ? e.removeEventListener(t, n, i) : e.detachEvent && e.detachEvent("on" + t, n),
                        E
                    },
                    addClass: function(e, t) {
                        if (void 0 === e.className)
                            e.className = t;
                        else if (e.className !== t) {
                            var n = e.className.split(/ +/);
                            -1 === n.indexOf(t) && (n.push(t),
                            e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                        }
                        return E
                    },
                    removeClass: function(e, t) {
                        if (t)
                            if (e.className === t)
                                e.removeAttribute("class");
                            else {
                                var n = e.className.split(/ +/)
                                  , r = n.indexOf(t);
                                -1 !== r && (n.splice(r, 1),
                                e.className = n.join(" "))
                            }
                        else
                            e.className = void 0;
                        return E
                    },
                    hasClass: function(e, t) {
                        return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
                    },
                    getWidth: function(e) {
                        var t = getComputedStyle(e);
                        return T(t["border-left-width"]) + T(t["border-right-width"]) + T(t["padding-left"]) + T(t["padding-right"]) + T(t.width)
                    },
                    getHeight: function(e) {
                        var t = getComputedStyle(e);
                        return T(t["border-top-width"]) + T(t["border-bottom-width"]) + T(t["padding-top"]) + T(t["padding-bottom"]) + T(t.height)
                    },
                    getOffset: function(e) {
                        var t = e
                          , n = {
                            left: 0,
                            top: 0
                        };
                        if (t.offsetParent)
                            do {
                                n.left += t.offsetLeft,
                                n.top += t.offsetTop,
                                t = t.offsetParent
                            } while (t);
                        return n
                    },
                    isActive: function(e) {
                        return e === document.activeElement && (e.type || e.href)
                    }
                }
                  , A = function(e) {
                    function t(e, n) {
                        f(this, t);
                        var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n))
                          , i = r;
                        return r.__prev = r.getValue(),
                        r.__checkbox = document.createElement("input"),
                        r.__checkbox.setAttribute("type", "checkbox"),
                        E.bind(r.__checkbox, "change", (function() {
                            i.setValue(!i.__prev)
                        }
                        ), !1),
                        r.domElement.appendChild(r.__checkbox),
                        r.updateDisplay(),
                        r
                    }
                    return v(t, e),
                    m(t, [{
                        key: "setValue",
                        value: function(e) {
                            var n = g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e);
                            return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                            this.__prev = this.getValue(),
                            n
                        }
                    }, {
                        key: "updateDisplay",
                        value: function() {
                            return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"),
                            this.__checkbox.checked = !0,
                            this.__prev = !0) : (this.__checkbox.checked = !1,
                            this.__prev = !1),
                            g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)
                        }
                    }]),
                    t
                }(w)
                  , C = function(e) {
                    function t(e, n, r) {
                        f(this, t);
                        var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n))
                          , a = r
                          , s = i;
                        if (i.__select = document.createElement("select"),
                        o.isArray(a)) {
                            var l = {};
                            o.each(a, (function(e) {
                                l[e] = e
                            }
                            )),
                            a = l
                        }
                        return o.each(a, (function(e, t) {
                            var n = document.createElement("option");
                            n.innerHTML = t,
                            n.setAttribute("value", e),
                            s.__select.appendChild(n)
                        }
                        )),
                        i.updateDisplay(),
                        E.bind(i.__select, "change", (function() {
                            var e = this.options[this.selectedIndex].value;
                            s.setValue(e)
                        }
                        )),
                        i.domElement.appendChild(i.__select),
                        i
                    }
                    return v(t, e),
                    m(t, [{
                        key: "setValue",
                        value: function(e) {
                            var n = g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e);
                            return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                            n
                        }
                    }, {
                        key: "updateDisplay",
                        value: function() {
                            return E.isActive(this.__select) ? this : (this.__select.value = this.getValue(),
                            g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this))
                        }
                    }]),
                    t
                }(w)
                  , P = function(e) {
                    function t(e, n) {
                        f(this, t);
                        var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n))
                          , i = r;
                        function a() {
                            i.setValue(i.__input.value)
                        }
                        return r.__input = document.createElement("input"),
                        r.__input.setAttribute("type", "text"),
                        E.bind(r.__input, "keyup", a),
                        E.bind(r.__input, "change", a),
                        E.bind(r.__input, "blur", (function() {
                            i.__onFinishChange && i.__onFinishChange.call(i, i.getValue())
                        }
                        )),
                        E.bind(r.__input, "keydown", (function(e) {
                            13 === e.keyCode && this.blur()
                        }
                        )),
                        r.updateDisplay(),
                        r.domElement.appendChild(r.__input),
                        r
                    }
                    return v(t, e),
                    m(t, [{
                        key: "updateDisplay",
                        value: function() {
                            return E.isActive(this.__input) || (this.__input.value = this.getValue()),
                            g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)
                        }
                    }]),
                    t
                }(w);
                function R(e) {
                    var t = e.toString();
                    return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0
                }
                var L = function(e) {
                    function t(e, n, r) {
                        f(this, t);
                        var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n))
                          , a = r || {};
                        return i.__min = a.min,
                        i.__max = a.max,
                        i.__step = a.step,
                        o.isUndefined(i.__step) ? 0 === i.initialValue ? i.__impliedStep = 1 : i.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(i.initialValue)) / Math.LN10)) / 10 : i.__impliedStep = i.__step,
                        i.__precision = R(i.__impliedStep),
                        i
                    }
                    return v(t, e),
                    m(t, [{
                        key: "setValue",
                        value: function(e) {
                            var n = e;
                            return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max),
                            void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step),
                            g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, n)
                        }
                    }, {
                        key: "min",
                        value: function(e) {
                            return this.__min = e,
                            this
                        }
                    }, {
                        key: "max",
                        value: function(e) {
                            return this.__max = e,
                            this
                        }
                    }, {
                        key: "step",
                        value: function(e) {
                            return this.__step = e,
                            this.__impliedStep = e,
                            this.__precision = R(e),
                            this
                        }
                    }]),
                    t
                }(w)
                  , D = function(e) {
                    function t(e, n, r) {
                        f(this, t);
                        var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, r));
                        i.__truncationSuspended = !1;
                        var a = i
                          , s = void 0;
                        function l() {
                            a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
                        }
                        function c(e) {
                            var t = s - e.clientY;
                            a.setValue(a.getValue() + t * a.__impliedStep),
                            s = e.clientY
                        }
                        function u() {
                            E.unbind(window, "mousemove", c),
                            E.unbind(window, "mouseup", u),
                            l()
                        }
                        return i.__input = document.createElement("input"),
                        i.__input.setAttribute("type", "text"),
                        E.bind(i.__input, "change", (function() {
                            var e = parseFloat(a.__input.value);
                            o.isNaN(e) || a.setValue(e)
                        }
                        )),
                        E.bind(i.__input, "blur", (function() {
                            l()
                        }
                        )),
                        E.bind(i.__input, "mousedown", (function(e) {
                            E.bind(window, "mousemove", c),
                            E.bind(window, "mouseup", u),
                            s = e.clientY
                        }
                        )),
                        E.bind(i.__input, "keydown", (function(e) {
                            13 === e.keyCode && (a.__truncationSuspended = !0,
                            this.blur(),
                            a.__truncationSuspended = !1,
                            l())
                        }
                        )),
                        i.updateDisplay(),
                        i.domElement.appendChild(i.__input),
                        i
                    }
                    return v(t, e),
                    m(t, [{
                        key: "updateDisplay",
                        value: function() {
                            var e, n, r;
                            return this.__input.value = this.__truncationSuspended ? this.getValue() : (e = this.getValue(),
                            n = this.__precision,
                            r = Math.pow(10, n),
                            Math.round(e * r) / r),
                            g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)
                        }
                    }]),
                    t
                }(L);
                function O(e, t, n, r, i) {
                    return r + (e - t) / (n - t) * (i - r)
                }
                var F = function(e) {
                    function t(e, n, r, i, a) {
                        f(this, t);
                        var o = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, {
                            min: r,
                            max: i,
                            step: a
                        }))
                          , s = o;
                        function l(e) {
                            e.preventDefault();
                            var t = s.__background.getBoundingClientRect();
                            return s.setValue(O(e.clientX, t.left, t.right, s.__min, s.__max)),
                            !1
                        }
                        function c() {
                            E.unbind(window, "mousemove", l),
                            E.unbind(window, "mouseup", c),
                            s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                        }
                        function u(e) {
                            var t = e.touches[0].clientX
                              , n = s.__background.getBoundingClientRect();
                            s.setValue(O(t, n.left, n.right, s.__min, s.__max))
                        }
                        function h() {
                            E.unbind(window, "touchmove", u),
                            E.unbind(window, "touchend", h),
                            s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                        }
                        return o.__background = document.createElement("div"),
                        o.__foreground = document.createElement("div"),
                        E.bind(o.__background, "mousedown", (function(e) {
                            document.activeElement.blur(),
                            E.bind(window, "mousemove", l),
                            E.bind(window, "mouseup", c),
                            l(e)
                        }
                        )),
                        E.bind(o.__background, "touchstart", (function(e) {
                            1 === e.touches.length && (E.bind(window, "touchmove", u),
                            E.bind(window, "touchend", h),
                            u(e))
                        }
                        )),
                        E.addClass(o.__background, "slider"),
                        E.addClass(o.__foreground, "slider-fg"),
                        o.updateDisplay(),
                        o.__background.appendChild(o.__foreground),
                        o.domElement.appendChild(o.__background),
                        o
                    }
                    return v(t, e),
                    m(t, [{
                        key: "updateDisplay",
                        value: function() {
                            var e = (this.getValue() - this.__min) / (this.__max - this.__min);
                            return this.__foreground.style.width = 100 * e + "%",
                            g(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)
                        }
                    }]),
                    t
                }(L)
                  , I = function(e) {
                    function t(e, n, r) {
                        f(this, t);
                        var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n))
                          , a = i;
                        return i.__button = document.createElement("div"),
                        i.__button.innerHTML = void 0 === r ? "Fire" : r,
                        E.bind(i.__button, "click", (function(e) {
                            return e.preventDefault(),
                            a.fire(),
                            !1
                        }
                        )),
                        E.addClass(i.__button, "button"),
                        i.domElement.appendChild(i.__button),
                        i
                    }
                    return v(t, e),
                    m(t, [{
                        key: "fire",
                        value: function() {
                            this.__onChange && this.__onChange.call(this),
                            this.getValue().call(this.object),
                            this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                        }
                    }]),
                    t
                }(w)
                  , N = function(e) {
                    function t(e, n) {
                        f(this, t);
                        var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n));
                        r.__color = new _(r.getValue()),
                        r.__temp = new _(0);
                        var i = r;
                        r.domElement = document.createElement("div"),
                        E.makeSelectable(r.domElement, !1),
                        r.__selector = document.createElement("div"),
                        r.__selector.className = "selector",
                        r.__saturation_field = document.createElement("div"),
                        r.__saturation_field.className = "saturation-field",
                        r.__field_knob = document.createElement("div"),
                        r.__field_knob.className = "field-knob",
                        r.__field_knob_border = "2px solid ",
                        r.__hue_knob = document.createElement("div"),
                        r.__hue_knob.className = "hue-knob",
                        r.__hue_field = document.createElement("div"),
                        r.__hue_field.className = "hue-field",
                        r.__input = document.createElement("input"),
                        r.__input.type = "text",
                        r.__input_textShadow = "0 1px 1px ",
                        E.bind(r.__input, "keydown", (function(e) {
                            13 === e.keyCode && p.call(this)
                        }
                        )),
                        E.bind(r.__input, "blur", p),
                        E.bind(r.__selector, "mousedown", (function() {
                            E.addClass(this, "drag").bind(window, "mouseup", (function() {
                                E.removeClass(i.__selector, "drag")
                            }
                            ))
                        }
                        )),
                        E.bind(r.__selector, "touchstart", (function() {
                            E.addClass(this, "drag").bind(window, "touchend", (function() {
                                E.removeClass(i.__selector, "drag")
                            }
                            ))
                        }
                        ));
                        var a, s = document.createElement("div");
                        function l(e) {
                            g(e),
                            E.bind(window, "mousemove", g),
                            E.bind(window, "touchmove", g),
                            E.bind(window, "mouseup", h),
                            E.bind(window, "touchend", h)
                        }
                        function c(e) {
                            v(e),
                            E.bind(window, "mousemove", v),
                            E.bind(window, "touchmove", v),
                            E.bind(window, "mouseup", d),
                            E.bind(window, "touchend", d)
                        }
                        function h() {
                            E.unbind(window, "mousemove", g),
                            E.unbind(window, "touchmove", g),
                            E.unbind(window, "mouseup", h),
                            E.unbind(window, "touchend", h),
                            m()
                        }
                        function d() {
                            E.unbind(window, "mousemove", v),
                            E.unbind(window, "touchmove", v),
                            E.unbind(window, "mouseup", d),
                            E.unbind(window, "touchend", d),
                            m()
                        }
                        function p() {
                            var e = u(this.value);
                            !1 !== e ? (i.__color.__state = e,
                            i.setValue(i.__color.toOriginal())) : this.value = i.__color.toString()
                        }
                        function m() {
                            i.__onFinishChange && i.__onFinishChange.call(i, i.__color.toOriginal())
                        }
                        function g(e) {
                            -1 === e.type.indexOf("touch") && e.preventDefault();
                            var t = i.__saturation_field.getBoundingClientRect()
                              , n = e.touches && e.touches[0] || e
                              , r = n.clientX
                              , a = n.clientY
                              , o = (r - t.left) / (t.right - t.left)
                              , s = 1 - (a - t.top) / (t.bottom - t.top);
                            return s > 1 ? s = 1 : s < 0 && (s = 0),
                            o > 1 ? o = 1 : o < 0 && (o = 0),
                            i.__color.v = s,
                            i.__color.s = o,
                            i.setValue(i.__color.toOriginal()),
                            !1
                        }
                        function v(e) {
                            -1 === e.type.indexOf("touch") && e.preventDefault();
                            var t = i.__hue_field.getBoundingClientRect()
                              , n = 1 - ((e.touches && e.touches[0] || e).clientY - t.top) / (t.bottom - t.top);
                            return n > 1 ? n = 1 : n < 0 && (n = 0),
                            i.__color.h = 360 * n,
                            i.setValue(i.__color.toOriginal()),
                            !1
                        }
                        return o.extend(r.__selector.style, {
                            width: "122px",
                            height: "102px",
                            padding: "3px",
                            backgroundColor: "#222",
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                        }),
                        o.extend(r.__field_knob.style, {
                            position: "absolute",
                            width: "12px",
                            height: "12px",
                            border: r.__field_knob_border + (r.__color.v < .5 ? "#fff" : "#000"),
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                            borderRadius: "12px",
                            zIndex: 1
                        }),
                        o.extend(r.__hue_knob.style, {
                            position: "absolute",
                            width: "15px",
                            height: "2px",
                            borderRight: "4px solid #fff",
                            zIndex: 1
                        }),
                        o.extend(r.__saturation_field.style, {
                            width: "100px",
                            height: "100px",
                            border: "1px solid #555",
                            marginRight: "3px",
                            display: "inline-block",
                            cursor: "pointer"
                        }),
                        o.extend(s.style, {
                            width: "100%",
                            height: "100%",
                            background: "none"
                        }),
                        k(s, "top", "rgba(0,0,0,0)", "#000"),
                        o.extend(r.__hue_field.style, {
                            width: "15px",
                            height: "100px",
                            border: "1px solid #555",
                            cursor: "ns-resize",
                            position: "absolute",
                            top: "3px",
                            right: "3px"
                        }),
                        (a = r.__hue_field).style.background = "",
                        a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",
                        a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                        a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                        a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                        a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                        o.extend(r.__input.style, {
                            outline: "none",
                            textAlign: "center",
                            color: "#fff",
                            border: 0,
                            fontWeight: "bold",
                            textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)"
                        }),
                        E.bind(r.__saturation_field, "mousedown", l),
                        E.bind(r.__saturation_field, "touchstart", l),
                        E.bind(r.__field_knob, "mousedown", l),
                        E.bind(r.__field_knob, "touchstart", l),
                        E.bind(r.__hue_field, "mousedown", c),
                        E.bind(r.__hue_field, "touchstart", c),
                        r.__saturation_field.appendChild(s),
                        r.__selector.appendChild(r.__field_knob),
                        r.__selector.appendChild(r.__saturation_field),
                        r.__selector.appendChild(r.__hue_field),
                        r.__hue_field.appendChild(r.__hue_knob),
                        r.domElement.appendChild(r.__input),
                        r.domElement.appendChild(r.__selector),
                        r.updateDisplay(),
                        r
                    }
                    return v(t, e),
                    m(t, [{
                        key: "updateDisplay",
                        value: function() {
                            var e = u(this.getValue());
                            if (!1 !== e) {
                                var t = !1;
                                o.each(_.COMPONENTS, (function(n) {
                                    if (!o.isUndefined(e[n]) && !o.isUndefined(this.__color.__state[n]) && e[n] !== this.__color.__state[n])
                                        return t = !0,
                                        {}
                                }
                                ), this),
                                t && o.extend(this.__color.__state, e)
                            }
                            o.extend(this.__temp.__state, this.__color.__state),
                            this.__temp.a = 1;
                            var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0
                              , r = 255 - n;
                            o.extend(this.__field_knob.style, {
                                marginLeft: 100 * this.__color.s - 7 + "px",
                                marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                                backgroundColor: this.__temp.toHexString(),
                                border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                            }),
                            this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px",
                            this.__temp.s = 1,
                            this.__temp.v = 1,
                            k(this.__saturation_field, "left", "#fff", this.__temp.toHexString()),
                            this.__input.value = this.__color.toString(),
                            o.extend(this.__input.style, {
                                backgroundColor: this.__color.toHexString(),
                                color: "rgb(" + n + "," + n + "," + n + ")",
                                textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)"
                            })
                        }
                    }]),
                    t
                }(w)
                  , B = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
                function k(e, t, n, r) {
                    e.style.background = "",
                    o.each(B, (function(i) {
                        e.style.cssText += "background: " + i + "linear-gradient(" + t + ", " + n + " 0%, " + r + " 100%); "
                    }
                    ))
                }
                var z = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'
                  , U = function(e, t) {
                    var n = e[t];
                    return o.isArray(arguments[2]) || o.isObject(arguments[2]) ? new C(e,t,arguments[2]) : o.isNumber(n) ? o.isNumber(arguments[2]) && o.isNumber(arguments[3]) ? o.isNumber(arguments[4]) ? new F(e,t,arguments[2],arguments[3],arguments[4]) : new F(e,t,arguments[2],arguments[3]) : o.isNumber(arguments[4]) ? new D(e,t,{
                        min: arguments[2],
                        max: arguments[3],
                        step: arguments[4]
                    }) : new D(e,t,{
                        min: arguments[2],
                        max: arguments[3]
                    }) : o.isString(n) ? new P(e,t) : o.isFunction(n) ? new I(e,t,"") : o.isBoolean(n) ? new A(e,t) : null
                }
                  , H = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) {
                    setTimeout(e, 1e3 / 60)
                }
                  , G = function() {
                    function e() {
                        f(this, e),
                        this.backgroundElement = document.createElement("div"),
                        o.extend(this.backgroundElement.style, {
                            backgroundColor: "rgba(0,0,0,0.8)",
                            top: 0,
                            left: 0,
                            display: "none",
                            zIndex: "1000",
                            opacity: 0,
                            WebkitTransition: "opacity 0.2s linear",
                            transition: "opacity 0.2s linear"
                        }),
                        E.makeFullscreen(this.backgroundElement),
                        this.backgroundElement.style.position = "fixed",
                        this.domElement = document.createElement("div"),
                        o.extend(this.domElement.style, {
                            position: "fixed",
                            display: "none",
                            zIndex: "1001",
                            opacity: 0,
                            WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                            transition: "transform 0.2s ease-out, opacity 0.2s linear"
                        }),
                        document.body.appendChild(this.backgroundElement),
                        document.body.appendChild(this.domElement);
                        var t = this;
                        E.bind(this.backgroundElement, "click", (function() {
                            t.hide()
                        }
                        ))
                    }
                    return m(e, [{
                        key: "show",
                        value: function() {
                            var e = this;
                            this.backgroundElement.style.display = "block",
                            this.domElement.style.display = "block",
                            this.domElement.style.opacity = 0,
                            this.domElement.style.webkitTransform = "scale(1.1)",
                            this.layout(),
                            o.defer((function() {
                                e.backgroundElement.style.opacity = 1,
                                e.domElement.style.opacity = 1,
                                e.domElement.style.webkitTransform = "scale(1)"
                            }
                            ))
                        }
                    }, {
                        key: "hide",
                        value: function() {
                            var e = this
                              , t = function t() {
                                e.domElement.style.display = "none",
                                e.backgroundElement.style.display = "none",
                                E.unbind(e.domElement, "webkitTransitionEnd", t),
                                E.unbind(e.domElement, "transitionend", t),
                                E.unbind(e.domElement, "oTransitionEnd", t)
                            };
                            E.bind(this.domElement, "webkitTransitionEnd", t),
                            E.bind(this.domElement, "transitionend", t),
                            E.bind(this.domElement, "oTransitionEnd", t),
                            this.backgroundElement.style.opacity = 0,
                            this.domElement.style.opacity = 0,
                            this.domElement.style.webkitTransform = "scale(1.1)"
                        }
                    }, {
                        key: "layout",
                        value: function() {
                            this.domElement.style.left = window.innerWidth / 2 - E.getWidth(this.domElement) / 2 + "px",
                            this.domElement.style.top = window.innerHeight / 2 - E.getHeight(this.domElement) / 2 + "px"
                        }
                    }]),
                    e
                }();
                !function(e, t) {
                    var n = t || document
                      , r = document.createElement("style");
                    r.type = "text/css",
                    r.innerHTML = e;
                    var i = n.getElementsByTagName("head")[0];
                    try {
                        i.appendChild(r)
                    } catch (e) {}
                }(function(e) {
                    if ("undefined" != typeof window) {
                        var t = document.createElement("style");
                        return t.setAttribute("type", "text/css"),
                        t.innerHTML = e,
                        document.head.appendChild(t),
                        e
                    }
                }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
                var j = "Default"
                  , V = function() {
                    try {
                        return !!window.localStorage
                    } catch (e) {
                        return !1
                    }
                }()
                  , W = void 0
                  , q = !0
                  , X = void 0
                  , Y = !1
                  , Z = []
                  , J = function e(t) {
                    var n = this
                      , r = t || {};
                    this.domElement = document.createElement("div"),
                    this.__ul = document.createElement("ul"),
                    this.domElement.appendChild(this.__ul),
                    E.addClass(this.domElement, "dg"),
                    this.__folders = {},
                    this.__controllers = [],
                    this.__rememberedObjects = [],
                    this.__rememberedObjectIndecesToControllers = [],
                    this.__listening = [],
                    r = o.defaults(r, {
                        closeOnTop: !1,
                        autoPlace: !0,
                        width: e.DEFAULT_WIDTH
                    }),
                    r = o.defaults(r, {
                        resizable: r.autoPlace,
                        hideable: r.autoPlace
                    }),
                    o.isUndefined(r.load) ? r.load = {
                        preset: j
                    } : r.preset && (r.load.preset = r.preset),
                    o.isUndefined(r.parent) && r.hideable && Z.push(this),
                    r.resizable = o.isUndefined(r.parent) && r.resizable,
                    r.autoPlace && o.isUndefined(r.scrollable) && (r.scrollable = !0);
                    var i, a = V && "true" === localStorage.getItem(ne(0, "isLocal")), s = void 0, l = void 0;
                    if (Object.defineProperties(this, {
                        parent: {
                            get: function() {
                                return r.parent
                            }
                        },
                        scrollable: {
                            get: function() {
                                return r.scrollable
                            }
                        },
                        autoPlace: {
                            get: function() {
                                return r.autoPlace
                            }
                        },
                        closeOnTop: {
                            get: function() {
                                return r.closeOnTop
                            }
                        },
                        preset: {
                            get: function() {
                                return n.parent ? n.getRoot().preset : r.load.preset
                            },
                            set: function(e) {
                                n.parent ? n.getRoot().preset = e : r.load.preset = e,
                                function(e) {
                                    for (var t = 0; t < e.__preset_select.length; t++)
                                        e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t)
                                }(this),
                                n.revert()
                            }
                        },
                        width: {
                            get: function() {
                                return r.width
                            },
                            set: function(e) {
                                r.width = e,
                                se(n, e)
                            }
                        },
                        name: {
                            get: function() {
                                return r.name
                            },
                            set: function(e) {
                                r.name = e,
                                l && (l.innerHTML = r.name)
                            }
                        },
                        closed: {
                            get: function() {
                                return r.closed
                            },
                            set: function(t) {
                                r.closed = t,
                                r.closed ? E.addClass(n.__ul, e.CLASS_CLOSED) : E.removeClass(n.__ul, e.CLASS_CLOSED),
                                this.onResize(),
                                n.__closeButton && (n.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED)
                            }
                        },
                        load: {
                            get: function() {
                                return r.load
                            }
                        },
                        useLocalStorage: {
                            get: function() {
                                return a
                            },
                            set: function(e) {
                                V && (a = e,
                                e ? E.bind(window, "unload", s) : E.unbind(window, "unload", s),
                                localStorage.setItem(ne(0, "isLocal"), e))
                            }
                        }
                    }),
                    o.isUndefined(r.parent)) {
                        if (this.closed = r.closed || !1,
                        E.addClass(this.domElement, e.CLASS_MAIN),
                        E.makeSelectable(this.domElement, !1),
                        V && a) {
                            n.useLocalStorage = !0;
                            var c = localStorage.getItem(ne(0, "gui"));
                            c && (r.load = JSON.parse(c))
                        }
                        this.__closeButton = document.createElement("div"),
                        this.__closeButton.innerHTML = e.TEXT_CLOSED,
                        E.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON),
                        r.closeOnTop ? (E.addClass(this.__closeButton, e.CLASS_CLOSE_TOP),
                        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (E.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM),
                        this.domElement.appendChild(this.__closeButton)),
                        E.bind(this.__closeButton, "click", (function() {
                            n.closed = !n.closed
                        }
                        ))
                    } else {
                        void 0 === r.closed && (r.closed = !0);
                        var u = document.createTextNode(r.name);
                        E.addClass(u, "controller-name"),
                        l = K(n, u),
                        E.addClass(this.__ul, e.CLASS_CLOSED),
                        E.addClass(l, "title"),
                        E.bind(l, "click", (function(e) {
                            return e.preventDefault(),
                            n.closed = !n.closed,
                            !1
                        }
                        )),
                        r.closed || (this.closed = !1)
                    }
                    r.autoPlace && (o.isUndefined(r.parent) && (q && (X = document.createElement("div"),
                    E.addClass(X, "dg"),
                    E.addClass(X, e.CLASS_AUTO_PLACE_CONTAINER),
                    document.body.appendChild(X),
                    q = !1),
                    X.appendChild(this.domElement),
                    E.addClass(this.domElement, e.CLASS_AUTO_PLACE)),
                    this.parent || se(n, r.width)),
                    this.__resizeHandler = function() {
                        n.onResizeDebounced()
                    }
                    ,
                    E.bind(window, "resize", this.__resizeHandler),
                    E.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
                    E.bind(this.__ul, "transitionend", this.__resizeHandler),
                    E.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
                    this.onResize(),
                    r.resizable && oe(this),
                    s = function() {
                        V && "true" === localStorage.getItem(ne(0, "isLocal")) && localStorage.setItem(ne(0, "gui"), JSON.stringify(n.getSaveObject()))
                    }
                    ,
                    this.saveToLocalStorageIfPossible = s,
                    r.parent || ((i = n.getRoot()).width += 1,
                    o.defer((function() {
                        i.width -= 1
                    }
                    )))
                };
                function K(e, t, n) {
                    var r = document.createElement("li");
                    return t && r.appendChild(t),
                    n ? e.__ul.insertBefore(r, n) : e.__ul.appendChild(r),
                    e.onResize(),
                    r
                }
                function Q(e) {
                    E.unbind(window, "resize", e.__resizeHandler),
                    e.saveToLocalStorageIfPossible && E.unbind(window, "unload", e.saveToLocalStorageIfPossible)
                }
                function $(e, t) {
                    var n = e.__preset_select[e.__preset_select.selectedIndex];
                    n.innerHTML = t ? n.value + "*" : n.value
                }
                function ee(e, t) {
                    var n = e.getRoot()
                      , r = n.__rememberedObjects.indexOf(t.object);
                    if (-1 !== r) {
                        var i = n.__rememberedObjectIndecesToControllers[r];
                        if (void 0 === i && (i = {},
                        n.__rememberedObjectIndecesToControllers[r] = i),
                        i[t.property] = t,
                        n.load && n.load.remembered) {
                            var a = n.load.remembered
                              , o = void 0;
                            if (a[e.preset])
                                o = a[e.preset];
                            else {
                                if (!a.Default)
                                    return;
                                o = a.Default
                            }
                            if (o[r] && void 0 !== o[r][t.property]) {
                                var s = o[r][t.property];
                                t.initialValue = s,
                                t.setValue(s)
                            }
                        }
                    }
                }
                function te(e, t, n, r) {
                    if (void 0 === t[n])
                        throw new Error('Object "' + t + '" has no property "' + n + '"');
                    var i = void 0;
                    if (r.color)
                        i = new N(t,n);
                    else {
                        var a = [t, n].concat(r.factoryArgs);
                        i = U.apply(e, a)
                    }
                    r.before instanceof w && (r.before = r.before.__li),
                    ee(e, i),
                    E.addClass(i.domElement, "c");
                    var s = document.createElement("span");
                    E.addClass(s, "property-name"),
                    s.innerHTML = i.property;
                    var l = document.createElement("div");
                    l.appendChild(s),
                    l.appendChild(i.domElement);
                    var c = K(e, l, r.before);
                    return E.addClass(c, J.CLASS_CONTROLLER_ROW),
                    i instanceof N ? E.addClass(c, "color") : E.addClass(c, p(i.getValue())),
                    function(e, t, n) {
                        if (n.__li = t,
                        n.__gui = e,
                        o.extend(n, {
                            options: function(t) {
                                if (arguments.length > 1) {
                                    var r = n.__li.nextElementSibling;
                                    return n.remove(),
                                    te(e, n.object, n.property, {
                                        before: r,
                                        factoryArgs: [o.toArray(arguments)]
                                    })
                                }
                                if (o.isArray(t) || o.isObject(t)) {
                                    var i = n.__li.nextElementSibling;
                                    return n.remove(),
                                    te(e, n.object, n.property, {
                                        before: i,
                                        factoryArgs: [t]
                                    })
                                }
                            },
                            name: function(e) {
                                return n.__li.firstElementChild.firstElementChild.innerHTML = e,
                                n
                            },
                            listen: function() {
                                return n.__gui.listen(n),
                                n
                            },
                            remove: function() {
                                return n.__gui.remove(n),
                                n
                            }
                        }),
                        n instanceof F) {
                            var r = new D(n.object,n.property,{
                                min: n.__min,
                                max: n.__max,
                                step: n.__step
                            });
                            o.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function(e) {
                                var t = n[e]
                                  , i = r[e];
                                n[e] = r[e] = function() {
                                    var e = Array.prototype.slice.call(arguments);
                                    return i.apply(r, e),
                                    t.apply(n, e)
                                }
                            }
                            )),
                            E.addClass(t, "has-slider"),
                            n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
                        } else if (n instanceof D) {
                            var i = function(t) {
                                if (o.isNumber(n.__min) && o.isNumber(n.__max)) {
                                    var r = n.__li.firstElementChild.firstElementChild.innerHTML
                                      , i = n.__gui.__listening.indexOf(n) > -1;
                                    n.remove();
                                    var a = te(e, n.object, n.property, {
                                        before: n.__li.nextElementSibling,
                                        factoryArgs: [n.__min, n.__max, n.__step]
                                    });
                                    return a.name(r),
                                    i && a.listen(),
                                    a
                                }
                                return t
                            };
                            n.min = o.compose(i, n.min),
                            n.max = o.compose(i, n.max)
                        } else
                            n instanceof A ? (E.bind(t, "click", (function() {
                                E.fakeEvent(n.__checkbox, "click")
                            }
                            )),
                            E.bind(n.__checkbox, "click", (function(e) {
                                e.stopPropagation()
                            }
                            ))) : n instanceof I ? (E.bind(t, "click", (function() {
                                E.fakeEvent(n.__button, "click")
                            }
                            )),
                            E.bind(t, "mouseover", (function() {
                                E.addClass(n.__button, "hover")
                            }
                            )),
                            E.bind(t, "mouseout", (function() {
                                E.removeClass(n.__button, "hover")
                            }
                            ))) : n instanceof N && (E.addClass(t, "color"),
                            n.updateDisplay = o.compose((function(e) {
                                return t.style.borderLeftColor = n.__color.toString(),
                                e
                            }
                            ), n.updateDisplay),
                            n.updateDisplay());
                        n.setValue = o.compose((function(t) {
                            return e.getRoot().__preset_select && n.isModified() && $(e.getRoot(), !0),
                            t
                        }
                        ), n.setValue)
                    }(e, c, i),
                    e.__controllers.push(i),
                    i
                }
                function ne(e, t) {
                    return document.location.href + "." + t
                }
                function re(e, t, n) {
                    var r = document.createElement("option");
                    r.innerHTML = t,
                    r.value = t,
                    e.__preset_select.appendChild(r),
                    n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1)
                }
                function ie(e, t) {
                    t.style.display = e.useLocalStorage ? "block" : "none"
                }
                function ae(e) {
                    var t = e.__save_row = document.createElement("li");
                    E.addClass(e.domElement, "has-save"),
                    e.__ul.insertBefore(t, e.__ul.firstChild),
                    E.addClass(t, "save-row");
                    var n = document.createElement("span");
                    n.innerHTML = "&nbsp;",
                    E.addClass(n, "button gears");
                    var r = document.createElement("span");
                    r.innerHTML = "Save",
                    E.addClass(r, "button"),
                    E.addClass(r, "save");
                    var i = document.createElement("span");
                    i.innerHTML = "New",
                    E.addClass(i, "button"),
                    E.addClass(i, "save-as");
                    var a = document.createElement("span");
                    a.innerHTML = "Revert",
                    E.addClass(a, "button"),
                    E.addClass(a, "revert");
                    var s = e.__preset_select = document.createElement("select");
                    if (e.load && e.load.remembered ? o.each(e.load.remembered, (function(t, n) {
                        re(e, n, n === e.preset)
                    }
                    )) : re(e, j, !1),
                    E.bind(s, "change", (function() {
                        for (var t = 0; t < e.__preset_select.length; t++)
                            e.__preset_select[t].innerHTML = e.__preset_select[t].value;
                        e.preset = this.value
                    }
                    )),
                    t.appendChild(s),
                    t.appendChild(n),
                    t.appendChild(r),
                    t.appendChild(i),
                    t.appendChild(a),
                    V) {
                        var l = document.getElementById("dg-local-explain")
                          , c = document.getElementById("dg-local-storage");
                        document.getElementById("dg-save-locally").style.display = "block",
                        "true" === localStorage.getItem(ne(0, "isLocal")) && c.setAttribute("checked", "checked"),
                        ie(e, l),
                        E.bind(c, "change", (function() {
                            e.useLocalStorage = !e.useLocalStorage,
                            ie(e, l)
                        }
                        ))
                    }
                    var u = document.getElementById("dg-new-constructor");
                    E.bind(u, "keydown", (function(e) {
                        !e.metaKey || 67 !== e.which && 67 !== e.keyCode || W.hide()
                    }
                    )),
                    E.bind(n, "click", (function() {
                        u.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2),
                        W.show(),
                        u.focus(),
                        u.select()
                    }
                    )),
                    E.bind(r, "click", (function() {
                        e.save()
                    }
                    )),
                    E.bind(i, "click", (function() {
                        var t = prompt("Enter a new preset name.");
                        t && e.saveAs(t)
                    }
                    )),
                    E.bind(a, "click", (function() {
                        e.revert()
                    }
                    ))
                }
                function oe(e) {
                    var t = void 0;
                    function n(n) {
                        return n.preventDefault(),
                        e.width += t - n.clientX,
                        e.onResize(),
                        t = n.clientX,
                        !1
                    }
                    function r() {
                        E.removeClass(e.__closeButton, J.CLASS_DRAG),
                        E.unbind(window, "mousemove", n),
                        E.unbind(window, "mouseup", r)
                    }
                    function i(i) {
                        return i.preventDefault(),
                        t = i.clientX,
                        E.addClass(e.__closeButton, J.CLASS_DRAG),
                        E.bind(window, "mousemove", n),
                        E.bind(window, "mouseup", r),
                        !1
                    }
                    e.__resize_handle = document.createElement("div"),
                    o.extend(e.__resize_handle.style, {
                        width: "6px",
                        marginLeft: "-3px",
                        height: "200px",
                        cursor: "ew-resize",
                        position: "absolute"
                    }),
                    E.bind(e.__resize_handle, "mousedown", i),
                    E.bind(e.__closeButton, "mousedown", i),
                    e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild)
                }
                function se(e, t) {
                    e.domElement.style.width = t + "px",
                    e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"),
                    e.__closeButton && (e.__closeButton.style.width = t + "px")
                }
                function le(e, t) {
                    var n = {};
                    return o.each(e.__rememberedObjects, (function(r, i) {
                        var a = {}
                          , s = e.__rememberedObjectIndecesToControllers[i];
                        o.each(s, (function(e, n) {
                            a[n] = t ? e.initialValue : e.getValue()
                        }
                        )),
                        n[i] = a
                    }
                    )),
                    n
                }
                function ce(e) {
                    0 !== e.length && H.call(window, (function() {
                        ce(e)
                    }
                    )),
                    o.each(e, (function(e) {
                        e.updateDisplay()
                    }
                    ))
                }
                J.toggleHide = function() {
                    Y = !Y,
                    o.each(Z, (function(e) {
                        e.domElement.style.display = Y ? "none" : ""
                    }
                    ))
                }
                ,
                J.CLASS_AUTO_PLACE = "a",
                J.CLASS_AUTO_PLACE_CONTAINER = "ac",
                J.CLASS_MAIN = "main",
                J.CLASS_CONTROLLER_ROW = "cr",
                J.CLASS_TOO_TALL = "taller-than-window",
                J.CLASS_CLOSED = "closed",
                J.CLASS_CLOSE_BUTTON = "close-button",
                J.CLASS_CLOSE_TOP = "close-top",
                J.CLASS_CLOSE_BOTTOM = "close-bottom",
                J.CLASS_DRAG = "drag",
                J.DEFAULT_WIDTH = 245,
                J.TEXT_CLOSED = "Close Controls",
                J.TEXT_OPEN = "Open Controls",
                J._keydownHandler = function(e) {
                    "text" === document.activeElement.type || 72 !== e.which && 72 !== e.keyCode || J.toggleHide()
                }
                ,
                E.bind(window, "keydown", J._keydownHandler, !1),
                o.extend(J.prototype, {
                    add: function(e, t) {
                        return te(this, e, t, {
                            factoryArgs: Array.prototype.slice.call(arguments, 2)
                        })
                    },
                    addColor: function(e, t) {
                        return te(this, e, t, {
                            color: !0
                        })
                    },
                    remove: function(e) {
                        this.__ul.removeChild(e.__li),
                        this.__controllers.splice(this.__controllers.indexOf(e), 1);
                        var t = this;
                        o.defer((function() {
                            t.onResize()
                        }
                        ))
                    },
                    destroy: function() {
                        if (this.parent)
                            throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                        this.autoPlace && X.removeChild(this.domElement);
                        var e = this;
                        o.each(this.__folders, (function(t) {
                            e.removeFolder(t)
                        }
                        )),
                        E.unbind(window, "keydown", J._keydownHandler, !1),
                        Q(this)
                    },
                    addFolder: function(e) {
                        if (void 0 !== this.__folders[e])
                            throw new Error('You already have a folder in this GUI by the name "' + e + '"');
                        var t = {
                            name: e,
                            parent: this
                        };
                        t.autoPlace = this.autoPlace,
                        this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed,
                        t.load = this.load.folders[e]);
                        var n = new J(t);
                        this.__folders[e] = n;
                        var r = K(this, n.domElement);
                        return E.addClass(r, "folder"),
                        n
                    },
                    removeFolder: function(e) {
                        this.__ul.removeChild(e.domElement.parentElement),
                        delete this.__folders[e.name],
                        this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name],
                        Q(e);
                        var t = this;
                        o.each(e.__folders, (function(t) {
                            e.removeFolder(t)
                        }
                        )),
                        o.defer((function() {
                            t.onResize()
                        }
                        ))
                    },
                    open: function() {
                        this.closed = !1
                    },
                    close: function() {
                        this.closed = !0
                    },
                    hide: function() {
                        this.domElement.style.display = "none"
                    },
                    show: function() {
                        this.domElement.style.display = ""
                    },
                    onResize: function() {
                        var e = this.getRoot();
                        if (e.scrollable) {
                            var t = E.getOffset(e.__ul).top
                              , n = 0;
                            o.each(e.__ul.childNodes, (function(t) {
                                e.autoPlace && t === e.__save_row || (n += E.getHeight(t))
                            }
                            )),
                            window.innerHeight - t - 20 < n ? (E.addClass(e.domElement, J.CLASS_TOO_TALL),
                            e.__ul.style.height = window.innerHeight - t - 20 + "px") : (E.removeClass(e.domElement, J.CLASS_TOO_TALL),
                            e.__ul.style.height = "auto")
                        }
                        e.__resize_handle && o.defer((function() {
                            e.__resize_handle.style.height = e.__ul.offsetHeight + "px"
                        }
                        )),
                        e.__closeButton && (e.__closeButton.style.width = e.width + "px")
                    },
                    onResizeDebounced: o.debounce((function() {
                        this.onResize()
                    }
                    ), 50),
                    remember: function() {
                        if (o.isUndefined(W) && ((W = new G).domElement.innerHTML = z),
                        this.parent)
                            throw new Error("You can only call remember on a top level GUI.");
                        var e = this;
                        o.each(Array.prototype.slice.call(arguments), (function(t) {
                            0 === e.__rememberedObjects.length && ae(e),
                            -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t)
                        }
                        )),
                        this.autoPlace && se(this, this.width)
                    },
                    getRoot: function() {
                        for (var e = this; e.parent; )
                            e = e.parent;
                        return e
                    },
                    getSaveObject: function() {
                        var e = this.load;
                        return e.closed = this.closed,
                        this.__rememberedObjects.length > 0 && (e.preset = this.preset,
                        e.remembered || (e.remembered = {}),
                        e.remembered[this.preset] = le(this)),
                        e.folders = {},
                        o.each(this.__folders, (function(t, n) {
                            e.folders[n] = t.getSaveObject()
                        }
                        )),
                        e
                    },
                    save: function() {
                        this.load.remembered || (this.load.remembered = {}),
                        this.load.remembered[this.preset] = le(this),
                        $(this, !1),
                        this.saveToLocalStorageIfPossible()
                    },
                    saveAs: function(e) {
                        this.load.remembered || (this.load.remembered = {},
                        this.load.remembered.Default = le(this, !0)),
                        this.load.remembered[e] = le(this),
                        this.preset = e,
                        re(this, e, !0),
                        this.saveToLocalStorageIfPossible()
                    },
                    revert: function(e) {
                        o.each(this.__controllers, (function(t) {
                            this.getRoot().load.remembered ? ee(e || this.getRoot(), t) : t.setValue(t.initialValue),
                            t.__onFinishChange && t.__onFinishChange.call(t, t.getValue())
                        }
                        ), this),
                        o.each(this.__folders, (function(e) {
                            e.revert(e)
                        }
                        )),
                        e || $(this.getRoot(), !1)
                    },
                    listen: function(e) {
                        var t = 0 === this.__listening.length;
                        this.__listening.push(e),
                        t && ce(this.__listening)
                    },
                    updateDisplay: function() {
                        o.each(this.__controllers, (function(e) {
                            e.updateDisplay()
                        }
                        )),
                        o.each(this.__folders, (function(e) {
                            e.updateDisplay()
                        }
                        ))
                    }
                });
                var ue = {
                    Color: _,
                    math: d,
                    interpret: u
                }
                  , he = {
                    Controller: w,
                    BooleanController: A,
                    OptionController: C,
                    StringController: P,
                    NumberController: L,
                    NumberControllerBox: D,
                    NumberControllerSlider: F,
                    FunctionController: I,
                    ColorController: N
                }
                  , de = {
                    dom: E
                }
                  , pe = {
                    GUI: J
                }
                  , fe = J;
                const me = {
                    color: ue,
                    controllers: he,
                    dom: de,
                    gui: pe,
                    GUI: J
                }
            }
            ,
            16: (e,t,n)=>{
                var r;
                window,
                e.exports = (r = n(2212),
                function(e) {
                    var t = {};
                    function n(r) {
                        if (t[r])
                            return t[r].exports;
                        var i = t[r] = {
                            i: r,
                            l: !1,
                            exports: {}
                        };
                        return e[r].call(i.exports, i, i.exports, n),
                        i.l = !0,
                        i.exports
                    }
                    return n.m = e,
                    n.c = t,
                    n.d = function(e, t, r) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: r
                        })
                    }
                    ,
                    n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    n.t = function(e, t) {
                        if (1 & t && (e = n(e)),
                        8 & t)
                            return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule)
                            return e;
                        var r = Object.create(null);
                        if (n.r(r),
                        Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }),
                        2 & t && "string" != typeof e)
                            for (var i in e)
                                n.d(r, i, function(t) {
                                    return e[t]
                                }
                                .bind(null, i));
                        return r
                    }
                    ,
                    n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return n.d(t, "a", t),
                        t
                    }
                    ,
                    n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    n.p = "",
                    n(n.s = "./src/GBufferPass.ts")
                }({
                    "./src/GBufferPass.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                            void 0 === r && (r = n),
                            Object.defineProperty(e, r, {
                                enumerable: !0,
                                get: function() {
                                    return t[n]
                                }
                            })
                        }
                        : function(e, t, n, r) {
                            void 0 === r && (r = n),
                            e[r] = t[n]
                        }
                        )
                          , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                            Object.defineProperty(e, "default", {
                                enumerable: !0,
                                value: t
                            })
                        }
                        : function(e, t) {
                            e.default = t
                        }
                        )
                          , a = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                            return i(t, e),
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.GBuffer = void 0;
                        var o, s = a(n("three")), l = n("./src/shaders/packDepth32Shader.ts"), c = n("./src/shaders/packDepthNormal16Shader.ts");
                        !function(e) {
                            e[e.NONE = 0] = "NONE",
                            e[e.DEPTH_NORMAL_16 = 1] = "DEPTH_NORMAL_16"
                        }(o || (o = {}));
                        var u = function() {
                            function e(e) {
                                this.u = !1,
                                this.h = !1,
                                this.v = new s.Color,
                                e = e || {},
                                this.g = void 0 === e.forceDepthAndNormalPass || e.forceDepthAndNormalPass,
                                this.j = void 0 !== e.packingMode ? e.packingMode : o.DEPTH_NORMAL_16,
                                this.N = new s.MeshNormalMaterial,
                                this.k = new s.ShaderMaterial(c.packDepthNormal16Shader),
                                this.O = void 0 === e.linearDepth || e.linearDepth,
                                this.O ? (this._ = new s.ShaderMaterial(l.packDepth32Shader),
                                this.g = !0) : (this._ = new s.MeshDepthMaterial,
                                this._.depthPacking = s.RGBADepthPacking),
                                this.M = new s.Color(16777215)
                            }
                            return e.prototype.dispose = function() {
                                this.D && this.D.dispose(),
                                this.F && this.F.dispose(),
                                this.P && this.P.dispose(),
                                this.N.dispose(),
                                this.k.dispose(),
                                this._.dispose()
                            }
                            ,
                            e.prototype.setSize = function(e, t) {
                                this.D && this.D.setSize(e, t),
                                this.F && this.F.setSize(e, t),
                                this.P && this.P.setSize(e, t)
                            }
                            ,
                            e.prototype.hasLinearDepth = function() {
                                return this.O
                            }
                            ,
                            e.prototype.hasDepthTexture = function() {
                                return this.h
                            }
                            ,
                            e.prototype.isDepthAndNormalPassForced = function() {
                                return this.g
                            }
                            ,
                            e.prototype.getNormalDepthTexture = function() {
                                var e;
                                return this.F || (e = this.D ? this.D.texture : null),
                                e
                            }
                            ,
                            e.prototype.getDepthTexture = function() {
                                return this.S ? this.S : this.F ? this.F.texture : null
                            }
                            ,
                            e.prototype.getNormalTexture = function() {
                                return this.P ? this.P.texture : null
                            }
                            ,
                            e.prototype.getVelocityTexture = function() {
                                throw new Error("Not implemented yet")
                            }
                            ,
                            e.prototype.getPackingMode = function() {
                                return this.j
                            }
                            ,
                            e.prototype.render = function(e, t, n) {
                                this.u || this.Z(e),
                                e.getClearColor(this.v);
                                var r = e.getClearAlpha()
                                  , i = e.autoClear
                                  , a = e.shadowMap.enabled
                                  , o = t.background;
                                e.shadowMap.enabled = !1,
                                e.autoClear = !1,
                                t.background = this.M,
                                this.B(e, t, n),
                                e.autoClear = i,
                                e.shadowMap.enabled = a,
                                e.setClearColor(this.v, r),
                                t.background = o
                            }
                            ,
                            e.prototype.Z = function(e) {
                                var t = e.extensions
                                  , n = e.capabilities.isWebGL2 || t.get("WEBGL_depth_texture")
                                  , r = new s.Vector2;
                                if (e.getDrawingBufferSize(r),
                                !this.g && n && !this.P) {
                                    var i = {
                                        minFilter: s.NearestFilter,
                                        magFilter: s.NearestFilter,
                                        format: s.RGBAFormat
                                    };
                                    this.P = new s.WebGLRenderTarget(r.x,r.y,i),
                                    this.S || (this.S = new s.DepthTexture(r.x,r.y),
                                    this.S.type = s.UnsignedShortType),
                                    this.P.depthTexture = this.S
                                }
                                n && !this.g || (i = {
                                    minFilter: s.NearestFilter,
                                    magFilter: s.NearestFilter,
                                    format: s.RGBAFormat
                                },
                                this.j === o.NONE && (this.F || (this.F = new s.WebGLRenderTarget(r.x,r.y,i),
                                this.F.depthTexture = this.S),
                                this.P || (this.P = new s.WebGLRenderTarget(r.x,r.y,i),
                                this.P.depthTexture = this.S)),
                                this.j === o.DEPTH_NORMAL_16 && (this.D || (this.D = new s.WebGLRenderTarget(r.x,r.y,i),
                                this.D.depthTexture = this.S))),
                                this.u = !0
                            }
                            ,
                            e.prototype.G = function(e) {
                                var t = e.extensions;
                                return this.h = e.capabilities.isWebGL2 || t.get("WEBGL_depth_texture"),
                                this.h
                            }
                            ,
                            e.prototype.B = function(e, t, n) {
                                !function(e) {
                                    e.traverse((function(e) {
                                        (e.isMesh || e.isLineSegments || e.isLine || e.isLineLoop || e.isPoints) && (e.material && e.material.transparent || e.castAO,
                                        (e.material && e.material.transparent && !e.material.isShadowMaterial || e.castAO || e.material.alphaTest > 0) && (e.aoVisibility = e.visible,
                                        e.visible = !1))
                                    }
                                    ))
                                }(t);
                                var r = this.G(e);
                                r && !this.g && (t.overrideMaterial = this.N,
                                e.setRenderTarget(this.P),
                                e.clear(!0, !0, !1),
                                e.render(t, n),
                                e.setRenderTarget(null),
                                t.overrideMaterial = null),
                                r && !this.g || (this.j === o.NONE && (t.overrideMaterial = this.N,
                                e.setRenderTarget(this.P),
                                e.clear(!0, !0, !1),
                                e.render(t, n),
                                e.setRenderTarget(null),
                                t.overrideMaterial = null,
                                t.overrideMaterial = this._,
                                this._.isMeshDepthMaterial || (this._.uniforms.cameraNearFar.value.x = n.near,
                                this._.uniforms.cameraNearFar.value.y = n.far),
                                e.setRenderTarget(this.F),
                                e.clear(!0, !0, !1),
                                e.render(t, n),
                                e.setRenderTarget(null),
                                t.overrideMaterial = null),
                                this.j === o.DEPTH_NORMAL_16 && (t.overrideMaterial = this.k,
                                this.k.uniforms.cameraNearFar.value.x = n.near,
                                this.k.uniforms.cameraNearFar.value.y = n.far,
                                e.setRenderTarget(this.D),
                                e.clear(!0, !0, !1),
                                e.render(t, n),
                                e.setRenderTarget(null),
                                t.overrideMaterial = null)),
                                function(e) {
                                    e.traverse((function(e) {
                                        e.aoVisibility && (e.visible = e.aoVisibility,
                                        e.aoVisibility = void 0)
                                    }
                                    ))
                                }(t)
                            }
                            ,
                            e.PackingMode = o,
                            e
                        }();
                        t.GBuffer = u
                    },
                    "./src/shaders/packDepth32.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "#include <packing>\r\nuniform vec2 cameraNearFar;\r\nvarying vec3 viewPosition;\r\n\r\nfloat linstep(float edge0, float edge1, float value){\r\n    return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);\r\n    vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));\r\n    gl_FragColor = packedZ;\r\n}"
                    },
                    "./src/shaders/packDepth32.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 viewPosition;\r\nvoid main() {\r\n    viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}"
                    },
                    "./src/shaders/packDepth32Shader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                            void 0 === r && (r = n),
                            Object.defineProperty(e, r, {
                                enumerable: !0,
                                get: function() {
                                    return t[n]
                                }
                            })
                        }
                        : function(e, t, n, r) {
                            void 0 === r && (r = n),
                            e[r] = t[n]
                        }
                        )
                          , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                            Object.defineProperty(e, "default", {
                                enumerable: !0,
                                value: t
                            })
                        }
                        : function(e, t) {
                            e.default = t
                        }
                        )
                          , a = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                            return i(t, e),
                            t
                        }
                          , o = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.packDepth32Shader = void 0;
                        var s = o(n("./src/shaders/packDepth32.vert"))
                          , l = o(n("./src/shaders/packDepth32.frag"))
                          , c = a(n("three"));
                        t.packDepth32Shader = {
                            uniforms: {
                                cameraNearFar: {
                                    type: "v2",
                                    value: new c.Vector2
                                }
                            },
                            vertexShader: s.default,
                            fragmentShader: l.default
                        }
                    },
                    "./src/shaders/packDepthNormal16.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 viewNormal;\r\nuniform vec2 cameraNearFar;\r\nvarying vec3 viewPosition;\r\n\r\nvec2 pack16(float value) {\r\n    float sMax = 65535.0;\r\n    int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);\r\n    int digit0 = v/256;\r\n    int digit1 = v-digit0*256;\r\n    return vec2(float(digit0)/255.0, float(digit1)/255.0);\r\n}\r\n\r\nvec2 packNormal(vec3 n){\r\n    float p = sqrt(n.z*8.0+8.0);\r\n    return vec2(n.xy/p + 0.5);\r\n}\r\n\r\nfloat linstep(float edge0, float edge1, float value) {\r\n    return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);\r\n    vec2 packedZ = pack16(pow(linearZ, 0.5));\r\n    vec2 packedNormal = packNormal(normalize(viewNormal));\r\n    gl_FragColor = vec4(packedZ.x, packedZ.y, packedNormal.x, packedNormal.y);\r\n}"
                    },
                    "./src/shaders/packDepthNormal16.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 viewNormal;\r\nvarying vec3 viewPosition;\r\nvoid main() {\r\n    viewNormal = normalMatrix * normal;\r\n    viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}"
                    },
                    "./src/shaders/packDepthNormal16Shader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                            void 0 === r && (r = n),
                            Object.defineProperty(e, r, {
                                enumerable: !0,
                                get: function() {
                                    return t[n]
                                }
                            })
                        }
                        : function(e, t, n, r) {
                            void 0 === r && (r = n),
                            e[r] = t[n]
                        }
                        )
                          , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                            Object.defineProperty(e, "default", {
                                enumerable: !0,
                                value: t
                            })
                        }
                        : function(e, t) {
                            e.default = t
                        }
                        )
                          , a = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                            return i(t, e),
                            t
                        }
                          , o = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.packDepthNormal16Shader = void 0;
                        var s = o(n("./src/shaders/packDepthNormal16.vert"))
                          , l = o(n("./src/shaders/packDepthNormal16.frag"))
                          , c = a(n("three"));
                        t.packDepthNormal16Shader = {
                            uniforms: {
                                cameraNearFar: {
                                    type: "v2",
                                    value: new c.Vector2
                                }
                            },
                            vertexShader: s.default,
                            fragmentShader: l.default
                        }
                    },
                    three: function(e, t) {
                        e.exports = r
                    }
                }))
            }
            ,
            9230: (e,t,n)=>{
                var r;
                window,
                e.exports = (r = n(2212),
                function(e) {
                    var t = {};
                    function n(r) {
                        if (t[r])
                            return t[r].exports;
                        var i = t[r] = {
                            i: r,
                            l: !1,
                            exports: {}
                        };
                        return e[r].call(i.exports, i, i.exports, n),
                        i.l = !0,
                        i.exports
                    }
                    return n.m = e,
                    n.c = t,
                    n.d = function(e, t, r) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: r
                        })
                    }
                    ,
                    n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    n.t = function(e, t) {
                        if (1 & t && (e = n(e)),
                        8 & t)
                            return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule)
                            return e;
                        var r = Object.create(null);
                        if (n.r(r),
                        Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }),
                        2 & t && "string" != typeof e)
                            for (var i in e)
                                n.d(r, i, function(t) {
                                    return e[t]
                                }
                                .bind(null, i));
                        return r
                    }
                    ,
                    n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return n.d(t, "a", t),
                        t
                    }
                    ,
                    n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    n.p = "",
                    n(n.s = 0)
                }({
                    "./src/Diamond.ts": function(e, t, n) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.Diamond = void 0;
                        const r = n("three");
                        t.Diamond = class {
                            constructor(e, t) {
                                this.u = [],
                                this.v = e,
                                this.v.material = t.clone(),
                                this.v.geometry.computeBoundingBox(),
                                this.h = new r.Vector3,
                                this.v.geometry.boundingBox.getCenter(this.h),
                                this.v.material.uniforms.centreOffset.value.copy(this.h),
                                this.v.geometry.computeBoundingSphere(),
                                this.M = this.v.geometry.boundingSphere.radius,
                                this.v.material.uniforms.radius.value = this.M;
                                let n = this;
                                this.v.onBeforeRender = function(e, t, r) {
                                    n.updateDiamond(r)
                                }
                            }
                            get isDiamond() {
                                return !0
                            }
                            getCentreOffset() {
                                return this.h
                            }
                            getBoundingRadius() {
                                return this.M
                            }
                            getMesh() {
                                return this.v
                            }
                            getMaterial() {
                                return this.v.material
                            }
                            setPosition(e, t, n) {
                                this.v.position.set(e, t, n)
                            }
                            setRotation(e, t, n) {
                                this.v.rotation.set(e, t, n)
                            }
                            setQuaternion(e, t, n, r) {
                                this.v.quaternion.set(e, t, n, r)
                            }
                            setScale(e, t, n) {
                                this.v.scale.set(e, t, n);
                                for (var r = 0; r < this.u.length; r++)
                                    this.u[r].setScale(e)
                            }
                            setTransform(e) {
                                this.v.matrix.copy(e)
                            }
                            updateDiamond(e) {
                                let t = new r.Vector3;
                                this.v.updateMatrixWorld();
                                let n = this.v.matrixWorld
                                  , i = this.v.material.uniforms.InverseModelMatrix;
                                i && i.value.copy(n).invert(),
                                this.v.material.uniforms.opacity.value = this.v.material.opacity;
                                for (var a = 0; a < this.u.length; a++) {
                                    this.u[a].syncWithTransform(this.v.matrixWorld),
                                    t.copy(e.position),
                                    t.sub(this.u[a].mesh.position),
                                    t.normalize();
                                    var o = t.x + t.y + t.z;
                                    this.u[a].setRotation(o * this.u[a].rotationSpeedFactor),
                                    this.u[a].alignWithCamera(e)
                                }
                            }
                            addSparkle(e) {
                                this.u.push(e)
                            }
                            dispose() {
                                this.v.onBeforeRender = ()=>{}
                            }
                        }
                    },
                    "./src/DiamondMaterial.ts": function(e, t, n) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.DiamondMaterial = void 0;
                        const r = n("three")
                          , i = n("./src/DiamondShaders.ts");
                        class a extends r.ShaderMaterial {
                            constructor(e, t, n, a) {
                                if (super(),
                                this.C = new r.Scene,
                                this.D = !0,
                                this.h = new r.Vector3,
                                this.u = [],
                                void 0 === e)
                                    return;
                                this._ = null,
                                a = a || 1024;
                                const o = new r.WebGLCubeRenderTarget(a,{
                                    format: r.RGBAFormat,
                                    generateMipmaps: !1,
                                    minFilter: r.NearestFilter,
                                    magFilter: r.NearestFilter
                                });
                                this.P = new r.CubeCamera(1e-4,100,o),
                                this.C.add(this.P),
                                this.extensions = i.diamondMaterial.extensions,
                                this.defines = i.diamondMaterial.defines,
                                this.uniforms = r.UniformsUtils.clone(i.diamondMaterial.uniforms),
                                this.side = r.DoubleSide,
                                this.envMap = t,
                                this.vertexShader = i.diamondMaterial.vertexShader,
                                this.fragmentShader = i.diamondMaterial.fragmentShader,
                                this.D = !0,
                                this._ = e.clone(),
                                this._.material = i.normalMapCaptureMaterial,
                                this._.material.side = r.DoubleSide,
                                this._.geometry = e.geometry.clone(),
                                this._.geometry.center();
                                let s = e.geometry;
                                s.computeBoundingBox(),
                                s.boundingBox.getCenter(this.h),
                                s.computeBoundingSphere(),
                                this._.position.set(0, 0, 0),
                                this._.rotation.set(0, 0, 0),
                                this._.quaternion.set(0, 0, 0, 1),
                                this._.scale.set(1, 1, 1),
                                this.C.add(this._),
                                this.prepareNormalsCubeMap(n)
                            }
                            clone() {
                                const e = new a;
                                return e.uniforms = r.UniformsUtils.clone(this.uniforms),
                                e.extensions = this.extensions,
                                e.defines = this.defines,
                                e.uniforms.tCubeMapNormals.value = this.P.renderTarget.texture,
                                e.uniforms.envMap.value = this.S,
                                e.envMap = this.S,
                                e.side = r.DoubleSide,
                                e.vertexShader = this.vertexShader,
                                e.fragmentShader = this.fragmentShader,
                                e.P = this.P,
                                e._ = this._,
                                e.name = this.name,
                                e.transparent = this.transparent,
                                e.opacity = this.opacity,
                                e
                            }
                            prepareNormalsCubeMap(e) {
                                this.D && (this.P.update(e, this.C),
                                this.uniforms.tCubeMapNormals.value = this.P.renderTarget,
                                this.D = !1)
                            }
                            dispose(e) {
                                e && (this.P.renderTarget.dispose(),
                                this._.geometry.dispose()),
                                super.dispose()
                            }
                            set lut(e) {
                                const t = this;
                                if (e !== this.lut)
                                    if (t.uniforms.lut3d.value = null,
                                    t.uniforms.lut.value = null,
                                    e) {
                                        const n = e.isDataTexture3D ? 1 : 0;
                                        n !== t.defines.USE_3DTEXTURE && (t.defines.USE_3DTEXTURE = n,
                                        t.needsUpdate = !0),
                                        e.isDataTexture3D ? t.uniforms.lut3d.value = e : (t.uniforms.lut.value = e,
                                        t.uniforms.lutSize.value = e.image.width),
                                        t.defines.USE_LUT = 1,
                                        t.needsUpdate = !0
                                    } else
                                        t.defines.USE_LUT = 0,
                                        t.needsUpdate = !0
                            }
                            get lut() {
                                return this.uniforms.lut.value || this.uniforms.lut3d.value
                            }
                            get isDiamondMaterial() {
                                return !0
                            }
                            set envMap(e) {
                                e && (this.S = e,
                                this.S.isCubeTexture ? this.defines.ENV_MAP_TYPE = 0 : this.defines.ENV_MAP_TYPE = 1,
                                this.uniforms.envMap.value = e)
                            }
                            set envMapRotation(e) {
                                this.uniforms.envMapRotation.value = e
                            }
                            set envMapIntensity(e) {
                                this.uniforms.envMapIntensity.value = e
                            }
                            set dispersion(e) {
                                this.uniforms.rIndexDelta.value = e
                            }
                            set squashFactor(e) {
                                this.uniforms.squashFactor.value = e
                            }
                            set geometryFactor(e) {
                                this.uniforms.geometryFactor.value = e
                            }
                            set gammaFactor(e) {
                                this.uniforms.gammaFactor.value = e
                            }
                            set absorbptionFactor(e) {
                                this.uniforms.absorbptionFactor.value = e
                            }
                            set refractiveIndex(e) {
                                this.uniforms.refractiveIndex.value = e
                            }
                            set color(e) {
                                const t = this.uniforms.Absorbption.value;
                                t.x = 1 - e.r,
                                t.y = 1 - e.g,
                                t.z = 1 - e.b
                            }
                            set boostFactors(e) {
                                const t = this.uniforms.boostFactors.value;
                                void 0 !== e.x && (t.x = e.x),
                                void 0 !== e.y && (t.y = e.y),
                                void 0 !== e.z && (t.z = e.z)
                            }
                            get envMap() {
                                return this.uniforms.envMap.value
                            }
                            get envMapRotation() {
                                return this.uniforms.envMapRotation.value
                            }
                            get envMapIntensity() {
                                return this.uniforms.envMapIntensity.value
                            }
                            get dispersion() {
                                return this.uniforms.rIndexDelta.value
                            }
                            get squashFactor() {
                                return this.uniforms.squashFactor.value
                            }
                            get geometryFactor() {
                                return this.uniforms.geometryFactor.value
                            }
                            get refractiveIndex() {
                                return this.uniforms.refractiveIndex.value
                            }
                            get color() {
                                const e = this.uniforms.Absorbption.value;
                                return new r.Color(1 - e.x,1 - e.y,1 - e.z)
                            }
                            get boostFactors() {
                                return this.uniforms.boostFactors.value
                            }
                            get gammaFactor() {
                                return this.uniforms.gammaFactor.value
                            }
                            get absorbptionFactor() {
                                return this.uniforms.absorbptionFactor.value
                            }
                        }
                        t.DiamondMaterial = a
                    },
                    "./src/DiamondShaders.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.diamondMaterial = t.normalMapCaptureMaterial = void 0;
                        const i = n("three")
                          , a = r(n("./src/shaders/normalcapture.vert"))
                          , o = r(n("./src/shaders/normalcapture.frag"))
                          , s = r(n("./src/shaders/diamond.vert"))
                          , l = r(n("./src/shaders/diamond.frag"))
                          , c = {
                            vertexShader: a.default,
                            fragmentShader: o.default,
                            side: i.DoubleSide
                        }
                          , u = {
                            defines: {
                                RAY_BOUNCES: 5,
                                ENV_MAP_TYPE: 0,
                                PI: 3.1428,
                                USE_3DTEXTURE: 0,
                                USE_LUT: 0
                            },
                            vertexShader: s.default,
                            fragmentShader: l.default,
                            uniforms: {
                                tCubeMapNormals: {
                                    type: "t",
                                    value: null
                                },
                                envMap: {
                                    type: "t",
                                    value: null
                                },
                                envRefractionMap: {
                                    type: "t",
                                    value: null
                                },
                                sphereMap: {
                                    type: "t",
                                    value: null
                                },
                                envMapIntensity: {
                                    type: "f",
                                    value: 1
                                },
                                maxBounces: {
                                    type: "i",
                                    value: 1
                                },
                                tanAngleSqCone: {
                                    type: "f",
                                    value: 0
                                },
                                coneHeight: {
                                    type: "f",
                                    value: 0
                                },
                                bDebugBounces: {
                                    type: "i",
                                    value: !1
                                },
                                rIndexDelta: {
                                    type: "f",
                                    value: .012
                                },
                                refractiveIndex: {
                                    type: "f",
                                    value: 2.4
                                },
                                radius: {
                                    type: "f",
                                    value: 1
                                },
                                normalOffset: {
                                    type: "f",
                                    value: 0
                                },
                                squashFactor: {
                                    type: "f",
                                    value: .98
                                },
                                distanceOffset: {
                                    type: "f",
                                    value: 0
                                },
                                geometryFactor: {
                                    type: "f",
                                    value: .28
                                },
                                Absorbption: {
                                    type: "v3",
                                    value: new i.Vector3(0,0,0)
                                },
                                colorCorrection: {
                                    type: "v3",
                                    value: new i.Vector3(1,1,1)
                                },
                                boostFactors: {
                                    type: "v3",
                                    value: new i.Vector3(.892,.892,.98595025)
                                },
                                centreOffset: {
                                    type: "v3",
                                    value: new i.Vector3(0,0,0)
                                },
                                gammaFactor: {
                                    type: "f",
                                    value: 1
                                },
                                absorbptionFactor: {
                                    type: "f",
                                    value: 1
                                },
                                envMapRotation: {
                                    type: "f",
                                    value: 0
                                },
                                InverseModelMatrix: {
                                    type: "m4",
                                    value: (new i.Matrix4).identity()
                                },
                                lut3d: {
                                    value: null
                                },
                                lut: {
                                    value: null
                                },
                                lutSize: {
                                    value: 0
                                },
                                opacity: {
                                    value: 1
                                }
                            },
                            side: i.DoubleSide
                        };
                        t.normalMapCaptureMaterial = new i.ShaderMaterial(c),
                        t.diamondMaterial = new i.ShaderMaterial(u)
                    },
                    "./src/DiamondUtils.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                            void 0 === r && (r = n),
                            Object.defineProperty(e, r, {
                                enumerable: !0,
                                get: function() {
                                    return t[n]
                                }
                            })
                        }
                        : function(e, t, n, r) {
                            void 0 === r && (r = n),
                            e[r] = t[n]
                        }
                        )
                          , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                            Object.defineProperty(e, "default", {
                                enumerable: !0,
                                value: t
                            })
                        }
                        : function(e, t) {
                            e.default = t
                        }
                        )
                          , a = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                            return i(t, e),
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.DiamondUtils = void 0;
                        const o = n("./src/Diamond.ts")
                          , s = n("./src/DiamondMaterial.ts")
                          , l = a(n("three"));
                        function c(e, t) {
                            let n;
                            const r = e.name.toLowerCase();
                            if (t && t.diamondClass) {
                                const e = t.diamondClass;
                                for (let t in e) {
                                    let n = e[t];
                                    if (n.name && r === n.name.toLowerCase())
                                        return n
                                }
                            } else
                                t && !t.diamondConfiguration && r.includes("diamond") && (n = {
                                    name: e.name.substring(0, 8)
                                });
                            return n
                        }
                        function u(e, t) {
                            let n;
                            const r = e.name.toLowerCase();
                            if (t && t.diamondClass) {
                                const e = t.diamondClass;
                                for (let t in e) {
                                    let n = e[t];
                                    if (n.name && r.includes(n.name.toLowerCase()))
                                        return n
                                }
                            } else
                                t && !t.diamondConfiguration && r.includes("diamond") && (n = {
                                    name: e.name.substring(0, 8)
                                });
                            return n
                        }
                        function h(e, t) {
                            const n = e.name.toLowerCase();
                            if (t && t.diamondConfiguration) {
                                const e = t.diamondConfiguration;
                                for (let t in e) {
                                    let r = e[t];
                                    if (r.name && n === r.name.toLowerCase())
                                        return r
                                }
                            } else
                                n.includes("diamond")
                        }
                        function d(e, t) {
                            const n = e.material;
                            void 0 !== t.color && (n.color = new l.Color(t.color)),
                            void 0 !== t.boostFactors && (n.boostFactors = {
                                x: t.boostFactors.x,
                                y: t.boostFactors.y,
                                z: t.boostFactors.z
                            }),
                            void 0 !== t.squashFactor && (n.squashFactor = t.squashFactor),
                            void 0 !== t.dispersion && (n.dispersion = t.dispersion),
                            void 0 !== t.geometryFactor && (n.geometryFactor = t.geometryFactor),
                            void 0 !== t.refractiveIndex && (n.refractiveIndex = t.refractiveIndex),
                            void 0 !== t.gammaFactor && (n.gammaFactor = t.gammaFactor),
                            void 0 !== t.absorbptionFactor && (n.absorbptionFactor = t.absorbptionFactor),
                            void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity),
                            n.needsUpdate = !0
                        }
                        t.DiamondUtils = {};
                        const p = new l.Vector3
                          , f = new l.Vector3
                          , m = new l.Vector3
                          , g = new l.Vector3;
                        t.DiamondUtils.processScene = function(e, n, r) {
                            return t.DiamondUtils.prototypeMaterials = [],
                            function(e, n) {
                                let r = [];
                                e.traverse((e=>{
                                    e.isMesh && r.push(e)
                                }
                                )),
                                r.forEach((e=>{
                                    if (e.isMesh) {
                                        const r = c(e.material, n)
                                          , i = u(e, n);
                                        let a = r && r.name;
                                        (a = a || i && i.name) || (a = e.name.toLowerCase().includes("diamond") ? "diamond" : void 0),
                                        a && (function(e) {
                                            let t = e.geometry;
                                            if (t.transformed) {
                                                let n = new l.Vector3
                                                  , r = new l.Quaternion
                                                  , i = new l.Vector3;
                                                t.xForm.decompose(n, r, i);
                                                let a = new l.Object3D;
                                                a.position.copy(e.position),
                                                a.quaternion.copy(e.quaternion),
                                                a.scale.copy(e.scale);
                                                let o = e.parent;
                                                return a.add(e),
                                                o.add(a),
                                                e.position.copy(n),
                                                e.quaternion.copy(r),
                                                void e.scale.copy(i)
                                            }
                                            g.set(0, 0, 0);
                                            let n = t.getAttribute("position").array
                                              , r = t.index;
                                            if (r) {
                                                let e = r.array;
                                                for (let t = 0; t < e.length / 3; t += 3) {
                                                    let r = 3 * e[t]
                                                      , i = 3 * e[t + 1]
                                                      , a = 3 * e[t + 2];
                                                    p.set(n[r], n[r + 1], n[r + 2]),
                                                    f.set(n[i], n[i + 1], n[i + 2]),
                                                    m.set(n[a], n[a + 1], n[a + 2]),
                                                    f.sub(p),
                                                    m.sub(p),
                                                    m.cross(f),
                                                    m.normalize(),
                                                    g.add(m)
                                                }
                                            } else
                                                for (let e = 0; e < n.length / 3; e += 9)
                                                    p.set(n[e], n[e + 1], n[e + 2]),
                                                    f.set(n[e + 3], n[e + 4], n[e + 5]),
                                                    m.set(n[e + 6], n[e + 7], n[e + 8]),
                                                    f.sub(p),
                                                    m.sub(p),
                                                    m.cross(f),
                                                    m.normalize(),
                                                    g.add(m);
                                            g.normalize(),
                                            t.computeBoundingBox(),
                                            t.computeBoundingSphere();
                                            let i = new l.Matrix4;
                                            i.identity();
                                            let a = t.boundingSphere.center;
                                            i.makeTranslation(a.x, a.y, a.z),
                                            t.center();
                                            let o = !1
                                              , s = 0;
                                            for (; !o; ) {
                                                p.set(n[s], n[s + 1], n[s + 2]),
                                                p.normalize();
                                                let e = g.dot(p);
                                                Math.abs(e - 1) > .001 && (o = !0),
                                                s += 3
                                            }
                                            f.crossVectors(p, g),
                                            f.normalize();
                                            let c = g.dot(f);
                                            p.crossVectors(g, f),
                                            p.normalize(),
                                            c = g.dot(p),
                                            c = f.dot(p);
                                            let u = new l.Matrix4;
                                            u.elements[0] = p.x,
                                            u.elements[1] = p.y,
                                            u.elements[2] = p.z,
                                            u.elements[3] = 0,
                                            u.elements[4] = g.x,
                                            u.elements[5] = g.y,
                                            u.elements[6] = g.z,
                                            u.elements[7] = 0,
                                            u.elements[8] = f.x,
                                            u.elements[9] = f.y,
                                            u.elements[10] = f.z,
                                            u.elements[11] = 0,
                                            u.elements[12] = 0,
                                            u.elements[13] = 0,
                                            u.elements[14] = 0,
                                            u.elements[15] = 1;
                                            let h = new l.Matrix4;
                                            h.copy(u).invert(),
                                            t.applyMatrix4(h),
                                            t.computeBoundingSphere();
                                            let d = t.boundingSphere.radius
                                              , v = new l.Matrix4;
                                            v.identity(),
                                            v.makeScale(d, d, d);
                                            let y = new l.Matrix4;
                                            y.copy(v).invert(),
                                            t.applyMatrix4(y),
                                            u.multiply(v),
                                            i.multiply(u);
                                            let _ = new l.Vector3
                                              , x = new l.Quaternion
                                              , b = new l.Vector3;
                                            i.decompose(_, x, b);
                                            let w = new l.Object3D;
                                            w.position.copy(e.position),
                                            w.quaternion.copy(e.quaternion),
                                            w.scale.copy(e.scale);
                                            let M = e.parent;
                                            w.add(e),
                                            M.add(w),
                                            e.position.copy(_),
                                            e.quaternion.copy(x),
                                            e.scale.copy(b),
                                            t.parentMesh = e,
                                            t.xForm = i,
                                            t.transformed = !0
                                        }(e),
                                        t.DiamondUtils.prototypeMaterials[a] || (t.DiamondUtils.prototypeMaterials[a] = e))
                                    }
                                }
                                ))
                            }(n, r),
                            function(e, n, r) {
                                let i = []
                                  , a = r && r.envCubeMap;
                                for (var l in t.DiamondUtils.prototypeMaterials) {
                                    const n = t.DiamondUtils.prototypeMaterials[l];
                                    let i;
                                    i = r && r.quality ? "low" === r.quality ? 64 : "medium" === r.quality ? 256 : "high" === r.quality ? 1024 : 256 : 256;
                                    const o = new s.DiamondMaterial(n,a,e,i);
                                    t.DiamondUtils.prototypeMaterials[l] = o
                                }
                                return n.updateMatrixWorld(),
                                n.traverse((e=>{
                                    if (e.isMesh) {
                                        e.material && (e.material.envMap = a);
                                        const n = u(e, r)
                                          , s = h(e, r)
                                          , l = c(e.material, r);
                                        let p = l && l.name;
                                        if ((p = (p = p || s && s.name) || n && n.name) || (p = e.name.toLowerCase().includes("diamond") ? "diamond" : void 0),
                                        p && t.DiamondUtils.prototypeMaterials[p]) {
                                            let r = t.DiamondUtils.prototypeMaterials[p];
                                            r.name = p;
                                            const a = new o.Diamond(e,r);
                                            d(e, l || s || n || {
                                                name: p
                                            }),
                                            i.push(a)
                                        }
                                    }
                                }
                                )),
                                i
                            }(e, n, r)
                        }
                        ,
                        t.DiamondUtils.setGemstoneConfig = function(e, t) {
                            let n = t && t.envCubeMap;
                            e.forEach((e=>{
                                const r = e.getMesh();
                                if (r.isMesh) {
                                    r.material && n && (r.material.uniforms.envMap.value = n,
                                    r.material.envMap = n);
                                    const e = u(r, t)
                                      , i = h(r, t)
                                      , a = c(r.material, t);
                                    let o = e && e.name;
                                    (o = (o = o || i && i.name) || a && a.name || "diamond") && d(r, a || i || e || {
                                        name: o
                                    })
                                }
                            }
                            ))
                        }
                    },
                    "./src/Sparkle.ts": function(e, t, n) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.Sparkle = void 0;
                        const r = n("three")
                          , i = n("./src/SparkleShader.ts");
                        class a {
                            constructor(e, t) {
                                this.F = e,
                                this.R = t,
                                this.O = new r.PlaneGeometry(1,1,1),
                                this.N = new r.ShaderMaterial,
                                this.N.depthTest = !1,
                                this.N.depthWrite = !1,
                                this.N.transparent = !0,
                                this.N.side = r.DoubleSide,
                                this.N.blending = r.AdditiveBlending,
                                this.N.vertexShader = i.SparkleShader.vertexShader,
                                this.N.fragmentShader = i.SparkleShader.fragmentShader,
                                this.N.uniforms = r.UniformsUtils.clone(i.SparkleShader.uniforms),
                                void 0 !== this.F && (this.N.uniforms.sparkleTexture.value = e),
                                void 0 !== this.R && (this.N.uniforms.noiseTexture.value = t),
                                this.v = new r.Mesh(this.O,this.N),
                                this.v.positionOffset = new r.Vector3,
                                this.j = 5
                            }
                            get mesh() {
                                return this.v
                            }
                            get material() {
                                return this.N
                            }
                            shallowCopy() {
                                let e = new a(this.F,this.R);
                                return e.mesh.positionOffset = new r.Vector3,
                                e.mesh.positionOffset.copy(this.v.positionOffset),
                                e.material.uniforms.scale.value = this.N.uniforms.scale.value,
                                e.material.uniforms.rotation.value = this.N.uniforms.rotation.value,
                                e.material.uniforms.intensity.value = this.N.uniforms.intensity.value,
                                e.material.uniforms.screenTexture.value = this.N.uniforms.screenTexture.value,
                                e.material.uniforms.noiseTexture.value = this.N.uniforms.noiseTexture.value,
                                e.material.uniforms.ModelViewMatrix.value.copy(this.N.uniforms.ModelViewMatrix.value),
                                e.rotationSpeedFactor = this.j,
                                e
                            }
                            setScale(e) {
                                this.N.uniforms.scale.value = e
                            }
                            setIntensity(e) {
                                this.N.uniforms.intensity.value = e
                            }
                            setRotation(e) {
                                this.N.uniforms.rotation.value = e
                            }
                            setRotationSpeedFactor(e) {
                                this.j = e
                            }
                            setPositionOffset(e, t, n) {
                                this.v.positionOffset.x = e,
                                this.v.positionOffset.y = t,
                                this.v.positionOffset.z = n,
                                this.v.position.copy(this.v.positionOffset),
                                this.v.updateMatrix()
                            }
                            alignWithCamera(e) {
                                this.v.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, this.v.matrix),
                                this.N.uniforms.ModelViewMatrix.value.copy(this.v.modelViewMatrix)
                            }
                            syncWithTransform(e, t) {
                                this.v.position.copy(this.v.positionOffset),
                                t && this.v.position.add(t),
                                this.v.position.applyMatrix4(e),
                                this.v.updateMatrix()
                            }
                        }
                        t.Sparkle = a
                    },
                    "./src/SparkleShader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                            void 0 === r && (r = n),
                            Object.defineProperty(e, r, {
                                enumerable: !0,
                                get: function() {
                                    return t[n]
                                }
                            })
                        }
                        : function(e, t, n, r) {
                            void 0 === r && (r = n),
                            e[r] = t[n]
                        }
                        )
                          , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                            Object.defineProperty(e, "default", {
                                enumerable: !0,
                                value: t
                            })
                        }
                        : function(e, t) {
                            e.default = t
                        }
                        )
                          , a = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                            return i(t, e),
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.SparkleShader = void 0;
                        const o = a(n("three"));
                        t.SparkleShader = {
                            vertexShader: ["varying vec2 vUv;", "varying vec4 sparkleProjectedCentre;", "uniform mat4 ModelViewMatrix;", "uniform float scale;", "uniform float rotation;", "void main() { ", "vUv = uv; ", "vec4 finalPosition;", "vec2 alignedPosition = position.xy * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "finalPosition = ModelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "sparkleProjectedCentre = projectionMatrix * ModelViewMatrix * vec4(0.0,0.0,0.0,1.0 );", "gl_Position = finalPosition;", "}"].join("\n"),
                            fragmentShader: ["varying vec2 vUv;", "varying vec4 sparkleProjectedCentre;", "uniform sampler2D sparkleTexture;", "uniform sampler2D screenTexture;", "uniform sampler2D noiseTexture;", "uniform float intensity;", "vec3 ClosestPrimaryColor(vec3 color) {", "vec3 diffColor1 = vec3(1.0,0.0,0.0) - color;", "vec3 diffColor2 = vec3(0.0,1.0,0.0) - color;", "vec3 diffColor3 = vec3(0.0,0.0,1.0) - color;", "const float margin = 0.5; ", "if(dot(diffColor1, diffColor1) < margin)", "return vec3(1.0, margin, margin); ", "if(dot(diffColor2, diffColor2) < margin)", "return vec3(margin, 1.0, margin);", "if(dot(diffColor3, diffColor3) < margin)", "return vec3(margin, margin, 1.0);", "return color;", "}", "void main() {", "vec2 uv = (sparkleProjectedCentre.xy/sparkleProjectedCentre.w + 1.0)*0.5;", "vec4 screenColor = texture2D( screenTexture, uv );", "//screenColor.rgb = ClosestPrimaryColor(screenColor.rgb);", "float noise = texture2D( noiseTexture, uv ).r;", "screenColor.xyz *= screenColor.xyz;", "screenColor.xyz *= screenColor.xyz;", "screenColor.xyz *= screenColor.xyz;", "//float luminance = dot(vec3(0.3, 0.59, 0.11), screenColor.xyz);", "//luminance = luminance > 0.0 ? luminance : 0.0;", "vec4 spriteColor = vec4(1.) * texture2D( sparkleTexture, vUv ).a * screenColor * noise * intensity;", "gl_FragColor = spriteColor;", "}"].join("\n"),
                            uniforms: {
                                ModelViewMatrix: {
                                    type: "m4",
                                    value: (new o.Matrix4).identity()
                                },
                                sparkleTexture: {
                                    type: "t",
                                    value: null
                                },
                                screenTexture: {
                                    type: "t",
                                    value: null
                                },
                                noiseTexture: {
                                    type: "t",
                                    value: null
                                },
                                scale: {
                                    type: "f",
                                    value: 1
                                },
                                rotation: {
                                    type: "f",
                                    value: 0
                                },
                                intensity: {
                                    type: "f",
                                    value: 1
                                }
                            },
                            side: o.DoubleSide
                        }
                    },
                    "./src/index.ts": function(e, t, n) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.Sparkle = t.DiamondUtils = t.DiamondMaterial = t.Diamond = void 0;
                        const r = n("./src/Diamond.ts");
                        Object.defineProperty(t, "Diamond", {
                            enumerable: !0,
                            get: function() {
                                return r.Diamond
                            }
                        });
                        const i = n("./src/DiamondUtils.ts");
                        Object.defineProperty(t, "DiamondUtils", {
                            enumerable: !0,
                            get: function() {
                                return i.DiamondUtils
                            }
                        });
                        const a = n("./src/Sparkle.ts");
                        Object.defineProperty(t, "Sparkle", {
                            enumerable: !0,
                            get: function() {
                                return a.Sparkle
                            }
                        });
                        const o = n("./src/DiamondMaterial.ts");
                        Object.defineProperty(t, "DiamondMaterial", {
                            enumerable: !0,
                            get: function() {
                                return o.DiamondMaterial
                            }
                        })
                    },
                    "./src/shaders/diamond.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec2 vUv;\n    varying vec3 Normal;\n    varying vec3 worldNormal;\n    varying vec3 vecPos;\n    varying vec3 viewPos;\n    uniform samplerCube tCubeMapNormals;\n\n    #if ENV_MAP_TYPE == 0\n      uniform samplerCube envMap;\n    #elif ENV_MAP_TYPE == 1\n      uniform sampler2D envMap;\n    #endif\n    uniform samplerCube envRefractionMap;\n    uniform sampler2D sphereMap;\n    uniform float envMapIntensity;\n    uniform float tanAngleSqCone;\n    uniform float coneHeight;\n    uniform int maxBounces;\n    uniform mat4 modelMatrix;\n    uniform mat4 InverseModelMatrix;\n    uniform float refractiveIndex;\n    uniform float radius;\n    uniform bool bDebugBounces;\n    uniform float rIndexDelta;\n    uniform float normalOffset;\n    uniform float squashFactor;\n    uniform float distanceOffset;\n    uniform float geometryFactor;\n    uniform vec3 Absorbption;\n    uniform vec3 colorCorrection;\n    uniform vec3 boostFactors;\n    uniform vec3 centreOffset;\n    uniform float gammaFactor;\n    uniform float absorbptionFactor;\n\n    uniform float envMapRotation;\n    uniform float opacity;\n\n    #if USE_3DTEXTURE\n    precision highp sampler3D;\n\t\tuniform sampler3D lut3d;\n\t\t#else\n\t\tuniform sampler2D lut;\n\t\tuniform float lutSize;\n\n\t\tvec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {\n\n\t\t\tfloat halfPixelWidth = 0.5 / size;\n\t\t\trgb.rg = clamp( rgb.rg, halfPixelWidth, 1.0 - halfPixelWidth );\n\n\t\t\tfloat gOffset = rgb.g / size;\n\t\t\tvec2 uv1 = vec2( rgb.r, gOffset );\n\t\t\tvec2 uv2 = vec2( rgb.r, gOffset );\n\n\t\t\tfloat bNormalized = size * rgb.b;\n\t\t\tfloat bSlice = min( floor( size * rgb.b ), size - 1.0 );\n\t\t\tfloat bMix = ( bNormalized - bSlice ) / size;\n\t\t\tfloat b1 = bSlice / size;\n\t\t\tfloat b2 = ( bSlice + 1.0 ) / size;\n\n\t\t\tuv1.y += b1;\n\t\t\tuv2.y += b2;\n\n\t\t\tvec3 sample1 = texture2D( tex, uv1 ).rgb;\n\t\t\tvec3 sample2 = texture2D( tex, uv2 ).rgb;\n\n\t\t\treturn mix( sample1, sample2, bMix );\n\t\t}\n\n\t\t#endif\n\n    vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n      float dotNV = abs( dot( normal, viewDir ) );\n      const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n      const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n      vec4 r = roughness * c0 + c1;\n      float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n      vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n      return specularColor * AB.x + AB.y;\n    }\n\n    vec4 sampleEnvMap(vec3 direction) {\n        float cs = cos(envMapRotation);\n        float sn = sin(envMapRotation);\n\n        float temp = cs * direction.x + sn * direction.z;\n        direction.z = -sn * direction.x + cs * direction.z;\n        direction.x = temp;\n\n        #if ENV_MAP_TYPE == 0\n          return textureCube( envMap, direction );\n        #elif ENV_MAP_TYPE == 1\n          float theta = acos(direction.y);\n          float phi = atan(direction.x, direction.z);\n          return texture2D( envMap, vec2(phi/(2. * PI), theta/PI) );\n        #endif\n    }\n\n    vec4 SampleSpecularReflection(vec4 specularColor, vec3 direction ) {\n        // direction = normalize(direction);\n        direction.x *= -1.0;\n        direction.z *= -1.0;\n        vec3 tempDir = normalize(vec3(0., 0., 1.) + direction);\n        vec4 sampleColorRGB = envMapIntensity * envMapTexelToLinear( sampleEnvMap( direction ) );\n        //vec4 sampleColorRefraction = envMapIntensity * ( texture2D( sphereMap, tempDir.xy * 0.5 + 0.5 ) );\n        #if defined(TONE_MAPPING)\n          vec3 toneMappedColor = toneMapping(sampleColorRGB.rgb);\n        #else\n          vec3 toneMappedColor = sampleColorRGB.rgb;\n        #endif\n        return vec4(toneMappedColor, 1.0);\n     }\n\n    vec4 SampleSpecularContribution(vec4 specularColor, vec3 direction ) {\n        direction = normalize(direction);\n        direction.x *= -1.0;\n        direction.z *= -1.0;\n        vec4 sampleColorRGB = envMapIntensity * envMapTexelToLinear( sampleEnvMap( direction ) );\n        vec3 tempDir = normalize(vec3(0., 0., 1.) + direction);\n        float m = 2.8284271247461903 * sqrt( direction.z+1.0 );\n        //vec4 sampleColorRefraction = envMapIntensity * texture2D( sphereMap, clamp(direction.xy / m + 0.45, vec2(0.), vec2(1.)) );\n        #if defined(TONE_MAPPING)\n          vec3 toneMappedColor = toneMapping( sampleColorRGB.rgb );\n        #else\n          vec3 toneMappedColor = sampleColorRGB.rgb;\n        #endif\n        return vec4(toneMappedColor, 1.0);\n     }\n\n     vec3 intersectSphere(vec3 origin, vec3 direction) {\n         origin -= centreOffset;\n         direction.y /= squashFactor;\n         float A = dot(direction, direction);\n         float B = 2.0*dot(origin, direction);\n         float C = dot(origin, origin) - radius * radius;\n         float disc = B*B - 4.0 * A * C;\n         if(disc > 0.0)\n         {\n             disc = sqrt(disc);\n             float t1 = (-B + disc)*geometryFactor/A;\n             float t2 = (-B - disc)*geometryFactor/A;\n             float t = (t1 > t2) ? t1 : t2;\n             direction.y *= squashFactor;\n             return vec3(origin + centreOffset + direction * t);\n         }\n         return vec3(0.0);\n     }\n\n     vec3 debugBounces(int count) {\n         vec3 color = vec3(1.,1.,1.);\n         if(count == 1)\n             color = vec3(0.0,1.0,0.0);\n         else if(count == 2)\n             color = vec3(0.0,0.0,1.0);\n         else if(count == 3)\n             color = vec3(1.0,1.0,0.0);\n         else if(count == 4)\n             color = vec3(0.0,1.0,1.0);\n         else\n             color = vec3(0.0,1.0,0.0);\n         if(count ==0)\n             color = vec3(1.0,0.0,0.0);\n         return color;\n     }\n\n     vec3 traceRay(vec3 origin, vec3 direction, vec3 normal) {\n       vec3 outColor = vec3(0.0);\n\n       // Reflect/Refract ray entering the diamond\n\n       const float n1 = 1.0;\n       const float epsilon = 1e-4;\n       float f0 = (2.4- n1)/(2.4 + n1);\n       f0 *= f0;\n       vec3 attenuationFactor = vec3(1.0);\n       vec3 newDirection = refract(direction, normal, n1/refractiveIndex);\n       vec3 reflectedDirection = reflect(direction, normal);\n       vec3 brdfReflected = BRDF_Specular_GGX_Environment(reflectedDirection, normal, vec3(f0), 0.0);\n       vec3 brdfRefracted = BRDF_Specular_GGX_Environment(newDirection, -normal, vec3(f0), 0.0);\n       attenuationFactor *= ( vec3(1.0) - brdfRefracted);\n       outColor += SampleSpecularReflection(vec4(1.0), reflectedDirection ).rgb * brdfReflected;\n       int count = 0;\n       newDirection = (InverseModelMatrix * vec4(newDirection, 0.0)).xyz;\n       newDirection = normalize(newDirection);\n       origin = (InverseModelMatrix * vec4(origin, 1.0)).xyz;\n\n       // ray bounces \n\n       for( int i=0; i<RAY_BOUNCES; i++) { \n          vec3 intersectedPos;\n          intersectedPos = intersectSphere(origin + vec3(epsilon), newDirection);\n          vec3 dist = intersectedPos - origin;\n          vec3 d = normalize(intersectedPos - centreOffset);\n\n          vec3 mappedNormal = textureCube( tCubeMapNormals, d ).xyz;\n          mappedNormal = 2. * mappedNormal - 1.;\n          mappedNormal.y += normalOffset;\n          mappedNormal = normalize(mappedNormal);\n          //dist = (modelMatrix * vec4(dist, 1.)).xyz;\n          float r = length(dist)/radius * absorbptionFactor;\n          attenuationFactor *= exp(-r*Absorbption);\n\n           // refract the ray at first intersection \n\n           vec3 oldOrigin = origin;\n           origin = intersectedPos - normalize(intersectedPos - centreOffset) * distanceOffset;\n\n          vec3 oldDir = newDirection;\n          newDirection = refract(newDirection, mappedNormal, refractiveIndex/n1);\n          if( dot(newDirection, newDirection) == 0.0) { // Total Internal Reflection. Continue inside the diamond \n               newDirection = reflect(oldDir, mappedNormal);\n               if(i == RAY_BOUNCES-1 ) //If the ray got trapped even after max iterations, simply sample along the outgoing refraction! \n               {\n                  vec3 brdfReflected = BRDF_Specular_GGX_Environment(-oldDir, mappedNormal, vec3(f0), 0.0);\n                  vec3 d1 = (modelMatrix * vec4(oldDir, 0.0)).xyz;\n                  outColor += SampleSpecularContribution(vec4(1.0), d1 ).rgb * colorCorrection * attenuationFactor  * boostFactors * (vec3(1.0) - brdfReflected);\n                  //outColor = vec3(1.,0.,0.);\n                  //if(d1.y > 0.95) {\n                    //outColor += d1.y * vec3(1.,0.,0) * attenuationFactor * (vec3(1.0) - brdfReflected) * boostFactors;\n                  //}\n               }\n          } else { // Add the contribution from outgoing ray, and continue the reflected ray inside the diamond \n              vec3 brdfRefracted = BRDF_Specular_GGX_Environment(newDirection, -mappedNormal, vec3(f0), 0.0);\n              // outgoing(refracted) ray's contribution \n              vec3 d1 = (modelMatrix * vec4(newDirection, 0.0)).xyz;\n              vec3 colorG = SampleSpecularContribution(vec4(1.0), d1 ).rgb * ( vec3(1.0) - brdfRefracted);\n              vec3 dir1 = refract(oldDir, mappedNormal, (refractiveIndex+rIndexDelta)/n1);\n              vec3 dir2 = refract(oldDir, mappedNormal, (refractiveIndex-rIndexDelta)/n1);\n              vec3 d2 = (modelMatrix * vec4(dir1, 0.0)).xyz;\n              vec3 d3 = (modelMatrix * vec4(dir2, 0.0)).xyz;\n              vec3 colorR = SampleSpecularContribution(vec4(1.0), d2 ).rgb * ( vec3(1.0) - brdfRefracted);\n              vec3 colorB = SampleSpecularContribution(vec4(1.0), d3 ).rgb * ( vec3(1.0) - brdfRefracted);\n              outColor += vec3(colorR.r, colorG.g, colorB.b) * colorCorrection * attenuationFactor * boostFactors;\n              //outColor = oldDir;\n              //new reflected ray inside the diamond \n\n              newDirection = reflect(oldDir, mappedNormal);\n              vec3 brdfReflected = BRDF_Specular_GGX_Environment(newDirection, mappedNormal, vec3(f0), 0.0);\n              attenuationFactor *= brdfReflected * boostFactors;\n              count++;\n          }\n       }\n         if(false)\n            outColor = debugBounces(count);\n         return outColor;\n     }\n\n      void main() {\n          vec3 normalizedNormal = normalize(worldNormal);\n          vec3 viewVector = normalize(vecPos - cameraPosition);\n          vec3 color = traceRay(vecPos, viewVector, normalizedNormal);\n          gl_FragColor = vec4(color.rgb,1.);\n          #include <tonemapping_fragment>\n          gl_FragColor = GammaToLinear(gl_FragColor, gammaFactor);\n\n          #if USE_LUT\n            vec4 lutVal;\n      \t\t\t#if USE_3DTEXTURE\n      \t\t\t   lutVal = vec4( texture( lut3d, gl_FragColor.rgb ).rgb, gl_FragColor.a );\n      \t\t\t#else\n      \t\t\t   lutVal = vec4( lutLookup( lut, lutSize, gl_FragColor.rgb ), gl_FragColor.a );\n      \t\t\t#endif\n            gl_FragColor = lutVal;\n          #endif\n\n          #include <encodings_fragment>\n          gl_FragColor.a = opacity;\n          //gl_FragColor = textureCube(tCubeMapNormals, normalize(Normal));\n      }"
                    },
                    "./src/shaders/diamond.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec2 vUv;\nvarying vec3 Normal;\nvarying vec3 worldNormal;\nvarying vec3 vecPos;\nvarying vec3 viewPos;\n\nvoid main() {\n    vUv = uv;\n    Normal =  normal;\n    worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;\n    vecPos = (modelMatrix * vec4(position, 1.0 )).xyz;\n    viewPos = (modelViewMatrix * vec4(position, 1.0 )).xyz;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
                    },
                    "./src/shaders/normalcapture.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 vNormal;\n\nvoid main() {\n    vec3 color = normalize(vNormal);\n    color = color * 0.5 + 0.5;\n    gl_FragColor = vec4( color.x, color.y, color.z, 1.0 );\n}\n"
                    },
                    "./src/shaders/normalcapture.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 vNormal;\n\nvoid main() {\n    vNormal = normal;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
                    },
                    0: function(e, t, n) {
                        e.exports = n("./src/index.ts")
                    },
                    three: function(e, t) {
                        e.exports = r
                    }
                }))
            }
            ,
            9474: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    default: ()=>r
                });
                const r = "varying vec2 vUv;\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tOcclusion;\r\nuniform bool useSao;\r\n\r\nvoid main()\t{\r\n    float occlusion = 1. - texture2D(tOcclusion, vUv).r;\r\n    gl_FragColor = texture2D(tDiffuse, vUv);\r\n    gl_FragColor.rgb *= occlusion;\r\n    if(useSao) {\r\n        gl_FragColor.rgb = vec3(occlusion);\r\n    }\r\n}"
            }
            ,
            5301: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    default: ()=>r
                });
                const r = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
            }
            ,
            2908: (e,t,n)=>{
                var r;
                window,
                e.exports = (r = n(2212),
                function(e) {
                    var t = {};
                    function n(r) {
                        if (t[r])
                            return t[r].exports;
                        var i = t[r] = {
                            i: r,
                            l: !1,
                            exports: {}
                        };
                        return e[r].call(i.exports, i, i.exports, n),
                        i.l = !0,
                        i.exports
                    }
                    return n.m = e,
                    n.c = t,
                    n.d = function(e, t, r) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: r
                        })
                    }
                    ,
                    n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    n.t = function(e, t) {
                        if (1 & t && (e = n(e)),
                        8 & t)
                            return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule)
                            return e;
                        var r = Object.create(null);
                        if (n.r(r),
                        Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }),
                        2 & t && "string" != typeof e)
                            for (var i in e)
                                n.d(r, i, function(t) {
                                    return e[t]
                                }
                                .bind(null, i));
                        return r
                    }
                    ,
                    n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return n.d(t, "a", t),
                        t
                    }
                    ,
                    n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    n.p = "",
                    n(n.s = "./src/ShadowBaker.ts")
                }({
                    "./node_modules/pixotronicsutils/dist/pixotronicsutils.js": function(e, t, n) {
                        var r;
                        window,
                        e.exports = (r = n("three"),
                        function(e) {
                            var t = {};
                            function n(r) {
                                if (t[r])
                                    return t[r].exports;
                                var i = t[r] = {
                                    i: r,
                                    l: !1,
                                    exports: {}
                                };
                                return e[r].call(i.exports, i, i.exports, n),
                                i.l = !0,
                                i.exports
                            }
                            return n.m = e,
                            n.c = t,
                            n.d = function(e, t, r) {
                                n.o(e, t) || Object.defineProperty(e, t, {
                                    enumerable: !0,
                                    get: r
                                })
                            }
                            ,
                            n.r = function(e) {
                                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                    value: "Module"
                                }),
                                Object.defineProperty(e, "__esModule", {
                                    value: !0
                                })
                            }
                            ,
                            n.t = function(e, t) {
                                if (1 & t && (e = n(e)),
                                8 & t)
                                    return e;
                                if (4 & t && "object" == typeof e && e && e.__esModule)
                                    return e;
                                var r = Object.create(null);
                                if (n.r(r),
                                Object.defineProperty(r, "default", {
                                    enumerable: !0,
                                    value: e
                                }),
                                2 & t && "string" != typeof e)
                                    for (var i in e)
                                        n.d(r, i, function(t) {
                                            return e[t]
                                        }
                                        .bind(null, i));
                                return r
                            }
                            ,
                            n.n = function(e) {
                                var t = e && e.__esModule ? function() {
                                    return e.default
                                }
                                : function() {
                                    return e
                                }
                                ;
                                return n.d(t, "a", t),
                                t
                            }
                            ,
                            n.o = function(e, t) {
                                return Object.prototype.hasOwnProperty.call(e, t)
                            }
                            ,
                            n.p = "",
                            n(n.s = 0)
                        }([function(e, t, n) {
                            "use strict";
                            var r = this && this.__importStar || function(e) {
                                if (e && e.__esModule)
                                    return e;
                                var t = {};
                                if (null != e)
                                    for (var n in e)
                                        Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                                return t.default = e,
                                t
                            }
                            ;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            });
                            var i = r(n(1))
                              , a = n(2)
                              , o = function() {
                                function e(e, t, n) {
                                    this.u = e,
                                    this.h = t,
                                    this.v = n,
                                    this.M = new Array(e);
                                    for (var r = 0; r < e; r++)
                                        this.M[r] = new Array(t)
                                }
                                return e.prototype.j = function(e) {
                                    var t = Math.floor(e.x / this.v)
                                      , n = Math.floor(e.y / this.v);
                                    this.M[t][n] = e
                                }
                                ,
                                e.prototype.g = function(e, t) {
                                    for (var n = Math.floor(e.x / this.v), r = Math.floor(e.y / this.v), i = n - 5; i < n + 5; i++)
                                        for (var a = r - 5; a < r + 5; a++)
                                            if (i >= 0 && i < this.u && a >= 0 && a < this.h) {
                                                var o = this.M[i][a]
                                                  , s = 1e10;
                                                if (void 0 !== o && (s = o.distanceTo(e)),
                                                s < t)
                                                    return !0
                                            }
                                    return !1
                                }
                                ,
                                e
                            }()
                              , s = function() {
                                function e() {
                                    var e = i.UniformsUtils.clone(a.copyShader.uniforms);
                                    this.O = new i.ShaderMaterial({
                                        uniforms: e,
                                        vertexShader: a.copyShader.vertexShader,
                                        fragmentShader: a.copyShader.fragmentShader,
                                        depthWrite: !1,
                                        depthTest: !1
                                    }),
                                    this.C = new i.Scene,
                                    this.S = new i.OrthographicCamera(-1,1,1,-1,0,1),
                                    this.D = new i.Mesh(new i.PlaneGeometry(2,2),this.O),
                                    this.D.frustumCulled = !1,
                                    this.C.add(this.D)
                                }
                                return e.getInstance = function() {
                                    return e.instance || (e.instance = new e),
                                    e.instance
                                }
                                ,
                                e.prototype.renderPass = function(e, t, n, r) {
                                    r = void 0 !== r && r,
                                    this.D.material = t,
                                    e.setRenderTarget(n),
                                    r && e.clear(!0, !0, !1),
                                    e.render(this.C, this.S),
                                    e.setRenderTarget(null)
                                }
                                ,
                                e.prototype.blit = function(e, t, n, r) {
                                    r = void 0 !== r && r,
                                    this.O.uniforms.tDiffuse.value = t,
                                    this.D.material = this.O,
                                    e.setRenderTarget(n),
                                    e.render(this.C, this.S),
                                    e.setRenderTarget(null)
                                }
                                ,
                                e.prototype.randomizeArray = function(e) {
                                    for (var t, n, r = e.length; 0 !== r; )
                                        n = Math.floor(Math.random() * r),
                                        t = e[r -= 1],
                                        e[r] = e[n],
                                        e[n] = t;
                                    return e
                                }
                                ,
                                e.prototype.T = function(e) {
                                    var t = Math.floor(Math.random() * e.length)
                                      , n = e[t];
                                    return e.splice(t, 1),
                                    n
                                }
                                ,
                                e.prototype.uniformDistribution = function() {
                                    return 1
                                }
                                ,
                                e.prototype.insideRectangle = function(e, t, n, r) {
                                    return n = void 0 !== n ? n : 1,
                                    r = void 0 !== r ? r : 1,
                                    e >= 0 && t >= 0 && e <= n && t <= r
                                }
                                ,
                                e.prototype.insideCircle = function(e, t, n) {
                                    var r = e - .5
                                      , i = t - .5;
                                    return r * r + i * i <= (n = void 0 !== n ? n : .5) * n
                                }
                                ,
                                e.prototype.U = function(e, t) {
                                    var n = t * (Math.random() + 1)
                                      , r = 6.283185307178 * Math.random()
                                      , a = e.x + n * Math.cos(r)
                                      , o = e.y + n * Math.sin(r);
                                    return new i.Vector2(a,o)
                                }
                                ,
                                e.prototype.generateQuasiRandomPoints = function(e, t, n, r) {
                                    e = void 0 === e ? 30 : e,
                                    t = void 0 === t ? -1 : t,
                                    n = n || this.uniformDistribution,
                                    r = r || this.insideCircle,
                                    t < 0 && (t = Math.sqrt(e) / e);
                                    var a = []
                                      , s = []
                                      , l = t / Math.sqrt(2)
                                      , c = Math.ceil(1 / l)
                                      , u = Math.ceil(1 / l)
                                      , h = new o(c,u,l)
                                      , d = new i.Vector2(.5,.5)
                                      , p = !1;
                                    do {
                                        d.x = Math.random(),
                                        d.y = Math.random(),
                                        p = r(d.x, d.y)
                                    } while (!p);
                                    for (s.push(d),
                                    a.push(d),
                                    h.j(d); 0 !== s.length && a.length < e; )
                                        for (var f = this.T(s), m = 0; m < 30; m++) {
                                            var g = f.x - .5
                                              , v = f.y - .5
                                              , y = n(Math.sqrt(g * g + v * v))
                                              , _ = this.U(f, y * t);
                                            !r(_.x, _.y) || h.g(_, y * t) || (s.push(_),
                                            a.push(_),
                                            h.j(_))
                                        }
                                    return a
                                }
                                ,
                                e
                            }();
                            t.Utils = s
                        }
                        , function(e, t) {
                            e.exports = r
                        }
                        , function(e, t, n) {
                            "use strict";
                            var r = this && this.__importDefault || function(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                }
                            }
                            ;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            });
                            var i = r(n(3))
                              , a = r(n(4));
                            t.copyShader = {
                                uniforms: {
                                    tDiffuse: {
                                        value: null
                                    }
                                },
                                vertexShader: i.default,
                                fragmentShader: a.default
                            }
                        }
                        , function(e, t, n) {
                            "use strict";
                            n.r(t),
                            t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                        }
                        , function(e, t, n) {
                            "use strict";
                            n.r(t),
                            t.default = "uniform sampler2D tDiffuse;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    vec4 texel = texture2D(tDiffuse, vUv);\r\n    gl_FragColor = texel;\r\n\r\n}"
                        }
                        ]))
                    },
                    "./src/ShadowBaker.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        const i = r(n("three"))
                          , a = n("./src/shaders/packDepthShader.ts")
                          , o = n("./src/shaders/softShadowBakeShader.ts")
                          , s = n("./src/shaders/blurShader.ts")
                          , l = n("./src/shaders/transitionShader.ts")
                          , c = n("./node_modules/pixotronicsutils/dist/pixotronicsutils.js");
                        var u;
                        !function(e) {
                            e[e.UP = 1] = "UP",
                            e[e.DOWN = 2] = "DOWN",
                            e[e.LEFT = 3] = "LEFT",
                            e[e.RIGHT = 4] = "RIGHT",
                            e[e.FRONT = 5] = "FRONT",
                            e[e.BACK = 6] = "BACK"
                        }(u || (u = {}));
                        class h extends i.Box3 {
                            constructor() {
                                super(),
                                this.N = new i.Vector3
                            }
                            expandByObject(e) {
                                let t, n;
                                if (e.castShadow) {
                                    e.updateWorldMatrix(!1, !1);
                                    let i = e.geometry;
                                    if (void 0 !== i)
                                        if (i.isGeometry) {
                                            let r = i.vertices;
                                            for (t = 0,
                                            n = r.length; t < n; t++)
                                                this.N.copy(r[t]),
                                                this.N.applyMatrix4(e.matrixWorld),
                                                this.expandByPoint(this.N)
                                        } else if (i.isBufferGeometry) {
                                            var r = i.attributes.position;
                                            if (void 0 !== r)
                                                for (t = 0,
                                                n = r.count; t < n; t++)
                                                    this.N.fromBufferAttribute(r, t).applyMatrix4(e.matrixWorld),
                                                    this.expandByPoint(this.N)
                                        }
                                }
                                let i = e.children;
                                for (t = 0,
                                n = i.length; t < n; t++)
                                    this.expandByObject(i[t]);
                                return this
                            }
                        }
                        class d {
                            constructor(e) {
                                this._ = 1,
                                this.R = 512,
                                this.A = new i.Scene,
                                this.B = c.Utils.getInstance(),
                                this.F = i.FrontSide,
                                this.k = new i.Color,
                                e = e || {},
                                this.L = 0,
                                this.V = 0,
                                this.P = new i.Color(0),
                                this.G = new h,
                                this.I = void 0 !== e.shadowMapResolution ? e.shadowMapResolution : 512,
                                this.W = void 0 !== e.shadowRadius ? e.shadowRadius : 1,
                                this.H = void 0 !== e.shadowQuality ? e.shadowQuality : 0,
                                this.q = void 0 === e.smoothTransition || e.smoothTransition,
                                this.Y = void 0 !== e.shadowBiasMultiplier ? e.shadowBiasMultiplier : 1,
                                this.Z = void 0 !== e.numSamples ? e.numSamples : 400,
                                this.K = void 0 !== e.numSamplesPerFrame ? e.numSamplesPerFrame : 2,
                                this.J = void 0 !== e.brightness ? e.brightness : .1,
                                this.X = void 0 !== e.falloff ? e.falloff : 1,
                                this.size = void 0 !== e.size ? e.size : 1,
                                this.$ = e.lightDirection ? e.lightDirection : new i.Vector3(0,1,0),
                                this.tt = e.lightSolidAngle ? e.lightSolidAngle : 45,
                                this.it = e.onCompleteCallback,
                                this.rt = e.onBeforeStartCallback,
                                this.et = e.onProgressCallback,
                                this.enable = void 0 === e.enable || e.enable,
                                this.st = void 0 === e.enableBlur || e.enableBlur,
                                this.ot = void 0 !== e.blurRadius ? e.blurRadius : .5,
                                this.at = void 0 !== e.side ? e.side : u.DOWN,
                                this.nt = void 0 !== e.useNormalWeights && e.useNormalWeights,
                                this.ht = void 0 !== e.distanceOffset ? e.distanceOffset : 0,
                                this.dt = void 0 !== e.useMovingAverage && e.useMovingAverage;
                                const t = void 0 === e.bShadowMaterial || e.bShadowMaterial
                                  , n = void 0 !== e.nearPlane ? e.nearPlane : .1
                                  , r = void 0 !== e.farPlane ? e.farPlane : 100;
                                this.ut = new i.OrthographicCamera(-3,3,3,-3,n,r),
                                this.boundingRadius = 10,
                                this.lt = 0,
                                this.ct(this.Z),
                                this.ft = 0,
                                this.vt = new i.Vector3,
                                this.wt = new i.Vector3(0,-1,0),
                                this.pt = new i.Vector3,
                                this.xt = new i.Matrix4,
                                this.Dt = !0,
                                this.Mt = new i.Mesh(new i.PlaneBufferGeometry(1,1),new i.MeshBasicMaterial({
                                    color: 16777215
                                })),
                                this.Mt.receiveShadow = !0,
                                this.Ct = new i.Scene,
                                this.Ct.add(this.Mt);
                                const a = t ? new i.MeshBasicMaterial({
                                    color: 16777215,
                                    transparent: !0
                                }) : new i.MeshStandardMaterial({
                                    roughness: 1,
                                    metalness: 0
                                });
                                this.St = new i.Mesh(new i.PlaneBufferGeometry(1,1),a);
                                const o = this.St.geometry
                                  , s = o.attributes.uv.array;
                                o.addAttribute("uv2", new i.BufferAttribute(s,2)),
                                this.gt = new i.Matrix4,
                                this.St.receiveShadow = !0,
                                this.yt = !1,
                                this.startBake = this.startBake.bind(this)
                            }
                            getNumSamples() {
                                return this.Z
                            }
                            setNumSamples(e) {
                                this.Z = e
                            }
                            getNumSamplesPerFrame() {
                                return this.K
                            }
                            setNumSamplesPerFrame(e) {
                                this.K = e
                            }
                            getBrightness() {
                                return this.J
                            }
                            setBrightness(e) {
                                this.J = e
                            }
                            getFalloff() {
                                return this.X
                            }
                            setFalloff(e) {
                                this.X = e
                            }
                            needsUpdate() {
                                this.Dt = !0
                            }
                            getSmoothTransition() {
                                return this.q
                            }
                            setSmoothTransition(e) {
                                this.q = e
                            }
                            getBlurRadius() {
                                return this.ot
                            }
                            setBlurRadius(e) {
                                this.ot = e
                            }
                            getLightDirection() {
                                return this.$
                            }
                            setLightDirection(e) {
                                this.$ = e
                            }
                            getLightSolidAngle() {
                                return this.tt
                            }
                            setLightSolidAngle(e) {
                                this.tt = e
                            }
                            getEnableSmooth() {
                                return this.st
                            }
                            setEnableSmooth(e) {
                                this.st = e
                            }
                            getDistanceOffset() {
                                return this.ht
                            }
                            setDistanceOffset(e) {
                                this.ht = e
                            }
                            getSide() {
                                return this.at
                            }
                            setSide(e) {
                                this.at = e
                            }
                            setShadowSide(e) {
                                this.F = e
                            }
                            setSize(e) {
                                this.Nt.setSize(e, e),
                                this._t.setSize(e, e),
                                this.Rt.uniforms.shadowBufferSize.value = new i.Vector2(e,e)
                            }
                            setShadowMapResolution(e) {
                                this.I = e,
                                this.zt && (this.zt.setSize(e, e),
                                this.Rt.uniforms.shadowMapResolution.value = new i.Vector2(this.I,this.I))
                            }
                            setShadowBufferResolution(e) {
                                this.R = e,
                                this._t && (this._t.setSize(e, e),
                                this.Nt.setSize(e, e),
                                this.Rt.uniforms.shadowBufferSize.value = new i.Vector2(this.R,this.R))
                            }
                            getShadowColor() {
                                return this.P
                            }
                            setShadowColor(e) {
                                this.P.copy(e)
                            }
                            dispose() {
                                this.zt && (this.zt.dispose(),
                                this.Nt.dispose(),
                                this._t.dispose()),
                                this.St.geometry && this.St.geometry.dispose()
                            }
                            getShadowPlaneTransform(e, t, n) {
                                e.copy(this.St.position),
                                t.copy(this.St.quaternion),
                                n.copy(this.St.scale)
                            }
                            getShadowPlaneMaterial() {
                                return this.St.material
                            }
                            startBake(e, t, n, r) {
                                if (!r)
                                    throw new Error("Must pass a target!");
                                this.bt = r,
                                this.needsUpdate();
                                const i = ()=>{
                                    this.At(e, t, n);
                                    const r = requestAnimationFrame(i);
                                    this.Tt() >= 1 && (this.it && !this.yt && (this.it(this.St),
                                    this.yt = !0),
                                    cancelAnimationFrame(r))
                                }
                                ;
                                requestAnimationFrame(i)
                            }
                            onComplete(e) {
                                this.it = e
                            }
                            onBeforeStart(e) {
                                this.rt = e
                            }
                            onProgress(e) {
                                this.et = e
                            }
                            Bt() {
                                this.Mt.rotation.set(0, 0, 0),
                                this.St.rotation.set(0, 0, 0),
                                this.gt.identity(),
                                this.at === u.DOWN ? (this.St.rotation.x = -Math.PI / 2,
                                this.Mt.rotation.x = -Math.PI / 2) : this.at === u.UP ? (this.St.rotation.x = Math.PI / 2,
                                this.Mt.rotation.x = Math.PI / 2,
                                this.gt.makeRotationZ(Math.PI)) : this.at === u.LEFT ? (this.St.rotation.y = Math.PI / 2,
                                this.Mt.rotation.y = Math.PI / 2,
                                this.gt.makeRotationY(-Math.PI / 2)) : this.at === u.RIGHT ? (this.St.rotation.y = -Math.PI / 2,
                                this.Mt.rotation.y = -Math.PI / 2,
                                this.gt.makeRotationY(Math.PI / 2)) : this.at === u.FRONT ? (this.St.rotation.y = Math.PI,
                                this.Mt.rotation.y = Math.PI,
                                this.gt.makeRotationX(Math.PI / 2)) : this.gt.makeRotationX(-Math.PI / 2)
                            }
                            Tt() {
                                return this.ft / this.Ot.length
                            }
                            Ft(e, t) {
                                const n = Math.abs(this.G.max.z - this.G.min.z)
                                  , r = Math.abs(this.G.max.y - this.G.min.y)
                                  , i = Math.abs(this.G.max.x - this.G.min.x);
                                this.at === u.DOWN ? e.set(t.x, t.y - r / 2 - this.ht, t.z) : this.at === u.UP ? e.set(t.x, t.y + r / 2 + this.ht, t.z) : this.at === u.LEFT ? e.set(t.x - i / 2 - this.ht, t.y, t.z) : this.at === u.RIGHT ? e.set(t.x + i / 2 + this.ht, t.y, t.z) : this.at === u.FRONT ? e.set(t.x, t.y, t.z + n / 2 + this.ht) : e.set(t.x, t.y, t.z - n / 2 - this.ht)
                            }
                            jt(e) {
                                this.Bt(),
                                e.updateMatrixWorld(),
                                this.G = new h,
                                e.traverse((e=>{
                                    e.isMesh && e.castShadow && this.G.expandByObject(e)
                                }
                                ));
                                const t = new i.Sphere;
                                this.G.getBoundingSphere(t);
                                const n = 2.5 * t.radius * this.size;
                                if (0 === n)
                                    return;
                                const r = new i.Vector3;
                                this.G.getCenter(r),
                                this.Ft(this.Mt.position, r),
                                this.Mt.scale.set(n, n, n),
                                this.Ft(this.St.position, r),
                                this.St.scale.copy(this.Mt.scale),
                                this.boundingRadius = 2 * t.radius,
                                this.ut.left = -t.radius,
                                this.ut.right = t.radius,
                                this.ut.bottom = -t.radius,
                                this.ut.top = t.radius,
                                this.ut.far = 2 * this.boundingRadius,
                                this.ut.near = this.boundingRadius / 100,
                                this.ut.updateProjectionMatrix(),
                                this.Dt = !0,
                                this.yt = !1
                            }
                            At(e, t, n) {
                                if (!this.enable)
                                    return;
                                if (this.Dt) {
                                    const e = t.parent;
                                    this.A.add(t),
                                    this.jt(t),
                                    e && e.add(t),
                                    this.ft = 0,
                                    this.V = 0,
                                    this.Dt = !1,
                                    this.rt && this.rt()
                                }
                                const r = this.Tt();
                                if (r >= 1)
                                    return void (this.it && !this.yt && (this.it(this.St),
                                    this.yt = !0));
                                this.et && this.et(r),
                                this.zt || (this.ut.layers.mask = n.layers.mask,
                                this.kt()),
                                this.ct(this.Z),
                                e.getClearColor(this.k);
                                let i, a, o = e.getClearAlpha(), s = e.autoClear;
                                e.autoClear = !0;
                                for (let r = 0; r < this.K; r++) {
                                    this.ft = Math.min(this.ft, this.Ot.length - 1),
                                    this.ft++,
                                    this.Lt();
                                    const r = t.parent;
                                    this.A.add(t),
                                    this.Vt(e, this.A, this.vt, this.zt),
                                    this.A.remove(t),
                                    r && r.add(t),
                                    i = this.ft % 2 == 0 ? this._t : this.Nt,
                                    a = this.ft % 2 == 0 ? this.Nt : this._t,
                                    this.Pt(e, n, i, a)
                                }
                                this.st && this.Ut(e, a, i),
                                this.Et(e, a, i),
                                this.B.blit(e, i, this.bt),
                                e.autoClear = s,
                                e.setClearColor(this.k),
                                e.setClearAlpha(o)
                            }
                            Et(e, t, n) {
                                this.Gt.uniforms.shadowAccumulationBuffer.value = t.texture,
                                this.Gt.uniforms.transition.value = this.q ? this.Tt() : 1,
                                this.Gt.uniforms.shadowColor.value.copy(this.P);
                                const r = this.Gt.uniforms.shadowData.value
                                  , i = this.St.material;
                                r.x = i.isMeshBasicMaterial ? 1 - this.J : this.J,
                                r.y = this.X,
                                this.B.renderPass(e, this.Gt, n)
                            }
                            Ut(e, t, n) {
                                this.It || (this.It = new i.ShaderMaterial(s.blurShader)),
                                this.It.uniforms.tDiffuse.value = t.texture,
                                this.It.uniforms.direction.value = new i.Vector3(1,0),
                                this.It.uniforms.step.value = this.ot,
                                this.It.uniforms.size.value.x = n.width,
                                this.It.uniforms.size.value.y = n.height,
                                this.B.renderPass(e, this.It, n),
                                this.It.uniforms.tDiffuse.value = n.texture,
                                this.It.uniforms.direction.value = new i.Vector3(0,1),
                                this.It.uniforms.size.value.x = n.width,
                                this.It.uniforms.size.value.y = n.height,
                                this.B.renderPass(e, this.It, t)
                            }
                            kt() {
                                const e = {
                                    format: i.RGBAFormat,
                                    minFilter: i.LinearFilter,
                                    magFilter: i.LinearFilter
                                };
                                this.zt = new i.WebGLRenderTarget(this.I,this.I,e),
                                this.Nt = new i.WebGLRenderTarget(this.R,this.R,e),
                                this._t = new i.WebGLRenderTarget(this.R,this.R,e),
                                this.zt.texture.generateMipmaps = !1,
                                this._t.texture.generateMipmaps = !1,
                                this.Nt.texture.generateMipmaps = !1,
                                1 === this._ ? (this.Wt = new i.ShaderMaterial(a.packDepthShader),
                                this.Wt.uniforms = i.UniformsUtils.clone(this.Wt.uniforms)) : this.Wt = new i.MeshDepthMaterial({
                                    depthPacking: i.RGBADepthPacking
                                }),
                                this.Rt = new i.ShaderMaterial(o.softShadowShader),
                                this.Rt.uniforms = i.UniformsUtils.clone(this.Rt.uniforms),
                                this.Rt.uniforms.shadowBufferSize.value = new i.Vector2(this.R,this.R),
                                this.Rt.uniforms.shadowMap.value = this.zt.texture,
                                this.Rt.uniforms.shadowData.value = new i.Vector4(0,1,1,1),
                                this.Rt.uniforms.shadowMapResolution.value = new i.Vector2(this.I,this.I),
                                this.Rt.defines.SHADOW_QUALITY = this.H,
                                this.Rt.defines.LINEAR_DEPTH = this._,
                                this.Rt.defines.NORMAL_WEIGHTS = this.nt ? 1 : 0,
                                this.Rt.defines.USE_MOVING_AVERAGE = this.dt ? 1 : 0,
                                this.Gt = new i.ShaderMaterial(l.transitionShader);
                                const t = this.St.material;
                                this.Gt.defines.SHADOW_MATERIAL = t.isMeshBasicMaterial ? 1 : 0,
                                this.Gt.uniforms = i.UniformsUtils.clone(this.Gt.uniforms)
                            }
                            Pt(e, t, n, r) {
                                this.ut.matrixWorldInverse.copy(this.ut.matrixWorld),
                                this.ut.matrixWorldInverse.invert(),
                                this.xt.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                                this.xt.multiply(this.ut.projectionMatrix),
                                this.xt.multiply(this.ut.matrixWorldInverse),
                                this.Rt.uniforms.shadowMatrix.value.copy(this.xt),
                                this.Rt.uniforms.shadowData.value.x = this.V,
                                this.Rt.uniforms.shadowData.value.y = this.W,
                                this.Rt.uniforms.shadowData.value.z = this.Y,
                                this.Rt.uniforms.shadowAccumulationBuffer.value = n.texture,
                                this.Rt.uniforms.vplPosition.value = this.ut.position,
                                this.Rt.uniforms.cameraNearFar.value.x = this.ut.near,
                                this.Rt.uniforms.cameraNearFar.value.y = this.ut.far,
                                this.Rt.uniforms.lightVector.value.x = -this.wt.x,
                                this.Rt.uniforms.lightVector.value.y = -this.wt.y,
                                this.Rt.uniforms.lightVector.value.z = -this.wt.z,
                                this.Rt.uniforms.totalWeightSum.value = 1 / this.L,
                                e.setClearColor(0);
                                const i = e.shadowMap.enabled;
                                e.shadowMap.enabled = !1,
                                this.Ct.overrideMaterial = this.Rt,
                                e.setRenderTarget(r),
                                e.render(this.Ct, t),
                                e.setRenderTarget(null),
                                this.Ct.overrideMaterial = null,
                                e.shadowMap.enabled = i
                            }
                            Vt(e, t, n, r) {
                                !function(e, t) {
                                    e.traverse((function(e) {
                                        (e.isMesh || e.isLineSegments || e.isLine || e.isLineLoop || e.isPoints) && (e.castShadow || (e.oldVisibility = e.visible,
                                        e.visible = !1))
                                    }
                                    ))
                                }(t),
                                this.ut.position.copy(n),
                                this.pt.copy(n),
                                this.pt.addScaledVector(this.wt, 10),
                                this.ut.lookAt(this.pt),
                                this.ut.updateMatrixWorld(),
                                t.overrideMaterial = this.Wt,
                                1 === this._ && (this.Wt.uniforms.cameraNearFar.value.x = this.ut.near,
                                this.Wt.uniforms.cameraNearFar.value.y = this.ut.far),
                                this.Wt.side = this.F,
                                e.setClearColor(0),
                                e.setRenderTarget(r),
                                e.render(t, this.ut),
                                e.setRenderTarget(null),
                                t.overrideMaterial = null,
                                function(e) {
                                    e.traverse((function(e) {
                                        e.oldVisibility && (e.visible = e.oldVisibility,
                                        e.oldVisibility = void 0)
                                    }
                                    ))
                                }(t)
                            }
                            Ht(e, t, n) {
                                const r = 1 - e.x + e.x * t
                                  , i = Math.sqrt(1 - r * r)
                                  , a = 2 * e.y * Math.PI;
                                n.x = Math.cos(a) * i,
                                n.y = Math.sin(a) * i,
                                n.z = r;
                                const o = this.nt ? Math.abs(r) : 1;
                                this.V += o
                            }
                            Lt() {
                                const e = this.boundingRadius
                                  , t = this.Ot[this.ft - 1]
                                  , n = this.qt();
                                this.Ht(t, n, this.wt),
                                this.wt.multiplyScalar(-1),
                                this.wt.normalize(),
                                this.wt.transformDirection(this.gt);
                                const r = new i.Matrix4;
                                this.$.normalize(),
                                r.lookAt(this.$, new i.Vector3(0,0,0), new i.Vector3(0,1,0)),
                                this.wt.transformDirection(r),
                                this.wt.normalize();
                                const a = new i.Vector3(-e * this.wt.x,-e * this.wt.y,-e * this.wt.z);
                                this.vt.copy(a),
                                this.vt.add(this.Mt.position)
                            }
                            calculateWeightSum() {
                                if (!this.nt)
                                    return this.Ot.length;
                                const e = new i.Vector3
                                  , t = this.qt();
                                let n = 0;
                                return this.Ot.forEach((r=>{
                                    this.Ht(r, t, e),
                                    n += Math.abs(e.z)
                                }
                                )),
                                n
                            }
                            qt() {
                                let e = this.tt > 90 ? 90 : this.tt;
                                return e = this.tt < 0 ? 0 : e,
                                Math.cos(e * Math.PI / 180)
                            }
                            Qt(e) {
                                const t = this.qt();
                                e.sort(((e,n)=>1 - e.x + e.x * t - (1 - n.x + n.x * t)))
                            }
                            ct(e) {
                                e !== this.lt && (this.lt = e,
                                this.Ot = this.B.generateQuasiRandomPoints(e, -1, this.B.uniformDistribution, this.B.insideRectangle),
                                this.Ot = this.B.randomizeArray(this.Ot),
                                this.Qt(this.Ot),
                                this.L = this.calculateWeightSum())
                            }
                        }
                        d.ShadowSide = u,
                        t.ShadowBaker = d
                    },
                    "./src/shaders/blur.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "#include <packing>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform vec2 size;\r\nuniform vec2 direction;\r\nuniform float step;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    float sum = 0.0;\r\n    vec2 uvDelta = step * direction / size;\r\n\r\n    sum += unpackRGBAToDepth(texture2D(tDiffuse, vUv - 1. * uvDelta)) * 0.3333;\r\n    sum += unpackRGBAToDepth(texture2D(tDiffuse, vec2(vUv.x, vUv.y))) * 0.3333;\r\n    sum += unpackRGBAToDepth(texture2D(tDiffuse, vUv + 1. * uvDelta)) * 0.3333;\r\n\r\n    gl_FragColor = packDepthToRGBA(sum);\r\n\r\n}"
                    },
                    "./src/shaders/blurShader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                          , i = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        const a = r(n("./src/shaders/simple_vert.vert"))
                          , o = r(n("./src/shaders/blur.frag"))
                          , s = i(n("three"));
                        t.blurShader = {
                            uniforms: {
                                tDiffuse: {
                                    value: null
                                },
                                size: {
                                    value: new s.Vector3
                                },
                                direction: {
                                    value: new s.Vector3(1,0)
                                },
                                step: {
                                    value: .25
                                }
                            },
                            vertexShader: a.default,
                            fragmentShader: o.default
                        }
                    },
                    "./src/shaders/packDepthShader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                          , i = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        const a = r(n("./src/shaders/pack_depth32.vert"))
                          , o = r(n("./src/shaders/pack_depth32.frag"))
                          , s = i(n("three"));
                        t.packDepthShader = {
                            uniforms: {
                                cameraNearFar: {
                                    type: "v2",
                                    value: new s.Vector2
                                }
                            },
                            vertexShader: a.default,
                            fragmentShader: o.default
                        }
                    },
                    "./src/shaders/pack_depth32.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "#include <packing>\r\n\r\nuniform vec2 cameraNearFar;\r\nvarying vec3 viewPosition;\r\nfloat linstep(float edge0, float edge1, float value) {\r\n    return clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);\r\n    vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));\r\n    gl_FragColor = packedZ;\r\n}"
                    },
                    "./src/shaders/pack_depth32.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 viewPosition;\r\nvoid main() {\r\n    viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}"
                    },
                    "./src/shaders/simple_vert.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                    },
                    "./src/shaders/softShadowBakeShader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                          , i = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        const a = r(n("./src/shaders/softshadow.vert"))
                          , o = r(n("./src/shaders/softshadow.frag"))
                          , s = i(n("three"));
                        t.softShadowShader = {
                            defines: {
                                SHADOW_QUALITY: 0,
                                LINEAR_DEPTH: 1,
                                NORMAL_WEIGHTS: 1,
                                USE_MOVING_AVERAGE: 0
                            },
                            uniforms: {
                                shadowMap: {
                                    value: null
                                },
                                shadowAccumulationBuffer: {
                                    value: null
                                },
                                shadowBufferSize: {
                                    value: null
                                },
                                shadowMatrix: {
                                    value: new s.Matrix4
                                },
                                vplPosition: {
                                    value: new s.Vector3
                                },
                                lightVector: {
                                    value: new s.Vector3
                                },
                                shadowData: {
                                    value: new s.Vector4
                                },
                                cameraNearFar: {
                                    value: new s.Vector2
                                },
                                shadowMapResolution: {
                                    value: null
                                },
                                normalBias: {
                                    value: 1
                                },
                                totalWeightSum: {
                                    value: 0
                                }
                            },
                            vertexShader: a.default,
                            fragmentShader: o.default
                        }
                    },
                    "./src/shaders/softshadow.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "    #include <common>\r\n\r\n    #include <packing>\r\n\r\n    varying vec3 viewNormal;\r\n    uniform vec3 lightVector;\r\n    varying vec4 shadowCoord;\r\n    uniform vec2 shadowBufferSize;\r\n    uniform vec2 shadowMapResolution;\r\n    uniform sampler2D shadowMap;\r\n    uniform sampler2D shadowAccumulationBuffer;\r\n    uniform vec4 shadowData;\r\n    uniform vec2 cameraNearFar;\r\n    uniform float totalWeightSum;\r\n    varying vec3 worldNormal;\r\n\r\n    float texture2DCompare(sampler2D depths, vec2 uv, float compare) {\r\n        #if LINEAR_DEPTH == 0\r\n            float shadowDepth = unpackRGBAToDepth(texture2D(depths, uv));\r\n        #else\r\n            float shadowDepth = pow2(unpackRGBAToDepth(texture2D(depths, uv))) + 0.01 * shadowData.z;\r\n            shadowDepth = shadowDepth * (cameraNearFar.y - cameraNearFar.x) + cameraNearFar.x;\r\n        #endif\r\n        return step(compare, shadowDepth);\r\n    }\r\n\r\n    float texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare) {\r\n        const vec2 offset = vec2(0.0, 1.0);\r\n        vec2 texelSize = vec2(1.0) / size;\r\n        vec2 centroidUV = floor(uv * size + 0.5) / size;\r\n        float lb = texture2DCompare(depths, centroidUV + texelSize * offset.xx, compare);\r\n        float lt = texture2DCompare(depths, centroidUV + texelSize * offset.xy, compare);\r\n        float rb = texture2DCompare(depths, centroidUV + texelSize * offset.yx, compare);\r\n        float rt = texture2DCompare(depths, centroidUV + texelSize * offset.yy, compare);\r\n        vec2 f = fract(uv * size + 0.5);\r\n        float a = mix(lb, lt, f.y);\r\n        float b = mix(rb, rt, f.y);\r\n        float c = mix(a, b, f.x);\r\n        return c;\r\n    }\r\n\r\n        void main() {\r\n\r\n            float shadowValue = 1.0;\r\n            float shadowRadius = shadowData.y;\r\n            float shadowBiasMultiplier = shadowData.z;\r\n\r\n            float nDotL = clamp(dot(lightVector, normalize(viewNormal)), 0.0, 1.0);\r\n            float shadowBias = 0.02 * sqrt(1.0 - nDotL * nDotL) / clamp(nDotL, 0.0006, 1.0);\r\n            shadowBias = clamp(shadowBias, 0.0001, 0.0003) * shadowBiasMultiplier;\r\n\r\n            vec3 shadowCoordNDC = shadowCoord.xyz; ///shadowCoord.w;\r\n            shadowCoordNDC.z -= shadowBias;\r\n\r\n            #if LINEAR_DEPTH == 1\r\n                float linearDepth = shadowCoord.z + (cameraNearFar.y + cameraNearFar.x) / (cameraNearFar.y - cameraNearFar.x);\r\n                linearDepth *= -(cameraNearFar.y - cameraNearFar.x) * 0.5;\r\n                linearDepth = -linearDepth;\r\n            #endif\r\n\r\n            bvec4 inFrustumVec = bvec4(shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0);\r\n            bool inFrustum = all(inFrustumVec);\r\n\r\n            bvec2 frustumTestVec = bvec2(inFrustum, shadowCoordNDC.z <= 1.0);\r\n\r\n            bool frustumTest = all(frustumTestVec);\r\n\r\n            #if LINEAR_DEPTH == 1\r\n                shadowCoordNDC.z = linearDepth;\r\n            #endif\r\n\r\n            if (frustumTest) {\r\n\r\n                #if SHADOW_QUALITY == 0\r\n\r\n                    shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);\r\n\r\n                #elif SHADOW_QUALITY == 1\r\n\r\n                    vec2 texelSize = vec2(1.0) / shadowMapResolution;\r\n                    float dx0 = -texelSize.x * shadowRadius;\r\n                    float dy0 = -texelSize.y * shadowRadius;\r\n                    float dx1 = +texelSize.x * shadowRadius;\r\n                    float dy1 = +texelSize.y * shadowRadius;\r\n                    float theta = rand(shadowCoord.xy) * PI2;\r\n                    float snTheta = sin(theta);\r\n                    float csTheta = cos(theta);\r\n                    mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);\r\n                    shadowValue = (\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx0, dy0), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(0.0, dy0), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx1, dy0), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx0, 0.0), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx1, 0.0), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx0, dy1), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(0.0, dy1), shadowCoordNDC.z) +\r\n                        texture2DCompare(shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx1, dy1), shadowCoordNDC.z)\r\n                    ) * (1.0 / 9.0);\r\n\r\n                #elif SHADOW_QUALITY == 2\r\n\r\n                    vec2 texelSize = vec2(1.0) / shadowMapResolution;\r\n                    float dx0 = -texelSize.x * shadowRadius;\r\n                    float dy0 = -texelSize.y * shadowRadius;\r\n                    float dx1 = +texelSize.x * shadowRadius;\r\n                    float dy1 = +texelSize.y * shadowRadius;\r\n                    float theta = rand(shadowCoord.xy) * PI2;\r\n                    float snTheta = sin(theta);\r\n                    float csTheta = cos(theta);\r\n                    mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);\r\n                    shadowValue = (\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx0, dy0), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(0.0, dy0), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx1, dy0), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx0, 0.0), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx1, 0.0), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx0, dy1), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(0.0, dy1), shadowCoordNDC.z) +\r\n                        texture2DShadowLerp(shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2(dx1, dy1), shadowCoordNDC.z)\r\n                    ) * (1.0 / 9.0);\r\n\r\n                #endif\r\n            }\r\n\r\n            float previousAccumulation = unpackRGBAToDepth(texture2D(shadowAccumulationBuffer, gl_FragCoord.xy / shadowBufferSize));\r\n            if (shadowData.x == 1.) {\r\n                previousAccumulation = 0.;\r\n            }\r\n\r\n            float dotProd = clamp(abs(dot(-lightVector, normalize(worldNormal))), 0.0, 1.0);\r\n\r\n            #if NORMAL_WEIGHTS == 1\r\n                float weight = dotProd;\r\n            #else\r\n                float weight = 1.;\r\n            #endif\r\n\r\n            #if USE_MOVING_AVERAGE == 1\r\n                float t = weight/shadowData.x;\r\n                float shadowAccumulation = mix(previousAccumulation, weight * shadowValue, t);\r\n            #else\r\n                float shadowAccumulation = previousAccumulation + shadowValue * totalWeightSum * weight;\r\n            #endif\r\n            gl_FragColor = packDepthToRGBA(shadowAccumulation);\r\n\r\n        }"
                    },
                    "./src/shaders/softshadow.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec3 viewNormal;\r\nvarying vec3 worldNormal;\r\nvarying vec4 shadowCoord;\r\nuniform vec3 vplPosition;\r\nuniform mat4 shadowMatrix;\r\nuniform float normalBias;\r\nvoid main() {\r\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n    viewNormal = normalize(normalMatrix * normal);\r\n    worldNormal = normalize((modelMatrix * vec4(normal, 0.))).xyz;\r\n    vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;\r\n    shadowCoord = shadowMatrix * worldPosition;\r\n    gl_Position = vec4(2. * uv.x - 1., 2. * uv.y - 1., 0., 1.0);\r\n}"
                    },
                    "./src/shaders/transition.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "#include <packing>\r\n\r\nvarying vec2 vUv;\r\nuniform float transition;\r\nuniform vec3 shadowData;\r\nuniform sampler2D shadowAccumulationBuffer;\r\nuniform vec3 shadowColor;\r\n\r\nvoid main() {\r\n\r\n    #if SHADOW_MATERIAL == 1\r\n        float shadowValue = unpackRGBAToDepth(texture2D(shadowAccumulationBuffer, vUv));\r\n        float mask = (1. - shadowValue) * shadowData.x;\r\n        mask = pow(mask, shadowData.y);\r\n        gl_FragColor = vec4(mix(vec4(0.), vec4(shadowColor, mask), pow(transition, 4.)));\r\n    #else\r\n        float shadowValue = unpackRGBAToDepth(texture2D(shadowAccumulationBuffer, vUv));\r\n        float mask = (1. - shadowValue);\r\n        mask = pow(shadowValue, shadowData.y);\r\n        gl_FragColor = vec4(mask + shadowData.x);\r\n    #endif\r\n}"
                    },
                    "./src/shaders/transitionShader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                          , i = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        const a = r(n("./src/shaders/simple_vert.vert"))
                          , o = r(n("./src/shaders/transition.frag"))
                          , s = i(n("three"));
                        t.transitionShader = {
                            defines: {
                                SHADOW_MATERIAL: 1
                            },
                            uniforms: {
                                shadowAccumulationBuffer: {
                                    value: null
                                },
                                transition: {
                                    value: 0
                                },
                                shadowData: {
                                    value: new s.Vector3(1,2,1)
                                },
                                shadowColor: {
                                    value: new s.Color(0)
                                }
                            },
                            vertexShader: a.default,
                            fragmentShader: o.default
                        }
                    },
                    three: function(e, t) {
                        e.exports = r
                    }
                }))
            }
            ,
            7473: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    SimpleDropzone: ()=>we
                });
                var r = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];
                function i() {
                    var e = this;
                    function t(e, t) {
                        var n = 0;
                        do {
                            n |= 1 & e,
                            e >>>= 1,
                            n <<= 1
                        } while (--t > 0);
                        return n >>> 1
                    }
                    e.build_tree = function(n) {
                        var r, i, a, o = e.dyn_tree, s = e.stat_desc.static_tree, l = e.stat_desc.elems, c = -1;
                        for (n.heap_len = 0,
                        n.heap_max = 573,
                        r = 0; r < l; r++)
                            0 !== o[2 * r] ? (n.heap[++n.heap_len] = c = r,
                            n.depth[r] = 0) : o[2 * r + 1] = 0;
                        for (; n.heap_len < 2; )
                            o[2 * (a = n.heap[++n.heap_len] = c < 2 ? ++c : 0)] = 1,
                            n.depth[a] = 0,
                            n.opt_len--,
                            s && (n.static_len -= s[2 * a + 1]);
                        for (e.max_code = c,
                        r = Math.floor(n.heap_len / 2); r >= 1; r--)
                            n.pqdownheap(o, r);
                        a = l;
                        do {
                            r = n.heap[1],
                            n.heap[1] = n.heap[n.heap_len--],
                            n.pqdownheap(o, 1),
                            i = n.heap[1],
                            n.heap[--n.heap_max] = r,
                            n.heap[--n.heap_max] = i,
                            o[2 * a] = o[2 * r] + o[2 * i],
                            n.depth[a] = Math.max(n.depth[r], n.depth[i]) + 1,
                            o[2 * r + 1] = o[2 * i + 1] = a,
                            n.heap[1] = a++,
                            n.pqdownheap(o, 1)
                        } while (n.heap_len >= 2);
                        n.heap[--n.heap_max] = n.heap[1],
                        function(t) {
                            var n, r, i, a, o, s, l = e.dyn_tree, c = e.stat_desc.static_tree, u = e.stat_desc.extra_bits, h = e.stat_desc.extra_base, d = e.stat_desc.max_length, p = 0;
                            for (a = 0; a <= 15; a++)
                                t.bl_count[a] = 0;
                            for (l[2 * t.heap[t.heap_max] + 1] = 0,
                            n = t.heap_max + 1; n < 573; n++)
                                (a = l[2 * l[2 * (r = t.heap[n]) + 1] + 1] + 1) > d && (a = d,
                                p++),
                                l[2 * r + 1] = a,
                                r > e.max_code || (t.bl_count[a]++,
                                o = 0,
                                r >= h && (o = u[r - h]),
                                t.opt_len += (s = l[2 * r]) * (a + o),
                                c && (t.static_len += s * (c[2 * r + 1] + o)));
                            if (0 !== p) {
                                do {
                                    for (a = d - 1; 0 === t.bl_count[a]; )
                                        a--;
                                    t.bl_count[a]--,
                                    t.bl_count[a + 1] += 2,
                                    t.bl_count[d]--,
                                    p -= 2
                                } while (p > 0);
                                for (a = d; 0 !== a; a--)
                                    for (r = t.bl_count[a]; 0 !== r; )
                                        (i = t.heap[--n]) > e.max_code || (l[2 * i + 1] != a && (t.opt_len += (a - l[2 * i + 1]) * l[2 * i],
                                        l[2 * i + 1] = a),
                                        r--)
                            }
                        }(n),
                        function(e, n, r) {
                            var i, a, o, s = [], l = 0;
                            for (i = 1; i <= 15; i++)
                                s[i] = l = l + r[i - 1] << 1;
                            for (a = 0; a <= n; a++)
                                0 !== (o = e[2 * a + 1]) && (e[2 * a] = t(s[o]++, o))
                        }(o, e.max_code, n.bl_count)
                    }
                }
                function a(e, t, n, r, i) {
                    this.static_tree = e,
                    this.extra_bits = t,
                    this.extra_base = n,
                    this.elems = r,
                    this.max_length = i
                }
                function o(e, t, n, r, i) {
                    this.good_length = e,
                    this.max_lazy = t,
                    this.nice_length = n,
                    this.max_chain = r,
                    this.func = i
                }
                i._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28],
                i.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0],
                i.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576],
                i.d_code = function(e) {
                    return e < 256 ? r[e] : r[256 + (e >>> 7)]
                }
                ,
                i.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
                i.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                i.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                i.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                a.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8],
                a.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5],
                a.static_l_desc = new a(a.static_ltree,i.extra_lbits,257,286,15),
                a.static_d_desc = new a(a.static_dtree,i.extra_dbits,0,30,15),
                a.static_bl_desc = new a(null,i.extra_blbits,0,19,7);
                var s = [new o(0,0,0,0,0), new o(4,4,8,4,1), new o(4,5,16,8,1), new o(4,6,32,32,1), new o(4,4,16,16,2), new o(8,16,32,32,2), new o(8,16,128,128,2), new o(8,32,128,256,2), new o(32,128,258,1024,2), new o(32,258,258,4096,2)]
                  , l = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""];
                function c(e, t, n, r) {
                    var i = e[2 * t]
                      , a = e[2 * n];
                    return i < a || i == a && r[t] <= r[n]
                }
                function u() {
                    var e, t, n, r, o, u, h, d, p, f, m, g, v, y, _, x, b, w, M, S, T, E, A, C, P, R, L, D, O, F, I, N, B, k, z, U, H, G, j, V, W, q = this, X = new i, Y = new i, Z = new i;
                    function J() {
                        var e;
                        for (e = 0; e < 286; e++)
                            I[2 * e] = 0;
                        for (e = 0; e < 30; e++)
                            N[2 * e] = 0;
                        for (e = 0; e < 19; e++)
                            B[2 * e] = 0;
                        I[512] = 1,
                        q.opt_len = q.static_len = 0,
                        U = G = 0
                    }
                    function K(e, t) {
                        var n, r, i = -1, a = e[1], o = 0, s = 7, l = 4;
                        for (0 === a && (s = 138,
                        l = 3),
                        e[2 * (t + 1) + 1] = 65535,
                        n = 0; n <= t; n++)
                            r = a,
                            a = e[2 * (n + 1) + 1],
                            ++o < s && r == a || (o < l ? B[2 * r] += o : 0 !== r ? (r != i && B[2 * r]++,
                            B[32]++) : o <= 10 ? B[34]++ : B[36]++,
                            o = 0,
                            i = r,
                            0 === a ? (s = 138,
                            l = 3) : r == a ? (s = 6,
                            l = 3) : (s = 7,
                            l = 4))
                    }
                    function Q(e) {
                        q.pending_buf[q.pending++] = e
                    }
                    function $(e) {
                        Q(255 & e),
                        Q(e >>> 8 & 255)
                    }
                    function ee(e, t) {
                        var n, r = t;
                        W > 16 - r ? ($(V |= (n = e) << W & 65535),
                        V = n >>> 16 - W,
                        W += r - 16) : (V |= e << W & 65535,
                        W += r)
                    }
                    function te(e, t) {
                        var n = 2 * e;
                        ee(65535 & t[n], 65535 & t[n + 1])
                    }
                    function ne(e, t) {
                        var n, r, i = -1, a = e[1], o = 0, s = 7, l = 4;
                        for (0 === a && (s = 138,
                        l = 3),
                        n = 0; n <= t; n++)
                            if (r = a,
                            a = e[2 * (n + 1) + 1],
                            !(++o < s && r == a)) {
                                if (o < l)
                                    do {
                                        te(r, B)
                                    } while (0 != --o);
                                else
                                    0 !== r ? (r != i && (te(r, B),
                                    o--),
                                    te(16, B),
                                    ee(o - 3, 2)) : o <= 10 ? (te(17, B),
                                    ee(o - 3, 3)) : (te(18, B),
                                    ee(o - 11, 7));
                                o = 0,
                                i = r,
                                0 === a ? (s = 138,
                                l = 3) : r == a ? (s = 6,
                                l = 3) : (s = 7,
                                l = 4)
                            }
                    }
                    function re() {
                        16 == W ? ($(V),
                        V = 0,
                        W = 0) : W >= 8 && (Q(255 & V),
                        V >>>= 8,
                        W -= 8)
                    }
                    function ie(e, t) {
                        var n, r, a;
                        if (q.pending_buf[H + 2 * U] = e >>> 8 & 255,
                        q.pending_buf[H + 2 * U + 1] = 255 & e,
                        q.pending_buf[k + U] = 255 & t,
                        U++,
                        0 === e ? I[2 * t]++ : (G++,
                        e--,
                        I[2 * (i._length_code[t] + 256 + 1)]++,
                        N[2 * i.d_code(e)]++),
                        0 == (8191 & U) && L > 2) {
                            for (n = 8 * U,
                            r = T - b,
                            a = 0; a < 30; a++)
                                n += N[2 * a] * (5 + i.extra_dbits[a]);
                            if (n >>>= 3,
                            G < Math.floor(U / 2) && n < Math.floor(r / 2))
                                return !0
                        }
                        return U == z - 1
                    }
                    function ae(e, t) {
                        var n, r, a, o, s = 0;
                        if (0 !== U)
                            do {
                                n = q.pending_buf[H + 2 * s] << 8 & 65280 | 255 & q.pending_buf[H + 2 * s + 1],
                                r = 255 & q.pending_buf[k + s],
                                s++,
                                0 === n ? te(r, e) : (te((a = i._length_code[r]) + 256 + 1, e),
                                0 !== (o = i.extra_lbits[a]) && ee(r -= i.base_length[a], o),
                                n--,
                                te(a = i.d_code(n), t),
                                0 !== (o = i.extra_dbits[a]) && ee(n -= i.base_dist[a], o))
                            } while (s < U);
                        te(256, e),
                        j = e[513]
                    }
                    function oe() {
                        W > 8 ? $(V) : W > 0 && Q(255 & V),
                        V = 0,
                        W = 0
                    }
                    function se(e, t, n) {
                        ee(0 + (n ? 1 : 0), 3),
                        function(e, t, n) {
                            oe(),
                            j = 8,
                            $(t),
                            $(~t),
                            q.pending_buf.set(d.subarray(e, e + t), q.pending),
                            q.pending += t
                        }(e, t)
                    }
                    function le(t) {
                        (function(e, t, n) {
                            var r, o, s = 0;
                            L > 0 ? (X.build_tree(q),
                            Y.build_tree(q),
                            s = function() {
                                var e;
                                for (K(I, X.max_code),
                                K(N, Y.max_code),
                                Z.build_tree(q),
                                e = 18; e >= 3 && 0 === B[2 * i.bl_order[e] + 1]; e--)
                                    ;
                                return q.opt_len += 3 * (e + 1) + 5 + 5 + 4,
                                e
                            }(),
                            (o = q.static_len + 3 + 7 >>> 3) <= (r = q.opt_len + 3 + 7 >>> 3) && (r = o)) : r = o = t + 5,
                            t + 4 <= r && -1 != e ? se(e, t, n) : o == r ? (ee(2 + (n ? 1 : 0), 3),
                            ae(a.static_ltree, a.static_dtree)) : (ee(4 + (n ? 1 : 0), 3),
                            function(e, t, n) {
                                var r;
                                for (ee(e - 257, 5),
                                ee(t - 1, 5),
                                ee(n - 4, 4),
                                r = 0; r < n; r++)
                                    ee(B[2 * i.bl_order[r] + 1], 3);
                                ne(I, e - 1),
                                ne(N, t - 1)
                            }(X.max_code + 1, Y.max_code + 1, s + 1),
                            ae(I, N)),
                            J(),
                            n && oe()
                        }
                        )(b >= 0 ? b : -1, T - b, t),
                        b = T,
                        e.flush_pending()
                    }
                    function ce() {
                        var t, n, r, i;
                        do {
                            if (0 == (i = p - A - T) && 0 === T && 0 === A)
                                i = o;
                            else if (-1 == i)
                                i--;
                            else if (T >= o + o - 262) {
                                d.set(d.subarray(o, o + o), 0),
                                E -= o,
                                T -= o,
                                b -= o,
                                r = t = v;
                                do {
                                    n = 65535 & m[--r],
                                    m[r] = n >= o ? n - o : 0
                                } while (0 != --t);
                                r = t = o;
                                do {
                                    n = 65535 & f[--r],
                                    f[r] = n >= o ? n - o : 0
                                } while (0 != --t);
                                i += o
                            }
                            if (0 === e.avail_in)
                                return;
                            t = e.read_buf(d, T + A, i),
                            (A += t) >= 3 && (g = ((g = 255 & d[T]) << x ^ 255 & d[T + 1]) & _)
                        } while (A < 262 && 0 !== e.avail_in)
                    }
                    function ue(e) {
                        var t, n, r = P, i = T, a = C, s = T > o - 262 ? T - (o - 262) : 0, l = F, c = h, u = T + 258, p = d[i + a - 1], m = d[i + a];
                        C >= O && (r >>= 2),
                        l > A && (l = A);
                        do {
                            if (d[(t = e) + a] == m && d[t + a - 1] == p && d[t] == d[i] && d[++t] == d[i + 1]) {
                                i += 2,
                                t++;
                                do {} while (d[++i] == d[++t] && d[++i] == d[++t] && d[++i] == d[++t] && d[++i] == d[++t] && d[++i] == d[++t] && d[++i] == d[++t] && d[++i] == d[++t] && d[++i] == d[++t] && i < u);
                                if (n = 258 - (u - i),
                                i = u - 258,
                                n > a) {
                                    if (E = e,
                                    a = n,
                                    n >= l)
                                        break;
                                    p = d[i + a - 1],
                                    m = d[i + a]
                                }
                            }
                        } while ((e = 65535 & f[e & c]) > s && 0 != --r);
                        return a <= A ? a : A
                    }
                    q.depth = [],
                    q.bl_count = [],
                    q.heap = [],
                    I = [],
                    N = [],
                    B = [],
                    q.pqdownheap = function(e, t) {
                        for (var n = q.heap, r = n[t], i = t << 1; i <= q.heap_len && (i < q.heap_len && c(e, n[i + 1], n[i], q.depth) && i++,
                        !c(e, r, n[i], q.depth)); )
                            n[t] = n[i],
                            t = i,
                            i <<= 1;
                        n[t] = r
                    }
                    ,
                    q.deflateInit = function(e, i, l, c, M, E) {
                        return c || (c = 8),
                        M || (M = 8),
                        E || (E = 0),
                        e.msg = null,
                        -1 == i && (i = 6),
                        M < 1 || M > 9 || 8 != c || l < 9 || l > 15 || i < 0 || i > 9 || E < 0 || E > 2 ? -2 : (e.dstate = q,
                        h = (o = 1 << (u = l)) - 1,
                        _ = (v = 1 << (y = M + 7)) - 1,
                        x = Math.floor((y + 3 - 1) / 3),
                        d = new Uint8Array(2 * o),
                        f = [],
                        m = [],
                        z = 1 << M + 6,
                        q.pending_buf = new Uint8Array(4 * z),
                        n = 4 * z,
                        H = Math.floor(z / 2),
                        k = 3 * z,
                        L = i,
                        D = E,
                        function(e) {
                            return e.total_in = e.total_out = 0,
                            e.msg = null,
                            q.pending = 0,
                            q.pending_out = 0,
                            t = 113,
                            r = 0,
                            X.dyn_tree = I,
                            X.stat_desc = a.static_l_desc,
                            Y.dyn_tree = N,
                            Y.stat_desc = a.static_d_desc,
                            Z.dyn_tree = B,
                            Z.stat_desc = a.static_bl_desc,
                            V = 0,
                            W = 0,
                            j = 8,
                            J(),
                            function() {
                                var e;
                                for (p = 2 * o,
                                m[v - 1] = 0,
                                e = 0; e < v - 1; e++)
                                    m[e] = 0;
                                R = s[L].max_lazy,
                                O = s[L].good_length,
                                F = s[L].nice_length,
                                P = s[L].max_chain,
                                T = 0,
                                b = 0,
                                A = 0,
                                w = C = 2,
                                S = 0,
                                g = 0
                            }(),
                            0
                        }(e))
                    }
                    ,
                    q.deflateEnd = function() {
                        return 42 != t && 113 != t && 666 != t ? -2 : (q.pending_buf = null,
                        m = null,
                        f = null,
                        d = null,
                        q.dstate = null,
                        113 == t ? -3 : 0)
                    }
                    ,
                    q.deflateParams = function(e, t, n) {
                        var r = 0;
                        return -1 == t && (t = 6),
                        t < 0 || t > 9 || n < 0 || n > 2 ? -2 : (s[L].func != s[t].func && 0 !== e.total_in && (r = e.deflate(1)),
                        L != t && (R = s[L = t].max_lazy,
                        O = s[L].good_length,
                        F = s[L].nice_length,
                        P = s[L].max_chain),
                        D = n,
                        r)
                    }
                    ,
                    q.deflateSetDictionary = function(e, n, r) {
                        var i, a = r, s = 0;
                        if (!n || 42 != t)
                            return -2;
                        if (a < 3)
                            return 0;
                        for (a > o - 262 && (s = r - (a = o - 262)),
                        d.set(n.subarray(s, s + a), 0),
                        T = a,
                        b = a,
                        g = ((g = 255 & d[0]) << x ^ 255 & d[1]) & _,
                        i = 0; i <= a - 3; i++)
                            f[i & h] = m[g = (g << x ^ 255 & d[i + 2]) & _],
                            m[g] = i;
                        return 0
                    }
                    ,
                    q.deflate = function(i, c) {
                        var p, y, P, O, F, I;
                        if (c > 4 || c < 0)
                            return -2;
                        if (!i.next_out || !i.next_in && 0 !== i.avail_in || 666 == t && 4 != c)
                            return i.msg = l[4],
                            -2;
                        if (0 === i.avail_out)
                            return i.msg = l[7],
                            -5;
                        if (e = i,
                        O = r,
                        r = c,
                        42 == t && (y = 8 + (u - 8 << 4) << 8,
                        (P = (L - 1 & 255) >> 1) > 3 && (P = 3),
                        y |= P << 6,
                        0 !== T && (y |= 32),
                        t = 113,
                        Q((I = y += 31 - y % 31) >> 8 & 255),
                        Q(255 & I)),
                        0 !== q.pending) {
                            if (e.flush_pending(),
                            0 === e.avail_out)
                                return r = -1,
                                0
                        } else if (0 === e.avail_in && c <= O && 4 != c)
                            return e.msg = l[7],
                            -5;
                        if (666 == t && 0 !== e.avail_in)
                            return i.msg = l[7],
                            -5;
                        if (0 !== e.avail_in || 0 !== A || 0 != c && 666 != t) {
                            switch (F = -1,
                            s[L].func) {
                            case 0:
                                F = function(t) {
                                    var r, i = 65535;
                                    for (i > n - 5 && (i = n - 5); ; ) {
                                        if (A <= 1) {
                                            if (ce(),
                                            0 === A && 0 == t)
                                                return 0;
                                            if (0 === A)
                                                break
                                        }
                                        if (T += A,
                                        A = 0,
                                        r = b + i,
                                        (0 === T || T >= r) && (A = T - r,
                                        T = r,
                                        le(!1),
                                        0 === e.avail_out))
                                            return 0;
                                        if (T - b >= o - 262 && (le(!1),
                                        0 === e.avail_out))
                                            return 0
                                    }
                                    return le(4 == t),
                                    0 === e.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1
                                }(c);
                                break;
                            case 1:
                                F = function(t) {
                                    for (var n, r = 0; ; ) {
                                        if (A < 262) {
                                            if (ce(),
                                            A < 262 && 0 == t)
                                                return 0;
                                            if (0 === A)
                                                break
                                        }
                                        if (A >= 3 && (r = 65535 & m[g = (g << x ^ 255 & d[T + 2]) & _],
                                        f[T & h] = m[g],
                                        m[g] = T),
                                        0 !== r && (T - r & 65535) <= o - 262 && 2 != D && (w = ue(r)),
                                        w >= 3)
                                            if (n = ie(T - E, w - 3),
                                            A -= w,
                                            w <= R && A >= 3) {
                                                w--;
                                                do {
                                                    T++,
                                                    r = 65535 & m[g = (g << x ^ 255 & d[T + 2]) & _],
                                                    f[T & h] = m[g],
                                                    m[g] = T
                                                } while (0 != --w);
                                                T++
                                            } else
                                                T += w,
                                                w = 0,
                                                g = ((g = 255 & d[T]) << x ^ 255 & d[T + 1]) & _;
                                        else
                                            n = ie(0, 255 & d[T]),
                                            A--,
                                            T++;
                                        if (n && (le(!1),
                                        0 === e.avail_out))
                                            return 0
                                    }
                                    return le(4 == t),
                                    0 === e.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1
                                }(c);
                                break;
                            case 2:
                                F = function(t) {
                                    for (var n, r, i = 0; ; ) {
                                        if (A < 262) {
                                            if (ce(),
                                            A < 262 && 0 == t)
                                                return 0;
                                            if (0 === A)
                                                break
                                        }
                                        if (A >= 3 && (i = 65535 & m[g = (g << x ^ 255 & d[T + 2]) & _],
                                        f[T & h] = m[g],
                                        m[g] = T),
                                        C = w,
                                        M = E,
                                        w = 2,
                                        0 !== i && C < R && (T - i & 65535) <= o - 262 && (2 != D && (w = ue(i)),
                                        w <= 5 && (1 == D || 3 == w && T - E > 4096) && (w = 2)),
                                        C >= 3 && w <= C) {
                                            r = T + A - 3,
                                            n = ie(T - 1 - M, C - 3),
                                            A -= C - 1,
                                            C -= 2;
                                            do {
                                                ++T <= r && (i = 65535 & m[g = (g << x ^ 255 & d[T + 2]) & _],
                                                f[T & h] = m[g],
                                                m[g] = T)
                                            } while (0 != --C);
                                            if (S = 0,
                                            w = 2,
                                            T++,
                                            n && (le(!1),
                                            0 === e.avail_out))
                                                return 0
                                        } else if (0 !== S) {
                                            if ((n = ie(0, 255 & d[T - 1])) && le(!1),
                                            T++,
                                            A--,
                                            0 === e.avail_out)
                                                return 0
                                        } else
                                            S = 1,
                                            T++,
                                            A--
                                    }
                                    return 0 !== S && (n = ie(0, 255 & d[T - 1]),
                                    S = 0),
                                    le(4 == t),
                                    0 === e.avail_out ? 4 == t ? 2 : 0 : 4 == t ? 3 : 1
                                }(c)
                            }
                            if (2 != F && 3 != F || (t = 666),
                            0 == F || 2 == F)
                                return 0 === e.avail_out && (r = -1),
                                0;
                            if (1 == F) {
                                if (1 == c)
                                    ee(2, 3),
                                    te(256, a.static_ltree),
                                    re(),
                                    1 + j + 10 - W < 9 && (ee(2, 3),
                                    te(256, a.static_ltree),
                                    re()),
                                    j = 7;
                                else if (se(0, 0, !1),
                                3 == c)
                                    for (p = 0; p < v; p++)
                                        m[p] = 0;
                                if (e.flush_pending(),
                                0 === e.avail_out)
                                    return r = -1,
                                    0
                            }
                        }
                        return 4 != c ? 0 : 1
                    }
                }
                function h() {
                    this.next_in_index = 0,
                    this.next_out_index = 0,
                    this.avail_in = 0,
                    this.total_in = 0,
                    this.avail_out = 0,
                    this.total_out = 0
                }
                function d(e) {
                    var t = new h
                      , n = new Uint8Array(512)
                      , r = e ? e.level : -1;
                    void 0 === r && (r = -1),
                    t.deflateInit(r),
                    t.next_out = n,
                    this.append = function(e, r) {
                        var i, a = [], o = 0, s = 0, l = 0;
                        if (e.length) {
                            t.next_in_index = 0,
                            t.next_in = e,
                            t.avail_in = e.length;
                            do {
                                if (t.next_out_index = 0,
                                t.avail_out = 512,
                                0 != t.deflate(0))
                                    throw new Error("deflating: " + t.msg);
                                t.next_out_index && a.push(512 == t.next_out_index ? new Uint8Array(n) : new Uint8Array(n.subarray(0, t.next_out_index))),
                                l += t.next_out_index,
                                r && t.next_in_index > 0 && t.next_in_index != o && (r(t.next_in_index),
                                o = t.next_in_index)
                            } while (t.avail_in > 0 || 0 === t.avail_out);
                            return i = new Uint8Array(l),
                            a.forEach((function(e) {
                                i.set(e, s),
                                s += e.length
                            }
                            )),
                            i
                        }
                    }
                    ,
                    this.flush = function() {
                        var e, r, i = [], a = 0, o = 0;
                        do {
                            if (t.next_out_index = 0,
                            t.avail_out = 512,
                            1 != (e = t.deflate(4)) && 0 != e)
                                throw new Error("deflating: " + t.msg);
                            512 - t.avail_out > 0 && i.push(new Uint8Array(n.subarray(0, t.next_out_index))),
                            o += t.next_out_index
                        } while (t.avail_in > 0 || 0 === t.avail_out);
                        return t.deflateEnd(),
                        r = new Uint8Array(o),
                        i.forEach((function(e) {
                            r.set(e, a),
                            a += e.length
                        }
                        )),
                        r
                    }
                }
                h.prototype = {
                    deflateInit: function(e, t) {
                        return this.dstate = new u,
                        t || (t = 15),
                        this.dstate.deflateInit(this, e, t)
                    },
                    deflate: function(e) {
                        return this.dstate ? this.dstate.deflate(this, e) : -2
                    },
                    deflateEnd: function() {
                        if (!this.dstate)
                            return -2;
                        var e = this.dstate.deflateEnd();
                        return this.dstate = null,
                        e
                    },
                    deflateParams: function(e, t) {
                        return this.dstate ? this.dstate.deflateParams(this, e, t) : -2
                    },
                    deflateSetDictionary: function(e, t) {
                        return this.dstate ? this.dstate.deflateSetDictionary(this, e, t) : -2
                    },
                    read_buf: function(e, t, n) {
                        var r = this.avail_in;
                        return r > n && (r = n),
                        0 === r ? 0 : (this.avail_in -= r,
                        e.set(this.next_in.subarray(this.next_in_index, this.next_in_index + r), t),
                        this.next_in_index += r,
                        this.total_in += r,
                        r)
                    },
                    flush_pending: function() {
                        var e = this.dstate.pending;
                        e > this.avail_out && (e = this.avail_out),
                        0 !== e && (this.next_out.set(this.dstate.pending_buf.subarray(this.dstate.pending_out, this.dstate.pending_out + e), this.next_out_index),
                        this.next_out_index += e,
                        this.dstate.pending_out += e,
                        this.total_out += e,
                        this.avail_out -= e,
                        this.dstate.pending -= e,
                        0 === this.dstate.pending && (this.dstate.pending_out = 0))
                    }
                },
                self._zipjs_Deflater = d;
                var p = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535]
                  , f = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255]
                  , m = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577]
                  , g = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]
                  , v = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112]
                  , y = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]
                  , _ = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
                function x() {
                    var e, t, n, r, i, a;
                    function o(e, t, o, s, l, c, u, h, d, p, f) {
                        var m, g, v, y, _, x, b, w, M, S, T, E, A, C, P;
                        S = 0,
                        _ = o;
                        do {
                            n[e[t + S]]++,
                            S++,
                            _--
                        } while (0 !== _);
                        if (n[0] == o)
                            return u[0] = -1,
                            h[0] = 0,
                            0;
                        for (w = h[0],
                        x = 1; x <= 15 && 0 === n[x]; x++)
                            ;
                        for (b = x,
                        w < x && (w = x),
                        _ = 15; 0 !== _ && 0 === n[_]; _--)
                            ;
                        for (v = _,
                        w > _ && (w = _),
                        h[0] = w,
                        C = 1 << x; x < _; x++,
                        C <<= 1)
                            if ((C -= n[x]) < 0)
                                return -3;
                        if ((C -= n[_]) < 0)
                            return -3;
                        for (n[_] += C,
                        a[1] = x = 0,
                        S = 1,
                        A = 2; 0 != --_; )
                            a[A] = x += n[S],
                            A++,
                            S++;
                        _ = 0,
                        S = 0;
                        do {
                            0 !== (x = e[t + S]) && (f[a[x]++] = _),
                            S++
                        } while (++_ < o);
                        for (o = a[v],
                        a[0] = _ = 0,
                        S = 0,
                        y = -1,
                        E = -w,
                        i[0] = 0,
                        T = 0,
                        P = 0; b <= v; b++)
                            for (m = n[b]; 0 != m--; ) {
                                for (; b > E + w; ) {
                                    if (y++,
                                    P = (P = v - (E += w)) > w ? w : P,
                                    (g = 1 << (x = b - E)) > m + 1 && (g -= m + 1,
                                    A = b,
                                    x < P))
                                        for (; ++x < P && !((g <<= 1) <= n[++A]); )
                                            g -= n[A];
                                    if (p[0] + (P = 1 << x) > 1440)
                                        return -3;
                                    i[y] = T = p[0],
                                    p[0] += P,
                                    0 !== y ? (a[y] = _,
                                    r[0] = x,
                                    r[1] = w,
                                    r[2] = T - i[y - 1] - (x = _ >>> E - w),
                                    d.set(r, 3 * (i[y - 1] + x))) : u[0] = T
                                }
                                for (r[1] = b - E,
                                S >= o ? r[0] = 192 : f[S] < s ? (r[0] = f[S] < 256 ? 0 : 96,
                                r[2] = f[S++]) : (r[0] = c[f[S] - s] + 16 + 64,
                                r[2] = l[f[S++] - s]),
                                g = 1 << b - E,
                                x = _ >>> E; x < P; x += g)
                                    d.set(r, 3 * (T + x));
                                for (x = 1 << b - 1; 0 != (_ & x); x >>>= 1)
                                    _ ^= x;
                                for (_ ^= x,
                                M = (1 << E) - 1; (_ & M) != a[y]; )
                                    y--,
                                    M = (1 << (E -= w)) - 1
                            }
                        return 0 !== C && 1 != v ? -5 : 0
                    }
                    function s(o) {
                        var s;
                        for (e || (e = [],
                        t = [],
                        n = new Int32Array(16),
                        r = [],
                        i = new Int32Array(15),
                        a = new Int32Array(16)),
                        t.length < o && (t = []),
                        s = 0; s < o; s++)
                            t[s] = 0;
                        for (s = 0; s < 16; s++)
                            n[s] = 0;
                        for (s = 0; s < 3; s++)
                            r[s] = 0;
                        i.set(n.subarray(0, 15), 0),
                        a.set(n.subarray(0, 16), 0)
                    }
                    this.inflate_trees_bits = function(n, r, i, a, l) {
                        var c;
                        return s(19),
                        e[0] = 0,
                        -3 == (c = o(n, 0, 19, 19, null, null, i, r, a, e, t)) ? l.msg = "oversubscribed dynamic bit lengths tree" : -5 != c && 0 !== r[0] || (l.msg = "incomplete dynamic bit lengths tree",
                        c = -3),
                        c
                    }
                    ,
                    this.inflate_trees_dynamic = function(n, r, i, a, l, c, u, h, d) {
                        var p;
                        return s(288),
                        e[0] = 0,
                        0 != (p = o(i, 0, n, 257, g, v, c, a, h, e, t)) || 0 === a[0] ? (-3 == p ? d.msg = "oversubscribed literal/length tree" : -4 != p && (d.msg = "incomplete literal/length tree",
                        p = -3),
                        p) : (s(288),
                        0 != (p = o(i, n, r, 0, y, _, u, l, h, e, t)) || 0 === l[0] && n > 257 ? (-3 == p ? d.msg = "oversubscribed distance tree" : -5 == p ? (d.msg = "incomplete distance tree",
                        p = -3) : -4 != p && (d.msg = "empty distance tree with lengths",
                        p = -3),
                        p) : 0)
                    }
                }
                function b() {
                    var e, t, n, r, i = 0, a = 0, o = 0, s = 0, l = 0, c = 0, u = 0, h = 0, d = 0, f = 0;
                    function m(e, t, n, r, i, a, o, s) {
                        var l, c, u, h, d, f, m, g, v, y, _, x, b, w, M, S;
                        m = s.next_in_index,
                        g = s.avail_in,
                        d = o.bitb,
                        f = o.bitk,
                        y = (v = o.write) < o.read ? o.read - v - 1 : o.end - v,
                        _ = p[e],
                        x = p[t];
                        do {
                            for (; f < 20; )
                                g--,
                                d |= (255 & s.read_byte(m++)) << f,
                                f += 8;
                            if (0 !== (h = (c = n)[S = 3 * ((u = r) + (l = d & _))]))
                                for (; ; ) {
                                    if (d >>= c[S + 1],
                                    f -= c[S + 1],
                                    0 != (16 & h)) {
                                        for (b = c[S + 2] + (d & p[h &= 15]),
                                        d >>= h,
                                        f -= h; f < 15; )
                                            g--,
                                            d |= (255 & s.read_byte(m++)) << f,
                                            f += 8;
                                        for (h = (c = i)[S = 3 * ((u = a) + (l = d & x))]; ; ) {
                                            if (d >>= c[S + 1],
                                            f -= c[S + 1],
                                            0 != (16 & h)) {
                                                for (h &= 15; f < h; )
                                                    g--,
                                                    d |= (255 & s.read_byte(m++)) << f,
                                                    f += 8;
                                                if (w = c[S + 2] + (d & p[h]),
                                                d >>= h,
                                                f -= h,
                                                y -= b,
                                                v >= w)
                                                    v - (M = v - w) > 0 && 2 > v - M ? (o.window[v++] = o.window[M++],
                                                    o.window[v++] = o.window[M++],
                                                    b -= 2) : (o.window.set(o.window.subarray(M, M + 2), v),
                                                    v += 2,
                                                    M += 2,
                                                    b -= 2);
                                                else {
                                                    M = v - w;
                                                    do {
                                                        M += o.end
                                                    } while (M < 0);
                                                    if (b > (h = o.end - M)) {
                                                        if (b -= h,
                                                        v - M > 0 && h > v - M)
                                                            do {
                                                                o.window[v++] = o.window[M++]
                                                            } while (0 != --h);
                                                        else
                                                            o.window.set(o.window.subarray(M, M + h), v),
                                                            v += h,
                                                            M += h,
                                                            h = 0;
                                                        M = 0
                                                    }
                                                }
                                                if (v - M > 0 && b > v - M)
                                                    do {
                                                        o.window[v++] = o.window[M++]
                                                    } while (0 != --b);
                                                else
                                                    o.window.set(o.window.subarray(M, M + b), v),
                                                    v += b,
                                                    M += b,
                                                    b = 0;
                                                break
                                            }
                                            if (0 != (64 & h))
                                                return s.msg = "invalid distance code",
                                                g += b = f >> 3 < (b = s.avail_in - g) ? f >> 3 : b,
                                                m -= b,
                                                f -= b << 3,
                                                o.bitb = d,
                                                o.bitk = f,
                                                s.avail_in = g,
                                                s.total_in += m - s.next_in_index,
                                                s.next_in_index = m,
                                                o.write = v,
                                                -3;
                                            l += c[S + 2],
                                            h = c[S = 3 * (u + (l += d & p[h]))]
                                        }
                                        break
                                    }
                                    if (0 != (64 & h))
                                        return 0 != (32 & h) ? (g += b = f >> 3 < (b = s.avail_in - g) ? f >> 3 : b,
                                        m -= b,
                                        f -= b << 3,
                                        o.bitb = d,
                                        o.bitk = f,
                                        s.avail_in = g,
                                        s.total_in += m - s.next_in_index,
                                        s.next_in_index = m,
                                        o.write = v,
                                        1) : (s.msg = "invalid literal/length code",
                                        g += b = f >> 3 < (b = s.avail_in - g) ? f >> 3 : b,
                                        m -= b,
                                        f -= b << 3,
                                        o.bitb = d,
                                        o.bitk = f,
                                        s.avail_in = g,
                                        s.total_in += m - s.next_in_index,
                                        s.next_in_index = m,
                                        o.write = v,
                                        -3);
                                    if (l += c[S + 2],
                                    0 === (h = c[S = 3 * (u + (l += d & p[h]))])) {
                                        d >>= c[S + 1],
                                        f -= c[S + 1],
                                        o.window[v++] = c[S + 2],
                                        y--;
                                        break
                                    }
                                }
                            else
                                d >>= c[S + 1],
                                f -= c[S + 1],
                                o.window[v++] = c[S + 2],
                                y--
                        } while (y >= 258 && g >= 10);
                        return g += b = f >> 3 < (b = s.avail_in - g) ? f >> 3 : b,
                        m -= b,
                        f -= b << 3,
                        o.bitb = d,
                        o.bitk = f,
                        s.avail_in = g,
                        s.total_in += m - s.next_in_index,
                        s.next_in_index = m,
                        o.write = v,
                        0
                    }
                    this.init = function(i, a, o, s, l, c) {
                        e = 0,
                        u = i,
                        h = a,
                        n = o,
                        d = s,
                        r = l,
                        f = c,
                        t = null
                    }
                    ,
                    this.proc = function(g, v, y) {
                        var _, x, b, w, M, S, T, E = 0, A = 0, C = 0;
                        for (C = v.next_in_index,
                        w = v.avail_in,
                        E = g.bitb,
                        A = g.bitk,
                        S = (M = g.write) < g.read ? g.read - M - 1 : g.end - M; ; )
                            switch (e) {
                            case 0:
                                if (S >= 258 && w >= 10 && (g.bitb = E,
                                g.bitk = A,
                                v.avail_in = w,
                                v.total_in += C - v.next_in_index,
                                v.next_in_index = C,
                                g.write = M,
                                y = m(u, h, n, d, r, f, g, v),
                                C = v.next_in_index,
                                w = v.avail_in,
                                E = g.bitb,
                                A = g.bitk,
                                S = (M = g.write) < g.read ? g.read - M - 1 : g.end - M,
                                0 != y)) {
                                    e = 1 == y ? 7 : 9;
                                    break
                                }
                                o = u,
                                t = n,
                                a = d,
                                e = 1;
                            case 1:
                                for (_ = o; A < _; ) {
                                    if (0 === w)
                                        return g.bitb = E,
                                        g.bitk = A,
                                        v.avail_in = w,
                                        v.total_in += C - v.next_in_index,
                                        v.next_in_index = C,
                                        g.write = M,
                                        g.inflate_flush(v, y);
                                    y = 0,
                                    w--,
                                    E |= (255 & v.read_byte(C++)) << A,
                                    A += 8
                                }
                                if (E >>>= t[1 + (x = 3 * (a + (E & p[_])))],
                                A -= t[x + 1],
                                0 === (b = t[x])) {
                                    s = t[x + 2],
                                    e = 6;
                                    break
                                }
                                if (0 != (16 & b)) {
                                    l = 15 & b,
                                    i = t[x + 2],
                                    e = 2;
                                    break
                                }
                                if (0 == (64 & b)) {
                                    o = b,
                                    a = x / 3 + t[x + 2];
                                    break
                                }
                                if (0 != (32 & b)) {
                                    e = 7;
                                    break
                                }
                                return e = 9,
                                v.msg = "invalid literal/length code",
                                y = -3,
                                g.bitb = E,
                                g.bitk = A,
                                v.avail_in = w,
                                v.total_in += C - v.next_in_index,
                                v.next_in_index = C,
                                g.write = M,
                                g.inflate_flush(v, y);
                            case 2:
                                for (_ = l; A < _; ) {
                                    if (0 === w)
                                        return g.bitb = E,
                                        g.bitk = A,
                                        v.avail_in = w,
                                        v.total_in += C - v.next_in_index,
                                        v.next_in_index = C,
                                        g.write = M,
                                        g.inflate_flush(v, y);
                                    y = 0,
                                    w--,
                                    E |= (255 & v.read_byte(C++)) << A,
                                    A += 8
                                }
                                i += E & p[_],
                                E >>= _,
                                A -= _,
                                o = h,
                                t = r,
                                a = f,
                                e = 3;
                            case 3:
                                for (_ = o; A < _; ) {
                                    if (0 === w)
                                        return g.bitb = E,
                                        g.bitk = A,
                                        v.avail_in = w,
                                        v.total_in += C - v.next_in_index,
                                        v.next_in_index = C,
                                        g.write = M,
                                        g.inflate_flush(v, y);
                                    y = 0,
                                    w--,
                                    E |= (255 & v.read_byte(C++)) << A,
                                    A += 8
                                }
                                if (E >>= t[1 + (x = 3 * (a + (E & p[_])))],
                                A -= t[x + 1],
                                0 != (16 & (b = t[x]))) {
                                    l = 15 & b,
                                    c = t[x + 2],
                                    e = 4;
                                    break
                                }
                                if (0 == (64 & b)) {
                                    o = b,
                                    a = x / 3 + t[x + 2];
                                    break
                                }
                                return e = 9,
                                v.msg = "invalid distance code",
                                y = -3,
                                g.bitb = E,
                                g.bitk = A,
                                v.avail_in = w,
                                v.total_in += C - v.next_in_index,
                                v.next_in_index = C,
                                g.write = M,
                                g.inflate_flush(v, y);
                            case 4:
                                for (_ = l; A < _; ) {
                                    if (0 === w)
                                        return g.bitb = E,
                                        g.bitk = A,
                                        v.avail_in = w,
                                        v.total_in += C - v.next_in_index,
                                        v.next_in_index = C,
                                        g.write = M,
                                        g.inflate_flush(v, y);
                                    y = 0,
                                    w--,
                                    E |= (255 & v.read_byte(C++)) << A,
                                    A += 8
                                }
                                c += E & p[_],
                                E >>= _,
                                A -= _,
                                e = 5;
                            case 5:
                                for (T = M - c; T < 0; )
                                    T += g.end;
                                for (; 0 !== i; ) {
                                    if (0 === S && (M == g.end && 0 !== g.read && (S = (M = 0) < g.read ? g.read - M - 1 : g.end - M),
                                    0 === S && (g.write = M,
                                    y = g.inflate_flush(v, y),
                                    S = (M = g.write) < g.read ? g.read - M - 1 : g.end - M,
                                    M == g.end && 0 !== g.read && (S = (M = 0) < g.read ? g.read - M - 1 : g.end - M),
                                    0 === S)))
                                        return g.bitb = E,
                                        g.bitk = A,
                                        v.avail_in = w,
                                        v.total_in += C - v.next_in_index,
                                        v.next_in_index = C,
                                        g.write = M,
                                        g.inflate_flush(v, y);
                                    g.window[M++] = g.window[T++],
                                    S--,
                                    T == g.end && (T = 0),
                                    i--
                                }
                                e = 0;
                                break;
                            case 6:
                                if (0 === S && (M == g.end && 0 !== g.read && (S = (M = 0) < g.read ? g.read - M - 1 : g.end - M),
                                0 === S && (g.write = M,
                                y = g.inflate_flush(v, y),
                                S = (M = g.write) < g.read ? g.read - M - 1 : g.end - M,
                                M == g.end && 0 !== g.read && (S = (M = 0) < g.read ? g.read - M - 1 : g.end - M),
                                0 === S)))
                                    return g.bitb = E,
                                    g.bitk = A,
                                    v.avail_in = w,
                                    v.total_in += C - v.next_in_index,
                                    v.next_in_index = C,
                                    g.write = M,
                                    g.inflate_flush(v, y);
                                y = 0,
                                g.window[M++] = s,
                                S--,
                                e = 0;
                                break;
                            case 7:
                                if (A > 7 && (A -= 8,
                                w++,
                                C--),
                                g.write = M,
                                y = g.inflate_flush(v, y),
                                S = (M = g.write) < g.read ? g.read - M - 1 : g.end - M,
                                g.read != g.write)
                                    return g.bitb = E,
                                    g.bitk = A,
                                    v.avail_in = w,
                                    v.total_in += C - v.next_in_index,
                                    v.next_in_index = C,
                                    g.write = M,
                                    g.inflate_flush(v, y);
                                e = 8;
                            case 8:
                                return y = 1,
                                g.bitb = E,
                                g.bitk = A,
                                v.avail_in = w,
                                v.total_in += C - v.next_in_index,
                                v.next_in_index = C,
                                g.write = M,
                                g.inflate_flush(v, y);
                            case 9:
                                return y = -3,
                                g.bitb = E,
                                g.bitk = A,
                                v.avail_in = w,
                                v.total_in += C - v.next_in_index,
                                v.next_in_index = C,
                                g.write = M,
                                g.inflate_flush(v, y);
                            default:
                                return y = -2,
                                g.bitb = E,
                                g.bitk = A,
                                v.avail_in = w,
                                v.total_in += C - v.next_in_index,
                                v.next_in_index = C,
                                g.write = M,
                                g.inflate_flush(v, y)
                            }
                    }
                    ,
                    this.free = function() {}
                }
                x.inflate_trees_fixed = function(e, t, n, r) {
                    return e[0] = 9,
                    t[0] = 5,
                    n[0] = f,
                    r[0] = m,
                    0
                }
                ;
                var w = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                function M(e, t) {
                    var n, r = this, i = 0, a = 0, o = 0, s = 0, l = [0], c = [0], u = new b, h = 0, d = new Int32Array(4320), f = new x;
                    r.bitk = 0,
                    r.bitb = 0,
                    r.window = new Uint8Array(t),
                    r.end = t,
                    r.read = 0,
                    r.write = 0,
                    r.reset = function(e, t) {
                        t && (t[0] = 0),
                        6 == i && u.free(e),
                        i = 0,
                        r.bitk = 0,
                        r.bitb = 0,
                        r.read = r.write = 0
                    }
                    ,
                    r.reset(e, null),
                    r.inflate_flush = function(e, t) {
                        var n, i, a;
                        return i = e.next_out_index,
                        (n = ((a = r.read) <= r.write ? r.write : r.end) - a) > e.avail_out && (n = e.avail_out),
                        0 !== n && -5 == t && (t = 0),
                        e.avail_out -= n,
                        e.total_out += n,
                        e.next_out.set(r.window.subarray(a, a + n), i),
                        i += n,
                        (a += n) == r.end && (a = 0,
                        r.write == r.end && (r.write = 0),
                        (n = r.write - a) > e.avail_out && (n = e.avail_out),
                        0 !== n && -5 == t && (t = 0),
                        e.avail_out -= n,
                        e.total_out += n,
                        e.next_out.set(r.window.subarray(a, a + n), i),
                        i += n,
                        a += n),
                        e.next_out_index = i,
                        r.read = a,
                        t
                    }
                    ,
                    r.proc = function(e, t) {
                        var m, g, v, y, _, b, M, S;
                        for (y = e.next_in_index,
                        _ = e.avail_in,
                        g = r.bitb,
                        v = r.bitk,
                        M = (b = r.write) < r.read ? r.read - b - 1 : r.end - b; ; )
                            switch (i) {
                            case 0:
                                for (; v < 3; ) {
                                    if (0 === _)
                                        return r.bitb = g,
                                        r.bitk = v,
                                        e.avail_in = _,
                                        e.total_in += y - e.next_in_index,
                                        e.next_in_index = y,
                                        r.write = b,
                                        r.inflate_flush(e, t);
                                    t = 0,
                                    _--,
                                    g |= (255 & e.read_byte(y++)) << v,
                                    v += 8
                                }
                                switch (h = 1 & (m = 7 & g),
                                m >>> 1) {
                                case 0:
                                    g >>>= 3,
                                    g >>>= m = 7 & (v -= 3),
                                    v -= m,
                                    i = 1;
                                    break;
                                case 1:
                                    var T = []
                                      , E = []
                                      , A = [[]]
                                      , C = [[]];
                                    x.inflate_trees_fixed(T, E, A, C),
                                    u.init(T[0], E[0], A[0], 0, C[0], 0),
                                    g >>>= 3,
                                    v -= 3,
                                    i = 6;
                                    break;
                                case 2:
                                    g >>>= 3,
                                    v -= 3,
                                    i = 3;
                                    break;
                                case 3:
                                    return g >>>= 3,
                                    v -= 3,
                                    i = 9,
                                    e.msg = "invalid block type",
                                    t = -3,
                                    r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t)
                                }
                                break;
                            case 1:
                                for (; v < 32; ) {
                                    if (0 === _)
                                        return r.bitb = g,
                                        r.bitk = v,
                                        e.avail_in = _,
                                        e.total_in += y - e.next_in_index,
                                        e.next_in_index = y,
                                        r.write = b,
                                        r.inflate_flush(e, t);
                                    t = 0,
                                    _--,
                                    g |= (255 & e.read_byte(y++)) << v,
                                    v += 8
                                }
                                if ((~g >>> 16 & 65535) != (65535 & g))
                                    return i = 9,
                                    e.msg = "invalid stored block lengths",
                                    t = -3,
                                    r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                a = 65535 & g,
                                g = v = 0,
                                i = 0 !== a ? 2 : 0 !== h ? 7 : 0;
                                break;
                            case 2:
                                if (0 === _)
                                    return r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                if (0 === M && (b == r.end && 0 !== r.read && (M = (b = 0) < r.read ? r.read - b - 1 : r.end - b),
                                0 === M && (r.write = b,
                                t = r.inflate_flush(e, t),
                                M = (b = r.write) < r.read ? r.read - b - 1 : r.end - b,
                                b == r.end && 0 !== r.read && (M = (b = 0) < r.read ? r.read - b - 1 : r.end - b),
                                0 === M)))
                                    return r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                if (t = 0,
                                (m = a) > _ && (m = _),
                                m > M && (m = M),
                                r.window.set(e.read_buf(y, m), b),
                                y += m,
                                _ -= m,
                                b += m,
                                M -= m,
                                0 != (a -= m))
                                    break;
                                i = 0 !== h ? 7 : 0;
                                break;
                            case 3:
                                for (; v < 14; ) {
                                    if (0 === _)
                                        return r.bitb = g,
                                        r.bitk = v,
                                        e.avail_in = _,
                                        e.total_in += y - e.next_in_index,
                                        e.next_in_index = y,
                                        r.write = b,
                                        r.inflate_flush(e, t);
                                    t = 0,
                                    _--,
                                    g |= (255 & e.read_byte(y++)) << v,
                                    v += 8
                                }
                                if (o = m = 16383 & g,
                                (31 & m) > 29 || (m >> 5 & 31) > 29)
                                    return i = 9,
                                    e.msg = "too many length or distance symbols",
                                    t = -3,
                                    r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                if (m = 258 + (31 & m) + (m >> 5 & 31),
                                !n || n.length < m)
                                    n = [];
                                else
                                    for (S = 0; S < m; S++)
                                        n[S] = 0;
                                g >>>= 14,
                                v -= 14,
                                s = 0,
                                i = 4;
                            case 4:
                                for (; s < 4 + (o >>> 10); ) {
                                    for (; v < 3; ) {
                                        if (0 === _)
                                            return r.bitb = g,
                                            r.bitk = v,
                                            e.avail_in = _,
                                            e.total_in += y - e.next_in_index,
                                            e.next_in_index = y,
                                            r.write = b,
                                            r.inflate_flush(e, t);
                                        t = 0,
                                        _--,
                                        g |= (255 & e.read_byte(y++)) << v,
                                        v += 8
                                    }
                                    n[w[s++]] = 7 & g,
                                    g >>>= 3,
                                    v -= 3
                                }
                                for (; s < 19; )
                                    n[w[s++]] = 0;
                                if (l[0] = 7,
                                0 != (m = f.inflate_trees_bits(n, l, c, d, e)))
                                    return -3 == (t = m) && (n = null,
                                    i = 9),
                                    r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                s = 0,
                                i = 5;
                            case 5:
                                for (; !(s >= 258 + (31 & (m = o)) + (m >> 5 & 31)); ) {
                                    var P, R;
                                    for (m = l[0]; v < m; ) {
                                        if (0 === _)
                                            return r.bitb = g,
                                            r.bitk = v,
                                            e.avail_in = _,
                                            e.total_in += y - e.next_in_index,
                                            e.next_in_index = y,
                                            r.write = b,
                                            r.inflate_flush(e, t);
                                        t = 0,
                                        _--,
                                        g |= (255 & e.read_byte(y++)) << v,
                                        v += 8
                                    }
                                    if ((R = d[3 * (c[0] + (g & p[m = d[3 * (c[0] + (g & p[m])) + 1]])) + 2]) < 16)
                                        g >>>= m,
                                        v -= m,
                                        n[s++] = R;
                                    else {
                                        for (S = 18 == R ? 7 : R - 14,
                                        P = 18 == R ? 11 : 3; v < m + S; ) {
                                            if (0 === _)
                                                return r.bitb = g,
                                                r.bitk = v,
                                                e.avail_in = _,
                                                e.total_in += y - e.next_in_index,
                                                e.next_in_index = y,
                                                r.write = b,
                                                r.inflate_flush(e, t);
                                            t = 0,
                                            _--,
                                            g |= (255 & e.read_byte(y++)) << v,
                                            v += 8
                                        }
                                        if (v -= m,
                                        P += (g >>>= m) & p[S],
                                        g >>>= S,
                                        v -= S,
                                        (S = s) + P > 258 + (31 & (m = o)) + (m >> 5 & 31) || 16 == R && S < 1)
                                            return n = null,
                                            i = 9,
                                            e.msg = "invalid bit length repeat",
                                            t = -3,
                                            r.bitb = g,
                                            r.bitk = v,
                                            e.avail_in = _,
                                            e.total_in += y - e.next_in_index,
                                            e.next_in_index = y,
                                            r.write = b,
                                            r.inflate_flush(e, t);
                                        R = 16 == R ? n[S - 1] : 0;
                                        do {
                                            n[S++] = R
                                        } while (0 != --P);
                                        s = S
                                    }
                                }
                                c[0] = -1;
                                var L = []
                                  , D = []
                                  , O = []
                                  , F = [];
                                if (L[0] = 9,
                                D[0] = 6,
                                0 != (m = f.inflate_trees_dynamic(257 + (31 & (m = o)), 1 + (m >> 5 & 31), n, L, D, O, F, d, e)))
                                    return -3 == m && (n = null,
                                    i = 9),
                                    t = m,
                                    r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                u.init(L[0], D[0], d, O[0], d, F[0]),
                                i = 6;
                            case 6:
                                if (r.bitb = g,
                                r.bitk = v,
                                e.avail_in = _,
                                e.total_in += y - e.next_in_index,
                                e.next_in_index = y,
                                r.write = b,
                                1 != (t = u.proc(r, e, t)))
                                    return r.inflate_flush(e, t);
                                if (t = 0,
                                u.free(e),
                                y = e.next_in_index,
                                _ = e.avail_in,
                                g = r.bitb,
                                v = r.bitk,
                                M = (b = r.write) < r.read ? r.read - b - 1 : r.end - b,
                                0 === h) {
                                    i = 0;
                                    break
                                }
                                i = 7;
                            case 7:
                                if (r.write = b,
                                t = r.inflate_flush(e, t),
                                M = (b = r.write) < r.read ? r.read - b - 1 : r.end - b,
                                r.read != r.write)
                                    return r.bitb = g,
                                    r.bitk = v,
                                    e.avail_in = _,
                                    e.total_in += y - e.next_in_index,
                                    e.next_in_index = y,
                                    r.write = b,
                                    r.inflate_flush(e, t);
                                i = 8;
                            case 8:
                                return t = 1,
                                r.bitb = g,
                                r.bitk = v,
                                e.avail_in = _,
                                e.total_in += y - e.next_in_index,
                                e.next_in_index = y,
                                r.write = b,
                                r.inflate_flush(e, t);
                            case 9:
                                return t = -3,
                                r.bitb = g,
                                r.bitk = v,
                                e.avail_in = _,
                                e.total_in += y - e.next_in_index,
                                e.next_in_index = y,
                                r.write = b,
                                r.inflate_flush(e, t);
                            default:
                                return t = -2,
                                r.bitb = g,
                                r.bitk = v,
                                e.avail_in = _,
                                e.total_in += y - e.next_in_index,
                                e.next_in_index = y,
                                r.write = b,
                                r.inflate_flush(e, t)
                            }
                    }
                    ,
                    r.free = function(e) {
                        r.reset(e, null),
                        r.window = null,
                        d = null
                    }
                    ,
                    r.set_dictionary = function(e, t, n) {
                        r.window.set(e.subarray(t, t + n), 0),
                        r.read = r.write = n
                    }
                    ,
                    r.sync_point = function() {
                        return 1 == i ? 1 : 0
                    }
                }
                var S = [0, 0, 255, 255];
                function T() {
                    var e = this;
                    function t(e) {
                        return e && e.istate ? (e.total_in = e.total_out = 0,
                        e.msg = null,
                        e.istate.mode = 7,
                        e.istate.blocks.reset(e, null),
                        0) : -2
                    }
                    e.mode = 0,
                    e.method = 0,
                    e.was = [0],
                    e.need = 0,
                    e.marker = 0,
                    e.wbits = 0,
                    e.inflateEnd = function(t) {
                        return e.blocks && e.blocks.free(t),
                        e.blocks = null,
                        0
                    }
                    ,
                    e.inflateInit = function(n, r) {
                        return n.msg = null,
                        e.blocks = null,
                        r < 8 || r > 15 ? (e.inflateEnd(n),
                        -2) : (e.wbits = r,
                        n.istate.blocks = new M(n,1 << r),
                        t(n),
                        0)
                    }
                    ,
                    e.inflate = function(e, t) {
                        var n, r;
                        if (!e || !e.istate || !e.next_in)
                            return -2;
                        for (t = 4 == t ? -5 : 0,
                        n = -5; ; )
                            switch (e.istate.mode) {
                            case 0:
                                if (0 === e.avail_in)
                                    return n;
                                if (n = t,
                                e.avail_in--,
                                e.total_in++,
                                8 != (15 & (e.istate.method = e.read_byte(e.next_in_index++)))) {
                                    e.istate.mode = 13,
                                    e.msg = "unknown compression method",
                                    e.istate.marker = 5;
                                    break
                                }
                                if (8 + (e.istate.method >> 4) > e.istate.wbits) {
                                    e.istate.mode = 13,
                                    e.msg = "invalid window size",
                                    e.istate.marker = 5;
                                    break
                                }
                                e.istate.mode = 1;
                            case 1:
                                if (0 === e.avail_in)
                                    return n;
                                if (n = t,
                                e.avail_in--,
                                e.total_in++,
                                r = 255 & e.read_byte(e.next_in_index++),
                                ((e.istate.method << 8) + r) % 31 != 0) {
                                    e.istate.mode = 13,
                                    e.msg = "incorrect header check",
                                    e.istate.marker = 5;
                                    break
                                }
                                if (0 == (32 & r)) {
                                    e.istate.mode = 7;
                                    break
                                }
                                e.istate.mode = 2;
                            case 2:
                                if (0 === e.avail_in)
                                    return n;
                                n = t,
                                e.avail_in--,
                                e.total_in++,
                                e.istate.need = (255 & e.read_byte(e.next_in_index++)) << 24 & 4278190080,
                                e.istate.mode = 3;
                            case 3:
                                if (0 === e.avail_in)
                                    return n;
                                n = t,
                                e.avail_in--,
                                e.total_in++,
                                e.istate.need += (255 & e.read_byte(e.next_in_index++)) << 16 & 16711680,
                                e.istate.mode = 4;
                            case 4:
                                if (0 === e.avail_in)
                                    return n;
                                n = t,
                                e.avail_in--,
                                e.total_in++,
                                e.istate.need += (255 & e.read_byte(e.next_in_index++)) << 8 & 65280,
                                e.istate.mode = 5;
                            case 5:
                                return 0 === e.avail_in ? n : (n = t,
                                e.avail_in--,
                                e.total_in++,
                                e.istate.need += 255 & e.read_byte(e.next_in_index++),
                                e.istate.mode = 6,
                                2);
                            case 6:
                                return e.istate.mode = 13,
                                e.msg = "need dictionary",
                                e.istate.marker = 0,
                                -2;
                            case 7:
                                if (-3 == (n = e.istate.blocks.proc(e, n))) {
                                    e.istate.mode = 13,
                                    e.istate.marker = 0;
                                    break
                                }
                                if (0 == n && (n = t),
                                1 != n)
                                    return n;
                                n = t,
                                e.istate.blocks.reset(e, e.istate.was),
                                e.istate.mode = 12;
                            case 12:
                                return 1;
                            case 13:
                                return -3;
                            default:
                                return -2
                            }
                    }
                    ,
                    e.inflateSetDictionary = function(e, t, n) {
                        var r = 0
                          , i = n;
                        return e && e.istate && 6 == e.istate.mode ? (i >= 1 << e.istate.wbits && (r = n - (i = (1 << e.istate.wbits) - 1)),
                        e.istate.blocks.set_dictionary(t, r, i),
                        e.istate.mode = 7,
                        0) : -2
                    }
                    ,
                    e.inflateSync = function(e) {
                        var n, r, i, a, o;
                        if (!e || !e.istate)
                            return -2;
                        if (13 != e.istate.mode && (e.istate.mode = 13,
                        e.istate.marker = 0),
                        0 === (n = e.avail_in))
                            return -5;
                        for (r = e.next_in_index,
                        i = e.istate.marker; 0 !== n && i < 4; )
                            e.read_byte(r) == S[i] ? i++ : i = 0 !== e.read_byte(r) ? 0 : 4 - i,
                            r++,
                            n--;
                        return e.total_in += r - e.next_in_index,
                        e.next_in_index = r,
                        e.avail_in = n,
                        e.istate.marker = i,
                        4 != i ? -3 : (a = e.total_in,
                        o = e.total_out,
                        t(e),
                        e.total_in = a,
                        e.total_out = o,
                        e.istate.mode = 7,
                        0)
                    }
                    ,
                    e.inflateSyncPoint = function(e) {
                        return e && e.istate && e.istate.blocks ? e.istate.blocks.sync_point() : -2
                    }
                }
                function E() {}
                function A() {
                    var e = new E
                      , t = new Uint8Array(512)
                      , n = !1;
                    e.inflateInit(),
                    e.next_out = t,
                    this.append = function(r, i) {
                        var a, o, s = [], l = 0, c = 0, u = 0;
                        if (0 !== r.length) {
                            e.next_in_index = 0,
                            e.next_in = r,
                            e.avail_in = r.length;
                            do {
                                if (e.next_out_index = 0,
                                e.avail_out = 512,
                                0 !== e.avail_in || n || (e.next_in_index = 0,
                                n = !0),
                                a = e.inflate(0),
                                n && -5 === a) {
                                    if (0 !== e.avail_in)
                                        throw new Error("inflating: bad input")
                                } else if (0 !== a && 1 !== a)
                                    throw new Error("inflating: " + e.msg);
                                if ((n || 1 === a) && e.avail_in === r.length)
                                    throw new Error("inflating: bad input");
                                e.next_out_index && s.push(512 === e.next_out_index ? new Uint8Array(t) : new Uint8Array(t.subarray(0, e.next_out_index))),
                                u += e.next_out_index,
                                i && e.next_in_index > 0 && e.next_in_index != l && (i(e.next_in_index),
                                l = e.next_in_index)
                            } while (e.avail_in > 0 || 0 === e.avail_out);
                            return o = new Uint8Array(u),
                            s.forEach((function(e) {
                                o.set(e, c),
                                c += e.length
                            }
                            )),
                            o
                        }
                    }
                    ,
                    this.flush = function() {
                        e.inflateEnd()
                    }
                }
                E.prototype = {
                    inflateInit: function(e) {
                        return this.istate = new T,
                        e || (e = 15),
                        this.istate.inflateInit(this, e)
                    },
                    inflate: function(e) {
                        return this.istate ? this.istate.inflate(this, e) : -2
                    },
                    inflateEnd: function() {
                        if (!this.istate)
                            return -2;
                        var e = this.istate.inflateEnd(this);
                        return this.istate = null,
                        e
                    },
                    inflateSync: function() {
                        return this.istate ? this.istate.inflateSync(this) : -2
                    },
                    inflateSetDictionary: function(e, t) {
                        return this.istate ? this.istate.inflateSetDictionary(this, e, t) : -2
                    },
                    read_byte: function(e) {
                        return this.next_in.subarray(e, e + 1)[0]
                    },
                    read_buf: function(e, t) {
                        return this.next_in.subarray(e, e + t)
                    }
                },
                self._zipjs_Inflater = A;
                var C, P = "File format is not recognized.", R = "Error while reading zip file.";
                try {
                    C = 0 === new Blob([new DataView(new ArrayBuffer(0))]).size
                } catch (r) {}
                function L() {
                    this.crc = -1
                }
                function D() {}
                function O(e, t) {
                    var n, r;
                    return n = new ArrayBuffer(e),
                    r = new Uint8Array(n),
                    t && r.set(t, 0),
                    {
                        buffer: n,
                        array: r,
                        view: new DataView(n)
                    }
                }
                function F() {}
                function I(e) {
                    var t, n = this;
                    n.size = 0,
                    n.init = function(r, i) {
                        var a = new Blob([e],{
                            type: "text/plain"
                        });
                        (t = new B(a)).init((function() {
                            n.size = t.size,
                            r()
                        }
                        ), i)
                    }
                    ,
                    n.readUint8Array = function(e, n, r, i) {
                        t.readUint8Array(e, n, r, i)
                    }
                }
                function N(e) {
                    var t, n = this;
                    n.size = 0,
                    n.init = function(r) {
                        for (var i = e.length; "=" == e.charAt(i - 1); )
                            i--;
                        t = e.indexOf(",") + 1,
                        n.size = Math.floor(.75 * (i - t)),
                        r()
                    }
                    ,
                    n.readUint8Array = function(n, r, i) {
                        var a, o = O(r), s = 4 * Math.floor(n / 3), l = 4 * Math.ceil((n + r) / 3), c = self.atob(e.substring(s + t, l + t)), u = n - 3 * Math.floor(s / 4);
                        for (a = u; a < u + r; a++)
                            o.array[a - u] = c.charCodeAt(a);
                        i(o.array)
                    }
                }
                function B(e) {
                    var t = this;
                    t.size = 0,
                    t.init = function(n) {
                        t.size = e.size,
                        n()
                    }
                    ,
                    t.readUint8Array = function(t, n, r, i) {
                        var a = new FileReader;
                        a.onload = function(e) {
                            r(new Uint8Array(e.target.result))
                        }
                        ,
                        a.onerror = i;
                        try {
                            a.readAsArrayBuffer(function(e, t, n) {
                                if (t < 0 || n < 0 || t + n > e.size)
                                    throw new RangeError("offset:" + t + ", length:" + n + ", size:" + e.size);
                                return e.slice ? e.slice(t, t + n) : e.webkitSlice ? e.webkitSlice(t, t + n) : e.mozSlice ? e.mozSlice(t, t + n) : e.msSlice ? e.msSlice(t, t + n) : void 0
                            }(e, t, n))
                        } catch (e) {
                            i(e)
                        }
                    }
                }
                function k() {}
                function z(e) {
                    var t;
                    this.init = function(e) {
                        t = new Blob([],{
                            type: "text/plain"
                        }),
                        e()
                    }
                    ,
                    this.writeUint8Array = function(e, n) {
                        t = new Blob([t, C ? e : e.buffer],{
                            type: "text/plain"
                        }),
                        n()
                    }
                    ,
                    this.getData = function(n, r) {
                        var i = new FileReader;
                        i.onload = function(e) {
                            n(e.target.result)
                        }
                        ,
                        i.onerror = r,
                        i.readAsText(t, e)
                    }
                }
                function U(e) {
                    var t = ""
                      , n = "";
                    this.init = function(n) {
                        t += "data:" + (e || "") + ";base64,",
                        n()
                    }
                    ,
                    this.writeUint8Array = function(e, r) {
                        var i, a = n.length, o = n;
                        for (n = "",
                        i = 0; i < 3 * Math.floor((a + e.length) / 3) - a; i++)
                            o += String.fromCharCode(e[i]);
                        for (; i < e.length; i++)
                            n += String.fromCharCode(e[i]);
                        o.length > 2 ? t += self.btoa(o) : n = o,
                        r()
                    }
                    ,
                    this.getData = function(e) {
                        e(t + self.btoa(n))
                    }
                }
                function H(e) {
                    var t;
                    this.init = function(n) {
                        t = new Blob([],{
                            type: e
                        }),
                        n()
                    }
                    ,
                    this.writeUint8Array = function(n, r) {
                        t = new Blob([t, C ? n : n.buffer],{
                            type: e
                        }),
                        r()
                    }
                    ,
                    this.getData = function(e) {
                        e(t)
                    }
                }
                function G(e, t, n, r, i, a, o, s, l, c) {
                    var u, h, d, p = 0, f = t.sn;
                    function m() {
                        e.removeEventListener("message", g, !1),
                        s(h, d)
                    }
                    function g(t) {
                        var n = t.data
                          , i = n.data
                          , s = n.error;
                        if (s)
                            return s.toString = function() {
                                return "Error: " + this.message
                            }
                            ,
                            void l(s);
                        if (n.sn === f)
                            switch ("number" == typeof n.codecTime && (e.codecTime += n.codecTime),
                            "number" == typeof n.crcTime && (e.crcTime += n.crcTime),
                            n.type) {
                            case "append":
                                i ? (h += i.length,
                                r.writeUint8Array(i, (function() {
                                    v()
                                }
                                ), c)) : v();
                                break;
                            case "flush":
                                d = n.crc,
                                i ? (h += i.length,
                                r.writeUint8Array(i, (function() {
                                    m()
                                }
                                ), c)) : m();
                                break;
                            case "progress":
                                o && o(u + n.loaded, a);
                                break;
                            case "importScripts":
                            case "newTask":
                            case "echo":
                                break;
                            default:
                                console.warn("zip.js:launchWorkerProcess: unknown message: ", n)
                            }
                    }
                    function v() {
                        (u = 524288 * p) <= a ? n.readUint8Array(i + u, Math.min(524288, a - u), (function(n) {
                            o && o(u, a);
                            var r = 0 === u ? t : {
                                sn: f
                            };
                            r.type = "append",
                            r.data = n;
                            try {
                                e.postMessage(r, [n.buffer])
                            } catch (t) {
                                e.postMessage(r)
                            }
                            p++
                        }
                        ), l) : e.postMessage({
                            sn: f,
                            type: "flush"
                        })
                    }
                    h = 0,
                    e.addEventListener("message", g, !1),
                    v()
                }
                function j(e, t, n, r, i, a, o, s, l, c) {
                    var u, h = 0, d = 0, p = "input" === a, f = "output" === a, m = new L;
                    !function a() {
                        var g;
                        if ((u = 524288 * h) < i)
                            t.readUint8Array(r + u, Math.min(524288, i - u), (function(t) {
                                var r;
                                try {
                                    r = e.append(t, (function(e) {
                                        o && o(u + e, i)
                                    }
                                    ))
                                } catch (e) {
                                    return void l(e)
                                }
                                r ? (d += r.length,
                                n.writeUint8Array(r, (function() {
                                    h++,
                                    setTimeout(a, 1)
                                }
                                ), c),
                                f && m.append(r)) : (h++,
                                setTimeout(a, 1)),
                                p && m.append(t),
                                o && o(u, i)
                            }
                            ), l);
                        else {
                            try {
                                g = e.flush()
                            } catch (e) {
                                return void l(e)
                            }
                            g ? (f && m.append(g),
                            d += g.length,
                            n.writeUint8Array(g, (function() {
                                s(d, m.get())
                            }
                            ), c)) : s(d, m.get())
                        }
                    }()
                }
                function V(e, t, n, r, i, a, o, s, l, c, u) {
                    ee.useWebWorkers && o ? G(e, {
                        sn: t,
                        codecClass: "_zipjs_NOOP",
                        crcType: "input"
                    }, n, r, i, a, l, s, c, u) : j(new D, n, r, i, a, "input", l, s, c, u)
                }
                function W(e) {
                    var t, n, r = "", i = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "_", "_", "_", "", "", "", "", "", "", "", "", "+", "+", "", "", "+", "+", "-", "-", "+", "-", "+", "", "", "+", "+", "-", "-", "", "-", "+", "", "", "", "", "", "", "i", "", "", "", "+", "+", "_", "_", "", "", "_", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "_", "", "", "", "", "", "", "", "", "", "", "", "_", " "];
                    for (t = 0; t < e.length; t++)
                        r += (n = 255 & e.charCodeAt(t)) > 127 ? i[n - 128] : String.fromCharCode(n);
                    return r
                }
                function q(e) {
                    return decodeURIComponent(escape(e))
                }
                function X(e) {
                    var t, n = "";
                    for (t = 0; t < e.length; t++)
                        n += String.fromCharCode(e[t]);
                    return n
                }
                function Y(e, t, n, r, i) {
                    e.version = t.view.getUint16(n, !0),
                    e.bitFlag = t.view.getUint16(n + 2, !0),
                    e.compressionMethod = t.view.getUint16(n + 4, !0),
                    e.lastModDateRaw = t.view.getUint32(n + 6, !0),
                    e.lastModDate = function(e) {
                        var t = (4294901760 & e) >> 16
                          , n = 65535 & e;
                        try {
                            return new Date(1980 + ((65024 & t) >> 9),((480 & t) >> 5) - 1,31 & t,(63488 & n) >> 11,(2016 & n) >> 5,2 * (31 & n),0)
                        } catch (e) {}
                    }(e.lastModDateRaw),
                    1 != (1 & e.bitFlag) ? ((r || 8 != (8 & e.bitFlag)) && (e.crc32 = t.view.getUint32(n + 10, !0),
                    e.compressedSize = t.view.getUint32(n + 14, !0),
                    e.uncompressedSize = t.view.getUint32(n + 18, !0)),
                    4294967295 !== e.compressedSize && 4294967295 !== e.uncompressedSize ? (e.filenameLength = t.view.getUint16(n + 22, !0),
                    e.extraFieldLength = t.view.getUint16(n + 24, !0)) : i("File is using Zip64 (4gb+ file size).")) : i("File contains encrypted entry.")
                }
                function Z(e) {
                    return unescape(encodeURIComponent(e))
                }
                function J(e) {
                    var t, n = [];
                    for (t = 0; t < e.length; t++)
                        n.push(e.charCodeAt(t));
                    return n
                }
                L.prototype.append = function(e) {
                    for (var t = 0 | this.crc, n = this.table, r = 0, i = 0 | e.length; r < i; r++)
                        t = t >>> 8 ^ n[255 & (t ^ e[r])];
                    this.crc = t
                }
                ,
                L.prototype.get = function() {
                    return ~this.crc
                }
                ,
                L.prototype.table = function() {
                    var e, t, n, r = [];
                    for (e = 0; e < 256; e++) {
                        for (n = e,
                        t = 0; t < 8; t++)
                            1 & n ? n = n >>> 1 ^ 3988292384 : n >>>= 1;
                        r[e] = n
                    }
                    return r
                }(),
                D.prototype.append = function(e, t) {
                    return e
                }
                ,
                D.prototype.flush = function() {}
                ,
                (I.prototype = new F).constructor = I,
                (N.prototype = new F).constructor = N,
                (B.prototype = new F).constructor = B,
                k.prototype.getData = function(e) {
                    e(this.data)
                }
                ,
                (z.prototype = new k).constructor = z,
                (U.prototype = new k).constructor = U,
                (H.prototype = new k).constructor = H;
                var K = {
                    deflater: ["z-worker.js", "deflate.js"],
                    inflater: ["z-worker.js", "inflate.js"]
                };
                function Q(e, t, n) {
                    if (null === ee.workerScripts || null === ee.workerScriptsPath) {
                        var r, i, a;
                        if (ee.workerScripts) {
                            if (r = ee.workerScripts[e],
                            !Array.isArray(r))
                                return void n(new Error("zip.workerScripts." + e + " is not an array!"));
                            i = r,
                            a = document.createElement("a"),
                            r = i.map((function(e) {
                                return a.href = e,
                                a.href
                            }
                            ))
                        } else
                            (r = K[e].slice(0))[0] = (ee.workerScriptsPath || "") + r[0];
                        var o = new Worker(r[0]);
                        o.codecTime = o.crcTime = 0,
                        o.postMessage({
                            type: "importScripts",
                            scripts: r.slice(1)
                        }),
                        o.addEventListener("message", (function e(r) {
                            var i = r.data;
                            if (i.error)
                                return o.terminate(),
                                void n(i.error);
                            "importScripts" === i.type && (o.removeEventListener("message", e),
                            o.removeEventListener("error", s),
                            t(o))
                        }
                        )),
                        o.addEventListener("error", s)
                    } else
                        n(new Error("Either zip.workerScripts or zip.workerScriptsPath may be set, not both."));
                    function s(e) {
                        o.terminate(),
                        n(e)
                    }
                }
                function $(e) {
                    console.error(e)
                }
                const ee = {
                    Reader: F,
                    Writer: k,
                    BlobReader: B,
                    Data64URIReader: N,
                    TextReader: I,
                    BlobWriter: H,
                    Data64URIWriter: U,
                    TextWriter: z,
                    createReader: function(e, t, n) {
                        e.init((function() {
                            !function(e, t, n) {
                                var r = 0;
                                function i() {}
                                i.prototype.getData = function(t, i, a, o) {
                                    var s = this;
                                    function l(e, r) {
                                        o && !function(e) {
                                            var t = O(4);
                                            return t.view.setUint32(0, e),
                                            s.crc32 == t.view.getUint32(0)
                                        }(r) ? n("CRC failed.") : t.getData((function(e) {
                                            i(e)
                                        }
                                        ))
                                    }
                                    function c(e) {
                                        n(e || "Error while reading file data.")
                                    }
                                    function u(e) {
                                        n(e || "Error while writing file data.")
                                    }
                                    e.readUint8Array(s.offset, 30, (function(i) {
                                        var h, d = O(i.length, i);
                                        1347093252 == d.view.getUint32(0) ? (Y(s, d, 4, !1, n),
                                        h = s.offset + 30 + s.filenameLength + s.extraFieldLength,
                                        t.init((function() {
                                            0 === s.compressionMethod ? V(s._worker, r++, e, t, h, s.compressedSize, o, l, a, c, u) : function(e, t, n, r, i, a, o, s, l, c, u) {
                                                var h = o ? "output" : "none";
                                                ee.useWebWorkers ? G(e, {
                                                    sn: t,
                                                    codecClass: "_zipjs_Inflater",
                                                    crcType: h
                                                }, n, r, i, a, l, s, c, u) : j(new A, n, r, i, a, h, l, s, c, u)
                                            }(s._worker, r++, e, t, h, s.compressedSize, o, l, a, c, u)
                                        }
                                        ), u)) : n(P)
                                    }
                                    ), c)
                                }
                                ;
                                var a = {
                                    getEntries: function(t) {
                                        var r = this._worker;
                                        !function(t) {
                                            function r(r, i) {
                                                e.readUint8Array(e.size - r, r, (function(e) {
                                                    for (var n = e.length - 22; n >= 0; n--)
                                                        if (80 === e[n] && 75 === e[n + 1] && 5 === e[n + 2] && 6 === e[n + 3])
                                                            return void t(new DataView(e.buffer,n,22));
                                                    i()
                                                }
                                                ), (function() {
                                                    n(R)
                                                }
                                                ))
                                            }
                                            e.size < 22 ? n(P) : r(22, (function() {
                                                r(Math.min(65558, e.size), (function() {
                                                    n(P)
                                                }
                                                ))
                                            }
                                            ))
                                        }((function(a) {
                                            var o, s;
                                            o = a.getUint32(16, !0),
                                            s = a.getUint16(8, !0),
                                            o < 0 || o >= e.size ? n(P) : e.readUint8Array(o, e.size - o, (function(e) {
                                                var a, o, l, c, u = 0, h = [], d = O(e.length, e);
                                                for (a = 0; a < s; a++) {
                                                    if ((o = new i)._worker = r,
                                                    1347092738 != d.view.getUint32(u))
                                                        return void n(P);
                                                    Y(o, d, u + 6, !0, n),
                                                    o.commentLength = d.view.getUint16(u + 32, !0),
                                                    o.directory = 16 == (16 & d.view.getUint8(u + 38)),
                                                    o.offset = d.view.getUint32(u + 42, !0),
                                                    l = X(d.array.subarray(u + 46, u + 46 + o.filenameLength)),
                                                    o.filename = 2048 == (2048 & o.bitFlag) ? q(l) : W(l),
                                                    o.directory || "/" != o.filename.charAt(o.filename.length - 1) || (o.directory = !0),
                                                    c = X(d.array.subarray(u + 46 + o.filenameLength + o.extraFieldLength, u + 46 + o.filenameLength + o.extraFieldLength + o.commentLength)),
                                                    o.comment = 2048 == (2048 & o.bitFlag) ? q(c) : W(c),
                                                    h.push(o),
                                                    u += 46 + o.filenameLength + o.extraFieldLength + o.commentLength
                                                }
                                                t(h)
                                            }
                                            ), (function() {
                                                n(R)
                                            }
                                            ))
                                        }
                                        ))
                                    },
                                    close: function(e) {
                                        this._worker && (this._worker.terminate(),
                                        this._worker = null),
                                        e && e()
                                    },
                                    _worker: null
                                };
                                ee.useWebWorkers ? Q("inflater", (function(e) {
                                    a._worker = e,
                                    t(a)
                                }
                                ), (function(e) {
                                    n(e)
                                }
                                )) : t(a)
                            }(e, t, n)
                        }
                        ), n = n || $)
                    },
                    createWriter: function(e, t, n, r) {
                        r = !!r,
                        e.init((function() {
                            !function(e, t, n, r) {
                                var i = {}
                                  , a = []
                                  , o = 0
                                  , s = 0;
                                function l(e) {
                                    n(e || "Error while writing zip file.")
                                }
                                function c(e) {
                                    n(e || "Error while reading file data.")
                                }
                                var u = {
                                    add: function(t, u, h, p, f) {
                                        var m, g, v, y = this._worker;
                                        function _(t, n) {
                                            var r = O(16);
                                            o += t || 0,
                                            r.view.setUint32(0, 1347094280),
                                            void 0 !== n && (m.view.setUint32(10, n, !0),
                                            r.view.setUint32(4, n, !0)),
                                            u && (r.view.setUint32(8, t, !0),
                                            m.view.setUint32(14, t, !0),
                                            r.view.setUint32(12, u.size, !0),
                                            m.view.setUint32(18, u.size, !0)),
                                            e.writeUint8Array(r.array, (function() {
                                                o += 16,
                                                h()
                                            }
                                            ), l)
                                        }
                                        function x() {
                                            var h;
                                            f = f || {},
                                            t = t.trim(),
                                            f.directory && "/" != t.charAt(t.length - 1) && (t += "/"),
                                            i.hasOwnProperty(t) ? n("File already exists.") : (g = J(Z(t)),
                                            a.push(t),
                                            v = f.lastModDate || new Date,
                                            m = O(26),
                                            i[t] = {
                                                headerArray: m.array,
                                                directory: f.directory,
                                                filename: g,
                                                offset: o,
                                                comment: J(Z(f.comment || ""))
                                            },
                                            m.view.setUint32(0, 335546376),
                                            f.version && m.view.setUint8(0, f.version),
                                            r || 0 === f.level || f.directory || m.view.setUint16(4, 2048),
                                            m.view.setUint16(6, (v.getHours() << 6 | v.getMinutes()) << 5 | v.getSeconds() / 2, !0),
                                            m.view.setUint16(8, (v.getFullYear() - 1980 << 4 | v.getMonth() + 1) << 5 | v.getDate(), !0),
                                            m.view.setUint16(22, g.length, !0),
                                            (h = O(30 + g.length)).view.setUint32(0, 1347093252),
                                            h.array.set(m.array, 4),
                                            h.array.set(g, 30),
                                            o += h.array.length,
                                            e.writeUint8Array(h.array, (function() {
                                                u ? r || 0 === f.level ? V(y, s++, u, e, 0, u.size, !0, _, p, c, l) : function(e, t, n, r, i, a, o, s, l) {
                                                    ee.useWebWorkers ? G(e, {
                                                        sn: t,
                                                        options: {
                                                            level: i
                                                        },
                                                        codecClass: "_zipjs_Deflater",
                                                        crcType: "input"
                                                    }, n, r, 0, n.size, o, a, s, l) : j(new d, n, r, 0, n.size, "input", o, a, s, l)
                                                }(y, s++, u, e, f.level, _, p, c, l) : _()
                                            }
                                            ), l))
                                        }
                                        u ? u.init(x, c) : x()
                                    },
                                    close: function(t) {
                                        this._worker && (this._worker.terminate(),
                                        this._worker = null);
                                        var n, r, s, c = 0, u = 0;
                                        for (r = 0; r < a.length; r++)
                                            c += 46 + (s = i[a[r]]).filename.length + s.comment.length;
                                        for (n = O(c + 22),
                                        r = 0; r < a.length; r++)
                                            s = i[a[r]],
                                            n.view.setUint32(u, 1347092738),
                                            n.view.setUint16(u + 4, 5120),
                                            n.array.set(s.headerArray, u + 6),
                                            n.view.setUint16(u + 32, s.comment.length, !0),
                                            s.directory && n.view.setUint8(u + 38, 16),
                                            n.view.setUint32(u + 42, s.offset, !0),
                                            n.array.set(s.filename, u + 46),
                                            n.array.set(s.comment, u + 46 + s.filename.length),
                                            u += 46 + s.filename.length + s.comment.length;
                                        n.view.setUint32(u, 1347093766),
                                        n.view.setUint16(u + 8, a.length, !0),
                                        n.view.setUint16(u + 10, a.length, !0),
                                        n.view.setUint32(u + 12, c, !0),
                                        n.view.setUint32(u + 16, o, !0),
                                        e.writeUint8Array(n.array, (function() {
                                            e.getData(t)
                                        }
                                        ), l)
                                    },
                                    _worker: null
                                };
                                ee.useWebWorkers ? Q("deflater", (function(e) {
                                    u._worker = e,
                                    t(u)
                                }
                                ), (function(e) {
                                    n(e)
                                }
                                )) : t(u)
                            }(e, t, n, r)
                        }
                        ), n = n || $)
                    },
                    useWebWorkers: !0,
                    workerScriptsPath: null,
                    workerScripts: null
                };
                var te, ne, re = ee.TextWriter, ie = ee.BlobWriter, ae = ee.Data64URIWriter, oe = ee.TextReader, se = ee.BlobReader, le = ee.Data64URIReader, ce = ee.createReader, ue = ee.createWriter;
                function he(e) {
                    var t, n = this;
                    n.size = 0,
                    n.init = function(t) {
                        n.size = e.uncompressedSize,
                        t()
                    }
                    ,
                    n.readUint8Array = function(r, i, a, o) {
                        !function(r) {
                            n.data ? r() : e.getData(new ie, (function(e) {
                                n.data = e,
                                t = new se(e),
                                r()
                            }
                            ), null, n.checkCrc32)
                        }((function() {
                            t.readUint8Array(r, i, a, o)
                        }
                        ))
                    }
                }
                function de(e) {
                    var t = 0;
                    return function e(n) {
                        t += n.uncompressedSize || 0,
                        n.children.forEach(e)
                    }(e),
                    t
                }
                function pe(e, t, n) {
                    var r = 0;
                    function i() {
                        ++r < e.children.length ? a(e.children[r]) : t()
                    }
                    function a(e) {
                        e.directory ? pe(e, i, n) : (e.reader = new e.Reader(e.data,n),
                        e.reader.init((function() {
                            e.uncompressedSize = e.reader.size,
                            i()
                        }
                        )))
                    }
                    e.children.length ? a(e.children[r]) : t()
                }
                function fe(e) {
                    var t = e.parent.children;
                    t.forEach((function(n, r) {
                        n.id == e.id && t.splice(r, 1)
                    }
                    ))
                }
                function me(e) {
                    e.entries = [],
                    e.root = new _e(e)
                }
                function ge(e, t, n, r) {
                    if (e.directory)
                        return r ? new _e(e.fs,t,n,e) : new ye(e.fs,t,n,e);
                    throw "Parent entry is not a directory."
                }
                function ve() {}
                function ye(e, t, n, r) {
                    ve.prototype.init.call(this, e, t, n, r),
                    this.Reader = n.Reader,
                    this.Writer = n.Writer,
                    this.data = n.data,
                    n.getData && (this.getData = n.getData)
                }
                function _e(e, t, n, r) {
                    ve.prototype.init.call(this, e, t, n, r),
                    this.directory = !0
                }
                function xe() {
                    me(this)
                }
                (he.prototype = new (0,
                ee.Reader)).constructor = he,
                he.prototype.checkCrc32 = !1,
                (ve.prototype = {
                    init: function(e, t, n, r) {
                        if (e.root && r && r.getChildByName(t))
                            throw "Entry filename already exists.";
                        n || (n = {}),
                        this.fs = e,
                        this.name = t,
                        this.id = e.entries.length,
                        this.parent = r,
                        this.children = [],
                        this.zipVersion = n.zipVersion || 20,
                        this.uncompressedSize = 0,
                        e.entries.push(this),
                        r && this.parent.children.push(this)
                    },
                    getFileEntry: function(e, t, n, r, i) {
                        var a = this;
                        pe(a, (function() {
                            !function(e, t, n, r, i, a, o) {
                                var s = 0;
                                t.directory ? function e(t, n, r, i, a, l) {
                                    var c = 0;
                                    !function u() {
                                        var h = n.children[c];
                                        h ? function(n) {
                                            function r(t) {
                                                s += n.uncompressedSize || 0,
                                                e(t, n, (function() {
                                                    c++,
                                                    u()
                                                }
                                                ), i, a, l)
                                            }
                                            n.directory ? t.getDirectory(n.name, {
                                                create: !0
                                            }, r, a) : t.getFile(n.name, {
                                                create: !0
                                            }, (function(e) {
                                                n.getData(new ee.FileWriter(e,ee.getMimeType(n.name)), r, (function(e) {
                                                    i && i(s + e, l)
                                                }
                                                ), o)
                                            }
                                            ), a)
                                        }(h) : r()
                                    }()
                                }(e, t, n, r, i, a) : t.getData(new ee.FileWriter(e,ee.getMimeType(t.name)), n, r, o)
                            }(e, a, t, n, r, de(a), i)
                        }
                        ), r)
                    },
                    moveTo: function(e) {
                        if (!e.directory)
                            throw "Target entry is not a directory.";
                        if (e.isDescendantOf(this))
                            throw "Entry is a ancestor of target entry.";
                        if (this != e) {
                            if (e.getChildByName(this.name))
                                throw "Entry filename already exists.";
                            fe(this),
                            this.parent = e,
                            e.children.push(this)
                        }
                    },
                    getFullname: function() {
                        for (var e = this.name, t = this.parent; t; )
                            e = (t.name ? t.name + "/" : "") + e,
                            t = t.parent;
                        return e
                    },
                    isDescendantOf: function(e) {
                        for (var t = this.parent; t && t.id != e.id; )
                            t = t.parent;
                        return !!t
                    }
                }).constructor = ve,
                ye.prototype = te = new ve,
                te.constructor = ye,
                te.getData = function(e, t, n, r) {
                    var i = this;
                    !e || e.constructor == i.Writer && i.data ? t(i.data) : (i.reader || (i.reader = new i.Reader(i.data,r)),
                    i.reader.init((function() {
                        e.init((function() {
                            !function(e, t, n, r, i) {
                                var a = 0;
                                !function o() {
                                    var s = 524288 * a;
                                    r && r(s, e.size),
                                    s < e.size ? e.readUint8Array(s, Math.min(524288, e.size - s), (function(e) {
                                        t.writeUint8Array(new Uint8Array(e), (function() {
                                            a++,
                                            o()
                                        }
                                        ))
                                    }
                                    ), i) : t.getData(n)
                                }()
                            }(i.reader, e, t, n, r)
                        }
                        ), r)
                    }
                    )))
                }
                ,
                te.getText = function(e, t, n, r) {
                    this.getData(new re(r), e, t, n)
                }
                ,
                te.getBlob = function(e, t, n, r) {
                    this.getData(new ie(e), t, n, r)
                }
                ,
                te.getData64URI = function(e, t, n, r) {
                    this.getData(new ae(e), t, n, r)
                }
                ,
                _e.prototype = ne = new ve,
                ne.constructor = _e,
                ne.addDirectory = function(e) {
                    return ge(this, e, null, !0)
                }
                ,
                ne.addText = function(e, t) {
                    return ge(this, e, {
                        data: t,
                        Reader: oe,
                        Writer: re
                    })
                }
                ,
                ne.addBlob = function(e, t) {
                    return ge(this, e, {
                        data: t,
                        Reader: se,
                        Writer: ie
                    })
                }
                ,
                ne.addData64URI = function(e, t) {
                    return ge(this, e, {
                        data: t,
                        Reader: le,
                        Writer: ae
                    })
                }
                ,
                ne.addFileEntry = function(e, t, n) {
                    !function(e, t, n, r) {
                        t.isDirectory ? function e(t, n, i) {
                            !function(e, t) {
                                e.isDirectory && e.createReader().readEntries(t),
                                e.isFile && t([])
                            }(n, (function(n) {
                                var a = 0;
                                !function o() {
                                    var s = n[a];
                                    s ? function(n) {
                                        function i(t) {
                                            e(t, n, (function() {
                                                a++,
                                                o()
                                            }
                                            ))
                                        }
                                        n.isDirectory && i(t.addDirectory(n.name)),
                                        n.isFile && n.file((function(e) {
                                            var r = t.addBlob(n.name, e);
                                            r.uncompressedSize = e.size,
                                            i(r)
                                        }
                                        ), r)
                                    }(s) : i()
                                }()
                            }
                            ))
                        }(e, t, n) : t.file((function(r) {
                            e.addBlob(t.name, r),
                            n()
                        }
                        ), r)
                    }(this, e, t, n)
                }
                ,
                ne.addData = function(e, t) {
                    return ge(this, e, t)
                }
                ,
                ne.importBlob = function(e, t, n) {
                    this.importZip(new se(e), t, n)
                }
                ,
                ne.importText = function(e, t, n) {
                    this.importZip(new oe(e), t, n)
                }
                ,
                ne.importData64URI = function(e, t, n) {
                    this.importZip(new le(e), t, n)
                }
                ,
                ne.exportBlob = function(e, t, n) {
                    this.exportZip(new ie("application/zip"), e, t, n)
                }
                ,
                ne.exportText = function(e, t, n) {
                    this.exportZip(new re, e, t, n)
                }
                ,
                ne.exportFileEntry = function(e, t, n, r) {
                    this.exportZip(new ee.FileWriter(e,"application/zip"), t, n, r)
                }
                ,
                ne.exportData64URI = function(e, t, n) {
                    this.exportZip(new ae("application/zip"), e, t, n)
                }
                ,
                ne.importZip = function(e, t, n) {
                    var r = this;
                    ce(e, (function(e) {
                        e.getEntries((function(e) {
                            e.forEach((function(e) {
                                var t = r
                                  , n = e.filename.split("/")
                                  , i = n.pop();
                                n.forEach((function(e) {
                                    t = t.getChildByName(e) || new _e(r.fs,e,null,t)
                                }
                                )),
                                e.directory || ge(t, i, {
                                    data: e,
                                    Reader: he
                                })
                            }
                            )),
                            t()
                        }
                        ))
                    }
                    ), n)
                }
                ,
                ne.exportZip = function(e, t, n, r) {
                    var i = this;
                    pe(i, (function() {
                        ue(e, (function(e) {
                            !function(e, t, n, r, i) {
                                var a = 0;
                                !function e(t, n, r, i, o) {
                                    var s = 0;
                                    !function l() {
                                        var c = n.children[s];
                                        c ? t.add(c.getFullname(), c.reader, (function() {
                                            a += c.uncompressedSize || 0,
                                            e(t, c, (function() {
                                                s++,
                                                l()
                                            }
                                            ), i, o)
                                        }
                                        ), (function(e) {
                                            i && i(a + e, o)
                                        }
                                        ), {
                                            directory: c.directory,
                                            version: c.zipVersion
                                        }) : r()
                                    }()
                                }(e, t, n, r, i)
                            }(e, i, (function() {
                                e.close(t)
                            }
                            ), n, de(i))
                        }
                        ), r)
                    }
                    ), r)
                }
                ,
                ne.getChildByName = function(e) {
                    var t, n;
                    for (t = 0; t < this.children.length; t++)
                        if ((n = this.children[t]).name == e)
                            return n
                }
                ,
                xe.prototype = {
                    remove: function(e) {
                        fe(e),
                        this.entries[e.id] = null
                    },
                    find: function(e) {
                        var t, n = e.split("/"), r = this.root;
                        for (t = 0; r && t < n.length; t++)
                            r = r.getChildByName(n[t]);
                        return r
                    },
                    getById: function(e) {
                        return this.entries[e]
                    },
                    importBlob: function(e, t, n) {
                        me(this),
                        this.root.importBlob(e, t, n)
                    },
                    importText: function(e, t, n) {
                        me(this),
                        this.root.importText(e, t, n)
                    },
                    importData64URI: function(e, t, n) {
                        me(this),
                        this.root.importData64URI(e, t, n)
                    },
                    exportBlob: function(e, t, n) {
                        this.root.exportBlob(e, t, n)
                    },
                    exportText: function(e, t, n) {
                        this.root.exportText(e, t, n)
                    },
                    exportFileEntry: function(e, t, n, r) {
                        this.root.exportFileEntry(e, t, n, r)
                    },
                    exportData64URI: function(e, t, n) {
                        this.root.exportData64URI(e, t, n)
                    }
                },
                ee.getMimeType = function() {
                    return "application/octet-stream"
                }
                ;
                var be = {
                    FS: xe,
                    ZipDirectoryEntry: _e,
                    ZipFileEntry: ye
                };
                ee.useWebWorkers = !1;
                var we = function() {
                    function e(e, t) {
                        this.el = e,
                        this.inputEl = t,
                        this.listeners = {
                            drop: [],
                            dropstart: [],
                            droperror: []
                        },
                        this._onDragover = this._onDragover.bind(this),
                        this._onDrop = this._onDrop.bind(this),
                        this._onSelect = this._onSelect.bind(this),
                        e.addEventListener("dragover", this._onDragover, !1),
                        e.addEventListener("drop", this._onDrop, !1),
                        t.addEventListener("change", this._onSelect)
                    }
                    var t = e.prototype;
                    return t.on = function(e, t) {
                        return this.listeners[e].push(t),
                        this
                    }
                    ,
                    t._emit = function(e, t) {
                        return this.listeners[e].forEach((function(e) {
                            return e(t)
                        }
                        )),
                        this
                    }
                    ,
                    t.destroy = function() {
                        var e = this.el
                          , t = this.inputEl;
                        e.removeEventListener(this._onDragover),
                        e.removeEventListener(this._onDrop),
                        t.removeEventListener(this._onSelect),
                        delete this.el,
                        delete this.inputEl,
                        delete this.listeners
                    }
                    ,
                    t._onDrop = function(e) {
                        e.stopPropagation(),
                        e.preventDefault(),
                        this._emit("dropstart");
                        var t = Array.from(e.dataTransfer.files || [])
                          , n = Array.from(e.dataTransfer.items || []);
                        if (0 !== t.length || 0 !== n.length)
                            if (n.length > 0) {
                                var r = n.map((function(e) {
                                    return e.webkitGetAsEntry()
                                }
                                ));
                                r[0].name.match(/\.zip$/) ? this._loadZip(n[0].getAsFile()) : this._loadNextEntry(new Map, r)
                            } else
                                1 === t.length && t[0].name.match(/\.zip$/) && this._loadZip(t[0]),
                                this._emit("drop", {
                                    files: new Map(t.map((function(e) {
                                        return [e.name, e]
                                    }
                                    )))
                                });
                        else
                            this._fail("Required drag-and-drop APIs are not supported in this browser.")
                    }
                    ,
                    t._onDragover = function(e) {
                        e.stopPropagation(),
                        e.preventDefault(),
                        e.dataTransfer.dropEffect = "copy"
                    }
                    ,
                    t._onSelect = function(e) {
                        this._emit("dropstart");
                        var t = [].slice.call(this.inputEl.files);
                        if (1 === t.length && this._isZip(t[0]))
                            this._loadZip(t[0]);
                        else {
                            var n = new Map;
                            t.forEach((function(e) {
                                return n.set(e.name, e)
                            }
                            )),
                            this._emit("drop", {
                                files: n
                            })
                        }
                    }
                    ,
                    t._loadNextEntry = function(e, t) {
                        var n = this
                          , r = t.pop();
                        if (r)
                            if (r.isFile)
                                r.file((function(i) {
                                    e.set(r.fullPath, i),
                                    n._loadNextEntry(e, t)
                                }
                                ), (function() {
                                    return console.error("Could not load file: %s", r.fullPath)
                                }
                                ));
                            else if (r.isDirectory) {
                                var i = r.createReader();
                                i.readEntries((function r(a) {
                                    a.length ? (t = t.concat(a),
                                    i.readEntries(r)) : n._loadNextEntry(e, t)
                                }
                                ))
                            } else
                                console.warn("Unknown asset type: " + r.fullPath),
                                this._loadNextEntry(e, t);
                        else
                            this._emit("drop", {
                                files: e
                            })
                    }
                    ,
                    t._loadZip = function(e) {
                        var t = this
                          , n = []
                          , r = new Map
                          , i = new be.FS;
                        i.importBlob(e, (function() {
                            !function e(t) {
                                t.directory ? t.children.forEach(e) : "." !== t.name[0] && n.push(new Promise((function(e) {
                                    t.getData(new ee.BlobWriter, (function(n) {
                                        n.name = t.name,
                                        r.set(t.getFullname(), n),
                                        e()
                                    }
                                    ))
                                }
                                )))
                            }(i.root),
                            Promise.all(n).then((function() {
                                t._emit("drop", {
                                    files: r,
                                    archive: e
                                })
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    t._isZip = function(e) {
                        return "application/zip" === e.type || e.name.match(/\.zip$/)
                    }
                    ,
                    t._fail = function(e) {
                        this._emit("droperror", {
                            message: e
                        })
                    }
                    ,
                    e
                }()
            }
            ,
            5268: (e,t,n)=>{
                var r;
                window,
                e.exports = (r = n(2212),
                function(e) {
                    var t = {};
                    function n(r) {
                        if (t[r])
                            return t[r].exports;
                        var i = t[r] = {
                            i: r,
                            l: !1,
                            exports: {}
                        };
                        return e[r].call(i.exports, i, i.exports, n),
                        i.l = !0,
                        i.exports
                    }
                    return n.m = e,
                    n.c = t,
                    n.d = function(e, t, r) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: r
                        })
                    }
                    ,
                    n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    n.t = function(e, t) {
                        if (1 & t && (e = n(e)),
                        8 & t)
                            return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule)
                            return e;
                        var r = Object.create(null);
                        if (n.r(r),
                        Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }),
                        2 & t && "string" != typeof e)
                            for (var i in e)
                                n.d(r, i, function(t) {
                                    return e[t]
                                }
                                .bind(null, i));
                        return r
                    }
                    ,
                    n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return n.d(t, "a", t),
                        t
                    }
                    ,
                    n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    n.p = "",
                    n(n.s = 1)
                }([function(e, t) {
                    e.exports = r
                }
                , function(e, t, n) {
                    "use strict";
                    var r, i = this && this.__extends || (r = function(e, t) {
                        return (r = Object.setPrototypeOf || {
                            __proto__: []
                        }instanceof Array && function(e, t) {
                            e.__proto__ = t
                        }
                        || function(e, t) {
                            for (var n in t)
                                t.hasOwnProperty(n) && (e[n] = t[n])
                        }
                        )(e, t)
                    }
                    ,
                    function(e, t) {
                        function n() {
                            this.constructor = e
                        }
                        r(e, t),
                        e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
                        new n)
                    }
                    ), a = this && this.__importStar || function(e) {
                        if (e && e.__esModule)
                            return e;
                        var t = {};
                        if (null != e)
                            for (var n in e)
                                Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                        return t.default = e,
                        t
                    }
                    ;
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                    var o = n(2)
                      , s = n(5)
                      , l = a(n(0))
                      , c = n(0);
                    l.Pass = function() {
                        this.enabled = !0,
                        this.needsSwap = !0,
                        this.clear = !1,
                        this.renderToScreen = !1
                    }
                    ,
                    Object.assign(l.Pass.prototype, {
                        setSize: function() {},
                        render: function() {
                            console.error("THREE.Pass: .render() must be implemented in derived pass.")
                        }
                    });
                    var u = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t._ = 0,
                            t.A = s.Utils.getInstance(),
                            t.needsUpdate = !0,
                            t.P = new c.Color,
                            t.F = new l.ShaderMaterial(o.supersampleShader),
                            t.needsSwap = !0,
                            t.needsUpdate = !0,
                            t
                        }
                        return i(t, e),
                        t.prototype.dispose = function() {
                            this.I && this.I.dispose(),
                            this.F.dispose()
                        }
                        ,
                        t.prototype.render = function(e, t, n) {
                            e.getClearColor(this.P);
                            var r = e.getClearAlpha()
                              , i = e.autoClear;
                            e.autoClear = !1,
                            e.setClearColor(new l.Color(0,0,0), 0),
                            this.needsUpdate && (this._ = 0,
                            this.needsUpdate = !1),
                            this.I || this.q(e),
                            this._++,
                            this.F.uniforms.sumIndex.value = this._,
                            this.F.uniforms.tDiffuse.value = n.texture,
                            this.F.uniforms.tAccPrevious.value = this.I.texture,
                            this.A.renderPass(e, this.F, t),
                            this.A.blit(e, t, this.I),
                            e.autoClear = i,
                            e.setClearColor(this.P, r)
                        }
                        ,
                        t.prototype.setSize = function(e, t) {
                            this.I && this.I.setSize(e, t)
                        }
                        ,
                        t.prototype.q = function(e) {
                            var t = {
                                minFilter: l.LinearFilter,
                                magFilter: l.LinearFilter,
                                format: l.RGBAFormat
                            }
                              , n = new l.Vector2;
                            e.getDrawingBufferSize(n),
                            this.I = new l.WebGLRenderTarget(n.width,n.height,t)
                        }
                        ,
                        t
                    }(l.Pass);
                    t.SuperSample = u
                }
                , function(e, t, n) {
                    "use strict";
                    var r = this && this.__importDefault || function(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    ;
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                    var i = r(n(3))
                      , a = r(n(4));
                    t.supersampleShader = {
                        uniforms: {
                            tAccPrevious: {
                                value: null
                            },
                            tDiffuse: {
                                value: null
                            },
                            sumIndex: {
                                value: 0
                            }
                        },
                        vertexShader: i.default,
                        fragmentShader: a.default
                    }
                }
                , function(e, t, n) {
                    "use strict";
                    n.r(t),
                    t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                }
                , function(e, t, n) {
                    "use strict";
                    n.r(t),
                    t.default = "varying vec2 vUv;\r\nuniform sampler2D tAccPrevious;\r\nuniform sampler2D tDiffuse;\r\nuniform float sumIndex;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(tDiffuse, vUv);\r\n    vec4 previousAccumulation = texture2D(tAccPrevious, vUv);\r\n    gl_FragColor = mix(previousAccumulation, color, 1./sumIndex);\r\n}\r\n    "
                }
                , function(e, t, n) {
                    var r;
                    window,
                    e.exports = (r = n(0),
                    function(e) {
                        var t = {};
                        function n(r) {
                            if (t[r])
                                return t[r].exports;
                            var i = t[r] = {
                                i: r,
                                l: !1,
                                exports: {}
                            };
                            return e[r].call(i.exports, i, i.exports, n),
                            i.l = !0,
                            i.exports
                        }
                        return n.m = e,
                        n.c = t,
                        n.d = function(e, t, r) {
                            n.o(e, t) || Object.defineProperty(e, t, {
                                enumerable: !0,
                                get: r
                            })
                        }
                        ,
                        n.r = function(e) {
                            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                value: "Module"
                            }),
                            Object.defineProperty(e, "__esModule", {
                                value: !0
                            })
                        }
                        ,
                        n.t = function(e, t) {
                            if (1 & t && (e = n(e)),
                            8 & t)
                                return e;
                            if (4 & t && "object" == typeof e && e && e.__esModule)
                                return e;
                            var r = Object.create(null);
                            if (n.r(r),
                            Object.defineProperty(r, "default", {
                                enumerable: !0,
                                value: e
                            }),
                            2 & t && "string" != typeof e)
                                for (var i in e)
                                    n.d(r, i, function(t) {
                                        return e[t]
                                    }
                                    .bind(null, i));
                            return r
                        }
                        ,
                        n.n = function(e) {
                            var t = e && e.__esModule ? function() {
                                return e.default
                            }
                            : function() {
                                return e
                            }
                            ;
                            return n.d(t, "a", t),
                            t
                        }
                        ,
                        n.o = function(e, t) {
                            return Object.prototype.hasOwnProperty.call(e, t)
                        }
                        ,
                        n.p = "",
                        n(n.s = 0)
                    }([function(e, t, n) {
                        "use strict";
                        var r = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = r(n(1))
                          , a = n(2)
                          , o = function() {
                            function e(e, t, n) {
                                this.u = e,
                                this.h = t,
                                this.v = n,
                                this.M = new Array(e);
                                for (var r = 0; r < e; r++)
                                    this.M[r] = new Array(t)
                            }
                            return e.prototype.j = function(e) {
                                var t = Math.floor(e.x / this.v)
                                  , n = Math.floor(e.y / this.v);
                                this.M[t][n] = e
                            }
                            ,
                            e.prototype.g = function(e, t) {
                                for (var n = Math.floor(e.x / this.v), r = Math.floor(e.y / this.v), i = n - 5; i < n + 5; i++)
                                    for (var a = r - 5; a < r + 5; a++)
                                        if (i >= 0 && i < this.u && a >= 0 && a < this.h) {
                                            var o = this.M[i][a]
                                              , s = 1e10;
                                            if (void 0 !== o && (s = o.distanceTo(e)),
                                            s < t)
                                                return !0
                                        }
                                return !1
                            }
                            ,
                            e
                        }()
                          , s = function() {
                            function e() {
                                var e = i.UniformsUtils.clone(a.copyShader.uniforms);
                                this.O = new i.ShaderMaterial({
                                    uniforms: e,
                                    vertexShader: a.copyShader.vertexShader,
                                    fragmentShader: a.copyShader.fragmentShader,
                                    depthWrite: !1,
                                    depthTest: !1
                                }),
                                this.C = new i.Scene,
                                this.S = new i.OrthographicCamera(-1,1,1,-1,0,1),
                                this.D = new i.Mesh(new i.PlaneGeometry(2,2),this.O),
                                this.D.frustumCulled = !1,
                                this.C.add(this.D)
                            }
                            return e.getInstance = function() {
                                return e.instance || (e.instance = new e),
                                e.instance
                            }
                            ,
                            e.prototype.renderPass = function(e, t, n, r) {
                                r = void 0 !== r && r,
                                this.D.material = t,
                                e.setRenderTarget(n),
                                r && e.clear(!0, !0, !1),
                                e.render(this.C, this.S),
                                e.setRenderTarget(null)
                            }
                            ,
                            e.prototype.blit = function(e, t, n, r) {
                                r = void 0 !== r && r,
                                this.O.uniforms.tDiffuse.value = t,
                                this.D.material = this.O,
                                e.setRenderTarget(n),
                                e.render(this.C, this.S),
                                e.setRenderTarget(null)
                            }
                            ,
                            e.prototype.randomizeArray = function(e) {
                                for (var t, n, r = e.length; 0 !== r; )
                                    n = Math.floor(Math.random() * r),
                                    t = e[r -= 1],
                                    e[r] = e[n],
                                    e[n] = t;
                                return e
                            }
                            ,
                            e.prototype.T = function(e) {
                                var t = Math.floor(Math.random() * e.length)
                                  , n = e[t];
                                return e.splice(t, 1),
                                n
                            }
                            ,
                            e.prototype.uniformDistribution = function() {
                                return 1
                            }
                            ,
                            e.prototype.insideRectangle = function(e, t, n, r) {
                                return n = void 0 !== n ? n : 1,
                                r = void 0 !== r ? r : 1,
                                e >= 0 && t >= 0 && e <= n && t <= r
                            }
                            ,
                            e.prototype.insideCircle = function(e, t, n) {
                                var r = e - .5
                                  , i = t - .5;
                                return r * r + i * i <= (n = void 0 !== n ? n : .5) * n
                            }
                            ,
                            e.prototype.U = function(e, t) {
                                var n = t * (Math.random() + 1)
                                  , r = 6.283185307178 * Math.random()
                                  , a = e.x + n * Math.cos(r)
                                  , o = e.y + n * Math.sin(r);
                                return new i.Vector2(a,o)
                            }
                            ,
                            e.prototype.generateQuasiRandomPoints = function(e, t, n, r) {
                                e = void 0 === e ? 30 : e,
                                t = void 0 === t ? -1 : t,
                                n = n || this.uniformDistribution,
                                r = r || this.insideCircle,
                                t < 0 && (t = Math.sqrt(e) / e);
                                var a = []
                                  , s = []
                                  , l = t / Math.sqrt(2)
                                  , c = Math.ceil(1 / l)
                                  , u = Math.ceil(1 / l)
                                  , h = new o(c,u,l)
                                  , d = new i.Vector2(.5,.5)
                                  , p = !1;
                                do {
                                    d.x = Math.random(),
                                    d.y = Math.random(),
                                    p = r(d.x, d.y)
                                } while (!p);
                                for (s.push(d),
                                a.push(d),
                                h.j(d); 0 !== s.length && a.length < e; )
                                    for (var f = this.T(s), m = 0; m < 30; m++) {
                                        var g = f.x - .5
                                          , v = f.y - .5
                                          , y = n(Math.sqrt(g * g + v * v))
                                          , _ = this.U(f, y * t);
                                        !r(_.x, _.y) || h.g(_, y * t) || (s.push(_),
                                        a.push(_),
                                        h.j(_))
                                    }
                                return a
                            }
                            ,
                            e
                        }();
                        t.Utils = s
                    }
                    , function(e, t) {
                        e.exports = r
                    }
                    , function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = r(n(3))
                          , a = r(n(4));
                        t.copyShader = {
                            uniforms: {
                                tDiffuse: {
                                    value: null
                                }
                            },
                            vertexShader: i.default,
                            fragmentShader: a.default
                        }
                    }
                    , function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                    }
                    , function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "uniform sampler2D tDiffuse;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    vec4 texel = texture2D(tDiffuse, vUv);\r\n    gl_FragColor = texel;\r\n\r\n}"
                    }
                    ]))
                }
                ]))
            }
            ,
            5351: (e,t,n)=>{
                var r;
                window,
                e.exports = (r = n(2212),
                function(e) {
                    var t = {};
                    function n(r) {
                        if (t[r])
                            return t[r].exports;
                        var i = t[r] = {
                            i: r,
                            l: !1,
                            exports: {}
                        };
                        return e[r].call(i.exports, i, i.exports, n),
                        i.l = !0,
                        i.exports
                    }
                    return n.m = e,
                    n.c = t,
                    n.d = function(e, t, r) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: r
                        })
                    }
                    ,
                    n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    n.t = function(e, t) {
                        if (1 & t && (e = n(e)),
                        8 & t)
                            return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule)
                            return e;
                        var r = Object.create(null);
                        if (n.r(r),
                        Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }),
                        2 & t && "string" != typeof e)
                            for (var i in e)
                                n.d(r, i, function(t) {
                                    return e[t]
                                }
                                .bind(null, i));
                        return r
                    }
                    ,
                    n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return n.d(t, "a", t),
                        t
                    }
                    ,
                    n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    n.p = "",
                    n(n.s = "./src/SAOPass.ts")
                }({
                    "./node_modules/gbuffer/dist/gbufferpass.js": function(e, t, n) {
                        var r;
                        window,
                        e.exports = (r = n("three"),
                        function(e) {
                            var t = {};
                            function n(r) {
                                if (t[r])
                                    return t[r].exports;
                                var i = t[r] = {
                                    i: r,
                                    l: !1,
                                    exports: {}
                                };
                                return e[r].call(i.exports, i, i.exports, n),
                                i.l = !0,
                                i.exports
                            }
                            return n.m = e,
                            n.c = t,
                            n.d = function(e, t, r) {
                                n.o(e, t) || Object.defineProperty(e, t, {
                                    enumerable: !0,
                                    get: r
                                })
                            }
                            ,
                            n.r = function(e) {
                                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                    value: "Module"
                                }),
                                Object.defineProperty(e, "__esModule", {
                                    value: !0
                                })
                            }
                            ,
                            n.t = function(e, t) {
                                if (1 & t && (e = n(e)),
                                8 & t)
                                    return e;
                                if (4 & t && "object" == typeof e && e && e.__esModule)
                                    return e;
                                var r = Object.create(null);
                                if (n.r(r),
                                Object.defineProperty(r, "default", {
                                    enumerable: !0,
                                    value: e
                                }),
                                2 & t && "string" != typeof e)
                                    for (var i in e)
                                        n.d(r, i, function(t) {
                                            return e[t]
                                        }
                                        .bind(null, i));
                                return r
                            }
                            ,
                            n.n = function(e) {
                                var t = e && e.__esModule ? function() {
                                    return e.default
                                }
                                : function() {
                                    return e
                                }
                                ;
                                return n.d(t, "a", t),
                                t
                            }
                            ,
                            n.o = function(e, t) {
                                return Object.prototype.hasOwnProperty.call(e, t)
                            }
                            ,
                            n.p = "",
                            n(n.s = "./src/GBufferPass.ts")
                        }({
                            "./src/GBufferPass.ts": function(e, t, n) {
                                "use strict";
                                var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                                    void 0 === r && (r = n),
                                    Object.defineProperty(e, r, {
                                        enumerable: !0,
                                        get: function() {
                                            return t[n]
                                        }
                                    })
                                }
                                : function(e, t, n, r) {
                                    void 0 === r && (r = n),
                                    e[r] = t[n]
                                }
                                )
                                  , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                                    Object.defineProperty(e, "default", {
                                        enumerable: !0,
                                        value: t
                                    })
                                }
                                : function(e, t) {
                                    e.default = t
                                }
                                )
                                  , a = this && this.__importStar || function(e) {
                                    if (e && e.__esModule)
                                        return e;
                                    var t = {};
                                    if (null != e)
                                        for (var n in e)
                                            "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                                    return i(t, e),
                                    t
                                }
                                ;
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }),
                                t.GBuffer = void 0;
                                var o, s = a(n("three")), l = n("./src/shaders/packDepth32Shader.ts"), c = n("./src/shaders/packDepthNormal16Shader.ts");
                                !function(e) {
                                    e[e.NONE = 0] = "NONE",
                                    e[e.DEPTH_NORMAL_16 = 1] = "DEPTH_NORMAL_16"
                                }(o || (o = {}));
                                var u = function() {
                                    function e(e) {
                                        this.u = !1,
                                        this.h = !1,
                                        e = e || {},
                                        this.v = void 0 === e.forceDepthAndNormalPass || e.forceDepthAndNormalPass,
                                        this.g = void 0 !== e.packingMode ? e.packingMode : o.DEPTH_NORMAL_16,
                                        this.j = new s.MeshNormalMaterial,
                                        this.N = new s.ShaderMaterial(c.packDepthNormal16Shader),
                                        this.k = void 0 === e.linearDepth || e.linearDepth,
                                        this.k ? (this.O = new s.ShaderMaterial(l.packDepth32Shader),
                                        this.v = !0) : (this.O = new s.MeshDepthMaterial,
                                        this.O.depthPacking = s.RGBADepthPacking),
                                        this._ = new s.Color(16777215)
                                    }
                                    return e.prototype.dispose = function() {
                                        this.M && this.M.dispose(),
                                        this.D && this.D.dispose(),
                                        this.F && this.F.dispose(),
                                        this.j.dispose(),
                                        this.N.dispose(),
                                        this.O.dispose()
                                    }
                                    ,
                                    e.prototype.setSize = function(e, t) {
                                        this.M && this.M.setSize(e, t),
                                        this.D && this.D.setSize(e, t),
                                        this.F && this.F.setSize(e, t)
                                    }
                                    ,
                                    e.prototype.hasLinearDepth = function() {
                                        return this.k
                                    }
                                    ,
                                    e.prototype.hasDepthTexture = function() {
                                        return this.h
                                    }
                                    ,
                                    e.prototype.isDepthAndNormalPassForced = function() {
                                        return this.v
                                    }
                                    ,
                                    e.prototype.getNormalDepthTexture = function() {
                                        var e;
                                        return this.D || (e = this.M ? this.M.texture : null),
                                        e
                                    }
                                    ,
                                    e.prototype.getDepthTexture = function() {
                                        return this.P ? this.P : this.D ? this.D.texture : null
                                    }
                                    ,
                                    e.prototype.getNormalTexture = function() {
                                        return this.F ? this.F.texture : null
                                    }
                                    ,
                                    e.prototype.getVelocityTexture = function() {
                                        throw new Error("Not implemented yet")
                                    }
                                    ,
                                    e.prototype.getPackingMode = function() {
                                        return this.g
                                    }
                                    ,
                                    e.prototype.render = function(e, t, n) {
                                        this.u || this.S(e);
                                        var r = e.getClearColor()
                                          , i = e.getClearAlpha()
                                          , a = e.autoClear
                                          , o = e.shadowMap.enabled
                                          , s = t.background;
                                        e.shadowMap.enabled = !1,
                                        e.autoClear = !1,
                                        t.background = this._,
                                        this.Z(e, t, n),
                                        e.autoClear = a,
                                        e.shadowMap.enabled = o,
                                        e.setClearColor(r, i),
                                        t.background = s
                                    }
                                    ,
                                    e.prototype.S = function(e) {
                                        var t = e.extensions
                                          , n = e.capabilities.isWebGL2 || t.get("WEBGL_depth_texture")
                                          , r = new s.Vector2;
                                        if (e.getDrawingBufferSize(r),
                                        !this.v && n && !this.F) {
                                            var i = {
                                                minFilter: s.NearestFilter,
                                                magFilter: s.NearestFilter,
                                                format: s.RGBAFormat
                                            };
                                            this.F = new s.WebGLRenderTarget(r.x,r.y,i),
                                            this.P || (this.P = new s.DepthTexture(r.x,r.y),
                                            this.P.type = s.UnsignedShortType),
                                            this.F.depthTexture = this.P
                                        }
                                        n && !this.v || (i = {
                                            minFilter: s.NearestFilter,
                                            magFilter: s.NearestFilter,
                                            format: s.RGBAFormat
                                        },
                                        this.g === o.NONE && (this.D || (this.D = new s.WebGLRenderTarget(r.x,r.y,i),
                                        this.D.depthTexture = this.P),
                                        this.F || (this.F = new s.WebGLRenderTarget(r.x,r.y,i),
                                        this.F.depthTexture = this.P)),
                                        this.g === o.DEPTH_NORMAL_16 && (this.M || (this.M = new s.WebGLRenderTarget(r.x,r.y,i),
                                        this.M.depthTexture = this.P))),
                                        this.u = !0
                                    }
                                    ,
                                    e.prototype.B = function(e) {
                                        var t = e.extensions;
                                        return this.h = e.capabilities.isWebGL2 || t.get("WEBGL_depth_texture"),
                                        this.h
                                    }
                                    ,
                                    e.prototype.Z = function(e, t, n) {
                                        !function(e) {
                                            e.traverse((function(e) {
                                                (e.isMesh || e.isLineSegments || e.isLine || e.isLineLoop || e.isPoints) && (e.material && e.material.transparent || e.castAO,
                                                (e.material && e.material.transparent && !e.material.isShadowMaterial || e.castAO || e.material.alphaTest > 0) && (e.aoVisibility = e.visible,
                                                e.visible = !1))
                                            }
                                            ))
                                        }(t);
                                        var r = this.B(e);
                                        r && !this.v && (t.overrideMaterial = this.j,
                                        e.setRenderTarget(this.F),
                                        e.clear(!0, !0, !1),
                                        e.render(t, n),
                                        e.setRenderTarget(null),
                                        t.overrideMaterial = null),
                                        r && !this.v || (this.g === o.NONE && (t.overrideMaterial = this.j,
                                        e.setRenderTarget(this.F),
                                        e.clear(!0, !0, !1),
                                        e.render(t, n),
                                        e.setRenderTarget(null),
                                        t.overrideMaterial = null,
                                        t.overrideMaterial = this.O,
                                        this.O.isMeshDepthMaterial || (this.O.uniforms.cameraNearFar.value.x = n.near,
                                        this.O.uniforms.cameraNearFar.value.y = n.far),
                                        e.setRenderTarget(this.D),
                                        e.clear(!0, !0, !1),
                                        e.render(t, n),
                                        e.setRenderTarget(null),
                                        t.overrideMaterial = null),
                                        this.g === o.DEPTH_NORMAL_16 && (t.overrideMaterial = this.N,
                                        this.N.uniforms.cameraNearFar.value.x = n.near,
                                        this.N.uniforms.cameraNearFar.value.y = n.far,
                                        e.setRenderTarget(this.M),
                                        e.clear(!0, !0, !1),
                                        e.render(t, n),
                                        e.setRenderTarget(null),
                                        t.overrideMaterial = null)),
                                        function(e) {
                                            e.traverse((function(e) {
                                                e.aoVisibility && (e.visible = e.aoVisibility,
                                                e.aoVisibility = void 0)
                                            }
                                            ))
                                        }(t)
                                    }
                                    ,
                                    e.PackingMode = o,
                                    e
                                }();
                                t.GBuffer = u
                            },
                            "./src/shaders/packDepth32.frag": function(e, t, n) {
                                "use strict";
                                n.r(t),
                                t.default = "#include <packing>\r\nuniform vec2 cameraNearFar;\r\nvarying vec3 viewPosition;\r\n\r\nfloat linstep(float edge0, float edge1, float value){\r\n    return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);\r\n    vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));\r\n    gl_FragColor = packedZ;\r\n}"
                            },
                            "./src/shaders/packDepth32.vert": function(e, t, n) {
                                "use strict";
                                n.r(t),
                                t.default = "varying vec3 viewPosition;\r\nvoid main() {\r\n    viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}"
                            },
                            "./src/shaders/packDepth32Shader.ts": function(e, t, n) {
                                "use strict";
                                var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                                    void 0 === r && (r = n),
                                    Object.defineProperty(e, r, {
                                        enumerable: !0,
                                        get: function() {
                                            return t[n]
                                        }
                                    })
                                }
                                : function(e, t, n, r) {
                                    void 0 === r && (r = n),
                                    e[r] = t[n]
                                }
                                )
                                  , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                                    Object.defineProperty(e, "default", {
                                        enumerable: !0,
                                        value: t
                                    })
                                }
                                : function(e, t) {
                                    e.default = t
                                }
                                )
                                  , a = this && this.__importStar || function(e) {
                                    if (e && e.__esModule)
                                        return e;
                                    var t = {};
                                    if (null != e)
                                        for (var n in e)
                                            "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                                    return i(t, e),
                                    t
                                }
                                  , o = this && this.__importDefault || function(e) {
                                    return e && e.__esModule ? e : {
                                        default: e
                                    }
                                }
                                ;
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }),
                                t.packDepth32Shader = void 0;
                                var s = o(n("./src/shaders/packDepth32.vert"))
                                  , l = o(n("./src/shaders/packDepth32.frag"))
                                  , c = a(n("three"));
                                t.packDepth32Shader = {
                                    uniforms: {
                                        cameraNearFar: {
                                            type: "v2",
                                            value: new c.Vector2
                                        }
                                    },
                                    vertexShader: s.default,
                                    fragmentShader: l.default
                                }
                            },
                            "./src/shaders/packDepthNormal16.frag": function(e, t, n) {
                                "use strict";
                                n.r(t),
                                t.default = "varying vec3 viewNormal;\r\nuniform vec2 cameraNearFar;\r\nvarying vec3 viewPosition;\r\n\r\nvec2 pack16(float value) {\r\n    float sMax = 65535.0;\r\n    int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);\r\n    int digit0 = v/256;\r\n    int digit1 = v-digit0*256;\r\n    return vec2(float(digit0)/255.0, float(digit1)/255.0);\r\n}\r\n\r\nvec2 packNormal(vec3 n){\r\n    float p = sqrt(n.z*8.0+8.0);\r\n    return vec2(n.xy/p + 0.5);\r\n}\r\n\r\nfloat linstep(float edge0, float edge1, float value) {\r\n    return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);\r\n    vec2 packedZ = pack16(pow(linearZ, 0.5));\r\n    vec2 packedNormal = packNormal(normalize(viewNormal));\r\n    gl_FragColor = vec4(packedZ.x, packedZ.y, packedNormal.x, packedNormal.y);\r\n}"
                            },
                            "./src/shaders/packDepthNormal16.vert": function(e, t, n) {
                                "use strict";
                                n.r(t),
                                t.default = "varying vec3 viewNormal;\r\nvarying vec3 viewPosition;\r\nvoid main() {\r\n    viewNormal = normalMatrix * normal;\r\n    viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}"
                            },
                            "./src/shaders/packDepthNormal16Shader.ts": function(e, t, n) {
                                "use strict";
                                var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                                    void 0 === r && (r = n),
                                    Object.defineProperty(e, r, {
                                        enumerable: !0,
                                        get: function() {
                                            return t[n]
                                        }
                                    })
                                }
                                : function(e, t, n, r) {
                                    void 0 === r && (r = n),
                                    e[r] = t[n]
                                }
                                )
                                  , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                                    Object.defineProperty(e, "default", {
                                        enumerable: !0,
                                        value: t
                                    })
                                }
                                : function(e, t) {
                                    e.default = t
                                }
                                )
                                  , a = this && this.__importStar || function(e) {
                                    if (e && e.__esModule)
                                        return e;
                                    var t = {};
                                    if (null != e)
                                        for (var n in e)
                                            "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                                    return i(t, e),
                                    t
                                }
                                  , o = this && this.__importDefault || function(e) {
                                    return e && e.__esModule ? e : {
                                        default: e
                                    }
                                }
                                ;
                                Object.defineProperty(t, "__esModule", {
                                    value: !0
                                }),
                                t.packDepthNormal16Shader = void 0;
                                var s = o(n("./src/shaders/packDepthNormal16.vert"))
                                  , l = o(n("./src/shaders/packDepthNormal16.frag"))
                                  , c = a(n("three"));
                                t.packDepthNormal16Shader = {
                                    uniforms: {
                                        cameraNearFar: {
                                            type: "v2",
                                            value: new c.Vector2
                                        }
                                    },
                                    vertexShader: s.default,
                                    fragmentShader: l.default
                                }
                            },
                            three: function(e, t) {
                                e.exports = r
                            }
                        }))
                    },
                    "./node_modules/pixotronicsutils/dist/pixotronicsutils.js": function(e, t, n) {
                        var r;
                        window,
                        e.exports = (r = n("three"),
                        function(e) {
                            var t = {};
                            function n(r) {
                                if (t[r])
                                    return t[r].exports;
                                var i = t[r] = {
                                    i: r,
                                    l: !1,
                                    exports: {}
                                };
                                return e[r].call(i.exports, i, i.exports, n),
                                i.l = !0,
                                i.exports
                            }
                            return n.m = e,
                            n.c = t,
                            n.d = function(e, t, r) {
                                n.o(e, t) || Object.defineProperty(e, t, {
                                    enumerable: !0,
                                    get: r
                                })
                            }
                            ,
                            n.r = function(e) {
                                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                    value: "Module"
                                }),
                                Object.defineProperty(e, "__esModule", {
                                    value: !0
                                })
                            }
                            ,
                            n.t = function(e, t) {
                                if (1 & t && (e = n(e)),
                                8 & t)
                                    return e;
                                if (4 & t && "object" == typeof e && e && e.__esModule)
                                    return e;
                                var r = Object.create(null);
                                if (n.r(r),
                                Object.defineProperty(r, "default", {
                                    enumerable: !0,
                                    value: e
                                }),
                                2 & t && "string" != typeof e)
                                    for (var i in e)
                                        n.d(r, i, function(t) {
                                            return e[t]
                                        }
                                        .bind(null, i));
                                return r
                            }
                            ,
                            n.n = function(e) {
                                var t = e && e.__esModule ? function() {
                                    return e.default
                                }
                                : function() {
                                    return e
                                }
                                ;
                                return n.d(t, "a", t),
                                t
                            }
                            ,
                            n.o = function(e, t) {
                                return Object.prototype.hasOwnProperty.call(e, t)
                            }
                            ,
                            n.p = "",
                            n(n.s = 0)
                        }([function(e, t, n) {
                            "use strict";
                            var r = this && this.__importStar || function(e) {
                                if (e && e.__esModule)
                                    return e;
                                var t = {};
                                if (null != e)
                                    for (var n in e)
                                        Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                                return t.default = e,
                                t
                            }
                            ;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            });
                            var i = r(n(1))
                              , a = n(2)
                              , o = function() {
                                function e(e, t, n) {
                                    this.u = e,
                                    this.h = t,
                                    this.v = n,
                                    this.M = new Array(e);
                                    for (var r = 0; r < e; r++)
                                        this.M[r] = new Array(t)
                                }
                                return e.prototype.j = function(e) {
                                    var t = Math.floor(e.x / this.v)
                                      , n = Math.floor(e.y / this.v);
                                    this.M[t][n] = e
                                }
                                ,
                                e.prototype.g = function(e, t) {
                                    for (var n = Math.floor(e.x / this.v), r = Math.floor(e.y / this.v), i = n - 5; i < n + 5; i++)
                                        for (var a = r - 5; a < r + 5; a++)
                                            if (i >= 0 && i < this.u && a >= 0 && a < this.h) {
                                                var o = this.M[i][a]
                                                  , s = 1e10;
                                                if (void 0 !== o && (s = o.distanceTo(e)),
                                                s < t)
                                                    return !0
                                            }
                                    return !1
                                }
                                ,
                                e
                            }()
                              , s = function() {
                                function e() {
                                    var e = i.UniformsUtils.clone(a.copyShader.uniforms);
                                    this.O = new i.ShaderMaterial({
                                        uniforms: e,
                                        vertexShader: a.copyShader.vertexShader,
                                        fragmentShader: a.copyShader.fragmentShader,
                                        depthWrite: !1,
                                        depthTest: !1
                                    }),
                                    this._ = new i.Scene,
                                    this.S = new i.OrthographicCamera(-1,1,1,-1,0,1),
                                    this.D = new i.Mesh(new i.PlaneGeometry(2,2),this.O),
                                    this.D.frustumCulled = !1,
                                    this._.add(this.D)
                                }
                                return e.getInstance = function() {
                                    return e.instance || (e.instance = new e),
                                    e.instance
                                }
                                ,
                                e.prototype.renderPass = function(e, t, n, r) {
                                    r = void 0 !== r && r,
                                    this.D.material = t,
                                    e.setRenderTarget(n),
                                    r && e.clear(!0, !0, !1),
                                    e.render(this._, this.S),
                                    e.setRenderTarget(null)
                                }
                                ,
                                e.prototype.blit = function(e, t, n, r) {
                                    r = void 0 !== r && r,
                                    this.O.uniforms.tDiffuse.value = t.texture,
                                    this.D.material = this.O,
                                    e.setRenderTarget(n),
                                    e.render(this._, this.S),
                                    e.setRenderTarget(null)
                                }
                                ,
                                e.prototype.randomizeArray = function(e) {
                                    for (var t, n, r = e.length; 0 !== r; )
                                        n = Math.floor(Math.random() * r),
                                        t = e[r -= 1],
                                        e[r] = e[n],
                                        e[n] = t;
                                    return e
                                }
                                ,
                                e.prototype.U = function(e) {
                                    var t = Math.floor(Math.random() * e.length)
                                      , n = e[t];
                                    return e.splice(t, 1),
                                    n
                                }
                                ,
                                e.prototype.uniformDistribution = function() {
                                    return 1
                                }
                                ,
                                e.prototype.insideRectangle = function(e, t, n, r) {
                                    return n = void 0 !== n ? n : 1,
                                    r = void 0 !== r ? r : 1,
                                    e >= 0 && t >= 0 && e <= n && t <= r
                                }
                                ,
                                e.prototype.insideCircle = function(e, t, n) {
                                    var r = e - .5
                                      , i = t - .5;
                                    return r * r + i * i <= (n = void 0 !== n ? n : .5) * n
                                }
                                ,
                                e.prototype.q = function(e, t) {
                                    var n = t * (Math.random() + 1)
                                      , r = 6.283185307178 * Math.random()
                                      , a = e.x + n * Math.cos(r)
                                      , o = e.y + n * Math.sin(r);
                                    return new i.Vector2(a,o)
                                }
                                ,
                                e.prototype.generateQuasiRandomPoints = function(e, t, n, r) {
                                    e = void 0 === e ? 30 : e,
                                    t = void 0 === t ? -1 : t,
                                    n = n || this.uniformDistribution,
                                    r = r || this.insideCircle,
                                    t < 0 && (t = Math.sqrt(e) / e);
                                    var a = []
                                      , s = []
                                      , l = t / Math.sqrt(2)
                                      , c = Math.ceil(1 / l)
                                      , u = Math.ceil(1 / l)
                                      , h = new o(c,u,l)
                                      , d = new i.Vector2(.5,.5)
                                      , p = !1;
                                    do {
                                        d.x = Math.random(),
                                        d.y = Math.random(),
                                        p = r(d.x, d.y)
                                    } while (!p);
                                    for (s.push(d),
                                    a.push(d),
                                    h.j(d); 0 !== s.length && a.length < e; )
                                        for (var f = this.U(s), m = 0; m < 30; m++) {
                                            var g = f.x - .5
                                              , v = f.y - .5
                                              , y = n(Math.sqrt(g * g + v * v))
                                              , _ = this.q(f, y * t);
                                            !r(_.x, _.y) || h.g(_, y * t) || (s.push(_),
                                            a.push(_),
                                            h.j(_))
                                        }
                                    return a
                                }
                                ,
                                e
                            }();
                            t.Utils = s
                        }
                        , function(e, t) {
                            e.exports = r
                        }
                        , function(e, t, n) {
                            "use strict";
                            var r = this && this.__importDefault || function(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                }
                            }
                            ;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            });
                            var i = r(n(3))
                              , a = r(n(4));
                            t.copyShader = {
                                uniforms: {
                                    tDiffuse: {
                                        value: null
                                    }
                                },
                                vertexShader: i.default,
                                fragmentShader: a.default
                            }
                        }
                        , function(e, t, n) {
                            "use strict";
                            n.r(t),
                            t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                        }
                        , function(e, t, n) {
                            "use strict";
                            n.r(t),
                            t.default = "uniform sampler2D tDiffuse;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    vec4 texel = texture2D(tDiffuse, vUv);\r\n    gl_FragColor = texel;\r\n\r\n}"
                        }
                        ]))
                    },
                    "./src/BilateralFilterPass.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = r(n("three"))
                          , a = n("./node_modules/pixotronicsutils/dist/pixotronicsutils.js")
                          , o = n("./src/shaders/saoBilateralFilterShader.ts")
                          , s = function() {
                            function e() {
                                this.R = a.Utils.getInstance(),
                                this.A = 3,
                                this.V = 1,
                                this.W = new i.ShaderMaterial(o.saoBilateralFilterShader),
                                this.W.uniforms = i.UniformsUtils.clone(this.W.uniforms),
                                this.W.defines = Object.assign({}, this.W.defines),
                                this.W.defines.USE_NORMAL_WEIGHT = 1
                            }
                            return e.prototype.render = function(e, t, n, r) {
                                this.T(e),
                                this.L(e, t, n, r)
                            }
                            ,
                            e.prototype.setEdgeSharpness = function(e) {
                                this.V = e
                            }
                            ,
                            e.prototype.setSize = function(e, t) {
                                this.C && this.C.setSize(e, t),
                                this.W.uniforms.size.value.set(e, t)
                            }
                            ,
                            e.prototype.dispose = function() {
                                this.C && (this.C.dispose(),
                                this.C = null),
                                this.W.dispose()
                            }
                            ,
                            e.prototype.T = function(e) {
                                if (!this.C) {
                                    var t = new i.Vector2;
                                    e.getDrawingBufferSize(t);
                                    var n = {
                                        minFilter: i.NearestFilter,
                                        magFilter: i.NearestFilter,
                                        format: i.RGBAFormat
                                    };
                                    this.C = new i.WebGLRenderTarget(t.x,t.y,n)
                                }
                            }
                            ,
                            e.prototype.L = function(e, t, n, r) {
                                var a = new i.Vector2;
                                e.getDrawingBufferSize(a),
                                this.W.uniforms.size.value.set(a.x, a.y);
                                var o = r.getNormalTexture()
                                  , s = r.getNormalDepthTexture();
                                s ? (this.W.defines.DEPTH_NORMAL_TEXTURE = 1,
                                this.W.uniforms.tNormal.value = s) : this.W.uniforms.tNormal.value = o,
                                this.W.defines.KERNEL_SAMPLE_RADIUS = this.blurKernelSize,
                                this.W.defines.LINEAR_DEPTH = r.hasLinearDepth() ? 1 : 0,
                                this.W.uniforms.tOcclusionDepth.value = t.texture,
                                this.W.uniforms.kernelDirection.value = new i.Vector2(1,0),
                                this.W.uniforms.edgeSharpness.value = this.V;
                                var l = this.W.uniforms.cameraNearFar.value;
                                l.x = n.near,
                                l.y = n.far,
                                this.R.renderPass(e, this.W, this.C),
                                this.W.uniforms.tOcclusionDepth.value = this.C.texture,
                                this.W.uniforms.kernelDirection.value = new i.Vector2(0,1),
                                this.R.renderPass(e, this.W, t)
                            }
                            ,
                            e
                        }();
                        t.BilateralFilterPass = s
                    },
                    "./src/SAOPass.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = r(n("three"))
                          , a = n("./node_modules/pixotronicsutils/dist/pixotronicsutils.js")
                          , o = n("./node_modules/gbuffer/dist/gbufferpass.js")
                          , s = n("./src/shaders/saoshader.ts")
                          , l = n("./src/BilateralFilterPass.ts")
                          , c = n("three")
                          , u = function() {
                            function e(e) {
                                this.R = a.Utils.getInstance(),
                                this.I = new c.Color,
                                e = e || {},
                                this.G = void 0 !== e.intensity ? e.intensity : .25,
                                this.occlusionWorldRadius = void 0 !== e.occlusionWorldRadius ? e.occlusionWorldRadius : .8,
                                this.H = void 0 !== e.bias ? e.bias : .001,
                                this.K = void 0 !== e.downscaleLevel ? e.downscaleLevel : 1,
                                this.K = this.K < 1 ? 1 : this.K,
                                this.falloff = void 0 !== e.falloff ? e.falloff : 1,
                                this.blurEnabled = void 0 === e.blurEnabled || e.blurEnabled,
                                this.edgeSharpness = .3,
                                this.debug = !1,
                                this.X = !0,
                                this.needsUpdate = !0,
                                this.J = new i.ShaderMaterial(s.saoShader),
                                this.J.uniforms = i.UniformsUtils.clone(this.J.uniforms),
                                this.J.defines = Object.assign({}, this.J.defines),
                                this.Y = 0,
                                this.$ = new l.BilateralFilterPass
                            }
                            return Object.defineProperty(e.prototype, "enabled", {
                                get: function() {
                                    return this.X
                                },
                                set: function(e) {
                                    this.X = e
                                },
                                enumerable: !0,
                                configurable: !0
                            }),
                            Object.defineProperty(e.prototype, "blur", {
                                get: function() {
                                    return this.blurEnabled
                                },
                                set: function(e) {
                                    this.blurEnabled = e
                                },
                                enumerable: !0,
                                configurable: !0
                            }),
                            Object.defineProperty(e.prototype, "intensity", {
                                get: function() {
                                    return this.G
                                },
                                set: function(e) {
                                    this.G = e
                                },
                                enumerable: !0,
                                configurable: !0
                            }),
                            Object.defineProperty(e.prototype, "radius", {
                                get: function() {
                                    return this.occlusionWorldRadius
                                },
                                set: function(e) {
                                    this.occlusionWorldRadius = e
                                },
                                enumerable: !0,
                                configurable: !0
                            }),
                            Object.defineProperty(e.prototype, "bias", {
                                get: function() {
                                    return this.H
                                },
                                set: function(e) {
                                    this.H = e
                                },
                                enumerable: !0,
                                configurable: !0
                            }),
                            e.prototype.getRenderTarget = function() {
                                return this.ee
                            }
                            ,
                            e.prototype.dispose = function() {
                                this.ee && (this.ee.dispose(),
                                this.ee = null,
                                this.J.dispose())
                            }
                            ,
                            e.prototype.setDownscaleLevel = function(e) {
                                this.K = e || 1,
                                this.K = this.K < 1 ? 1 : this.K,
                                this.needsUpdate = !0
                            }
                            ,
                            e.prototype.setSize = function(e, t) {
                                this.ee && (this.ee.setSize(e, t),
                                this.$.setSize(e, t)),
                                this.J.uniforms.size.value.set(e, t)
                            }
                            ,
                            e.prototype.convergenceMetric = function() {
                                return this.X ? this.Y > 1 ? 1 : 0 : 1
                            }
                            ,
                            e.prototype.render = function(e, t, n) {
                                if (this.X) {
                                    this.needsUpdate && (this.Y = 0,
                                    this.needsUpdate = !1),
                                    this.ee || this.T(e);
                                    var r = new i.Vector2;
                                    e.getDrawingBufferSize(r);
                                    var a = r.x / this.K
                                      , o = r.y / this.K;
                                    this.J.uniforms.size.value.set(a, o),
                                    this.te(a, o),
                                    this.ne(t, n),
                                    e.getClearColor(this.I);
                                    var s = e.getClearAlpha()
                                      , l = e.autoClear;
                                    e.autoClear = !1,
                                    this.R.renderPass(e, this.J, this.ee, !0),
                                    this.blurEnabled && (this.$.setEdgeSharpness(this.edgeSharpness),
                                    this.$.render(e, this.ee, t, n)),
                                    e.autoClear = l,
                                    e.setClearColor(this.I),
                                    e.setClearAlpha(s)
                                }
                            }
                            ,
                            e.prototype.T = function(e) {
                                var t = new i.Vector2;
                                e.getDrawingBufferSize(t);
                                var n = t.x / this.K
                                  , r = t.y / this.K;
                                if (!this.ee) {
                                    var a = {
                                        minFilter: i.NearestFilter,
                                        magFilter: i.NearestFilter,
                                        format: i.RGBAFormat
                                    };
                                    this.ee = new i.WebGLRenderTarget(n,r,a)
                                }
                            }
                            ,
                            e.prototype.te = function(e, t) {
                                (this.ee.width !== e || this.ee.height !== t) && this.ee.setSize(e, t)
                            }
                            ,
                            e.prototype.ne = function(e, t) {
                                var n = 1 / (2 * Math.tan(i.MathUtils.DEG2RAD * e.fov / 2))
                                  , r = this.J.uniforms.saoData.value;
                                r.x = n,
                                r.y = this.G,
                                r.z = this.occlusionWorldRadius,
                                r.w = this.Y++;
                                var a = this.J.uniforms.saoBiasEpsilon.value;
                                a.x = this.H,
                                a.y = .001,
                                a.z = this.falloff;
                                var s = this.J.uniforms.cameraNearFar.value;
                                s.x = e.near,
                                s.y = e.far,
                                this.J.uniforms.ProjectionMatrix.value = e.projectionMatrix;
                                var l = t.getDepthTexture()
                                  , c = t.getNormalTexture()
                                  , u = t.getNormalDepthTexture()
                                  , h = t.hasDepthTexture() ? 0 : 1;
                                t.isDepthAndNormalPassForced() && t.getPackingMode() === o.GBuffer.PackingMode.DEPTH_NORMAL_16 && (h = 2),
                                this.J.defines.DEPTH_PACKING_MODE = h,
                                this.J.defines.DEPTH_NORMAL_TEXTURE = u ? 1 : 0,
                                this.J.defines.LINEAR_DEPTH = t.hasLinearDepth() ? 1 : 0,
                                u ? this.J.uniforms.tNormalDepth.value = u : (this.J.uniforms.tNormal.value = c,
                                this.J.uniforms.tDepth.value = l)
                            }
                            ,
                            e
                        }();
                        t.SAOPass = u
                    },
                    "./src/shaders/bilateral_fragment.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = " #include <common>\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform sampler2D tOcclusionDepth;\r\nuniform sampler2D tNormal;\r\nuniform vec2 size;\r\n\r\nuniform vec2 cameraNearFar;\r\nuniform float edgeSharpness;\r\n\r\nuniform vec2 kernelDirection;\r\n\r\n#include <packing>\r\n\r\nfloat getViewZ( const in float depth ) {\r\n\r\n    #if PERSPECTIVE_CAMERA == 1\r\n        return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\r\n    #else\r\n        return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\r\n    #endif\r\n\r\n}\r\n\r\nvec3 unpackNormal(vec2 enc) {\r\n    vec2 fenc = enc*4.0-2.0;\r\n    float f = dot(fenc,fenc);\r\n    float g = sqrt(1.0-f/4.0);\r\n    return vec3(fenc*g, 1.0-f/2.0);\r\n}\r\n\r\nvec3 getViewNormal( const in vec2 uv ) {\r\n    #if DEPTH_NORMAL_TEXTURE == 1\r\n        return unpackNormal( texture2D( tNormal, uv ).zw );\r\n    #else\r\n        return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\r\n    #endif\r\n}\r\n        \r\nfloat linearStep(float edge0, float edge1, float value){\r\n    return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\r\n}\r\n\r\nfloat unpackRGBToFloat(const in vec3 x) {\r\n    const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);\r\n    return dot(x, decode);\r\n}\r\n\r\nvoid calculateBilateralWeight( const in vec2 uv, const in vec3 centreNormal, const in float centerDepth,\r\n    const in float kernelWeight, inout float totalOcclusion, inout float totalBilateralWeight ) {\r\n\r\n    vec4 aoDepth = texture2D( tOcclusionDepth, uv );\r\n    float occlusion = aoDepth.r;\r\n\r\n    float depth = unpackRGBToFloat( aoDepth.gba ); \r\n\r\n    if( depth >= ( 1.0 - EPSILON ) ) {\r\n        return;\r\n    }\r\n\r\n    vec3 normal = getViewNormal(uv);\r\n\r\n    #if LINEAR_DEPTH == 0\r\n        depth = -getViewZ( depth );\r\n        depth = linearStep(cameraNearFar.x, cameraNearFar.y, depth);\r\n    #endif\r\n    \r\n    float normalWeight = 1.;\r\n\r\n    #if USE_NORMAL_WEIGHT == 1\r\n        float normalCloseness = dot(normal, centreNormal);\r\n        normalCloseness *= normalCloseness;\r\n        float normalError = (1.0 - normalCloseness) * 8.;\r\n        normalWeight = max((1.0 - normalError * edgeSharpness), 0.00);\r\n    #endif\r\n\r\n    float depthWeight = max(0.0, 1.0 - edgeSharpness * 4000. * abs(depth - centerDepth)) * kernelWeight;\r\n\r\n    float bilateralWeight = depthWeight * normalWeight;\r\n\r\n    totalOcclusion += occlusion * bilateralWeight;\r\n    totalBilateralWeight += bilateralWeight;\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec4 aoDepth = texture2D( tOcclusionDepth, vUv );\r\n    float occlusion = aoDepth.r;\r\n\r\n    float depth = unpackRGBToFloat( aoDepth.gba );\r\n\r\n    if( depth >= ( 1.0 - EPSILON ) ) {\r\n        discard;\r\n    }\r\n\r\n    vec3 centreNormal = getViewNormal(vUv);\r\n\r\n    #if LINEAR_DEPTH == 0\r\n        float centerViewZ = -getViewZ( depth );\r\n        centerViewZ = linearStep(cameraNearFar.x, cameraNearFar.y, centerViewZ);\r\n    #else\r\n        float centerViewZ = depth;\r\n    #endif\r\n\r\n    float gaussianWeights[4];\r\n    gaussianWeights[0] = 0.153170;\r\n    gaussianWeights[1] = 0.144893;\r\n    gaussianWeights[2] = 0.122649;\r\n    gaussianWeights[3] = 0.092902;\r\n\r\n    float totalBilateralWeight = gaussianWeights[0] + 0.03;\r\n    float totalOcclusion = occlusion * totalBilateralWeight;\r\n\r\n    vec2 uvDelta = 2.0 * kernelDirection / size;\r\n\r\n    float kernelWeight = gaussianWeights[1] + 0.03;\r\n    calculateBilateralWeight( vUv + uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );\r\n    calculateBilateralWeight( vUv - uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );\r\n\r\n    kernelWeight = gaussianWeights[2] + 0.03;\r\n    calculateBilateralWeight( vUv + 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );\r\n    calculateBilateralWeight( vUv - 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );\r\n\r\n    kernelWeight = gaussianWeights[3] + 0.03;\r\n    calculateBilateralWeight( vUv + 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );\r\n    calculateBilateralWeight( vUv - 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );\r\n\r\n    occlusion = totalOcclusion / totalBilateralWeight;\r\n\r\n    gl_FragColor = vec4( occlusion, aoDepth.gba );\r\n}"
                    },
                    "./src/shaders/saoBilateralFilterShader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                          , i = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var a = r(n("./src/shaders/simple_vert.vert"))
                          , o = r(n("./src/shaders/bilateral_fragment.frag"))
                          , s = i(n("three"));
                        t.saoBilateralFilterShader = {
                            defines: {
                                PERSPECTIVE_CAMERA: 1,
                                KERNEL_SAMPLE_RADIUS: 4,
                                LINEAR_DEPTH: 1,
                                DEPTH_NORMAL_TEXTURE: 0
                            },
                            uniforms: {
                                tOcclusionDepth: {
                                    type: "t",
                                    value: null
                                },
                                tNormal: {
                                    type: "t",
                                    value: null
                                },
                                size: {
                                    type: "v2",
                                    value: new s.Vector2(256,256)
                                },
                                kernelDirection: {
                                    type: "v2",
                                    value: new s.Vector2(1,0)
                                },
                                cameraNearFar: {
                                    type: "v2",
                                    value: new s.Vector2(1,0)
                                },
                                edgeSharpness: {
                                    type: "f",
                                    value: 1
                                }
                            },
                            vertexShader: a.default,
                            fragmentShader: o.default
                        }
                    },
                    "./src/shaders/saoshader.frag": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "#include <common>\r\n#include <packing>\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D tDepth;\r\n\r\n#if DEPTH_NORMAL_TEXTURE == 1\r\n    uniform sampler2D tNormalDepth;\r\n#else\r\n    uniform sampler2D tNormal;\r\n#endif\r\n\r\nuniform vec2 cameraNearFar;\r\nuniform mat4 ProjectionMatrix;\r\n\r\nuniform vec4 saoData;\r\nuniform vec3 saoBiasEpsilon; \r\nuniform vec2 size;\r\n\r\nconst float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\r\n\r\nfloat getViewZFromNDCZ(const in float depth) {\r\n#if PERSPECTIVE_CAMERA == 1\r\n    return perspectiveDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);\r\n#else\r\n    return orthographicDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);\r\n#endif\r\n}\r\n\r\nfloat unpack16(vec2 value) {\r\n    return (\r\n    value.x*0.996108949416342426275150501169264316558837890625 +\r\n    value.y*0.00389105058365758760263730664519243873655796051025390625\r\n    );\r\n}\r\n\r\nvec3 packFloatToRGB(const in float x) {\r\n    const vec3 code = vec3(1.0, 255.0, 65025.0);\r\n    vec3 pack = vec3(code * x);\r\n    pack.gb = fract(pack.gb);\r\n    pack.rg -= pack.gb * (1.0 / 256.0);\r\n    return pack;\r\n}\r\n\r\nvec3 unpackNormal(vec2 enc) {\r\n    vec2 fenc = enc*4.0-2.0;\r\n    float f = dot(fenc,fenc);\r\n    float g = sqrt(1.0-f/4.0);\r\n    return vec3(fenc*g, 1.0-f/2.0);\r\n}\r\n\r\nvec3 getViewNormal(const in vec2 uv ) {\r\n    #if DEPTH_NORMAL_TEXTURE == 1\r\n        return unpackNormal( texture2D( tNormalDepth, uv ).zw );\r\n    #else\r\n        return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\r\n    #endif\r\n}\r\n\r\nvec3 getViewPositionFromViewZ(const in vec2 uv,\r\n    const in float viewDepth) {\r\n    vec2 uv_ = 2. * uv - 1.;\r\n    float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth / ProjectionMatrix[0][0];\r\n    float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth / ProjectionMatrix[1][1];\r\n    return vec3(xe, ye, viewDepth);\r\n}\r\n\r\nfloat random3(vec3 v) {\r\n    v = fract(v * 443.8975);\r\n    v += dot(v, v.yzx + 19.19);\r\n    return fract((v.x + v.y) * v.z);\r\n}\r\n\r\nfloat decodeDepth( const in vec2 uv ) {\r\n    vec4 uncodedDepth;\r\n    #if DEPTH_PACKING_MODE == 2\r\n        uncodedDepth = texture2D( tNormalDepth, uv );\r\n    #else\r\n        uncodedDepth = texture2D( tDepth, uv );\r\n    #endif\r\n\r\n    #if DEPTH_PACKING_MODE == 0\r\n        return uncodedDepth.x;\r\n    #elif DEPTH_PACKING_MODE == 1\r\n    #if LINEAR_DEPTH == 1\r\n        return pow2(unpackRGBAToDepth(uncodedDepth));\r\n    #else\r\n        return unpackRGBAToDepth( uncodedDepth );\r\n    #endif\r\n    #else\r\n        return pow2(unpack16(uncodedDepth.xy));\r\n    #endif\r\n}\r\n\r\nvec3 getPositionFromOffset(const in vec2 uv,\r\n    const in vec2 offset,\r\n    const in float screenSpaceRadius) {\r\n\r\n    vec2 uvOffset = uv + floor(screenSpaceRadius * offset) / size;\r\n    float d = decodeDepth(uvOffset);\r\n\r\n    #if LINEAR_DEPTH == 0\r\n        float centerViewZ = getViewZFromNDCZ(d);\r\n        return getViewPositionFromViewZ(uvOffset, centerViewZ);\r\n    #else\r\n        d = mix(-cameraNearFar.x, -cameraNearFar.y, d);\r\n        return getViewPositionFromViewZ(uvOffset, d);\r\n    #endif\r\n}\r\n\r\nfloat getOcclusion(const in vec2 uv,\r\n    const in int id,\r\n    const in float randomAngle,\r\n    const in float occlusionSphereRadius,\r\n    const in vec3 centerPosition,\r\n    const in vec3 centerNormal) {\r\n    float screenSpaceRadius = (float(id) + mod(randomAngle, 1.) + 0.5) * INV_NUM_SAMPLES;\r\n\r\n    float angle = screenSpaceRadius * (float(NUM_SPIRAL_TURNS) * 6.28) + randomAngle;\r\n\r\n    screenSpaceRadius = (screenSpaceRadius * occlusionSphereRadius);\r\n\r\n    vec2 offset = vec2(cos(angle), sin(angle));\r\n\r\n    vec3 samplePosition = getPositionFromOffset(uv, offset, screenSpaceRadius);\r\n    vec3 direction = samplePosition - centerPosition;\r\n    float d2 = dot(direction, direction);\r\n    float ao = max((dot(centerNormal, direction) + centerPosition.z * saoBiasEpsilon.x) / (saoBiasEpsilon.z * d2 + saoBiasEpsilon.y), 0.0);\r\n    return ao;\r\n}\r\n\r\nvoid main() {\r\n\r\n    float centerDepth = decodeDepth(vUv);\r\n\r\n    if (centerDepth >= (1.0 - EPSILON)) {\r\n        discard;\r\n    }\r\n\r\n    #if LINEAR_DEPTH == 0\r\n        float centerViewZ = getViewZFromNDCZ(centerDepth);\r\n    #else\r\n        float centerViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);\r\n    #endif\r\n\r\n    vec3 centerPosition = getViewPositionFromViewZ(vUv, centerViewZ);\r\n\r\n    vec3 centerNormal = getViewNormal(vUv);\r\n\r\n    float occlusionSphereScreenRadius = 200. * saoData.z / (-centerPosition.z);\r\n\r\n    if (occlusionSphereScreenRadius < 1.) {\r\n        discard;\r\n    }\r\n\r\n    float randomAngle = 6.2 * random3(vec3(vUv, saoData.w * 0.1));\r\n\r\n    float sum = 0.0;\r\n\r\n    sum += getOcclusion(vUv, 0, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 1, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 2, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 3, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 4, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 5, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 6, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 7, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 8, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 9, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n    sum += getOcclusion(vUv, 10, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);\r\n\r\n    float aoValue = sum * saoData.y * INV_NUM_SAMPLES;\r\n\r\n    gl_FragColor.gba = packFloatToRGB(centerDepth);\r\n    gl_FragColor.r = max(aoValue, 0.0);\r\n}"
                    },
                    "./src/shaders/saoshader.ts": function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                          , i = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var a = r(n("./src/shaders/simple_vert.vert"))
                          , o = r(n("./src/shaders/saoshader.frag"))
                          , s = i(n("three"));
                        t.saoShader = {
                            defines: {
                                NUM_SAMPLES: 11,
                                NUM_SPIRAL_TURNS: 3,
                                DEPTH_NORMAL_TEXTURE: 0,
                                DEPTH_PACKING_MODE: 1,
                                PERSPECTIVE_CAMERA: 1
                            },
                            uniforms: {
                                tDepth: {
                                    type: "t",
                                    value: null
                                },
                                tNormal: {
                                    type: "t",
                                    value: null
                                },
                                tNormalDepth: {
                                    type: "t",
                                    value: null
                                },
                                cameraNearFar: {
                                    type: "v2",
                                    value: new s.Vector2
                                },
                                saoData: {
                                    type: "v4",
                                    value: new s.Vector4
                                },
                                size: {
                                    type: "v2",
                                    value: new s.Vector2(512,512)
                                },
                                ProjectionMatrix: {
                                    type: "m4",
                                    value: new s.Matrix4
                                },
                                saoBiasEpsilon: {
                                    type: "v3",
                                    value: new s.Vector3(1,1,1)
                                }
                            },
                            vertexShader: a.default,
                            fragmentShader: o.default
                        }
                    },
                    "./src/shaders/simple_vert.vert": function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                    },
                    three: function(e, t) {
                        e.exports = r
                    }
                }))
            }
            ,
            5377: (e,t,n)=>{
                var r, i, a;
                self,
                e.exports = (r = n(2212),
                i = n(740),
                a = n(8546),
                (()=>{
                    "use strict";
                    var e = {
                        665: (e,t,n)=>{
                            n.r(t),
                            n.d(t, {
                                default: ()=>r
                            });
                            const r = "uniform sampler2D tNormalDepth;\nfloat unpack16(vec2 value) {\n    return (\n    value.x*0.996108949416342426275150501169264316558837890625 +\n    value.y*0.00389105058365758760263730664519243873655796051025390625\n    );\n}\nfloat getDepth(vec2 uv){\n    vec4 uncodedDepth = texture2D(tNormalDepth, uv);\n    float x = unpack16(uncodedDepth.xy);\n    return x*x;\n}\nvec3 unpackNormal(vec2 enc) {\n    vec2 fenc = enc*4.0-2.0;\n    float f = dot(fenc, fenc);\n    float g = sqrt(1.0-f/4.0);\n    return vec3(fenc*g, 1.0-f/2.0);\n}\nvoid getDepthNormal(const in vec2 uv, out float depth, out vec3 normal){\n    vec4 uncodedDepth = texture2D(tNormalDepth, uv);\n    depth = unpack16(uncodedDepth.xy);\n    depth = depth*depth;\n    normal = unpackNormal(uncodedDepth.zw);\n}\n"
                        }
                        ,
                        748: (e,t,n)=>{
                            n.r(t),
                            n.d(t, {
                                default: ()=>r
                            });
                            const r = "//varying vec2 vUv;\n\n//#define PI 3.1415926535\n\n//uniform sampler2D tRoughness;\n//uniform vec2 screenSize;\nuniform sampler2D tLastFrame;\nuniform float ssReflectivity;\nuniform float frameCount;\nuniform bool ssrEnabled;\nuniform float ssrToleranceFactor;// 0.5\n//uniform float weight;\n//uniform float roughness;\nuniform mat4 projection;\nuniform vec2 cameraNearFar;\nuniform vec2 objectBounds; //vec2(dist from camera, bounding radius)\n//vec3 getPosition(const in vec2 uv, const in float viewDepth) {\n//    float xe = -(uv.x + projection[2][0]) * viewDepth/projection[0][0];\n//    float ye = -(uv.y + projection[2][1]) * viewDepth/projection[1][1];\n//    return vec3(xe, ye, viewDepth);\n//}\n//void getViewPosNormal(const in vec2 uv, out vec3 position, out vec3 normal){\n//    float depth;\n//    getDepthNormal(uv, depth, normal);\n//    position = depth > 0.999 ? vec3(1000.) : getPosition(2.*uv-1., -mix(cameraNearFar.x, cameraNearFar.y, depth));\n//}\nfloat getDepth2(const in vec2 uv, const in float lod) {\n    float viewDepth = getDepth(uv);\n    return (viewDepth > 0.999) ? -cameraNearFar.y * 1000.0 : -mix(cameraNearFar.x, cameraNearFar.y, viewDepth);\n}\n\n\n    #define LOD_DEPTH 1.0// todo: generate mipmap depth and set.\n    #define LOD_COLOR 5.0\n    #define SSR_QUALITY 0\n\nvec3 viewToScreen(const in vec3 pos) {\n    vec4 projected = projection * vec4(pos, 1.0);\n    return vec3(0.5 + 0.5 * projected.xy / projected.w, projected.w);\n}\n\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush#L27\nfloat interleavedGradientNoise(const in vec2 fragCoord, const in float seed) {\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(fragCoord.xy + seed * vec2(2.083, 4.867), magic.xy)));\n}\n\n    #define STEP_COUNT 8.\nvoid traceRay(in vec3 ray_origin, in vec3 ray_dir, in float tolerance, in float iSteps, inout vec3 state){\n    vec3 sampleUV;\n    float d, hit;\n    float dLod = 0.;//floor(LOD_DEPTH * roughness);\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < 8; i ++){\n        sampleUV = ray_origin + ray_dir * state.y;\n        d = getDepth2(sampleUV.xy, dLod);\n        d = -1.0 / sampleUV.z - d;\n        if (abs(d + tolerance) < tolerance){\n\n            hit = clamp(state.x / (state.x - d), 0., 1.) - 1.;\n            hit = (state.y + hit * iSteps);\n            state.z = min(state.z, hit);\n\n        }\n        state.x = d;//depth diff\n        state.y += iSteps;\n    }\n    #pragma unroll_loop_end\n}\n\nvec3 fetchColorLod(const in vec2 uv, const in float lod) {\n    return inputTexelToLinear(texture2D(tLastFrame, uv)).rgb;\n\n}\n\n// normal and viewdir in view space.\nvec4 getSSR(const in float roughness, const in vec3 normal, const in vec3 viewPos, const in vec3 viewDir) {\n    float alpha = 5.0 * ssReflectivity * clamp(-4.0 * dot(viewDir, normal) + 3.0, 0.0, 1.0);// fade ray that points toward camera\n    //    alpha *= clamp(4.7 - roughness * 5.0, 0.0, 1.0); // fade out ssr for high roughness values\n\n    if (!ssrEnabled || ssReflectivity < 0.001 || roughness > 0.80){\n        return vec4(0.);\n    }\n    vec4 result = vec4(0.0);\n    float rough4 = roughness * roughness; rough4 = rough4 * rough4;\n\n    // compute ray uv origin\n    vec3 ray_origin = viewToScreen(viewPos.xyz);\n    ray_origin.z = 1.0 / ray_origin.z;\n\n    vec2 rand_e;// random\n    rand_e.x = interleavedGradientNoise(gl_FragCoord.xy, frameCount*117.);\n    rand_e.y = fract(rand_e.x * 38.65435);\n    // https://www.slideshare.net/DICEStudio/stochastic-screenspace-reflections#p=67\n    rand_e.y = mix(rand_e.y, 1.0, 0.7);\n\n    // importance sampling\n    float phi = 2.0 * PI * rand_e.x;\n    //    float cos_theta = sqrt((1.0 - rand_e.y) / (1.0 + (rough4 - 1.0) * rand_e.y)); // ggx, NOISY\n    float cos_theta = pow(max(rand_e.y, 0.000001), rough4 / (2.0 - rough4));// blinn\n    float sin_theta = sqrt(max(0., 1.0 - cos_theta * cos_theta));\n    vec3 half_vec = vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);\n    vec3 tangentX = normalize(cross(abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0), normal));\n    vec3 tangentY = cross(normal, tangentX);\n    half_vec = half_vec.x * tangentX + half_vec.y * tangentY + half_vec.z * normal;\n\n    // in view space\n    vec3 ray_dir = (2.0 * dot(viewDir, half_vec)) * half_vec - viewDir;\n    ray_dir = normalize(ray_dir);\n\n    // if reflection is toward us, we cast [near, vertex], otherwise [vertex, far]\n    float ray_len = mix((objectBounds.x + objectBounds.y) + viewPos.z, -viewPos.z - (objectBounds.x - objectBounds.y), ray_dir.z * 0.5 + 0.5);\n    if (dot(ray_dir.xyz, normal) > 0.001) {\n\n        float iSteps = 1.0 / float(STEP_COUNT);\n        #if SSR_QUALITY >= 1\n        iSteps /= 2.0;\n        #endif\n\n        float tolerance = 0.5 * ray_len * iSteps;\n\n        // to uv space\n        ray_dir = viewToScreen(viewPos.xyz + ray_dir * ray_len);\n        ray_dir.z = 1.0 / ray_dir.z;\n        ray_dir -= ray_origin;\n\n        // clip the line to the viewport edges\n        // https://github.com/godotengine/godot/blob/master/drivers/gles3/shaders/screen_space_reflection.glsl#L124\n        float sx = min(1.0, 0.99 * (1.0 - ray_origin.x) / max(1e-5, ray_dir.x));\n        float sy = min(1.0, 0.99 * (1.0 - ray_origin.y) / max(1e-5, ray_dir.y));\n        ray_dir *= min(sx, sy);\n        sx = min(1.0, 0.99 * ray_origin.x / max(1e-5, -ray_dir.x));\n        sy = min(1.0, 0.99 * ray_origin.y / max(1e-5, -ray_dir.y));\n        ray_dir *= min(sx, sy);\n        //        vec3 rr = ray_origin;\n\n        vec3 state = vec3(0.0, 0.0, 1.0);// depth diff, current dist, hit dist.\n        state.y = (interleavedGradientNoise(gl_FragCoord.xy, frameCount) + 0.5) * iSteps;// start jitter\n\n        traceRay(ray_origin, ray_dir, tolerance, iSteps, state);\n        #if SSR_QUALITY >= 1\n        traceRay(ray_origin, ray_dir, tolerance, iSteps, state);\n        #endif\n        //                                return vec4(ray_origin.z, 0., 0., 1.);\n\n        if (state.z < 0.99) {\n\n\n            state.xy = ray_origin.xy + ray_dir.xy * state.z;// result uv\n\n            //                        return vec4((state.x<=0.||state.y<=0.||state.y>=1.||state.x>=1.)?1.:0., 0., 0., 1.);\n            //                        return vec4(state.xy, 0., 1.);\n            //                        return vec4(1.-ray_len, 0., 0., 1.);\n            //                        return vec4(state.z<0.?1.:0.,0., 0., 1.);\n            alpha *= clamp(20.0 * (1. - max(abs(state.x), abs(state.y))), 0.0, 1.0);// can use vignette, like in unreal\n            result = vec4(fetchColorLod(state.xy, LOD_COLOR * roughness * state.z), clamp(alpha, 0.0, 1.0));\n            //            result *= state.z<0.9?1.:0.;\n        }\n    }\n\n    return result;\n}\n"
                        }
                        ,
                        636: function(e, t, n) {
                            var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                                void 0 === r && (r = n),
                                Object.defineProperty(e, r, {
                                    enumerable: !0,
                                    get: function() {
                                        return t[n]
                                    }
                                })
                            }
                            : function(e, t, n, r) {
                                void 0 === r && (r = n),
                                e[r] = t[n]
                            }
                            )
                              , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                                Object.defineProperty(e, "default", {
                                    enumerable: !0,
                                    value: t
                                })
                            }
                            : function(e, t) {
                                e.default = t
                            }
                            )
                              , a = this && this.__importStar || function(e) {
                                if (e && e.__esModule)
                                    return e;
                                var t = {};
                                if (null != e)
                                    for (var n in e)
                                        "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                                return i(t, e),
                                t
                            }
                              , o = this && this.__importDefault || function(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                }
                            }
                            ;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }),
                            t.MeshReflectiveMaterial = void 0;
                            const s = a(n(293))
                              , l = o(n(748))
                              , c = o(n(665));
                            class u extends s.MeshStandardMaterial {
                                constructor(e, t) {
                                    super(e),
                                    this.ssrPass = t
                                }
                                onBeforeCompile(e, t) {
                                    const n = "void main() {"
                                      , r = "vec3 outgoingLight =";
                                    e.uniforms = Object.assign(Object.assign({}, e.uniforms), this.ssrPass.uniforms),
                                    e.fragmentShader = e.fragmentShader.replace(n, `\n#define inputTexelToLinear(x) x\n${c.default}\n${l.default}\n${n}`),
                                    e.fragmentShader = e.fragmentShader.replace(r, `        vec4 ssr  = getSSR(material.specularRoughness, geometry.normal, geometry.position, geometry.viewDir);\n        reflectedLight.indirectSpecular = mix(reflectedLight.indirectSpecular, material.specularColor * ssr.xyz, ssr.a); \n${r}`),
                                    super.onBeforeCompile(e, t)
                                }
                            }
                            t.MeshReflectiveMaterial = u
                        },
                        267: function(e, t, n) {
                            var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                                void 0 === r && (r = n),
                                Object.defineProperty(e, r, {
                                    enumerable: !0,
                                    get: function() {
                                        return t[n]
                                    }
                                })
                            }
                            : function(e, t, n, r) {
                                void 0 === r && (r = n),
                                e[r] = t[n]
                            }
                            )
                              , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                                Object.defineProperty(e, "default", {
                                    enumerable: !0,
                                    value: t
                                })
                            }
                            : function(e, t) {
                                e.default = t
                            }
                            )
                              , a = this && this.__importStar || function(e) {
                                if (e && e.__esModule)
                                    return e;
                                var t = {};
                                if (null != e)
                                    for (var n in e)
                                        "default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);
                                return i(t, e),
                                t
                            }
                            ;
                            Object.defineProperty(t, "__esModule", {
                                value: !0
                            }),
                            t.SSRPass = void 0;
                            const o = a(n(293))
                              , s = n(950)
                              , l = n(527);
                            class c extends s.Pass {
                                constructor(e, t) {
                                    super(),
                                    this._scene = e,
                                    this._camera = t,
                                    this._target = new o.WebGLRenderTarget(512,512,{}),
                                    this._frameCount = 0,
                                    this._uniforms = {
                                        tLastFrame: {
                                            value: this._target.texture
                                        },
                                        tNormalDepth: {
                                            value: null
                                        },
                                        ssReflectivity: {
                                            value: .9
                                        },
                                        ssrEnabled: {
                                            value: !0
                                        },
                                        frameCount: {
                                            value: 0
                                        },
                                        ssrToleranceFactor: {
                                            value: .5
                                        },
                                        projection: {
                                            value: null
                                        },
                                        cameraNearFar: {
                                            value: new o.Vector2(0,0)
                                        },
                                        objectBounds: {
                                            value: new o.Vector2(0,0)
                                        },
                                        ssrDebug: {
                                            value: !1
                                        }
                                    },
                                    this.needsSwap = !1;
                                    const n = o.UniformsUtils.clone(l.CopyShader.uniforms);
                                    n.opacity.value = 1,
                                    this._copyMaterial = new o.ShaderMaterial({
                                        uniforms: n,
                                        vertexShader: l.CopyShader.vertexShader,
                                        fragmentShader: l.CopyShader.fragmentShader,
                                        blending: o.NoBlending,
                                        depthTest: !1,
                                        depthWrite: !1,
                                        transparent: !0
                                    }),
                                    this.fsQuad = new s.Pass.FullScreenQuad(this._copyMaterial)
                                }
                                get uniforms() {
                                    return this._uniforms
                                }
                                set scene(e) {
                                    this._scene = e
                                }
                                reset() {
                                    this._frameCount = 0
                                }
                                get lastFrame() {
                                    return this._target.texture
                                }
                                get debug() {
                                    return this.uniforms.ssrDebug.value
                                }
                                set debug(e) {
                                    this.uniforms.ssrDebug.value = e
                                }
                                setSize(e, t) {
                                    super.setSize(e, t)
                                }
                                setNormalDepth(e) {
                                    this.uniforms.tNormalDepth.value = e
                                }
                                setGBuffer(e) {
                                    e && this.setNormalDepth(e.getNormalDepthTexture())
                                }
                                render(e, t, n, r, i) {
                                    this.fsQuad.material = this._copyMaterial,
                                    this._copyMaterial.uniforms.tDiffuse.value = n.texture,
                                    e.setRenderTarget(this._target),
                                    e.clear(),
                                    this.fsQuad.render(e),
                                    e.setRenderTarget(null),
                                    this._frameCount++
                                }
                                updateUniforms() {
                                    var e;
                                    this.uniforms.projection.value = this._camera.projectionMatrix,
                                    this.uniforms.frameCount.value = this._frameCount,
                                    this.uniforms.ssrEnabled.value = this.enabled,
                                    this.uniforms.cameraNearFar.value.set(this._camera.near, this._camera.far);
                                    let t = Math.abs(this._camera.near - this._camera.far) / 2
                                      , n = (this._camera.near + this._camera.far) / 2
                                      , r = null !== (e = this._objectBounds) && void 0 !== e ? e : new o.Vector2(n,t);
                                    this.uniforms.objectBounds.value.copy(r)
                                }
                                get objectBounds() {
                                    return this._objectBounds
                                }
                                set objectBounds(e) {
                                    this._objectBounds = e
                                }
                            }
                            t.SSRPass = c
                        },
                        293: e=>{
                            e.exports = r
                        }
                        ,
                        950: e=>{
                            e.exports = i
                        }
                        ,
                        527: e=>{
                            e.exports = a
                        }
                    }
                      , t = {};
                    function n(r) {
                        var i = t[r];
                        if (void 0 !== i)
                            return i.exports;
                        var a = t[r] = {
                            exports: {}
                        };
                        return e[r].call(a.exports, a, a.exports, n),
                        a.exports
                    }
                    n.d = (e,t)=>{
                        for (var r in t)
                            n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
                                enumerable: !0,
                                get: t[r]
                            })
                    }
                    ,
                    n.o = (e,t)=>Object.prototype.hasOwnProperty.call(e, t),
                    n.r = e=>{
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ;
                    var o = {};
                    return (()=>{
                        var e = o;
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        }),
                        e.MeshReflectiveMaterial = e.SSRPass = void 0;
                        const t = n(267);
                        Object.defineProperty(e, "SSRPass", {
                            enumerable: !0,
                            get: function() {
                                return t.SSRPass
                            }
                        });
                        const r = n(636);
                        Object.defineProperty(e, "MeshReflectiveMaterial", {
                            enumerable: !0,
                            get: function() {
                                return r.MeshReflectiveMaterial
                            }
                        })
                    }
                    )(),
                    o
                }
                )())
            }
            ,
            5157: (e,t,n)=>{
                var r;
                window,
                e.exports = (r = n(2212),
                function(e) {
                    var t = {};
                    function n(r) {
                        if (t[r])
                            return t[r].exports;
                        var i = t[r] = {
                            i: r,
                            l: !1,
                            exports: {}
                        };
                        return e[r].call(i.exports, i, i.exports, n),
                        i.l = !0,
                        i.exports
                    }
                    return n.m = e,
                    n.c = t,
                    n.d = function(e, t, r) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: r
                        })
                    }
                    ,
                    n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    n.t = function(e, t) {
                        if (1 & t && (e = n(e)),
                        8 & t)
                            return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule)
                            return e;
                        var r = Object.create(null);
                        if (n.r(r),
                        Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }),
                        2 & t && "string" != typeof e)
                            for (var i in e)
                                n.d(r, i, function(t) {
                                    return e[t]
                                }
                                .bind(null, i));
                        return r
                    }
                    ,
                    n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return n.d(t, "a", t),
                        t
                    }
                    ,
                    n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    n.p = "",
                    n(n.s = 1)
                }([function(e, t) {
                    e.exports = r
                }
                , function(e, t, n) {
                    "use strict";
                    var r, i = this && this.__extends || (r = function(e, t) {
                        return (r = Object.setPrototypeOf || {
                            __proto__: []
                        }instanceof Array && function(e, t) {
                            e.__proto__ = t
                        }
                        || function(e, t) {
                            for (var n in t)
                                t.hasOwnProperty(n) && (e[n] = t[n])
                        }
                        )(e, t)
                    }
                    ,
                    function(e, t) {
                        function n() {
                            this.constructor = e
                        }
                        r(e, t),
                        e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
                        new n)
                    }
                    ), a = this && this.__importStar || function(e) {
                        if (e && e.__esModule)
                            return e;
                        var t = {};
                        if (null != e)
                            for (var n in e)
                                Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                        return t.default = e,
                        t
                    }
                    ;
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                    var o = a(n(0))
                      , s = n(2)
                      , l = n(5)
                      , c = function(e) {
                        function t(t, n) {
                            var r = e.call(this) || this;
                            return r.prevPVM_ = new o.Matrix4,
                            r.currentPVM_ = new o.Matrix4,
                            r.currentPM_ = new o.Matrix4,
                            r.taaMaterial_ = new o.ShaderMaterial(new s.TAAShader),
                            r.screenSize_ = new o.Vector2,
                            r.pixotronicsUtilInstance_ = l.Utils.getInstance(),
                            r.frameStart_ = !0,
                            r.oldClearColor_ = new o.Color,
                            r.gBufferPass_ = n,
                            r.camera_ = t,
                            r.currentPM_.copy(r.camera_.projectionMatrix),
                            r
                        }
                        return i(t, e),
                        t.prototype.setSize = function(e, t) {
                            this.taaRT_ && this.taaRT_.setSize(e, t)
                        }
                        ,
                        t.prototype.dispose = function() {
                            this.taaRT_ && (this.taaMaterial_.dispose(),
                            this.taaRT_.dispose())
                        }
                        ,
                        t.prototype.needsUpdate = function() {
                            this.frameStart_ = !0
                        }
                        ,
                        t.prototype.setFeedbackMinMax = function(e) {
                            e && (e.x && (this.taaMaterial_.uniforms.feedBackMinMax.value.x = e.x),
                            e.y && (this.taaMaterial_.uniforms.feedBackMinMax.value.y = e.y))
                        }
                        ,
                        t.prototype.render = function(e, t, n) {
                            var r = e.getClearAlpha();
                            e.getClearColor(this.oldClearColor_);
                            var i = e.autoClear;
                            e.autoClear = !1,
                            e.setClearColor(new o.Color(0,0,0), 0),
                            void 0 === this.taaRT_ && (e.getDrawingBufferSize(this.screenSize_),
                            this.taaRT_ = new o.WebGLRenderTarget(this.screenSize_.x,this.screenSize_.y)),
                            e.getDrawingBufferSize(this.screenSize_),
                            this.updateUniforms_(),
                            this.taaMaterial_.uniforms.mainTexture.value = n.texture,
                            this.pixotronicsUtilInstance_.renderPass(e, this.taaMaterial_, t, !1),
                            this.pixotronicsUtilInstance_.blit(e, t, this.taaRT_),
                            this.prevPVM_.copy(this.currentPVM_),
                            e.setClearColor(this.oldClearColor_, r),
                            e.autoClear = i,
                            this.frameStart_ = !1
                        }
                        ,
                        t.prototype.updateUniforms_ = function() {
                            var e = this.taaMaterial_.uniforms.invTextureSize.value;
                            e.x = 1 / this.screenSize_.x,
                            e.y = 1 / this.screenSize_.y;
                            var t = this.gBufferPass_.getDepthTexture()
                              , n = this.gBufferPass_.getNormalDepthTexture();
                            this.currentPVM_.multiplyMatrices(this.currentPM_, this.camera_.matrixWorldInverse),
                            this.taaMaterial_.uniforms.depthTexture.value = t || n,
                            this.taaRT_ && (this.taaMaterial_.uniforms.taaTexture.value = this.taaRT_.texture),
                            this.taaMaterial_.uniforms.currentPVM.value.copy(this.currentPVM_),
                            this.taaMaterial_.uniforms.prevPVM.value.copy(this.prevPVM_),
                            this.taaMaterial_.uniforms.projection.value.copy(this.currentPM_),
                            this.taaMaterial_.uniforms.invView.value.copy(this.camera_.matrixWorld),
                            this.taaMaterial_.uniforms.frameStart.value = this.frameStart_;
                            var r = this.taaMaterial_.uniforms.cameraPlanes.value;
                            r.x = this.camera_.near,
                            r.y = this.camera_.far
                        }
                        ,
                        t
                    }(function() {
                        function e() {
                            this.enabled = !0,
                            this.needsSwap = !0,
                            this.clear = !1,
                            this.renderToScreen = !1
                        }
                        return e.prototype.setSize = function(e, t) {}
                        ,
                        e.prototype.render = function(e, t, n) {
                            console.error("THREE.Pass: .render() must be implemented in derived pass.")
                        }
                        ,
                        e
                    }());
                    t.TAAPass = c
                }
                , function(e, t, n) {
                    "use strict";
                    var r = this && this.__importDefault || function(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                      , i = this && this.__importStar || function(e) {
                        if (e && e.__esModule)
                            return e;
                        var t = {};
                        if (null != e)
                            for (var n in e)
                                Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                        return t.default = e,
                        t
                    }
                    ;
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                    var a = r(n(3))
                      , o = r(n(4))
                      , s = i(n(0));
                    t.TAAShader = function() {
                        this.uniforms = {
                            cameraPlanes: {
                                value: new s.Vector2
                            },
                            currentPVM: {
                                value: new s.Matrix4
                            },
                            depthTexture: {
                                value: null
                            },
                            frameStart: {
                                value: !0
                            },
                            invTextureSize: {
                                value: new s.Vector2
                            },
                            invView: {
                                value: new s.Matrix4
                            },
                            mainTexture: {
                                value: null
                            },
                            prevPVM: {
                                value: new s.Matrix4
                            },
                            projection: {
                                value: new s.Matrix4
                            },
                            taaTexture: {
                                value: null
                            },
                            feedBackMinMax: {
                                value: new s.Vector2(.85,.95)
                            }
                        },
                        this.vertexShader = a.default,
                        this.fragmentShader = o.default
                    }
                }
                , function(e, t, n) {
                    "use strict";
                    n.r(t),
                    t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                }
                , function(e, t, n) {
                    "use strict";
                    n.r(t),
                    t.default = "#include <common>\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform vec2 cameraPlanes;\r\nuniform mat4 currentPVM;\r\nuniform sampler2D depthTexture;\r\nuniform vec2 invTextureSize;\r\nuniform mat4 invView;\r\nuniform mat4 prevPVM;\r\nuniform mat4 projection;\r\nuniform sampler2D mainTexture;\r\nuniform sampler2D taaTexture;\r\nuniform bool frameStart;\r\nuniform vec2 feedBackMinMax;\r\n\r\nfloat unpackDepth(vec2 value) {\r\n    return value.x*0.99610894941634 + value.y*0.00389105058365;\r\n}\r\n        \r\nfloat getDepth( const in vec2 uv ) {\r\n    return pow2(unpackDepth(texture2D( depthTexture, uv ).xy));\r\n}\r\n\r\n/*Reference\r\n  https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\r\n*/\r\nvec3 find_closest_fragment(const in vec2 uv) { \r\n    vec3 c1 = vec3(-1, 1, getDepth( uv + vec2(1., -1.) * invTextureSize) ); \r\n    vec3 c2 = vec3( 0, 1, getDepth( uv + vec2(0., -1.) * invTextureSize) );\r\n    vec3 c3 = vec3( 1, 1, getDepth( uv + vec2(-1., -1.) * invTextureSize) );\r\n\r\n    vec3 c4 = vec3(-1, 0, getDepth( uv + vec2(1., 0.) * invTextureSize) );\r\n    vec3 c5 = vec3( 0, 0, getDepth( uv ) );\r\n    vec3 c6 = vec3( 1, 0, getDepth( uv + vec2(-1., 0.) * invTextureSize) );\r\n\r\n    vec3 c7 = vec3(-1, -1, getDepth( uv + vec2(1., 1.) * invTextureSize) );\r\n    vec3 c8 = vec3( 0, -1, getDepth( uv + vec2(0., 1.) * invTextureSize) );\r\n    vec3 c9 = vec3( 1, -1, getDepth( uv + vec2(-1., 1.) * invTextureSize) );\r\n\r\n    vec3 minVal = c3;\r\n    if ( minVal.z > c2.z ) minVal = c2;\r\n    if ( minVal.z > c1.z ) minVal = c1;\r\n\r\n    if ( minVal.z > c4.z ) minVal = c4;\r\n    if ( minVal.z > c5.z ) minVal = c5;\r\n    if ( minVal.z > c6.z ) minVal = c6;\r\n\r\n    if ( minVal.z > c7.z ) minVal = c7;\r\n    if ( minVal.z > c8.z ) minVal = c8;\r\n    if ( minVal.z > c9.z ) minVal = c9;\r\n\r\n    return vec3(uv + invTextureSize.xy * minVal.xy, minVal.z);\r\n}\r\n\r\nvec4 clip_aabb(const in vec4 aabb_min, const in vec4 aabb_max, vec4 p ) { \r\n    const float FLT_EPS = 1e-8;\r\n    vec4 p_clip = 0.5 * (aabb_max + aabb_min); \r\n    vec4 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS; \r\n\r\n    vec4 v_clip = p - p_clip;\r\n    vec4 v_unit = abs(v_clip / e_clip);\r\n    float ma_unit = max(v_unit.x, max(v_unit.y, v_unit.z));\r\n\r\n    if (ma_unit > 1.0) \r\n        return p_clip + v_clip / ma_unit;\r\n    else \r\n        return p;\r\n}\r\n\r\nvec4 temporalReprojection(const in vec2 uv, const in vec2 velocity) {\r\n\r\n    vec4 color0 = texture2D(mainTexture, uv);\r\n    vec4 color1 = texture2D(taaTexture, uv - velocity);\r\n\r\n    vec4 tl = texture2D(mainTexture, uv + vec2(-1., 1.) * invTextureSize);\r\n    vec4 tc = texture2D(mainTexture, uv + vec2(0., 1.) * invTextureSize);\r\n    vec4 tr = texture2D(mainTexture, uv + vec2(1., 1.) * invTextureSize);\r\n    vec4 ml = texture2D(mainTexture, uv + vec2(-1., 0.) * invTextureSize);\r\n    vec4 mc = color0;\r\n    vec4 mr = texture2D(mainTexture, uv + vec2(1., 0.) * invTextureSize);\r\n    vec4 bl = texture2D(mainTexture, uv + vec2(-1., -1.) * invTextureSize);\r\n    vec4 bc = texture2D(mainTexture, uv + vec2(0., -1.) * invTextureSize);\r\n    vec4 br = texture2D(mainTexture, uv + vec2(1., -1.) * invTextureSize);\r\n\r\n    vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * mc;\r\n    mc += (mc - (corners * 0.166667)) * 2.718282 * 0.3;\r\n    mc = max(vec4(0.0), mc);\r\n\r\n    vec4 min5 = min(tc, min(ml, min(mc, min(mr, bc))));\r\n    vec4 max5 = max(tc, max(ml, max(mc, max(mr, bc))));\r\n\r\n    vec4 cmin = min(min5, min(tl, min(tr, min(bl, br))));\r\n    vec4 cmax = max(min5, max(tl, max(tr, max(bl, br))));;\r\n\r\n    cmin = 0.5 * (cmin + min5);\r\n    cmax = 0.5 * (cmax + max5);\r\n    color1 = clip_aabb(cmin, cmax, color1);\r\n\r\n    float lum0 = linearToRelativeLuminance(color0.rgb);\r\n    float lum1 = linearToRelativeLuminance(color1.rgb);\r\n    float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));\r\n    float unbiased_weight = 1.0 - unbiased_diff;\r\n    float unbiased_weight_sqr = unbiased_weight * unbiased_weight;\r\n    float k_feedBackMinMax = mix(feedBackMinMax.x, feedBackMinMax.y, unbiased_weight_sqr);\r\n\r\n    return mix(color0, color1, k_feedBackMinMax);\r\n}\r\n\r\nvec3 getPosition(const in vec2 uv, const in float viewDepth) {\r\n    float xe = -(uv.x + projection[2][0]) * viewDepth/projection[0][0];\r\n    float ye = -(uv.y + projection[2][1]) * viewDepth/projection[1][1];\r\n    return (invView * vec4(xe, ye, viewDepth, 1.)).xyz;\r\n}\r\n\r\nvec2 ScreenSpaceVelocity(const in vec3 worldPosition) {\r\n    vec4 currentPositionClip = currentPVM * vec4(worldPosition, 1.0);\r\n    vec4 prevPositionClip = prevPVM * vec4(worldPosition, 1.0);\r\n\r\n    vec2 currentPositionNDC = currentPositionClip.xy / currentPositionClip.w;\r\n    vec2 prevPositionNDC = prevPositionClip.xy / prevPositionClip.w;\r\n\r\n    if(prevPositionNDC.x >= 1.0 || prevPositionNDC.x <= -1.0 || prevPositionNDC.x >= 1.0 || prevPositionNDC.y <= -1.0) {\r\n        return vec2(0.0);\r\n    }\r\n    return 0.5 * (currentPositionNDC - prevPositionNDC);\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 closestFragment = find_closest_fragment(vUv);\r\n\r\n    if( closestFragment.z < 0.999 ) {\r\n        float sampleViewZ = -mix(cameraPlanes.x, cameraPlanes.y, closestFragment.z);\r\n        closestFragment.xy = 2. * closestFragment.xy - 1.;\r\n        vec2 velocity = ScreenSpaceVelocity(getPosition(closestFragment.xy, sampleViewZ));\r\n        gl_FragColor = frameStart ? texture2D(mainTexture, vUv) : temporalReprojection(vUv, velocity);\r\n    }\r\n    else {\r\n        gl_FragColor = texture2D(mainTexture, vUv);\r\n    }\r\n}"
                }
                , function(e, t, n) {
                    var r;
                    window,
                    e.exports = (r = n(0),
                    function(e) {
                        var t = {};
                        function n(r) {
                            if (t[r])
                                return t[r].exports;
                            var i = t[r] = {
                                i: r,
                                l: !1,
                                exports: {}
                            };
                            return e[r].call(i.exports, i, i.exports, n),
                            i.l = !0,
                            i.exports
                        }
                        return n.m = e,
                        n.c = t,
                        n.d = function(e, t, r) {
                            n.o(e, t) || Object.defineProperty(e, t, {
                                enumerable: !0,
                                get: r
                            })
                        }
                        ,
                        n.r = function(e) {
                            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                value: "Module"
                            }),
                            Object.defineProperty(e, "__esModule", {
                                value: !0
                            })
                        }
                        ,
                        n.t = function(e, t) {
                            if (1 & t && (e = n(e)),
                            8 & t)
                                return e;
                            if (4 & t && "object" == typeof e && e && e.__esModule)
                                return e;
                            var r = Object.create(null);
                            if (n.r(r),
                            Object.defineProperty(r, "default", {
                                enumerable: !0,
                                value: e
                            }),
                            2 & t && "string" != typeof e)
                                for (var i in e)
                                    n.d(r, i, function(t) {
                                        return e[t]
                                    }
                                    .bind(null, i));
                            return r
                        }
                        ,
                        n.n = function(e) {
                            var t = e && e.__esModule ? function() {
                                return e.default
                            }
                            : function() {
                                return e
                            }
                            ;
                            return n.d(t, "a", t),
                            t
                        }
                        ,
                        n.o = function(e, t) {
                            return Object.prototype.hasOwnProperty.call(e, t)
                        }
                        ,
                        n.p = "",
                        n(n.s = 0)
                    }([function(e, t, n) {
                        "use strict";
                        var r = this && this.__importStar || function(e) {
                            if (e && e.__esModule)
                                return e;
                            var t = {};
                            if (null != e)
                                for (var n in e)
                                    Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
                            return t.default = e,
                            t
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = r(n(1))
                          , a = n(2)
                          , o = function() {
                            function e(e, t, n) {
                                this.u = e,
                                this.h = t,
                                this.v = n,
                                this.M = new Array(e);
                                for (var r = 0; r < e; r++)
                                    this.M[r] = new Array(t)
                            }
                            return e.prototype.j = function(e) {
                                var t = Math.floor(e.x / this.v)
                                  , n = Math.floor(e.y / this.v);
                                this.M[t][n] = e
                            }
                            ,
                            e.prototype.g = function(e, t) {
                                for (var n = Math.floor(e.x / this.v), r = Math.floor(e.y / this.v), i = n - 5; i < n + 5; i++)
                                    for (var a = r - 5; a < r + 5; a++)
                                        if (i >= 0 && i < this.u && a >= 0 && a < this.h) {
                                            var o = this.M[i][a]
                                              , s = 1e10;
                                            if (void 0 !== o && (s = o.distanceTo(e)),
                                            s < t)
                                                return !0
                                        }
                                return !1
                            }
                            ,
                            e
                        }()
                          , s = function() {
                            function e() {
                                var e = i.UniformsUtils.clone(a.copyShader.uniforms);
                                this.O = new i.ShaderMaterial({
                                    uniforms: e,
                                    vertexShader: a.copyShader.vertexShader,
                                    fragmentShader: a.copyShader.fragmentShader,
                                    depthWrite: !1,
                                    depthTest: !1
                                }),
                                this._ = new i.Scene,
                                this.S = new i.OrthographicCamera(-1,1,1,-1,0,1),
                                this.D = new i.Mesh(new i.PlaneGeometry(2,2),this.O),
                                this.D.frustumCulled = !1,
                                this._.add(this.D)
                            }
                            return e.getInstance = function() {
                                return e.instance || (e.instance = new e),
                                e.instance
                            }
                            ,
                            e.prototype.renderPass = function(e, t, n, r) {
                                r = void 0 !== r && r,
                                this.D.material = t,
                                e.setRenderTarget(n),
                                r && e.clear(!0, !0, !1),
                                e.render(this._, this.S),
                                e.setRenderTarget(null)
                            }
                            ,
                            e.prototype.blit = function(e, t, n, r) {
                                r = void 0 !== r && r,
                                this.O.uniforms.tDiffuse.value = t,
                                this.D.material = this.O,
                                e.setRenderTarget(n),
                                e.render(this._, this.S),
                                e.setRenderTarget(null)
                            }
                            ,
                            e.prototype.randomizeArray = function(e) {
                                for (var t, n, r = e.length; 0 !== r; )
                                    n = Math.floor(Math.random() * r),
                                    t = e[r -= 1],
                                    e[r] = e[n],
                                    e[n] = t;
                                return e
                            }
                            ,
                            e.prototype.T = function(e) {
                                var t = Math.floor(Math.random() * e.length)
                                  , n = e[t];
                                return e.splice(t, 1),
                                n
                            }
                            ,
                            e.prototype.uniformDistribution = function() {
                                return 1
                            }
                            ,
                            e.prototype.insideRectangle = function(e, t, n, r) {
                                return n = void 0 !== n ? n : 1,
                                r = void 0 !== r ? r : 1,
                                e >= 0 && t >= 0 && e <= n && t <= r
                            }
                            ,
                            e.prototype.insideCircle = function(e, t, n) {
                                var r = e - .5
                                  , i = t - .5;
                                return r * r + i * i <= (n = void 0 !== n ? n : .5) * n
                            }
                            ,
                            e.prototype.U = function(e, t) {
                                var n = t * (Math.random() + 1)
                                  , r = 6.283185307178 * Math.random()
                                  , a = e.x + n * Math.cos(r)
                                  , o = e.y + n * Math.sin(r);
                                return new i.Vector2(a,o)
                            }
                            ,
                            e.prototype.generateQuasiRandomPoints = function(e, t, n, r) {
                                e = void 0 === e ? 30 : e,
                                t = void 0 === t ? -1 : t,
                                n = n || this.uniformDistribution,
                                r = r || this.insideCircle,
                                t < 0 && (t = Math.sqrt(e) / e);
                                var a = []
                                  , s = []
                                  , l = t / Math.sqrt(2)
                                  , c = Math.ceil(1 / l)
                                  , u = Math.ceil(1 / l)
                                  , h = new o(c,u,l)
                                  , d = new i.Vector2(.5,.5)
                                  , p = !1;
                                do {
                                    d.x = Math.random(),
                                    d.y = Math.random(),
                                    p = r(d.x, d.y)
                                } while (!p);
                                for (s.push(d),
                                a.push(d),
                                h.j(d); 0 !== s.length && a.length < e; )
                                    for (var f = this.T(s), m = 0; m < 30; m++) {
                                        var g = f.x - .5
                                          , v = f.y - .5
                                          , y = n(Math.sqrt(g * g + v * v))
                                          , _ = this.U(f, y * t);
                                        !r(_.x, _.y) || h.g(_, y * t) || (s.push(_),
                                        a.push(_),
                                        h.j(_))
                                    }
                                return a
                            }
                            ,
                            e
                        }();
                        t.Utils = s
                    }
                    , function(e, t) {
                        e.exports = r
                    }
                    , function(e, t, n) {
                        "use strict";
                        var r = this && this.__importDefault || function(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            }
                        }
                        ;
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = r(n(3))
                          , a = r(n(4));
                        t.copyShader = {
                            uniforms: {
                                tDiffuse: {
                                    value: null
                                }
                            },
                            vertexShader: i.default,
                            fragmentShader: a.default
                        }
                    }
                    , function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}"
                    }
                    , function(e, t, n) {
                        "use strict";
                        n.r(t),
                        t.default = "uniform sampler2D tDiffuse;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n    vec4 texel = texture2D(tDiffuse, vUv);\r\n    gl_FragColor = texel;\r\n\r\n}"
                    }
                    ]))
                }
                ]))
            }
            ,
            2212: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    ACESFilmicToneMapping: ()=>ne,
                    AddEquation: ()=>T,
                    AddOperation: ()=>K,
                    AdditiveAnimationBlendMode: ()=>qt,
                    AdditiveBlending: ()=>b,
                    AlphaFormat: ()=>Ne,
                    AlwaysDepth: ()=>G,
                    AlwaysStencilFunc: ()=>Sn,
                    AmbientLight: ()=>oh,
                    AmbientLightProbe: ()=>Ch,
                    AnimationClip: ()=>pu,
                    AnimationLoader: ()=>bu,
                    AnimationMixer: ()=>od,
                    AnimationObjectGroup: ()=>id,
                    AnimationUtils: ()=>eu,
                    ArcCurve: ()=>Pu,
                    ArrayCamera: ()=>Ps,
                    ArrowHelper: ()=>Jd,
                    Audio: ()=>zh,
                    AudioAnalyser: ()=>Wh,
                    AudioContext: ()=>Th,
                    AudioListener: ()=>kh,
                    AudioLoader: ()=>Eh,
                    AxesHelper: ()=>Kd,
                    AxisHelper: ()=>Qp,
                    BackSide: ()=>m,
                    BasicDepthPacking: ()=>an,
                    BasicShadowMap: ()=>u,
                    BinaryTextureLoader: ()=>rf,
                    Bone: ()=>pl,
                    BooleanKeyframeTrack: ()=>ou,
                    BoundingBoxHelper: ()=>$p,
                    Box2: ()=>gd,
                    Box3: ()=>er,
                    Box3Helper: ()=>Wd,
                    BoxBufferGeometry: ()=>da,
                    BoxGeometry: ()=>da,
                    BoxHelper: ()=>Vd,
                    BufferAttribute: ()=>Ti,
                    BufferGeometry: ()=>qi,
                    BufferGeometryLoader: ()=>fh,
                    ByteType: ()=>Te,
                    Cache: ()=>mu,
                    Camera: ()=>va,
                    CameraHelper: ()=>Hd,
                    CanvasRenderer: ()=>sf,
                    CanvasTexture: ()=>Gl,
                    CatmullRomCurve3: ()=>Iu,
                    CineonToneMapping: ()=>te,
                    CircleBufferGeometry: ()=>Vl,
                    CircleGeometry: ()=>Vl,
                    ClampToEdgeWrapping: ()=>de,
                    Clock: ()=>Dh,
                    ClosedSplineCurve3: ()=>Zp,
                    Color: ()=>yi,
                    ColorKeyframeTrack: ()=>su,
                    CompressedTexture: ()=>Hl,
                    CompressedTextureLoader: ()=>wu,
                    ConeBufferGeometry: ()=>ql,
                    ConeGeometry: ()=>ql,
                    CubeCamera: ()=>xa,
                    CubeReflectionMapping: ()=>ae,
                    CubeRefractionMapping: ()=>oe,
                    CubeTexture: ()=>ba,
                    CubeTextureLoader: ()=>Su,
                    CubeUVReflectionMapping: ()=>ce,
                    CubeUVRefractionMapping: ()=>ue,
                    CubicBezierCurve: ()=>zu,
                    CubicBezierCurve3: ()=>Uu,
                    CubicInterpolant: ()=>nu,
                    CullFaceBack: ()=>s,
                    CullFaceFront: ()=>l,
                    CullFaceFrontBack: ()=>c,
                    CullFaceNone: ()=>o,
                    Curve: ()=>Au,
                    CurvePath: ()=>Xu,
                    CustomBlending: ()=>S,
                    CustomToneMapping: ()=>re,
                    CylinderBufferGeometry: ()=>Wl,
                    CylinderGeometry: ()=>Wl,
                    Cylindrical: ()=>fd,
                    DataTexture: ()=>Ma,
                    DataTexture2DArray: ()=>Xa,
                    DataTexture3D: ()=>Ya,
                    DataTextureLoader: ()=>Tu,
                    DataUtils: ()=>ep,
                    DecrementStencilOp: ()=>pn,
                    DecrementWrapStencilOp: ()=>mn,
                    DefaultLoadingManager: ()=>vu,
                    DepthFormat: ()=>Ge,
                    DepthStencilFormat: ()=>je,
                    DepthTexture: ()=>jl,
                    DirectionalLight: ()=>ah,
                    DirectionalLightHelper: ()=>kd,
                    DiscreteInterpolant: ()=>iu,
                    DodecahedronBufferGeometry: ()=>Yl,
                    DodecahedronGeometry: ()=>Yl,
                    DoubleSide: ()=>g,
                    DstAlphaFactor: ()=>N,
                    DstColorFactor: ()=>k,
                    DynamicBufferAttribute: ()=>zp,
                    DynamicCopyUsage: ()=>Dn,
                    DynamicDrawUsage: ()=>En,
                    DynamicReadUsage: ()=>Pn,
                    EdgesGeometry: ()=>$l,
                    EdgesHelper: ()=>ef,
                    EllipseCurve: ()=>Cu,
                    EqualDepth: ()=>W,
                    EqualStencilFunc: ()=>_n,
                    EquirectangularReflectionMapping: ()=>se,
                    EquirectangularRefractionMapping: ()=>le,
                    Euler: ()=>Or,
                    EventDispatcher: ()=>Nn,
                    ExtrudeBufferGeometry: ()=>Ac,
                    ExtrudeGeometry: ()=>Ac,
                    Face3: ()=>_i,
                    Face4: ()=>Sp,
                    FaceColors: ()=>Cp,
                    FileLoader: ()=>xu,
                    FlatShading: ()=>v,
                    Float16BufferAttribute: ()=>Oi,
                    Float32Attribute: ()=>Xp,
                    Float32BufferAttribute: ()=>Fi,
                    Float64Attribute: ()=>Yp,
                    Float64BufferAttribute: ()=>Ii,
                    FloatType: ()=>Re,
                    Fog: ()=>Bs,
                    FogExp2: ()=>Ns,
                    Font: ()=>bh,
                    FontLoader: ()=>Mh,
                    FrontSide: ()=>f,
                    Frustum: ()=>Ea,
                    GLBufferAttribute: ()=>cd,
                    GLSL1: ()=>Fn,
                    GLSL3: ()=>In,
                    GammaEncoding: ()=>Qt,
                    GeometryUtils: ()=>of,
                    GreaterDepth: ()=>X,
                    GreaterEqualDepth: ()=>q,
                    GreaterEqualStencilFunc: ()=>Mn,
                    GreaterStencilFunc: ()=>bn,
                    GridHelper: ()=>Od,
                    Group: ()=>Rs,
                    HalfFloatType: ()=>Le,
                    HemisphereLight: ()=>Ku,
                    HemisphereLightHelper: ()=>Dd,
                    HemisphereLightProbe: ()=>Ah,
                    IcosahedronBufferGeometry: ()=>Pc,
                    IcosahedronGeometry: ()=>Pc,
                    ImageBitmapLoader: ()=>_h,
                    ImageLoader: ()=>Mu,
                    ImageUtils: ()=>jn,
                    ImmediateRenderObject: ()=>xd,
                    IncrementStencilOp: ()=>dn,
                    IncrementWrapStencilOp: ()=>fn,
                    InstancedBufferAttribute: ()=>ph,
                    InstancedBufferGeometry: ()=>dh,
                    InstancedInterleavedBuffer: ()=>ld,
                    InstancedMesh: ()=>bl,
                    Int16Attribute: ()=>jp,
                    Int16BufferAttribute: ()=>Pi,
                    Int32Attribute: ()=>Wp,
                    Int32BufferAttribute: ()=>Li,
                    Int8Attribute: ()=>Up,
                    Int8BufferAttribute: ()=>Ei,
                    IntType: ()=>Ce,
                    InterleavedBuffer: ()=>zs,
                    InterleavedBufferAttribute: ()=>Hs,
                    Interpolant: ()=>tu,
                    InterpolateDiscrete: ()=>zt,
                    InterpolateLinear: ()=>Ut,
                    InterpolateSmooth: ()=>Ht,
                    InvertStencilOp: ()=>gn,
                    JSONLoader: ()=>lf,
                    KeepStencilOp: ()=>un,
                    KeyframeTrack: ()=>au,
                    LOD: ()=>ol,
                    LatheBufferGeometry: ()=>Rc,
                    LatheGeometry: ()=>Rc,
                    Layers: ()=>Nr,
                    LensFlare: ()=>uf,
                    LessDepth: ()=>j,
                    LessEqualDepth: ()=>V,
                    LessEqualStencilFunc: ()=>xn,
                    LessStencilFunc: ()=>yn,
                    Light: ()=>Ju,
                    LightProbe: ()=>ch,
                    Line: ()=>Cl,
                    Line3: ()=>_d,
                    LineBasicMaterial: ()=>wl,
                    LineCurve: ()=>Hu,
                    LineCurve3: ()=>Gu,
                    LineDashedMaterial: ()=>Qc,
                    LineLoop: ()=>Dl,
                    LinePieces: ()=>Ep,
                    LineSegments: ()=>Ll,
                    LineStrip: ()=>Tp,
                    LinearEncoding: ()=>Jt,
                    LinearFilter: ()=>_e,
                    LinearInterpolant: ()=>ru,
                    LinearMipMapLinearFilter: ()=>Me,
                    LinearMipMapNearestFilter: ()=>be,
                    LinearMipmapLinearFilter: ()=>we,
                    LinearMipmapNearestFilter: ()=>xe,
                    LinearToneMapping: ()=>$,
                    Loader: ()=>yu,
                    LoaderUtils: ()=>hh,
                    LoadingManager: ()=>gu,
                    LogLuvEncoding: ()=>en,
                    LoopOnce: ()=>Nt,
                    LoopPingPong: ()=>kt,
                    LoopRepeat: ()=>Bt,
                    LuminanceAlphaFormat: ()=>Ue,
                    LuminanceFormat: ()=>ze,
                    MOUSE: ()=>i,
                    Material: ()=>bi,
                    MaterialLoader: ()=>uh,
                    Math: ()=>zn,
                    MathUtils: ()=>zn,
                    Matrix3: ()=>Hn,
                    Matrix4: ()=>Tr,
                    MaxEquation: ()=>P,
                    Mesh: ()=>ua,
                    MeshBasicMaterial: ()=>wi,
                    MeshDepthMaterial: ()=>Ms,
                    MeshDistanceMaterial: ()=>Ss,
                    MeshFaceMaterial: ()=>Rp,
                    MeshLambertMaterial: ()=>Jc,
                    MeshMatcapMaterial: ()=>Kc,
                    MeshNormalMaterial: ()=>Zc,
                    MeshPhongMaterial: ()=>Xc,
                    MeshPhysicalMaterial: ()=>qc,
                    MeshStandardMaterial: ()=>Wc,
                    MeshToonMaterial: ()=>Yc,
                    MinEquation: ()=>C,
                    MirroredRepeatWrapping: ()=>pe,
                    MixOperation: ()=>J,
                    MultiMaterial: ()=>Lp,
                    MultiplyBlending: ()=>M,
                    MultiplyOperation: ()=>Z,
                    NearestFilter: ()=>fe,
                    NearestMipMapLinearFilter: ()=>ye,
                    NearestMipMapNearestFilter: ()=>ge,
                    NearestMipmapLinearFilter: ()=>ve,
                    NearestMipmapNearestFilter: ()=>me,
                    NeverDepth: ()=>H,
                    NeverStencilFunc: ()=>vn,
                    NoBlending: ()=>_,
                    NoColors: ()=>Ap,
                    NoToneMapping: ()=>Q,
                    NormalAnimationBlendMode: ()=>Wt,
                    NormalBlending: ()=>x,
                    NotEqualDepth: ()=>Y,
                    NotEqualStencilFunc: ()=>wn,
                    NumberKeyframeTrack: ()=>lu,
                    Object3D: ()=>Jr,
                    ObjectLoader: ()=>mh,
                    ObjectSpaceNormalMap: ()=>ln,
                    OctahedronBufferGeometry: ()=>Lc,
                    OctahedronGeometry: ()=>Lc,
                    OneFactor: ()=>L,
                    OneMinusDstAlphaFactor: ()=>B,
                    OneMinusDstColorFactor: ()=>z,
                    OneMinusSrcAlphaFactor: ()=>I,
                    OneMinusSrcColorFactor: ()=>O,
                    OrthographicCamera: ()=>rh,
                    PCFShadowMap: ()=>h,
                    PCFSoftShadowMap: ()=>d,
                    PMREMGenerator: ()=>vp,
                    ParametricBufferGeometry: ()=>Dc,
                    ParametricGeometry: ()=>Dc,
                    Particle: ()=>Op,
                    ParticleBasicMaterial: ()=>Np,
                    ParticleSystem: ()=>Fp,
                    ParticleSystemMaterial: ()=>Bp,
                    Path: ()=>Yu,
                    PerspectiveCamera: ()=>ya,
                    Plane: ()=>ei,
                    PlaneBufferGeometry: ()=>Pa,
                    PlaneGeometry: ()=>Pa,
                    PlaneHelper: ()=>qd,
                    PointCloud: ()=>Dp,
                    PointCloudMaterial: ()=>Ip,
                    PointLight: ()=>nh,
                    PointLightHelper: ()=>Cd,
                    Points: ()=>kl,
                    PointsMaterial: ()=>Ol,
                    PolarGridHelper: ()=>Fd,
                    PolyhedronBufferGeometry: ()=>Xl,
                    PolyhedronGeometry: ()=>Xl,
                    PositionalAudio: ()=>Vh,
                    PropertyBinding: ()=>rd,
                    PropertyMixer: ()=>qh,
                    QuadraticBezierCurve: ()=>ju,
                    QuadraticBezierCurve3: ()=>Vu,
                    Quaternion: ()=>Jn,
                    QuaternionKeyframeTrack: ()=>uu,
                    QuaternionLinearInterpolant: ()=>cu,
                    REVISION: ()=>r,
                    RGBADepthPacking: ()=>on,
                    RGBAFormat: ()=>ke,
                    RGBAIntegerFormat: ()=>Ze,
                    RGBA_ASTC_10x10_Format: ()=>yt,
                    RGBA_ASTC_10x5_Format: ()=>mt,
                    RGBA_ASTC_10x6_Format: ()=>gt,
                    RGBA_ASTC_10x8_Format: ()=>vt,
                    RGBA_ASTC_12x10_Format: ()=>_t,
                    RGBA_ASTC_12x12_Format: ()=>xt,
                    RGBA_ASTC_4x4_Format: ()=>st,
                    RGBA_ASTC_5x4_Format: ()=>lt,
                    RGBA_ASTC_5x5_Format: ()=>ct,
                    RGBA_ASTC_6x5_Format: ()=>ut,
                    RGBA_ASTC_6x6_Format: ()=>ht,
                    RGBA_ASTC_8x5_Format: ()=>dt,
                    RGBA_ASTC_8x6_Format: ()=>pt,
                    RGBA_ASTC_8x8_Format: ()=>ft,
                    RGBA_BPTC_Format: ()=>bt,
                    RGBA_ETC2_EAC_Format: ()=>ot,
                    RGBA_PVRTC_2BPPV1_Format: ()=>rt,
                    RGBA_PVRTC_4BPPV1_Format: ()=>nt,
                    RGBA_S3TC_DXT1_Format: ()=>Ke,
                    RGBA_S3TC_DXT3_Format: ()=>Qe,
                    RGBA_S3TC_DXT5_Format: ()=>$e,
                    RGBDEncoding: ()=>rn,
                    RGBEEncoding: ()=>$t,
                    RGBEFormat: ()=>He,
                    RGBFormat: ()=>Be,
                    RGBIntegerFormat: ()=>Ye,
                    RGBM16Encoding: ()=>nn,
                    RGBM7Encoding: ()=>tn,
                    RGB_ETC1_Format: ()=>it,
                    RGB_ETC2_Format: ()=>at,
                    RGB_PVRTC_2BPPV1_Format: ()=>tt,
                    RGB_PVRTC_4BPPV1_Format: ()=>et,
                    RGB_S3TC_DXT1_Format: ()=>Je,
                    RGFormat: ()=>qe,
                    RGIntegerFormat: ()=>Xe,
                    RawShaderMaterial: ()=>Vc,
                    Ray: ()=>Sr,
                    Raycaster: ()=>ud,
                    RectAreaLight: ()=>sh,
                    RedFormat: ()=>Ve,
                    RedIntegerFormat: ()=>We,
                    ReinhardToneMapping: ()=>ee,
                    RepeatWrapping: ()=>he,
                    ReplaceStencilOp: ()=>hn,
                    ReverseSubtractEquation: ()=>A,
                    RingBufferGeometry: ()=>Oc,
                    RingGeometry: ()=>Oc,
                    SRGB8_ALPHA8_ASTC_10x10_Format: ()=>Ot,
                    SRGB8_ALPHA8_ASTC_10x5_Format: ()=>Rt,
                    SRGB8_ALPHA8_ASTC_10x6_Format: ()=>Lt,
                    SRGB8_ALPHA8_ASTC_10x8_Format: ()=>Dt,
                    SRGB8_ALPHA8_ASTC_12x10_Format: ()=>Ft,
                    SRGB8_ALPHA8_ASTC_12x12_Format: ()=>It,
                    SRGB8_ALPHA8_ASTC_4x4_Format: ()=>wt,
                    SRGB8_ALPHA8_ASTC_5x4_Format: ()=>Mt,
                    SRGB8_ALPHA8_ASTC_5x5_Format: ()=>St,
                    SRGB8_ALPHA8_ASTC_6x5_Format: ()=>Tt,
                    SRGB8_ALPHA8_ASTC_6x6_Format: ()=>Et,
                    SRGB8_ALPHA8_ASTC_8x5_Format: ()=>At,
                    SRGB8_ALPHA8_ASTC_8x6_Format: ()=>Ct,
                    SRGB8_ALPHA8_ASTC_8x8_Format: ()=>Pt,
                    Scene: ()=>ks,
                    SceneUtils: ()=>cf,
                    ShaderChunk: ()=>Ra,
                    ShaderLib: ()=>Da,
                    ShaderMaterial: ()=>ga,
                    ShadowMaterial: ()=>jc,
                    Shape: ()=>Zu,
                    ShapeBufferGeometry: ()=>Fc,
                    ShapeGeometry: ()=>Fc,
                    ShapePath: ()=>xh,
                    ShapeUtils: ()=>Sc,
                    ShortType: ()=>Ee,
                    Skeleton: ()=>gl,
                    SkeletonHelper: ()=>Ed,
                    SkinnedMesh: ()=>dl,
                    SmoothShading: ()=>y,
                    Sphere: ()=>gr,
                    SphereBufferGeometry: ()=>Ic,
                    SphereGeometry: ()=>Ic,
                    Spherical: ()=>pd,
                    SphericalHarmonics3: ()=>lh,
                    Spline: ()=>Kp,
                    SplineCurve: ()=>Wu,
                    SplineCurve3: ()=>Jp,
                    SpotLight: ()=>eh,
                    SpotLightHelper: ()=>wd,
                    Sprite: ()=>nl,
                    SpriteMaterial: ()=>Gs,
                    SrcAlphaFactor: ()=>F,
                    SrcAlphaSaturateFactor: ()=>U,
                    SrcColorFactor: ()=>D,
                    StaticCopyUsage: ()=>Ln,
                    StaticDrawUsage: ()=>Tn,
                    StaticReadUsage: ()=>Cn,
                    StereoCamera: ()=>Lh,
                    StreamCopyUsage: ()=>On,
                    StreamDrawUsage: ()=>An,
                    StreamReadUsage: ()=>Rn,
                    StringKeyframeTrack: ()=>hu,
                    SubtractEquation: ()=>E,
                    SubtractiveBlending: ()=>w,
                    TOUCH: ()=>a,
                    TangentSpaceNormalMap: ()=>sn,
                    TetrahedronBufferGeometry: ()=>Nc,
                    TetrahedronGeometry: ()=>Nc,
                    TextBufferGeometry: ()=>Bc,
                    TextGeometry: ()=>Bc,
                    Texture: ()=>Wn,
                    TextureLoader: ()=>Eu,
                    TorusBufferGeometry: ()=>kc,
                    TorusGeometry: ()=>kc,
                    TorusKnotBufferGeometry: ()=>zc,
                    TorusKnotGeometry: ()=>zc,
                    Triangle: ()=>hi,
                    TriangleFanDrawMode: ()=>Zt,
                    TriangleStripDrawMode: ()=>Yt,
                    TrianglesDrawMode: ()=>Xt,
                    TubeBufferGeometry: ()=>Uc,
                    TubeGeometry: ()=>Uc,
                    UVMapping: ()=>ie,
                    Uint16Attribute: ()=>Vp,
                    Uint16BufferAttribute: ()=>Ri,
                    Uint32Attribute: ()=>qp,
                    Uint32BufferAttribute: ()=>Di,
                    Uint8Attribute: ()=>Hp,
                    Uint8BufferAttribute: ()=>Ai,
                    Uint8ClampedAttribute: ()=>Gp,
                    Uint8ClampedBufferAttribute: ()=>Ci,
                    Uniform: ()=>sd,
                    UniformsLib: ()=>La,
                    UniformsUtils: ()=>ma,
                    UnsignedByteType: ()=>Se,
                    UnsignedInt248Type: ()=>Ie,
                    UnsignedIntType: ()=>Pe,
                    UnsignedShort4444Type: ()=>De,
                    UnsignedShort5551Type: ()=>Oe,
                    UnsignedShort565Type: ()=>Fe,
                    UnsignedShortType: ()=>Ae,
                    VSMShadowMap: ()=>p,
                    Vector2: ()=>Un,
                    Vector3: ()=>Kn,
                    Vector4: ()=>Xn,
                    VectorKeyframeTrack: ()=>du,
                    Vertex: ()=>kp,
                    VertexColors: ()=>Pp,
                    VideoTexture: ()=>Ul,
                    WebGL1Renderer: ()=>Is,
                    WebGLCubeRenderTarget: ()=>wa,
                    WebGLMultisampleRenderTarget: ()=>Zn,
                    WebGLRenderTarget: ()=>Yn,
                    WebGLRenderTargetCube: ()=>af,
                    WebGLRenderer: ()=>Fs,
                    WebGLUtils: ()=>Cs,
                    WireframeGeometry: ()=>Hc,
                    WireframeHelper: ()=>tf,
                    WrapAroundEnding: ()=>Vt,
                    XHRLoader: ()=>nf,
                    ZeroCurvatureEnding: ()=>Gt,
                    ZeroFactor: ()=>R,
                    ZeroSlopeEnding: ()=>jt,
                    ZeroStencilOp: ()=>cn,
                    sRGBEncoding: ()=>Kt
                });
                const r = "125"
                  , i = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                }
                  , a = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                }
                  , o = 0
                  , s = 1
                  , l = 2
                  , c = 3
                  , u = 0
                  , h = 1
                  , d = 2
                  , p = 3
                  , f = 0
                  , m = 1
                  , g = 2
                  , v = 1
                  , y = 2
                  , _ = 0
                  , x = 1
                  , b = 2
                  , w = 3
                  , M = 4
                  , S = 5
                  , T = 100
                  , E = 101
                  , A = 102
                  , C = 103
                  , P = 104
                  , R = 200
                  , L = 201
                  , D = 202
                  , O = 203
                  , F = 204
                  , I = 205
                  , N = 206
                  , B = 207
                  , k = 208
                  , z = 209
                  , U = 210
                  , H = 0
                  , G = 1
                  , j = 2
                  , V = 3
                  , W = 4
                  , q = 5
                  , X = 6
                  , Y = 7
                  , Z = 0
                  , J = 1
                  , K = 2
                  , Q = 0
                  , $ = 1
                  , ee = 2
                  , te = 3
                  , ne = 4
                  , re = 5
                  , ie = 300
                  , ae = 301
                  , oe = 302
                  , se = 303
                  , le = 304
                  , ce = 306
                  , ue = 307
                  , he = 1e3
                  , de = 1001
                  , pe = 1002
                  , fe = 1003
                  , me = 1004
                  , ge = 1004
                  , ve = 1005
                  , ye = 1005
                  , _e = 1006
                  , xe = 1007
                  , be = 1007
                  , we = 1008
                  , Me = 1008
                  , Se = 1009
                  , Te = 1010
                  , Ee = 1011
                  , Ae = 1012
                  , Ce = 1013
                  , Pe = 1014
                  , Re = 1015
                  , Le = 1016
                  , De = 1017
                  , Oe = 1018
                  , Fe = 1019
                  , Ie = 1020
                  , Ne = 1021
                  , Be = 1022
                  , ke = 1023
                  , ze = 1024
                  , Ue = 1025
                  , He = ke
                  , Ge = 1026
                  , je = 1027
                  , Ve = 1028
                  , We = 1029
                  , qe = 1030
                  , Xe = 1031
                  , Ye = 1032
                  , Ze = 1033
                  , Je = 33776
                  , Ke = 33777
                  , Qe = 33778
                  , $e = 33779
                  , et = 35840
                  , tt = 35841
                  , nt = 35842
                  , rt = 35843
                  , it = 36196
                  , at = 37492
                  , ot = 37496
                  , st = 37808
                  , lt = 37809
                  , ct = 37810
                  , ut = 37811
                  , ht = 37812
                  , dt = 37813
                  , pt = 37814
                  , ft = 37815
                  , mt = 37816
                  , gt = 37817
                  , vt = 37818
                  , yt = 37819
                  , _t = 37820
                  , xt = 37821
                  , bt = 36492
                  , wt = 37840
                  , Mt = 37841
                  , St = 37842
                  , Tt = 37843
                  , Et = 37844
                  , At = 37845
                  , Ct = 37846
                  , Pt = 37847
                  , Rt = 37848
                  , Lt = 37849
                  , Dt = 37850
                  , Ot = 37851
                  , Ft = 37852
                  , It = 37853
                  , Nt = 2200
                  , Bt = 2201
                  , kt = 2202
                  , zt = 2300
                  , Ut = 2301
                  , Ht = 2302
                  , Gt = 2400
                  , jt = 2401
                  , Vt = 2402
                  , Wt = 2500
                  , qt = 2501
                  , Xt = 0
                  , Yt = 1
                  , Zt = 2
                  , Jt = 3e3
                  , Kt = 3001
                  , Qt = 3007
                  , $t = 3002
                  , en = 3003
                  , tn = 3004
                  , nn = 3005
                  , rn = 3006
                  , an = 3200
                  , on = 3201
                  , sn = 0
                  , ln = 1
                  , cn = 0
                  , un = 7680
                  , hn = 7681
                  , dn = 7682
                  , pn = 7683
                  , fn = 34055
                  , mn = 34056
                  , gn = 5386
                  , vn = 512
                  , yn = 513
                  , _n = 514
                  , xn = 515
                  , bn = 516
                  , wn = 517
                  , Mn = 518
                  , Sn = 519
                  , Tn = 35044
                  , En = 35048
                  , An = 35040
                  , Cn = 35045
                  , Pn = 35049
                  , Rn = 35041
                  , Ln = 35046
                  , Dn = 35050
                  , On = 35042
                  , Fn = "100"
                  , In = "300 es";
                function Nn() {}
                Object.assign(Nn.prototype, {
                    addEventListener: function(e, t) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[e] && (n[e] = []),
                        -1 === n[e].indexOf(t) && n[e].push(t)
                    },
                    hasEventListener: function(e, t) {
                        if (void 0 === this._listeners)
                            return !1;
                        const n = this._listeners;
                        return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                    },
                    removeEventListener: function(e, t) {
                        if (void 0 === this._listeners)
                            return;
                        const n = this._listeners[e];
                        if (void 0 !== n) {
                            const e = n.indexOf(t);
                            -1 !== e && n.splice(e, 1)
                        }
                    },
                    dispatchEvent: function(e) {
                        if (void 0 === this._listeners)
                            return;
                        const t = this._listeners[e.type];
                        if (void 0 !== t) {
                            e.target = this;
                            const n = t.slice(0);
                            for (let t = 0, r = n.length; t < r; t++)
                                n[t].call(this, e)
                        }
                    }
                });
                const Bn = [];
                for (let e = 0; e < 256; e++)
                    Bn[e] = (e < 16 ? "0" : "") + e.toString(16);
                let kn = 1234567;
                const zn = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        const e = 4294967295 * Math.random() | 0
                          , t = 4294967295 * Math.random() | 0
                          , n = 4294967295 * Math.random() | 0
                          , r = 4294967295 * Math.random() | 0;
                        return (Bn[255 & e] + Bn[e >> 8 & 255] + Bn[e >> 16 & 255] + Bn[e >> 24 & 255] + "-" + Bn[255 & t] + Bn[t >> 8 & 255] + "-" + Bn[t >> 16 & 15 | 64] + Bn[t >> 24 & 255] + "-" + Bn[63 & n | 128] + Bn[n >> 8 & 255] + "-" + Bn[n >> 16 & 255] + Bn[n >> 24 & 255] + Bn[255 & r] + Bn[r >> 8 & 255] + Bn[r >> 16 & 255] + Bn[r >> 24 & 255]).toUpperCase()
                    },
                    clamp: function(e, t, n) {
                        return Math.max(t, Math.min(n, e))
                    },
                    euclideanModulo: function(e, t) {
                        return (e % t + t) % t
                    },
                    mapLinear: function(e, t, n, r, i) {
                        return r + (e - t) * (i - r) / (n - t)
                    },
                    lerp: function(e, t, n) {
                        return (1 - n) * e + n * t
                    },
                    damp: function(e, t, n, r) {
                        return zn.lerp(e, t, 1 - Math.exp(-n * r))
                    },
                    pingpong: function(e, t=1) {
                        return t - Math.abs(zn.euclideanModulo(e, 2 * t) - t)
                    },
                    smoothstep: function(e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                    },
                    smootherstep: function(e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                    },
                    randInt: function(e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function(e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function(e) {
                        return e * (.5 - Math.random())
                    },
                    seededRandom: function(e) {
                        return void 0 !== e && (kn = e % 2147483647),
                        kn = 16807 * kn % 2147483647,
                        (kn - 1) / 2147483646
                    },
                    degToRad: function(e) {
                        return e * zn.DEG2RAD
                    },
                    radToDeg: function(e) {
                        return e * zn.RAD2DEG
                    },
                    isPowerOfTwo: function(e) {
                        return 0 == (e & e - 1) && 0 !== e
                    },
                    ceilPowerOfTwo: function(e) {
                        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                    },
                    floorPowerOfTwo: function(e) {
                        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                    },
                    setQuaternionFromProperEuler: function(e, t, n, r, i) {
                        const a = Math.cos
                          , o = Math.sin
                          , s = a(n / 2)
                          , l = o(n / 2)
                          , c = a((t + r) / 2)
                          , u = o((t + r) / 2)
                          , h = a((t - r) / 2)
                          , d = o((t - r) / 2)
                          , p = a((r - t) / 2)
                          , f = o((r - t) / 2);
                        switch (i) {
                        case "XYX":
                            e.set(s * u, l * h, l * d, s * c);
                            break;
                        case "YZY":
                            e.set(l * d, s * u, l * h, s * c);
                            break;
                        case "ZXZ":
                            e.set(l * h, l * d, s * u, s * c);
                            break;
                        case "XZX":
                            e.set(s * u, l * f, l * p, s * c);
                            break;
                        case "YXY":
                            e.set(l * p, s * u, l * f, s * c);
                            break;
                        case "ZYZ":
                            e.set(l * f, l * p, s * u, s * c);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                        }
                    }
                };
                class Un {
                    constructor(e=0, t=0) {
                        Object.defineProperty(this, "isVector2", {
                            value: !0
                        }),
                        this.x = e,
                        this.y = t
                    }
                    get width() {
                        return this.x
                    }
                    set width(e) {
                        this.x = e
                    }
                    get height() {
                        return this.y
                    }
                    set height(e) {
                        this.y = e
                    }
                    set(e, t) {
                        return this.x = e,
                        this.y = t,
                        this
                    }
                    setScalar(e) {
                        return this.x = e,
                        this.y = e,
                        this
                    }
                    setX(e) {
                        return this.x = e,
                        this
                    }
                    setY(e) {
                        return this.y = e,
                        this
                    }
                    setComponent(e, t) {
                        switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                        return this
                    }
                    getComponent(e) {
                        switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y)
                    }
                    copy(e) {
                        return this.x = e.x,
                        this.y = e.y,
                        this
                    }
                    add(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(e, t)) : (this.x += e.x,
                        this.y += e.y,
                        this)
                    }
                    addScalar(e) {
                        return this.x += e,
                        this.y += e,
                        this
                    }
                    addVectors(e, t) {
                        return this.x = e.x + t.x,
                        this.y = e.y + t.y,
                        this
                    }
                    addScaledVector(e, t) {
                        return this.x += e.x * t,
                        this.y += e.y * t,
                        this
                    }
                    sub(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(e, t)) : (this.x -= e.x,
                        this.y -= e.y,
                        this)
                    }
                    subScalar(e) {
                        return this.x -= e,
                        this.y -= e,
                        this
                    }
                    subVectors(e, t) {
                        return this.x = e.x - t.x,
                        this.y = e.y - t.y,
                        this
                    }
                    multiply(e) {
                        return this.x *= e.x,
                        this.y *= e.y,
                        this
                    }
                    multiplyScalar(e) {
                        return this.x *= e,
                        this.y *= e,
                        this
                    }
                    divide(e) {
                        return this.x /= e.x,
                        this.y /= e.y,
                        this
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e)
                    }
                    applyMatrix3(e) {
                        const t = this.x
                          , n = this.y
                          , r = e.elements;
                        return this.x = r[0] * t + r[3] * n + r[6],
                        this.y = r[1] * t + r[4] * n + r[7],
                        this
                    }
                    min(e) {
                        return this.x = Math.min(this.x, e.x),
                        this.y = Math.min(this.y, e.y),
                        this
                    }
                    max(e) {
                        return this.x = Math.max(this.x, e.x),
                        this.y = Math.max(this.y, e.y),
                        this
                    }
                    clamp(e, t) {
                        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                        this.y = Math.max(e.y, Math.min(t.y, this.y)),
                        this
                    }
                    clampScalar(e, t) {
                        return this.x = Math.max(e, Math.min(t, this.x)),
                        this.y = Math.max(e, Math.min(t, this.y)),
                        this
                    }
                    clampLength(e, t) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y
                    }
                    cross(e) {
                        return this.x * e.y - this.y * e.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    distanceTo(e) {
                        return Math.sqrt(this.distanceToSquared(e))
                    }
                    distanceToSquared(e) {
                        const t = this.x - e.x
                          , n = this.y - e.y;
                        return t * t + n * n
                    }
                    manhattanDistanceTo(e) {
                        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                    lerp(e, t) {
                        return this.x += (e.x - this.x) * t,
                        this.y += (e.y - this.y) * t,
                        this
                    }
                    lerpVectors(e, t, n) {
                        return this.x = e.x + (t.x - e.x) * n,
                        this.y = e.y + (t.y - e.y) * n,
                        this
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y
                    }
                    fromArray(e, t=0) {
                        return this.x = e[t],
                        this.y = e[t + 1],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.x,
                        e[t + 1] = this.y,
                        e
                    }
                    fromBufferAttribute(e, t, n) {
                        return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
                        this.x = e.getX(t),
                        this.y = e.getY(t),
                        this
                    }
                    rotateAround(e, t) {
                        const n = Math.cos(t)
                          , r = Math.sin(t)
                          , i = this.x - e.x
                          , a = this.y - e.y;
                        return this.x = i * n - a * r + e.x,
                        this.y = i * r + a * n + e.y,
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this
                    }
                }
                class Hn {
                    constructor() {
                        Object.defineProperty(this, "isMatrix3", {
                            value: !0
                        }),
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                    }
                    set(e, t, n, r, i, a, o, s, l) {
                        const c = this.elements;
                        return c[0] = e,
                        c[1] = r,
                        c[2] = o,
                        c[3] = t,
                        c[4] = i,
                        c[5] = s,
                        c[6] = n,
                        c[7] = a,
                        c[8] = l,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                    }
                    clone() {
                        return (new this.constructor).fromArray(this.elements)
                    }
                    copy(e) {
                        const t = this.elements
                          , n = e.elements;
                        return t[0] = n[0],
                        t[1] = n[1],
                        t[2] = n[2],
                        t[3] = n[3],
                        t[4] = n[4],
                        t[5] = n[5],
                        t[6] = n[6],
                        t[7] = n[7],
                        t[8] = n[8],
                        this
                    }
                    extractBasis(e, t, n) {
                        return e.setFromMatrix3Column(this, 0),
                        t.setFromMatrix3Column(this, 1),
                        n.setFromMatrix3Column(this, 2),
                        this
                    }
                    setFromMatrix4(e) {
                        const t = e.elements;
                        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                        this
                    }
                    multiply(e) {
                        return this.multiplyMatrices(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyMatrices(e, this)
                    }
                    multiplyMatrices(e, t) {
                        const n = e.elements
                          , r = t.elements
                          , i = this.elements
                          , a = n[0]
                          , o = n[3]
                          , s = n[6]
                          , l = n[1]
                          , c = n[4]
                          , u = n[7]
                          , h = n[2]
                          , d = n[5]
                          , p = n[8]
                          , f = r[0]
                          , m = r[3]
                          , g = r[6]
                          , v = r[1]
                          , y = r[4]
                          , _ = r[7]
                          , x = r[2]
                          , b = r[5]
                          , w = r[8];
                        return i[0] = a * f + o * v + s * x,
                        i[3] = a * m + o * y + s * b,
                        i[6] = a * g + o * _ + s * w,
                        i[1] = l * f + c * v + u * x,
                        i[4] = l * m + c * y + u * b,
                        i[7] = l * g + c * _ + u * w,
                        i[2] = h * f + d * v + p * x,
                        i[5] = h * m + d * y + p * b,
                        i[8] = h * g + d * _ + p * w,
                        this
                    }
                    multiplyScalar(e) {
                        const t = this.elements;
                        return t[0] *= e,
                        t[3] *= e,
                        t[6] *= e,
                        t[1] *= e,
                        t[4] *= e,
                        t[7] *= e,
                        t[2] *= e,
                        t[5] *= e,
                        t[8] *= e,
                        this
                    }
                    determinant() {
                        const e = this.elements
                          , t = e[0]
                          , n = e[1]
                          , r = e[2]
                          , i = e[3]
                          , a = e[4]
                          , o = e[5]
                          , s = e[6]
                          , l = e[7]
                          , c = e[8];
                        return t * a * c - t * o * l - n * i * c + n * o * s + r * i * l - r * a * s
                    }
                    invert() {
                        const e = this.elements
                          , t = e[0]
                          , n = e[1]
                          , r = e[2]
                          , i = e[3]
                          , a = e[4]
                          , o = e[5]
                          , s = e[6]
                          , l = e[7]
                          , c = e[8]
                          , u = c * a - o * l
                          , h = o * s - c * i
                          , d = l * i - a * s
                          , p = t * u + n * h + r * d;
                        if (0 === p)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const f = 1 / p;
                        return e[0] = u * f,
                        e[1] = (r * l - c * n) * f,
                        e[2] = (o * n - r * a) * f,
                        e[3] = h * f,
                        e[4] = (c * t - r * s) * f,
                        e[5] = (r * i - o * t) * f,
                        e[6] = d * f,
                        e[7] = (n * s - l * t) * f,
                        e[8] = (a * t - n * i) * f,
                        this
                    }
                    transpose() {
                        let e;
                        const t = this.elements;
                        return e = t[1],
                        t[1] = t[3],
                        t[3] = e,
                        e = t[2],
                        t[2] = t[6],
                        t[6] = e,
                        e = t[5],
                        t[5] = t[7],
                        t[7] = e,
                        this
                    }
                    getNormalMatrix(e) {
                        return this.setFromMatrix4(e).copy(this).invert().transpose()
                    }
                    transposeIntoArray(e) {
                        const t = this.elements;
                        return e[0] = t[0],
                        e[1] = t[3],
                        e[2] = t[6],
                        e[3] = t[1],
                        e[4] = t[4],
                        e[5] = t[7],
                        e[6] = t[2],
                        e[7] = t[5],
                        e[8] = t[8],
                        this
                    }
                    setUvTransform(e, t, n, r, i, a, o) {
                        const s = Math.cos(i)
                          , l = Math.sin(i);
                        return this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1),
                        this
                    }
                    scale(e, t) {
                        const n = this.elements;
                        return n[0] *= e,
                        n[3] *= e,
                        n[6] *= e,
                        n[1] *= t,
                        n[4] *= t,
                        n[7] *= t,
                        this
                    }
                    rotate(e) {
                        const t = Math.cos(e)
                          , n = Math.sin(e)
                          , r = this.elements
                          , i = r[0]
                          , a = r[3]
                          , o = r[6]
                          , s = r[1]
                          , l = r[4]
                          , c = r[7];
                        return r[0] = t * i + n * s,
                        r[3] = t * a + n * l,
                        r[6] = t * o + n * c,
                        r[1] = -n * i + t * s,
                        r[4] = -n * a + t * l,
                        r[7] = -n * o + t * c,
                        this
                    }
                    translate(e, t) {
                        const n = this.elements;
                        return n[0] += e * n[2],
                        n[3] += e * n[5],
                        n[6] += e * n[8],
                        n[1] += t * n[2],
                        n[4] += t * n[5],
                        n[7] += t * n[8],
                        this
                    }
                    equals(e) {
                        const t = this.elements
                          , n = e.elements;
                        for (let e = 0; e < 9; e++)
                            if (t[e] !== n[e])
                                return !1;
                        return !0
                    }
                    fromArray(e, t=0) {
                        for (let n = 0; n < 9; n++)
                            this.elements[n] = e[n + t];
                        return this
                    }
                    toArray(e=[], t=0) {
                        const n = this.elements;
                        return e[t] = n[0],
                        e[t + 1] = n[1],
                        e[t + 2] = n[2],
                        e[t + 3] = n[3],
                        e[t + 4] = n[4],
                        e[t + 5] = n[5],
                        e[t + 6] = n[6],
                        e[t + 7] = n[7],
                        e[t + 8] = n[8],
                        e
                    }
                }
                let Gn;
                const jn = {
                    getDataURL: function(e) {
                        if (/^data:/i.test(e.src))
                            return e.src;
                        if ("undefined" == typeof HTMLCanvasElement)
                            return e.src;
                        let t;
                        if (e instanceof HTMLCanvasElement)
                            t = e;
                        else {
                            void 0 === Gn && (Gn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                            Gn.width = e.width,
                            Gn.height = e.height;
                            const n = Gn.getContext("2d");
                            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                            t = Gn
                        }
                        return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }
                };
                let Vn = 0;
                function Wn(e=Wn.DEFAULT_IMAGE, t=Wn.DEFAULT_MAPPING, n=de, r=de, i=_e, a=we, o=ke, s=Se, l=1, c=Jt) {
                    Object.defineProperty(this, "id", {
                        value: Vn++
                    }),
                    this.uuid = zn.generateUUID(),
                    this.name = "",
                    this.image = e,
                    this.mipmaps = [],
                    this.mapping = t,
                    this.wrapS = n,
                    this.wrapT = r,
                    this.magFilter = i,
                    this.minFilter = a,
                    this.anisotropy = l,
                    this.format = o,
                    this.internalFormat = null,
                    this.type = s,
                    this.offset = new Un(0,0),
                    this.repeat = new Un(1,1),
                    this.center = new Un(0,0),
                    this.rotation = 0,
                    this.matrixAutoUpdate = !0,
                    this.matrix = new Hn,
                    this.generateMipmaps = !0,
                    this.premultiplyAlpha = !1,
                    this.flipY = !0,
                    this.unpackAlignment = 4,
                    this.encoding = c,
                    this.version = 0,
                    this.onUpdate = null
                }
                function qn(e) {
                    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? jn.getDataURL(e) : e.data ? {
                        data: Array.prototype.slice.call(e.data),
                        width: e.width,
                        height: e.height,
                        type: e.data.constructor.name
                    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
                    {})
                }
                Wn.DEFAULT_IMAGE = void 0,
                Wn.DEFAULT_MAPPING = ie,
                Wn.prototype = Object.assign(Object.create(Nn.prototype), {
                    constructor: Wn,
                    isTexture: !0,
                    updateMatrix: function() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(e) {
                        return this.name = e.name,
                        this.image = e.image,
                        this.mipmaps = e.mipmaps.slice(0),
                        this.mapping = e.mapping,
                        this.wrapS = e.wrapS,
                        this.wrapT = e.wrapT,
                        this.magFilter = e.magFilter,
                        this.minFilter = e.minFilter,
                        this.anisotropy = e.anisotropy,
                        this.format = e.format,
                        this.internalFormat = e.internalFormat,
                        this.type = e.type,
                        this.offset.copy(e.offset),
                        this.repeat.copy(e.repeat),
                        this.center.copy(e.center),
                        this.rotation = e.rotation,
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this.matrix.copy(e.matrix),
                        this.generateMipmaps = e.generateMipmaps,
                        this.premultiplyAlpha = e.premultiplyAlpha,
                        this.flipY = e.flipY,
                        this.unpackAlignment = e.unpackAlignment,
                        this.encoding = e.encoding,
                        this
                    },
                    toJSON: function(e) {
                        const t = void 0 === e || "string" == typeof e;
                        if (!t && void 0 !== e.textures[this.uuid])
                            return e.textures[this.uuid];
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        if (void 0 !== this.image) {
                            const r = this.image;
                            if (void 0 === r.uuid && (r.uuid = zn.generateUUID()),
                            !t && void 0 === e.images[r.uuid]) {
                                let t;
                                if (Array.isArray(r)) {
                                    t = [];
                                    for (let e = 0, n = r.length; e < n; e++)
                                        r[e].isDataTexture ? t.push(qn(r[e].image)) : t.push(qn(r[e]))
                                } else
                                    t = qn(r);
                                e.images[r.uuid] = {
                                    uuid: r.uuid,
                                    url: t
                                }
                            }
                            n.image = r.uuid
                        }
                        return t || (e.textures[this.uuid] = n),
                        n
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    },
                    transformUv: function(e) {
                        if (this.mapping !== ie)
                            return e;
                        if (e.applyMatrix3(this.matrix),
                        e.x < 0 || e.x > 1)
                            switch (this.wrapS) {
                            case he:
                                e.x = e.x - Math.floor(e.x);
                                break;
                            case de:
                                e.x = e.x < 0 ? 0 : 1;
                                break;
                            case pe:
                                1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                            }
                        if (e.y < 0 || e.y > 1)
                            switch (this.wrapT) {
                            case he:
                                e.y = e.y - Math.floor(e.y);
                                break;
                            case de:
                                e.y = e.y < 0 ? 0 : 1;
                                break;
                            case pe:
                                1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                            }
                        return this.flipY && (e.y = 1 - e.y),
                        e
                    }
                }),
                Object.defineProperty(Wn.prototype, "needsUpdate", {
                    set: function(e) {
                        !0 === e && this.version++
                    }
                });
                class Xn {
                    constructor(e=0, t=0, n=0, r=1) {
                        Object.defineProperty(this, "isVector4", {
                            value: !0
                        }),
                        this.x = e,
                        this.y = t,
                        this.z = n,
                        this.w = r
                    }
                    get width() {
                        return this.z
                    }
                    set width(e) {
                        this.z = e
                    }
                    get height() {
                        return this.w
                    }
                    set height(e) {
                        this.w = e
                    }
                    set(e, t, n, r) {
                        return this.x = e,
                        this.y = t,
                        this.z = n,
                        this.w = r,
                        this
                    }
                    setScalar(e) {
                        return this.x = e,
                        this.y = e,
                        this.z = e,
                        this.w = e,
                        this
                    }
                    setX(e) {
                        return this.x = e,
                        this
                    }
                    setY(e) {
                        return this.y = e,
                        this
                    }
                    setZ(e) {
                        return this.z = e,
                        this
                    }
                    setW(e) {
                        return this.w = e,
                        this
                    }
                    setComponent(e, t) {
                        switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                        return this
                    }
                    getComponent(e) {
                        switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z,this.w)
                    }
                    copy(e) {
                        return this.x = e.x,
                        this.y = e.y,
                        this.z = e.z,
                        this.w = void 0 !== e.w ? e.w : 1,
                        this
                    }
                    add(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(e, t)) : (this.x += e.x,
                        this.y += e.y,
                        this.z += e.z,
                        this.w += e.w,
                        this)
                    }
                    addScalar(e) {
                        return this.x += e,
                        this.y += e,
                        this.z += e,
                        this.w += e,
                        this
                    }
                    addVectors(e, t) {
                        return this.x = e.x + t.x,
                        this.y = e.y + t.y,
                        this.z = e.z + t.z,
                        this.w = e.w + t.w,
                        this
                    }
                    addScaledVector(e, t) {
                        return this.x += e.x * t,
                        this.y += e.y * t,
                        this.z += e.z * t,
                        this.w += e.w * t,
                        this
                    }
                    sub(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(e, t)) : (this.x -= e.x,
                        this.y -= e.y,
                        this.z -= e.z,
                        this.w -= e.w,
                        this)
                    }
                    subScalar(e) {
                        return this.x -= e,
                        this.y -= e,
                        this.z -= e,
                        this.w -= e,
                        this
                    }
                    subVectors(e, t) {
                        return this.x = e.x - t.x,
                        this.y = e.y - t.y,
                        this.z = e.z - t.z,
                        this.w = e.w - t.w,
                        this
                    }
                    multiply(e) {
                        return this.x *= e.x,
                        this.y *= e.y,
                        this.z *= e.z,
                        this.w *= e.w,
                        this
                    }
                    multiplyScalar(e) {
                        return this.x *= e,
                        this.y *= e,
                        this.z *= e,
                        this.w *= e,
                        this
                    }
                    applyMatrix4(e) {
                        const t = this.x
                          , n = this.y
                          , r = this.z
                          , i = this.w
                          , a = e.elements;
                        return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i,
                        this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i,
                        this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i,
                        this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i,
                        this
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e)
                    }
                    setAxisAngleFromQuaternion(e) {
                        this.w = 2 * Math.acos(e.w);
                        const t = Math.sqrt(1 - e.w * e.w);
                        return t < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = e.x / t,
                        this.y = e.y / t,
                        this.z = e.z / t),
                        this
                    }
                    setAxisAngleFromRotationMatrix(e) {
                        let t, n, r, i;
                        const a = .01
                          , o = .1
                          , s = e.elements
                          , l = s[0]
                          , c = s[4]
                          , u = s[8]
                          , h = s[1]
                          , d = s[5]
                          , p = s[9]
                          , f = s[2]
                          , m = s[6]
                          , g = s[10];
                        if (Math.abs(c - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                            if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o)
                                return this.set(1, 0, 0, 0),
                                this;
                            t = Math.PI;
                            const e = (l + 1) / 2
                              , s = (d + 1) / 2
                              , v = (g + 1) / 2
                              , y = (c + h) / 4
                              , _ = (u + f) / 4
                              , x = (p + m) / 4;
                            return e > s && e > v ? e < a ? (n = 0,
                            r = .707106781,
                            i = .707106781) : (n = Math.sqrt(e),
                            r = y / n,
                            i = _ / n) : s > v ? s < a ? (n = .707106781,
                            r = 0,
                            i = .707106781) : (r = Math.sqrt(s),
                            n = y / r,
                            i = x / r) : v < a ? (n = .707106781,
                            r = .707106781,
                            i = 0) : (i = Math.sqrt(v),
                            n = _ / i,
                            r = x / i),
                            this.set(n, r, i, t),
                            this
                        }
                        let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                        return Math.abs(v) < .001 && (v = 1),
                        this.x = (m - p) / v,
                        this.y = (u - f) / v,
                        this.z = (h - c) / v,
                        this.w = Math.acos((l + d + g - 1) / 2),
                        this
                    }
                    min(e) {
                        return this.x = Math.min(this.x, e.x),
                        this.y = Math.min(this.y, e.y),
                        this.z = Math.min(this.z, e.z),
                        this.w = Math.min(this.w, e.w),
                        this
                    }
                    max(e) {
                        return this.x = Math.max(this.x, e.x),
                        this.y = Math.max(this.y, e.y),
                        this.z = Math.max(this.z, e.z),
                        this.w = Math.max(this.w, e.w),
                        this
                    }
                    clamp(e, t) {
                        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                        this.y = Math.max(e.y, Math.min(t.y, this.y)),
                        this.z = Math.max(e.z, Math.min(t.z, this.z)),
                        this.w = Math.max(e.w, Math.min(t.w, this.w)),
                        this
                    }
                    clampScalar(e, t) {
                        return this.x = Math.max(e, Math.min(t, this.x)),
                        this.y = Math.max(e, Math.min(t, this.y)),
                        this.z = Math.max(e, Math.min(t, this.z)),
                        this.w = Math.max(e, Math.min(t, this.w)),
                        this
                    }
                    clampLength(e, t) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                    lerp(e, t) {
                        return this.x += (e.x - this.x) * t,
                        this.y += (e.y - this.y) * t,
                        this.z += (e.z - this.z) * t,
                        this.w += (e.w - this.w) * t,
                        this
                    }
                    lerpVectors(e, t, n) {
                        return this.x = e.x + (t.x - e.x) * n,
                        this.y = e.y + (t.y - e.y) * n,
                        this.z = e.z + (t.z - e.z) * n,
                        this.w = e.w + (t.w - e.w) * n,
                        this
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                    }
                    fromArray(e, t=0) {
                        return this.x = e[t],
                        this.y = e[t + 1],
                        this.z = e[t + 2],
                        this.w = e[t + 3],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.x,
                        e[t + 1] = this.y,
                        e[t + 2] = this.z,
                        e[t + 3] = this.w,
                        e
                    }
                    fromBufferAttribute(e, t, n) {
                        return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
                        this.x = e.getX(t),
                        this.y = e.getY(t),
                        this.z = e.getZ(t),
                        this.w = e.getW(t),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this.w = Math.random(),
                        this
                    }
                }
                class Yn extends Nn {
                    constructor(e, t, n) {
                        super(),
                        Object.defineProperty(this, "isWebGLRenderTarget", {
                            value: !0
                        }),
                        this.width = e,
                        this.height = t,
                        this.scissor = new Xn(0,0,e,t),
                        this.scissorTest = !1,
                        this.viewport = new Xn(0,0,e,t),
                        n = n || {},
                        this.texture = new Wn(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                        this.texture.image = {},
                        this.texture.image.width = e,
                        this.texture.image.height = t,
                        this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
                        this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : _e,
                        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                        this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
                        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                    }
                    setSize(e, t) {
                        this.width === e && this.height === t || (this.width = e,
                        this.height = t,
                        this.texture.image.width = e,
                        this.texture.image.height = t,
                        this.dispose()),
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.width = e.width,
                        this.height = e.height,
                        this.viewport.copy(e.viewport),
                        this.texture = e.texture.clone(),
                        this.depthBuffer = e.depthBuffer,
                        this.stencilBuffer = e.stencilBuffer,
                        this.depthTexture = e.depthTexture,
                        this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                class Zn extends Yn {
                    constructor(e, t, n) {
                        super(e, t, n),
                        Object.defineProperty(this, "isWebGLMultisampleRenderTarget", {
                            value: !0
                        }),
                        this.samples = 4
                    }
                    copy(e) {
                        return super.copy.call(this, e),
                        this.samples = e.samples,
                        this
                    }
                }
                class Jn {
                    constructor(e=0, t=0, n=0, r=1) {
                        Object.defineProperty(this, "isQuaternion", {
                            value: !0
                        }),
                        this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = r
                    }
                    static slerp(e, t, n, r) {
                        return n.copy(e).slerp(t, r)
                    }
                    static slerpFlat(e, t, n, r, i, a, o) {
                        let s = n[r + 0]
                          , l = n[r + 1]
                          , c = n[r + 2]
                          , u = n[r + 3];
                        const h = i[a + 0]
                          , d = i[a + 1]
                          , p = i[a + 2]
                          , f = i[a + 3];
                        if (u !== f || s !== h || l !== d || c !== p) {
                            let e = 1 - o;
                            const t = s * h + l * d + c * p + u * f
                              , n = t >= 0 ? 1 : -1
                              , r = 1 - t * t;
                            if (r > Number.EPSILON) {
                                const i = Math.sqrt(r)
                                  , a = Math.atan2(i, t * n);
                                e = Math.sin(e * a) / i,
                                o = Math.sin(o * a) / i
                            }
                            const i = o * n;
                            if (s = s * e + h * i,
                            l = l * e + d * i,
                            c = c * e + p * i,
                            u = u * e + f * i,
                            e === 1 - o) {
                                const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                                s *= e,
                                l *= e,
                                c *= e,
                                u *= e
                            }
                        }
                        e[t] = s,
                        e[t + 1] = l,
                        e[t + 2] = c,
                        e[t + 3] = u
                    }
                    static multiplyQuaternionsFlat(e, t, n, r, i, a) {
                        const o = n[r]
                          , s = n[r + 1]
                          , l = n[r + 2]
                          , c = n[r + 3]
                          , u = i[a]
                          , h = i[a + 1]
                          , d = i[a + 2]
                          , p = i[a + 3];
                        return e[t] = o * p + c * u + s * d - l * h,
                        e[t + 1] = s * p + c * h + l * u - o * d,
                        e[t + 2] = l * p + c * d + o * h - s * u,
                        e[t + 3] = c * p - o * u - s * h - l * d,
                        e
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x = e,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y = e,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(e) {
                        this._z = e,
                        this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(e) {
                        this._w = e,
                        this._onChangeCallback()
                    }
                    set(e, t, n, r) {
                        return this._x = e,
                        this._y = t,
                        this._z = n,
                        this._w = r,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._w)
                    }
                    copy(e) {
                        return this._x = e.x,
                        this._y = e.y,
                        this._z = e.z,
                        this._w = e.w,
                        this._onChangeCallback(),
                        this
                    }
                    setFromEuler(e, t) {
                        if (!e || !e.isEuler)
                            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        const n = e._x
                          , r = e._y
                          , i = e._z
                          , a = e._order
                          , o = Math.cos
                          , s = Math.sin
                          , l = o(n / 2)
                          , c = o(r / 2)
                          , u = o(i / 2)
                          , h = s(n / 2)
                          , d = s(r / 2)
                          , p = s(i / 2);
                        switch (a) {
                        case "XYZ":
                            this._x = h * c * u + l * d * p,
                            this._y = l * d * u - h * c * p,
                            this._z = l * c * p + h * d * u,
                            this._w = l * c * u - h * d * p;
                            break;
                        case "YXZ":
                            this._x = h * c * u + l * d * p,
                            this._y = l * d * u - h * c * p,
                            this._z = l * c * p - h * d * u,
                            this._w = l * c * u + h * d * p;
                            break;
                        case "ZXY":
                            this._x = h * c * u - l * d * p,
                            this._y = l * d * u + h * c * p,
                            this._z = l * c * p + h * d * u,
                            this._w = l * c * u - h * d * p;
                            break;
                        case "ZYX":
                            this._x = h * c * u - l * d * p,
                            this._y = l * d * u + h * c * p,
                            this._z = l * c * p - h * d * u,
                            this._w = l * c * u + h * d * p;
                            break;
                        case "YZX":
                            this._x = h * c * u + l * d * p,
                            this._y = l * d * u + h * c * p,
                            this._z = l * c * p - h * d * u,
                            this._w = l * c * u - h * d * p;
                            break;
                        case "XZY":
                            this._x = h * c * u - l * d * p,
                            this._y = l * d * u - h * c * p,
                            this._z = l * c * p + h * d * u,
                            this._w = l * c * u + h * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                        }
                        return !1 !== t && this._onChangeCallback(),
                        this
                    }
                    setFromAxisAngle(e, t) {
                        const n = t / 2
                          , r = Math.sin(n);
                        return this._x = e.x * r,
                        this._y = e.y * r,
                        this._z = e.z * r,
                        this._w = Math.cos(n),
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(e) {
                        const t = e.elements
                          , n = t[0]
                          , r = t[4]
                          , i = t[8]
                          , a = t[1]
                          , o = t[5]
                          , s = t[9]
                          , l = t[2]
                          , c = t[6]
                          , u = t[10]
                          , h = n + o + u;
                        if (h > 0) {
                            const e = .5 / Math.sqrt(h + 1);
                            this._w = .25 / e,
                            this._x = (c - s) * e,
                            this._y = (i - l) * e,
                            this._z = (a - r) * e
                        } else if (n > o && n > u) {
                            const e = 2 * Math.sqrt(1 + n - o - u);
                            this._w = (c - s) / e,
                            this._x = .25 * e,
                            this._y = (r + a) / e,
                            this._z = (i + l) / e
                        } else if (o > u) {
                            const e = 2 * Math.sqrt(1 + o - n - u);
                            this._w = (i - l) / e,
                            this._x = (r + a) / e,
                            this._y = .25 * e,
                            this._z = (s + c) / e
                        } else {
                            const e = 2 * Math.sqrt(1 + u - n - o);
                            this._w = (a - r) / e,
                            this._x = (i + l) / e,
                            this._y = (s + c) / e,
                            this._z = .25 * e
                        }
                        return this._onChangeCallback(),
                        this
                    }
                    setFromUnitVectors(e, t) {
                        let n = e.dot(t) + 1;
                        return n < 1e-6 ? (n = 0,
                        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                        this._y = e.x,
                        this._z = 0,
                        this._w = n) : (this._x = 0,
                        this._y = -e.z,
                        this._z = e.y,
                        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                        this._y = e.z * t.x - e.x * t.z,
                        this._z = e.x * t.y - e.y * t.x,
                        this._w = n),
                        this.normalize()
                    }
                    angleTo(e) {
                        return 2 * Math.acos(Math.abs(zn.clamp(this.dot(e), -1, 1)))
                    }
                    rotateTowards(e, t) {
                        const n = this.angleTo(e);
                        if (0 === n)
                            return this;
                        const r = Math.min(1, t / n);
                        return this.slerp(e, r),
                        this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this._onChangeCallback(),
                        this
                    }
                    dot(e) {
                        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let e = this.length();
                        return 0 === e ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (e = 1 / e,
                        this._x = this._x * e,
                        this._y = this._y * e,
                        this._z = this._z * e,
                        this._w = this._w * e),
                        this._onChangeCallback(),
                        this
                    }
                    multiply(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                        this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyQuaternions(e, this)
                    }
                    multiplyQuaternions(e, t) {
                        const n = e._x
                          , r = e._y
                          , i = e._z
                          , a = e._w
                          , o = t._x
                          , s = t._y
                          , l = t._z
                          , c = t._w;
                        return this._x = n * c + a * o + r * l - i * s,
                        this._y = r * c + a * s + i * o - n * l,
                        this._z = i * c + a * l + n * s - r * o,
                        this._w = a * c - n * o - r * s - i * l,
                        this._onChangeCallback(),
                        this
                    }
                    slerp(e, t) {
                        if (0 === t)
                            return this;
                        if (1 === t)
                            return this.copy(e);
                        const n = this._x
                          , r = this._y
                          , i = this._z
                          , a = this._w;
                        let o = a * e._w + n * e._x + r * e._y + i * e._z;
                        if (o < 0 ? (this._w = -e._w,
                        this._x = -e._x,
                        this._y = -e._y,
                        this._z = -e._z,
                        o = -o) : this.copy(e),
                        o >= 1)
                            return this._w = a,
                            this._x = n,
                            this._y = r,
                            this._z = i,
                            this;
                        const s = 1 - o * o;
                        if (s <= Number.EPSILON) {
                            const e = 1 - t;
                            return this._w = e * a + t * this._w,
                            this._x = e * n + t * this._x,
                            this._y = e * r + t * this._y,
                            this._z = e * i + t * this._z,
                            this.normalize(),
                            this._onChangeCallback(),
                            this
                        }
                        const l = Math.sqrt(s)
                          , c = Math.atan2(l, o)
                          , u = Math.sin((1 - t) * c) / l
                          , h = Math.sin(t * c) / l;
                        return this._w = a * u + this._w * h,
                        this._x = n * u + this._x * h,
                        this._y = r * u + this._y * h,
                        this._z = i * u + this._z * h,
                        this._onChangeCallback(),
                        this
                    }
                    equals(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                    }
                    fromArray(e, t=0) {
                        return this._x = e[t],
                        this._y = e[t + 1],
                        this._z = e[t + 2],
                        this._w = e[t + 3],
                        this._onChangeCallback(),
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this._x,
                        e[t + 1] = this._y,
                        e[t + 2] = this._z,
                        e[t + 3] = this._w,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this._x = e.getX(t),
                        this._y = e.getY(t),
                        this._z = e.getZ(t),
                        this._w = e.getW(t),
                        this
                    }
                    _onChange(e) {
                        return this._onChangeCallback = e,
                        this
                    }
                    _onChangeCallback() {}
                }
                class Kn {
                    constructor(e=0, t=0, n=0) {
                        Object.defineProperty(this, "isVector3", {
                            value: !0
                        }),
                        this.x = e,
                        this.y = t,
                        this.z = n
                    }
                    set(e, t, n) {
                        return void 0 === n && (n = this.z),
                        this.x = e,
                        this.y = t,
                        this.z = n,
                        this
                    }
                    setScalar(e) {
                        return this.x = e,
                        this.y = e,
                        this.z = e,
                        this
                    }
                    setX(e) {
                        return this.x = e,
                        this
                    }
                    setY(e) {
                        return this.y = e,
                        this
                    }
                    setZ(e) {
                        return this.z = e,
                        this
                    }
                    setComponent(e, t) {
                        switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                        return this
                    }
                    getComponent(e) {
                        switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x,this.y,this.z)
                    }
                    copy(e) {
                        return this.x = e.x,
                        this.y = e.y,
                        this.z = e.z,
                        this
                    }
                    add(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(e, t)) : (this.x += e.x,
                        this.y += e.y,
                        this.z += e.z,
                        this)
                    }
                    addScalar(e) {
                        return this.x += e,
                        this.y += e,
                        this.z += e,
                        this
                    }
                    addVectors(e, t) {
                        return this.x = e.x + t.x,
                        this.y = e.y + t.y,
                        this.z = e.z + t.z,
                        this
                    }
                    addScaledVector(e, t) {
                        return this.x += e.x * t,
                        this.y += e.y * t,
                        this.z += e.z * t,
                        this
                    }
                    sub(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(e, t)) : (this.x -= e.x,
                        this.y -= e.y,
                        this.z -= e.z,
                        this)
                    }
                    subScalar(e) {
                        return this.x -= e,
                        this.y -= e,
                        this.z -= e,
                        this
                    }
                    subVectors(e, t) {
                        return this.x = e.x - t.x,
                        this.y = e.y - t.y,
                        this.z = e.z - t.z,
                        this
                    }
                    multiply(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                        this.multiplyVectors(e, t)) : (this.x *= e.x,
                        this.y *= e.y,
                        this.z *= e.z,
                        this)
                    }
                    multiplyScalar(e) {
                        return this.x *= e,
                        this.y *= e,
                        this.z *= e,
                        this
                    }
                    multiplyVectors(e, t) {
                        return this.x = e.x * t.x,
                        this.y = e.y * t.y,
                        this.z = e.z * t.z,
                        this
                    }
                    applyEuler(e) {
                        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                        this.applyQuaternion($n.setFromEuler(e))
                    }
                    applyAxisAngle(e, t) {
                        return this.applyQuaternion($n.setFromAxisAngle(e, t))
                    }
                    applyMatrix3(e) {
                        const t = this.x
                          , n = this.y
                          , r = this.z
                          , i = e.elements;
                        return this.x = i[0] * t + i[3] * n + i[6] * r,
                        this.y = i[1] * t + i[4] * n + i[7] * r,
                        this.z = i[2] * t + i[5] * n + i[8] * r,
                        this
                    }
                    applyNormalMatrix(e) {
                        return this.applyMatrix3(e).normalize()
                    }
                    applyMatrix4(e) {
                        const t = this.x
                          , n = this.y
                          , r = this.z
                          , i = e.elements
                          , a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                        return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a,
                        this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a,
                        this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a,
                        this
                    }
                    applyQuaternion(e) {
                        const t = this.x
                          , n = this.y
                          , r = this.z
                          , i = e.x
                          , a = e.y
                          , o = e.z
                          , s = e.w
                          , l = s * t + a * r - o * n
                          , c = s * n + o * t - i * r
                          , u = s * r + i * n - a * t
                          , h = -i * t - a * n - o * r;
                        return this.x = l * s + h * -i + c * -o - u * -a,
                        this.y = c * s + h * -a + u * -i - l * -o,
                        this.z = u * s + h * -o + l * -a - c * -i,
                        this
                    }
                    project(e) {
                        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                    }
                    unproject(e) {
                        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                    }
                    transformDirection(e) {
                        const t = this.x
                          , n = this.y
                          , r = this.z
                          , i = e.elements;
                        return this.x = i[0] * t + i[4] * n + i[8] * r,
                        this.y = i[1] * t + i[5] * n + i[9] * r,
                        this.z = i[2] * t + i[6] * n + i[10] * r,
                        this.normalize()
                    }
                    divide(e) {
                        return this.x /= e.x,
                        this.y /= e.y,
                        this.z /= e.z,
                        this
                    }
                    divideScalar(e) {
                        return this.multiplyScalar(1 / e)
                    }
                    min(e) {
                        return this.x = Math.min(this.x, e.x),
                        this.y = Math.min(this.y, e.y),
                        this.z = Math.min(this.z, e.z),
                        this
                    }
                    max(e) {
                        return this.x = Math.max(this.x, e.x),
                        this.y = Math.max(this.y, e.y),
                        this.z = Math.max(this.z, e.z),
                        this
                    }
                    clamp(e, t) {
                        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                        this.y = Math.max(e.y, Math.min(t.y, this.y)),
                        this.z = Math.max(e.z, Math.min(t.z, this.z)),
                        this
                    }
                    clampScalar(e, t) {
                        return this.x = Math.max(e, Math.min(t, this.x)),
                        this.y = Math.max(e, Math.min(t, this.y)),
                        this.z = Math.max(e, Math.min(t, this.z)),
                        this
                    }
                    clampLength(e, t) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                    }
                    round() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this
                    }
                    negate() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                    }
                    dot(e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(e) {
                        return this.normalize().multiplyScalar(e)
                    }
                    lerp(e, t) {
                        return this.x += (e.x - this.x) * t,
                        this.y += (e.y - this.y) * t,
                        this.z += (e.z - this.z) * t,
                        this
                    }
                    lerpVectors(e, t, n) {
                        return this.x = e.x + (t.x - e.x) * n,
                        this.y = e.y + (t.y - e.y) * n,
                        this.z = e.z + (t.z - e.z) * n,
                        this
                    }
                    cross(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                        this.crossVectors(e, t)) : this.crossVectors(this, e)
                    }
                    crossVectors(e, t) {
                        const n = e.x
                          , r = e.y
                          , i = e.z
                          , a = t.x
                          , o = t.y
                          , s = t.z;
                        return this.x = r * s - i * o,
                        this.y = i * a - n * s,
                        this.z = n * o - r * a,
                        this
                    }
                    projectOnVector(e) {
                        const t = e.lengthSq();
                        if (0 === t)
                            return this.set(0, 0, 0);
                        const n = e.dot(this) / t;
                        return this.copy(e).multiplyScalar(n)
                    }
                    projectOnPlane(e) {
                        return Qn.copy(this).projectOnVector(e),
                        this.sub(Qn)
                    }
                    reflect(e) {
                        return this.sub(Qn.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                    angleTo(e) {
                        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                        if (0 === t)
                            return Math.PI / 2;
                        const n = this.dot(e) / t;
                        return Math.acos(zn.clamp(n, -1, 1))
                    }
                    distanceTo(e) {
                        return Math.sqrt(this.distanceToSquared(e))
                    }
                    distanceToSquared(e) {
                        const t = this.x - e.x
                          , n = this.y - e.y
                          , r = this.z - e.z;
                        return t * t + n * n + r * r
                    }
                    manhattanDistanceTo(e) {
                        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                    }
                    setFromSpherical(e) {
                        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                    }
                    setFromSphericalCoords(e, t, n) {
                        const r = Math.sin(t) * e;
                        return this.x = r * Math.sin(n),
                        this.y = Math.cos(t) * e,
                        this.z = r * Math.cos(n),
                        this
                    }
                    setFromCylindrical(e) {
                        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                    }
                    setFromCylindricalCoords(e, t, n) {
                        return this.x = e * Math.sin(t),
                        this.y = n,
                        this.z = e * Math.cos(t),
                        this
                    }
                    setFromMatrixPosition(e) {
                        const t = e.elements;
                        return this.x = t[12],
                        this.y = t[13],
                        this.z = t[14],
                        this
                    }
                    setFromMatrixScale(e) {
                        const t = this.setFromMatrixColumn(e, 0).length()
                          , n = this.setFromMatrixColumn(e, 1).length()
                          , r = this.setFromMatrixColumn(e, 2).length();
                        return this.x = t,
                        this.y = n,
                        this.z = r,
                        this
                    }
                    setFromMatrixColumn(e, t) {
                        return this.fromArray(e.elements, 4 * t)
                    }
                    setFromMatrix3Column(e, t) {
                        return this.fromArray(e.elements, 3 * t)
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y && e.z === this.z
                    }
                    fromArray(e, t=0) {
                        return this.x = e[t],
                        this.y = e[t + 1],
                        this.z = e[t + 2],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.x,
                        e[t + 1] = this.y,
                        e[t + 2] = this.z,
                        e
                    }
                    fromBufferAttribute(e, t, n) {
                        return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
                        this.x = e.getX(t),
                        this.y = e.getY(t),
                        this.z = e.getZ(t),
                        this
                    }
                    random() {
                        return this.x = Math.random(),
                        this.y = Math.random(),
                        this.z = Math.random(),
                        this
                    }
                }
                const Qn = new Kn
                  , $n = new Jn;
                class er {
                    constructor(e, t) {
                        Object.defineProperty(this, "isBox3", {
                            value: !0
                        }),
                        this.min = void 0 !== e ? e : new Kn(1 / 0,1 / 0,1 / 0),
                        this.max = void 0 !== t ? t : new Kn(-1 / 0,-1 / 0,-1 / 0)
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromArray(e) {
                        let t = 1 / 0
                          , n = 1 / 0
                          , r = 1 / 0
                          , i = -1 / 0
                          , a = -1 / 0
                          , o = -1 / 0;
                        for (let s = 0, l = e.length; s < l; s += 3) {
                            const l = e[s]
                              , c = e[s + 1]
                              , u = e[s + 2];
                            l < t && (t = l),
                            c < n && (n = c),
                            u < r && (r = u),
                            l > i && (i = l),
                            c > a && (a = c),
                            u > o && (o = u)
                        }
                        return this.min.set(t, n, r),
                        this.max.set(i, a, o),
                        this
                    }
                    setFromBufferAttribute(e) {
                        let t = 1 / 0
                          , n = 1 / 0
                          , r = 1 / 0
                          , i = -1 / 0
                          , a = -1 / 0
                          , o = -1 / 0;
                        for (let s = 0, l = e.count; s < l; s++) {
                            const l = e.getX(s)
                              , c = e.getY(s)
                              , u = e.getZ(s);
                            l < t && (t = l),
                            c < n && (n = c),
                            u < r && (r = u),
                            l > i && (i = l),
                            c > a && (a = c),
                            u > o && (o = u)
                        }
                        return this.min.set(t, n, r),
                        this.max.set(i, a, o),
                        this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = rr.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    setFromObject(e) {
                        return this.makeEmpty(),
                        this.expandByObject(e)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0,
                        this.max.x = this.max.y = this.max.z = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"),
                        e = new Kn),
                        this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"),
                        e = new Kn),
                        this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    expandByObject(e) {
                        e.updateWorldMatrix(!1, !1);
                        const t = e.geometry;
                        void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(),
                        ir.copy(t.boundingBox),
                        ir.applyMatrix4(e.matrixWorld),
                        this.union(ir));
                        const n = e.children;
                        for (let e = 0, t = n.length; e < t; e++)
                            this.expandByObject(n[e]);
                        return this
                    }
                    containsPoint(e) {
                        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                    }
                    getParameter(e, t) {
                        return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"),
                        t = new Kn),
                        t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(e) {
                        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                    }
                    intersectsSphere(e) {
                        return this.clampPoint(e.center, rr),
                        rr.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                    intersectsPlane(e) {
                        let t, n;
                        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                        n = e.normal.x * this.min.x),
                        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                        n += e.normal.y * this.min.y),
                        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                        n += e.normal.z * this.min.z),
                        t <= -e.constant && n >= -e.constant
                    }
                    intersectsTriangle(e) {
                        if (this.isEmpty())
                            return !1;
                        this.getCenter(hr),
                        dr.subVectors(this.max, hr),
                        ar.subVectors(e.a, hr),
                        or.subVectors(e.b, hr),
                        sr.subVectors(e.c, hr),
                        lr.subVectors(or, ar),
                        cr.subVectors(sr, or),
                        ur.subVectors(ar, sr);
                        let t = [0, -lr.z, lr.y, 0, -cr.z, cr.y, 0, -ur.z, ur.y, lr.z, 0, -lr.x, cr.z, 0, -cr.x, ur.z, 0, -ur.x, -lr.y, lr.x, 0, -cr.y, cr.x, 0, -ur.y, ur.x, 0];
                        return !!tr(t, ar, or, sr, dr) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                        !!tr(t, ar, or, sr, dr) && (pr.crossVectors(lr, cr),
                        t = [pr.x, pr.y, pr.z],
                        tr(t, ar, or, sr, dr)))
                    }
                    clampPoint(e, t) {
                        return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"),
                        t = new Kn),
                        t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return rr.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                    getBoundingSphere(e) {
                        return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
                        this.getCenter(e.center),
                        e.radius = .5 * this.getSize(rr).length(),
                        e
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    applyMatrix4(e) {
                        return this.isEmpty() || (nr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                        nr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                        nr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                        nr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                        nr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                        nr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                        nr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                        nr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                        this.setFromPoints(nr)),
                        this
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                }
                function tr(e, t, n, r, i) {
                    for (let a = 0, o = e.length - 3; a <= o; a += 3) {
                        fr.fromArray(e, a);
                        const o = i.x * Math.abs(fr.x) + i.y * Math.abs(fr.y) + i.z * Math.abs(fr.z)
                          , s = t.dot(fr)
                          , l = n.dot(fr)
                          , c = r.dot(fr);
                        if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o)
                            return !1
                    }
                    return !0
                }
                const nr = [new Kn, new Kn, new Kn, new Kn, new Kn, new Kn, new Kn, new Kn]
                  , rr = new Kn
                  , ir = new er
                  , ar = new Kn
                  , or = new Kn
                  , sr = new Kn
                  , lr = new Kn
                  , cr = new Kn
                  , ur = new Kn
                  , hr = new Kn
                  , dr = new Kn
                  , pr = new Kn
                  , fr = new Kn
                  , mr = new er;
                class gr {
                    constructor(e, t) {
                        this.center = void 0 !== e ? e : new Kn,
                        this.radius = void 0 !== t ? t : -1
                    }
                    set(e, t) {
                        return this.center.copy(e),
                        this.radius = t,
                        this
                    }
                    setFromPoints(e, t) {
                        const n = this.center;
                        void 0 !== t ? n.copy(t) : mr.setFromPoints(e).getCenter(n);
                        let r = 0;
                        for (let t = 0, i = e.length; t < i; t++)
                            r = Math.max(r, n.distanceToSquared(e[t]));
                        return this.radius = Math.sqrt(r),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.center.copy(e.center),
                        this.radius = e.radius,
                        this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0),
                        this.radius = -1,
                        this
                    }
                    containsPoint(e) {
                        return e.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(e) {
                        return e.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(e) {
                        const t = this.radius + e.radius;
                        return e.center.distanceToSquared(this.center) <= t * t
                    }
                    intersectsBox(e) {
                        return e.intersectsSphere(this)
                    }
                    intersectsPlane(e) {
                        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(e, t) {
                        const n = this.center.distanceToSquared(e);
                        return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
                        t = new Kn),
                        t.copy(e),
                        n > this.radius * this.radius && (t.sub(this.center).normalize(),
                        t.multiplyScalar(this.radius).add(this.center)),
                        t
                    }
                    getBoundingBox(e) {
                        return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
                        e = new er),
                        this.isEmpty() ? (e.makeEmpty(),
                        e) : (e.set(this.center, this.center),
                        e.expandByScalar(this.radius),
                        e)
                    }
                    applyMatrix4(e) {
                        return this.center.applyMatrix4(e),
                        this.radius = this.radius * e.getMaxScaleOnAxis(),
                        this
                    }
                    translate(e) {
                        return this.center.add(e),
                        this
                    }
                    equals(e) {
                        return e.center.equals(this.center) && e.radius === this.radius
                    }
                }
                const vr = new Kn
                  , yr = new Kn
                  , _r = new Kn
                  , xr = new Kn
                  , br = new Kn
                  , wr = new Kn
                  , Mr = new Kn;
                class Sr {
                    constructor(e, t) {
                        this.origin = void 0 !== e ? e : new Kn,
                        this.direction = void 0 !== t ? t : new Kn(0,0,-1)
                    }
                    set(e, t) {
                        return this.origin.copy(e),
                        this.direction.copy(t),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.origin.copy(e.origin),
                        this.direction.copy(e.direction),
                        this
                    }
                    at(e, t) {
                        return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"),
                        t = new Kn),
                        t.copy(this.direction).multiplyScalar(e).add(this.origin)
                    }
                    lookAt(e) {
                        return this.direction.copy(e).sub(this.origin).normalize(),
                        this
                    }
                    recast(e) {
                        return this.origin.copy(this.at(e, vr)),
                        this
                    }
                    closestPointToPoint(e, t) {
                        void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
                        t = new Kn),
                        t.subVectors(e, this.origin);
                        const n = t.dot(this.direction);
                        return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                    }
                    distanceToPoint(e) {
                        return Math.sqrt(this.distanceSqToPoint(e))
                    }
                    distanceSqToPoint(e) {
                        const t = vr.subVectors(e, this.origin).dot(this.direction);
                        return t < 0 ? this.origin.distanceToSquared(e) : (vr.copy(this.direction).multiplyScalar(t).add(this.origin),
                        vr.distanceToSquared(e))
                    }
                    distanceSqToSegment(e, t, n, r) {
                        yr.copy(e).add(t).multiplyScalar(.5),
                        _r.copy(t).sub(e).normalize(),
                        xr.copy(this.origin).sub(yr);
                        const i = .5 * e.distanceTo(t)
                          , a = -this.direction.dot(_r)
                          , o = xr.dot(this.direction)
                          , s = -xr.dot(_r)
                          , l = xr.lengthSq()
                          , c = Math.abs(1 - a * a);
                        let u, h, d, p;
                        if (c > 0)
                            if (u = a * s - o,
                            h = a * o - s,
                            p = i * c,
                            u >= 0)
                                if (h >= -p)
                                    if (h <= p) {
                                        const e = 1 / c;
                                        u *= e,
                                        h *= e,
                                        d = u * (u + a * h + 2 * o) + h * (a * u + h + 2 * s) + l
                                    } else
                                        h = i,
                                        u = Math.max(0, -(a * h + o)),
                                        d = -u * u + h * (h + 2 * s) + l;
                                else
                                    h = -i,
                                    u = Math.max(0, -(a * h + o)),
                                    d = -u * u + h * (h + 2 * s) + l;
                            else
                                h <= -p ? (u = Math.max(0, -(-a * i + o)),
                                h = u > 0 ? -i : Math.min(Math.max(-i, -s), i),
                                d = -u * u + h * (h + 2 * s) + l) : h <= p ? (u = 0,
                                h = Math.min(Math.max(-i, -s), i),
                                d = h * (h + 2 * s) + l) : (u = Math.max(0, -(a * i + o)),
                                h = u > 0 ? i : Math.min(Math.max(-i, -s), i),
                                d = -u * u + h * (h + 2 * s) + l);
                        else
                            h = a > 0 ? -i : i,
                            u = Math.max(0, -(a * h + o)),
                            d = -u * u + h * (h + 2 * s) + l;
                        return n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
                        r && r.copy(_r).multiplyScalar(h).add(yr),
                        d
                    }
                    intersectSphere(e, t) {
                        vr.subVectors(e.center, this.origin);
                        const n = vr.dot(this.direction)
                          , r = vr.dot(vr) - n * n
                          , i = e.radius * e.radius;
                        if (r > i)
                            return null;
                        const a = Math.sqrt(i - r)
                          , o = n - a
                          , s = n + a;
                        return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
                    }
                    intersectsSphere(e) {
                        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                    }
                    distanceToPlane(e) {
                        const t = e.normal.dot(this.direction);
                        if (0 === t)
                            return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                        const n = -(this.origin.dot(e.normal) + e.constant) / t;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(e, t) {
                        const n = this.distanceToPlane(e);
                        return null === n ? null : this.at(n, t)
                    }
                    intersectsPlane(e) {
                        const t = e.distanceToPoint(this.origin);
                        return 0 === t || e.normal.dot(this.direction) * t < 0
                    }
                    intersectBox(e, t) {
                        let n, r, i, a, o, s;
                        const l = 1 / this.direction.x
                          , c = 1 / this.direction.y
                          , u = 1 / this.direction.z
                          , h = this.origin;
                        return l >= 0 ? (n = (e.min.x - h.x) * l,
                        r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l,
                        r = (e.min.x - h.x) * l),
                        c >= 0 ? (i = (e.min.y - h.y) * c,
                        a = (e.max.y - h.y) * c) : (i = (e.max.y - h.y) * c,
                        a = (e.min.y - h.y) * c),
                        n > a || i > r ? null : ((i > n || n != n) && (n = i),
                        (a < r || r != r) && (r = a),
                        u >= 0 ? (o = (e.min.z - h.z) * u,
                        s = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u,
                        s = (e.min.z - h.z) * u),
                        n > s || o > r ? null : ((o > n || n != n) && (n = o),
                        (s < r || r != r) && (r = s),
                        r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                    }
                    intersectsBox(e) {
                        return null !== this.intersectBox(e, vr)
                    }
                    intersectTriangle(e, t, n, r, i) {
                        br.subVectors(t, e),
                        wr.subVectors(n, e),
                        Mr.crossVectors(br, wr);
                        let a, o = this.direction.dot(Mr);
                        if (o > 0) {
                            if (r)
                                return null;
                            a = 1
                        } else {
                            if (!(o < 0))
                                return null;
                            a = -1,
                            o = -o
                        }
                        xr.subVectors(this.origin, e);
                        const s = a * this.direction.dot(wr.crossVectors(xr, wr));
                        if (s < 0)
                            return null;
                        const l = a * this.direction.dot(br.cross(xr));
                        if (l < 0)
                            return null;
                        if (s + l > o)
                            return null;
                        const c = -a * xr.dot(Mr);
                        return c < 0 ? null : this.at(c / o, i)
                    }
                    applyMatrix4(e) {
                        return this.origin.applyMatrix4(e),
                        this.direction.transformDirection(e),
                        this
                    }
                    equals(e) {
                        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                    }
                }
                class Tr {
                    constructor() {
                        Object.defineProperty(this, "isMatrix4", {
                            value: !0
                        }),
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                    }
                    set(e, t, n, r, i, a, o, s, l, c, u, h, d, p, f, m) {
                        const g = this.elements;
                        return g[0] = e,
                        g[4] = t,
                        g[8] = n,
                        g[12] = r,
                        g[1] = i,
                        g[5] = a,
                        g[9] = o,
                        g[13] = s,
                        g[2] = l,
                        g[6] = c,
                        g[10] = u,
                        g[14] = h,
                        g[3] = d,
                        g[7] = p,
                        g[11] = f,
                        g[15] = m,
                        this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    clone() {
                        return (new Tr).fromArray(this.elements)
                    }
                    copy(e) {
                        const t = this.elements
                          , n = e.elements;
                        return t[0] = n[0],
                        t[1] = n[1],
                        t[2] = n[2],
                        t[3] = n[3],
                        t[4] = n[4],
                        t[5] = n[5],
                        t[6] = n[6],
                        t[7] = n[7],
                        t[8] = n[8],
                        t[9] = n[9],
                        t[10] = n[10],
                        t[11] = n[11],
                        t[12] = n[12],
                        t[13] = n[13],
                        t[14] = n[14],
                        t[15] = n[15],
                        this
                    }
                    copyPosition(e) {
                        const t = this.elements
                          , n = e.elements;
                        return t[12] = n[12],
                        t[13] = n[13],
                        t[14] = n[14],
                        this
                    }
                    setFromMatrix3(e) {
                        const t = e.elements;
                        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                        this
                    }
                    extractBasis(e, t, n) {
                        return e.setFromMatrixColumn(this, 0),
                        t.setFromMatrixColumn(this, 1),
                        n.setFromMatrixColumn(this, 2),
                        this
                    }
                    makeBasis(e, t, n) {
                        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                        this
                    }
                    extractRotation(e) {
                        const t = this.elements
                          , n = e.elements
                          , r = 1 / Er.setFromMatrixColumn(e, 0).length()
                          , i = 1 / Er.setFromMatrixColumn(e, 1).length()
                          , a = 1 / Er.setFromMatrixColumn(e, 2).length();
                        return t[0] = n[0] * r,
                        t[1] = n[1] * r,
                        t[2] = n[2] * r,
                        t[3] = 0,
                        t[4] = n[4] * i,
                        t[5] = n[5] * i,
                        t[6] = n[6] * i,
                        t[7] = 0,
                        t[8] = n[8] * a,
                        t[9] = n[9] * a,
                        t[10] = n[10] * a,
                        t[11] = 0,
                        t[12] = 0,
                        t[13] = 0,
                        t[14] = 0,
                        t[15] = 1,
                        this
                    }
                    makeRotationFromEuler(e) {
                        e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        const t = this.elements
                          , n = e.x
                          , r = e.y
                          , i = e.z
                          , a = Math.cos(n)
                          , o = Math.sin(n)
                          , s = Math.cos(r)
                          , l = Math.sin(r)
                          , c = Math.cos(i)
                          , u = Math.sin(i);
                        if ("XYZ" === e.order) {
                            const e = a * c
                              , n = a * u
                              , r = o * c
                              , i = o * u;
                            t[0] = s * c,
                            t[4] = -s * u,
                            t[8] = l,
                            t[1] = n + r * l,
                            t[5] = e - i * l,
                            t[9] = -o * s,
                            t[2] = i - e * l,
                            t[6] = r + n * l,
                            t[10] = a * s
                        } else if ("YXZ" === e.order) {
                            const e = s * c
                              , n = s * u
                              , r = l * c
                              , i = l * u;
                            t[0] = e + i * o,
                            t[4] = r * o - n,
                            t[8] = a * l,
                            t[1] = a * u,
                            t[5] = a * c,
                            t[9] = -o,
                            t[2] = n * o - r,
                            t[6] = i + e * o,
                            t[10] = a * s
                        } else if ("ZXY" === e.order) {
                            const e = s * c
                              , n = s * u
                              , r = l * c
                              , i = l * u;
                            t[0] = e - i * o,
                            t[4] = -a * u,
                            t[8] = r + n * o,
                            t[1] = n + r * o,
                            t[5] = a * c,
                            t[9] = i - e * o,
                            t[2] = -a * l,
                            t[6] = o,
                            t[10] = a * s
                        } else if ("ZYX" === e.order) {
                            const e = a * c
                              , n = a * u
                              , r = o * c
                              , i = o * u;
                            t[0] = s * c,
                            t[4] = r * l - n,
                            t[8] = e * l + i,
                            t[1] = s * u,
                            t[5] = i * l + e,
                            t[9] = n * l - r,
                            t[2] = -l,
                            t[6] = o * s,
                            t[10] = a * s
                        } else if ("YZX" === e.order) {
                            const e = a * s
                              , n = a * l
                              , r = o * s
                              , i = o * l;
                            t[0] = s * c,
                            t[4] = i - e * u,
                            t[8] = r * u + n,
                            t[1] = u,
                            t[5] = a * c,
                            t[9] = -o * c,
                            t[2] = -l * c,
                            t[6] = n * u + r,
                            t[10] = e - i * u
                        } else if ("XZY" === e.order) {
                            const e = a * s
                              , n = a * l
                              , r = o * s
                              , i = o * l;
                            t[0] = s * c,
                            t[4] = -u,
                            t[8] = l * c,
                            t[1] = e * u + i,
                            t[5] = a * c,
                            t[9] = n * u - r,
                            t[2] = r * u - n,
                            t[6] = o * c,
                            t[10] = i * u + e
                        }
                        return t[3] = 0,
                        t[7] = 0,
                        t[11] = 0,
                        t[12] = 0,
                        t[13] = 0,
                        t[14] = 0,
                        t[15] = 1,
                        this
                    }
                    makeRotationFromQuaternion(e) {
                        return this.compose(Cr, e, Pr)
                    }
                    lookAt(e, t, n) {
                        const r = this.elements;
                        return Dr.subVectors(e, t),
                        0 === Dr.lengthSq() && (Dr.z = 1),
                        Dr.normalize(),
                        Rr.crossVectors(n, Dr),
                        0 === Rr.lengthSq() && (1 === Math.abs(n.z) ? Dr.x += 1e-4 : Dr.z += 1e-4,
                        Dr.normalize(),
                        Rr.crossVectors(n, Dr)),
                        Rr.normalize(),
                        Lr.crossVectors(Dr, Rr),
                        r[0] = Rr.x,
                        r[4] = Lr.x,
                        r[8] = Dr.x,
                        r[1] = Rr.y,
                        r[5] = Lr.y,
                        r[9] = Dr.y,
                        r[2] = Rr.z,
                        r[6] = Lr.z,
                        r[10] = Dr.z,
                        this
                    }
                    multiply(e, t) {
                        return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                        this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                    }
                    premultiply(e) {
                        return this.multiplyMatrices(e, this)
                    }
                    multiplyMatrices(e, t) {
                        const n = e.elements
                          , r = t.elements
                          , i = this.elements
                          , a = n[0]
                          , o = n[4]
                          , s = n[8]
                          , l = n[12]
                          , c = n[1]
                          , u = n[5]
                          , h = n[9]
                          , d = n[13]
                          , p = n[2]
                          , f = n[6]
                          , m = n[10]
                          , g = n[14]
                          , v = n[3]
                          , y = n[7]
                          , _ = n[11]
                          , x = n[15]
                          , b = r[0]
                          , w = r[4]
                          , M = r[8]
                          , S = r[12]
                          , T = r[1]
                          , E = r[5]
                          , A = r[9]
                          , C = r[13]
                          , P = r[2]
                          , R = r[6]
                          , L = r[10]
                          , D = r[14]
                          , O = r[3]
                          , F = r[7]
                          , I = r[11]
                          , N = r[15];
                        return i[0] = a * b + o * T + s * P + l * O,
                        i[4] = a * w + o * E + s * R + l * F,
                        i[8] = a * M + o * A + s * L + l * I,
                        i[12] = a * S + o * C + s * D + l * N,
                        i[1] = c * b + u * T + h * P + d * O,
                        i[5] = c * w + u * E + h * R + d * F,
                        i[9] = c * M + u * A + h * L + d * I,
                        i[13] = c * S + u * C + h * D + d * N,
                        i[2] = p * b + f * T + m * P + g * O,
                        i[6] = p * w + f * E + m * R + g * F,
                        i[10] = p * M + f * A + m * L + g * I,
                        i[14] = p * S + f * C + m * D + g * N,
                        i[3] = v * b + y * T + _ * P + x * O,
                        i[7] = v * w + y * E + _ * R + x * F,
                        i[11] = v * M + y * A + _ * L + x * I,
                        i[15] = v * S + y * C + _ * D + x * N,
                        this
                    }
                    multiplyScalar(e) {
                        const t = this.elements;
                        return t[0] *= e,
                        t[4] *= e,
                        t[8] *= e,
                        t[12] *= e,
                        t[1] *= e,
                        t[5] *= e,
                        t[9] *= e,
                        t[13] *= e,
                        t[2] *= e,
                        t[6] *= e,
                        t[10] *= e,
                        t[14] *= e,
                        t[3] *= e,
                        t[7] *= e,
                        t[11] *= e,
                        t[15] *= e,
                        this
                    }
                    determinant() {
                        const e = this.elements
                          , t = e[0]
                          , n = e[4]
                          , r = e[8]
                          , i = e[12]
                          , a = e[1]
                          , o = e[5]
                          , s = e[9]
                          , l = e[13]
                          , c = e[2]
                          , u = e[6]
                          , h = e[10]
                          , d = e[14];
                        return e[3] * (+i * s * u - r * l * u - i * o * h + n * l * h + r * o * d - n * s * d) + e[7] * (+t * s * d - t * l * h + i * a * h - r * a * d + r * l * c - i * s * c) + e[11] * (+t * l * u - t * o * d - i * a * u + n * a * d + i * o * c - n * l * c) + e[15] * (-r * o * c - t * s * u + t * o * h + r * a * u - n * a * h + n * s * c)
                    }
                    transpose() {
                        const e = this.elements;
                        let t;
                        return t = e[1],
                        e[1] = e[4],
                        e[4] = t,
                        t = e[2],
                        e[2] = e[8],
                        e[8] = t,
                        t = e[6],
                        e[6] = e[9],
                        e[9] = t,
                        t = e[3],
                        e[3] = e[12],
                        e[12] = t,
                        t = e[7],
                        e[7] = e[13],
                        e[13] = t,
                        t = e[11],
                        e[11] = e[14],
                        e[14] = t,
                        this
                    }
                    setPosition(e, t, n) {
                        const r = this.elements;
                        return e.isVector3 ? (r[12] = e.x,
                        r[13] = e.y,
                        r[14] = e.z) : (r[12] = e,
                        r[13] = t,
                        r[14] = n),
                        this
                    }
                    invert() {
                        const e = this.elements
                          , t = e[0]
                          , n = e[1]
                          , r = e[2]
                          , i = e[3]
                          , a = e[4]
                          , o = e[5]
                          , s = e[6]
                          , l = e[7]
                          , c = e[8]
                          , u = e[9]
                          , h = e[10]
                          , d = e[11]
                          , p = e[12]
                          , f = e[13]
                          , m = e[14]
                          , g = e[15]
                          , v = u * m * l - f * h * l + f * s * d - o * m * d - u * s * g + o * h * g
                          , y = p * h * l - c * m * l - p * s * d + a * m * d + c * s * g - a * h * g
                          , _ = c * f * l - p * u * l + p * o * d - a * f * d - c * o * g + a * u * g
                          , x = p * u * s - c * f * s - p * o * h + a * f * h + c * o * m - a * u * m
                          , b = t * v + n * y + r * _ + i * x;
                        if (0 === b)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const w = 1 / b;
                        return e[0] = v * w,
                        e[1] = (f * h * i - u * m * i - f * r * d + n * m * d + u * r * g - n * h * g) * w,
                        e[2] = (o * m * i - f * s * i + f * r * l - n * m * l - o * r * g + n * s * g) * w,
                        e[3] = (u * s * i - o * h * i - u * r * l + n * h * l + o * r * d - n * s * d) * w,
                        e[4] = y * w,
                        e[5] = (c * m * i - p * h * i + p * r * d - t * m * d - c * r * g + t * h * g) * w,
                        e[6] = (p * s * i - a * m * i - p * r * l + t * m * l + a * r * g - t * s * g) * w,
                        e[7] = (a * h * i - c * s * i + c * r * l - t * h * l - a * r * d + t * s * d) * w,
                        e[8] = _ * w,
                        e[9] = (p * u * i - c * f * i - p * n * d + t * f * d + c * n * g - t * u * g) * w,
                        e[10] = (a * f * i - p * o * i + p * n * l - t * f * l - a * n * g + t * o * g) * w,
                        e[11] = (c * o * i - a * u * i - c * n * l + t * u * l + a * n * d - t * o * d) * w,
                        e[12] = x * w,
                        e[13] = (c * f * r - p * u * r + p * n * h - t * f * h - c * n * m + t * u * m) * w,
                        e[14] = (p * o * r - a * f * r - p * n * s + t * f * s + a * n * m - t * o * m) * w,
                        e[15] = (a * u * r - c * o * r + c * n * s - t * u * s - a * n * h + t * o * h) * w,
                        this
                    }
                    scale(e) {
                        const t = this.elements
                          , n = e.x
                          , r = e.y
                          , i = e.z;
                        return t[0] *= n,
                        t[4] *= r,
                        t[8] *= i,
                        t[1] *= n,
                        t[5] *= r,
                        t[9] *= i,
                        t[2] *= n,
                        t[6] *= r,
                        t[10] *= i,
                        t[3] *= n,
                        t[7] *= r,
                        t[11] *= i,
                        this
                    }
                    getMaxScaleOnAxis() {
                        const e = this.elements
                          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                        return Math.sqrt(Math.max(t, n, r))
                    }
                    makeTranslation(e, t, n) {
                        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                        this
                    }
                    makeRotationX(e) {
                        const t = Math.cos(e)
                          , n = Math.sin(e);
                        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationY(e) {
                        const t = Math.cos(e)
                          , n = Math.sin(e);
                        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationZ(e) {
                        const t = Math.cos(e)
                          , n = Math.sin(e);
                        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    makeRotationAxis(e, t) {
                        const n = Math.cos(t)
                          , r = Math.sin(t)
                          , i = 1 - n
                          , a = e.x
                          , o = e.y
                          , s = e.z
                          , l = i * a
                          , c = i * o;
                        return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, c * o + n, c * s - r * a, 0, l * s - r * o, c * s + r * a, i * s * s + n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeScale(e, t, n) {
                        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                        this
                    }
                    makeShear(e, t, n) {
                        return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1),
                        this
                    }
                    compose(e, t, n) {
                        const r = this.elements
                          , i = t._x
                          , a = t._y
                          , o = t._z
                          , s = t._w
                          , l = i + i
                          , c = a + a
                          , u = o + o
                          , h = i * l
                          , d = i * c
                          , p = i * u
                          , f = a * c
                          , m = a * u
                          , g = o * u
                          , v = s * l
                          , y = s * c
                          , _ = s * u
                          , x = n.x
                          , b = n.y
                          , w = n.z;
                        return r[0] = (1 - (f + g)) * x,
                        r[1] = (d + _) * x,
                        r[2] = (p - y) * x,
                        r[3] = 0,
                        r[4] = (d - _) * b,
                        r[5] = (1 - (h + g)) * b,
                        r[6] = (m + v) * b,
                        r[7] = 0,
                        r[8] = (p + y) * w,
                        r[9] = (m - v) * w,
                        r[10] = (1 - (h + f)) * w,
                        r[11] = 0,
                        r[12] = e.x,
                        r[13] = e.y,
                        r[14] = e.z,
                        r[15] = 1,
                        this
                    }
                    decompose(e, t, n) {
                        const r = this.elements;
                        let i = Er.set(r[0], r[1], r[2]).length();
                        const a = Er.set(r[4], r[5], r[6]).length()
                          , o = Er.set(r[8], r[9], r[10]).length();
                        this.determinant() < 0 && (i = -i),
                        e.x = r[12],
                        e.y = r[13],
                        e.z = r[14],
                        Ar.copy(this);
                        const s = 1 / i
                          , l = 1 / a
                          , c = 1 / o;
                        return Ar.elements[0] *= s,
                        Ar.elements[1] *= s,
                        Ar.elements[2] *= s,
                        Ar.elements[4] *= l,
                        Ar.elements[5] *= l,
                        Ar.elements[6] *= l,
                        Ar.elements[8] *= c,
                        Ar.elements[9] *= c,
                        Ar.elements[10] *= c,
                        t.setFromRotationMatrix(Ar),
                        n.x = i,
                        n.y = a,
                        n.z = o,
                        this
                    }
                    makePerspective(e, t, n, r, i, a) {
                        void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        const o = this.elements
                          , s = 2 * i / (t - e)
                          , l = 2 * i / (n - r)
                          , c = (t + e) / (t - e)
                          , u = (n + r) / (n - r)
                          , h = -(a + i) / (a - i)
                          , d = -2 * a * i / (a - i);
                        return o[0] = s,
                        o[4] = 0,
                        o[8] = c,
                        o[12] = 0,
                        o[1] = 0,
                        o[5] = l,
                        o[9] = u,
                        o[13] = 0,
                        o[2] = 0,
                        o[6] = 0,
                        o[10] = h,
                        o[14] = d,
                        o[3] = 0,
                        o[7] = 0,
                        o[11] = -1,
                        o[15] = 0,
                        this
                    }
                    makeOrthographic(e, t, n, r, i, a) {
                        const o = this.elements
                          , s = 1 / (t - e)
                          , l = 1 / (n - r)
                          , c = 1 / (a - i)
                          , u = (t + e) * s
                          , h = (n + r) * l
                          , d = (a + i) * c;
                        return o[0] = 2 * s,
                        o[4] = 0,
                        o[8] = 0,
                        o[12] = -u,
                        o[1] = 0,
                        o[5] = 2 * l,
                        o[9] = 0,
                        o[13] = -h,
                        o[2] = 0,
                        o[6] = 0,
                        o[10] = -2 * c,
                        o[14] = -d,
                        o[3] = 0,
                        o[7] = 0,
                        o[11] = 0,
                        o[15] = 1,
                        this
                    }
                    equals(e) {
                        const t = this.elements
                          , n = e.elements;
                        for (let e = 0; e < 16; e++)
                            if (t[e] !== n[e])
                                return !1;
                        return !0
                    }
                    fromArray(e, t=0) {
                        for (let n = 0; n < 16; n++)
                            this.elements[n] = e[n + t];
                        return this
                    }
                    toArray(e=[], t=0) {
                        const n = this.elements;
                        return e[t] = n[0],
                        e[t + 1] = n[1],
                        e[t + 2] = n[2],
                        e[t + 3] = n[3],
                        e[t + 4] = n[4],
                        e[t + 5] = n[5],
                        e[t + 6] = n[6],
                        e[t + 7] = n[7],
                        e[t + 8] = n[8],
                        e[t + 9] = n[9],
                        e[t + 10] = n[10],
                        e[t + 11] = n[11],
                        e[t + 12] = n[12],
                        e[t + 13] = n[13],
                        e[t + 14] = n[14],
                        e[t + 15] = n[15],
                        e
                    }
                }
                const Er = new Kn
                  , Ar = new Tr
                  , Cr = new Kn(0,0,0)
                  , Pr = new Kn(1,1,1)
                  , Rr = new Kn
                  , Lr = new Kn
                  , Dr = new Kn;
                class Or {
                    constructor(e=0, t=0, n=0, r=Or.DefaultOrder) {
                        Object.defineProperty(this, "isEuler", {
                            value: !0
                        }),
                        this._x = e,
                        this._y = t,
                        this._z = n,
                        this._order = r
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x = e,
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y = e,
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(e) {
                        this._z = e,
                        this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(e) {
                        this._order = e,
                        this._onChangeCallback()
                    }
                    set(e, t, n, r) {
                        return this._x = e,
                        this._y = t,
                        this._z = n,
                        this._order = r || this._order,
                        this._onChangeCallback(),
                        this
                    }
                    clone() {
                        return new this.constructor(this._x,this._y,this._z,this._order)
                    }
                    copy(e) {
                        return this._x = e._x,
                        this._y = e._y,
                        this._z = e._z,
                        this._order = e._order,
                        this._onChangeCallback(),
                        this
                    }
                    setFromRotationMatrix(e, t, n) {
                        const r = zn.clamp
                          , i = e.elements
                          , a = i[0]
                          , o = i[4]
                          , s = i[8]
                          , l = i[1]
                          , c = i[5]
                          , u = i[9]
                          , h = i[2]
                          , d = i[6]
                          , p = i[10];
                        switch (t = t || this._order) {
                        case "XYZ":
                            this._y = Math.asin(r(s, -1, 1)),
                            Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p),
                            this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c),
                            this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-r(u, -1, 1)),
                            Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p),
                            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, a),
                            this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(r(d, -1, 1)),
                            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p),
                            this._z = Math.atan2(-o, c)) : (this._y = 0,
                            this._z = Math.atan2(l, a));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-r(h, -1, 1)),
                            Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p),
                            this._z = Math.atan2(l, a)) : (this._x = 0,
                            this._z = Math.atan2(-o, c));
                            break;
                        case "YZX":
                            this._z = Math.asin(r(l, -1, 1)),
                            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
                            this._y = Math.atan2(-h, a)) : (this._x = 0,
                            this._y = Math.atan2(s, p));
                            break;
                        case "XZY":
                            this._z = Math.asin(-r(o, -1, 1)),
                            Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c),
                            this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p),
                            this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                        }
                        return this._order = t,
                        !1 !== n && this._onChangeCallback(),
                        this
                    }
                    setFromQuaternion(e, t, n) {
                        return Fr.makeRotationFromQuaternion(e),
                        this.setFromRotationMatrix(Fr, t, n)
                    }
                    setFromVector3(e, t) {
                        return this.set(e.x, e.y, e.z, t || this._order)
                    }
                    reorder(e) {
                        return Ir.setFromEuler(this),
                        this.setFromQuaternion(Ir, e)
                    }
                    equals(e) {
                        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                    }
                    fromArray(e) {
                        return this._x = e[0],
                        this._y = e[1],
                        this._z = e[2],
                        void 0 !== e[3] && (this._order = e[3]),
                        this._onChangeCallback(),
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this._x,
                        e[t + 1] = this._y,
                        e[t + 2] = this._z,
                        e[t + 3] = this._order,
                        e
                    }
                    toVector3(e) {
                        return e ? e.set(this._x, this._y, this._z) : new Kn(this._x,this._y,this._z)
                    }
                    _onChange(e) {
                        return this._onChangeCallback = e,
                        this
                    }
                    _onChangeCallback() {}
                }
                Or.DefaultOrder = "XYZ",
                Or.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
                const Fr = new Tr
                  , Ir = new Jn;
                class Nr {
                    constructor() {
                        this.mask = 1
                    }
                    set(e) {
                        this.mask = 1 << e | 0
                    }
                    enable(e) {
                        this.mask |= 1 << e | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(e) {
                        this.mask ^= 1 << e | 0
                    }
                    disable(e) {
                        this.mask &= ~(1 << e | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(e) {
                        return 0 != (this.mask & e.mask)
                    }
                }
                let Br = 0;
                const kr = new Kn
                  , zr = new Jn
                  , Ur = new Tr
                  , Hr = new Kn
                  , Gr = new Kn
                  , jr = new Kn
                  , Vr = new Jn
                  , Wr = new Kn(1,0,0)
                  , qr = new Kn(0,1,0)
                  , Xr = new Kn(0,0,1)
                  , Yr = {
                    type: "added"
                }
                  , Zr = {
                    type: "removed"
                };
                function Jr() {
                    Object.defineProperty(this, "id", {
                        value: Br++
                    }),
                    this.uuid = zn.generateUUID(),
                    this.name = "",
                    this.type = "Object3D",
                    this.parent = null,
                    this.children = [],
                    this.up = Jr.DefaultUp.clone();
                    const e = new Kn
                      , t = new Or
                      , n = new Jn
                      , r = new Kn(1,1,1);
                    t._onChange((function() {
                        n.setFromEuler(t, !1)
                    }
                    )),
                    n._onChange((function() {
                        t.setFromQuaternion(n, void 0, !1)
                    }
                    )),
                    Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        },
                        modelViewMatrix: {
                            value: new Tr
                        },
                        normalMatrix: {
                            value: new Hn
                        }
                    }),
                    this.matrix = new Tr,
                    this.matrixWorld = new Tr,
                    this.matrixAutoUpdate = Jr.DefaultMatrixAutoUpdate,
                    this.matrixWorldNeedsUpdate = !1,
                    this.layers = new Nr,
                    this.visible = !0,
                    this.castShadow = !1,
                    this.receiveShadow = !1,
                    this.frustumCulled = !0,
                    this.renderOrder = 0,
                    this.animations = [],
                    this.userData = {}
                }
                Jr.DefaultUp = new Kn(0,1,0),
                Jr.DefaultMatrixAutoUpdate = !0,
                Jr.prototype = Object.assign(Object.create(Nn.prototype), {
                    constructor: Jr,
                    isObject3D: !0,
                    onBeforeRender: function() {},
                    onAfterRender: function() {},
                    applyMatrix4: function(e) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(e),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    },
                    applyQuaternion: function(e) {
                        return this.quaternion.premultiply(e),
                        this
                    },
                    setRotationFromAxisAngle: function(e, t) {
                        this.quaternion.setFromAxisAngle(e, t)
                    },
                    setRotationFromEuler: function(e) {
                        this.quaternion.setFromEuler(e, !0)
                    },
                    setRotationFromMatrix: function(e) {
                        this.quaternion.setFromRotationMatrix(e)
                    },
                    setRotationFromQuaternion: function(e) {
                        this.quaternion.copy(e)
                    },
                    rotateOnAxis: function(e, t) {
                        return zr.setFromAxisAngle(e, t),
                        this.quaternion.multiply(zr),
                        this
                    },
                    rotateOnWorldAxis: function(e, t) {
                        return zr.setFromAxisAngle(e, t),
                        this.quaternion.premultiply(zr),
                        this
                    },
                    rotateX: function(e) {
                        return this.rotateOnAxis(Wr, e)
                    },
                    rotateY: function(e) {
                        return this.rotateOnAxis(qr, e)
                    },
                    rotateZ: function(e) {
                        return this.rotateOnAxis(Xr, e)
                    },
                    translateOnAxis: function(e, t) {
                        return kr.copy(e).applyQuaternion(this.quaternion),
                        this.position.add(kr.multiplyScalar(t)),
                        this
                    },
                    translateX: function(e) {
                        return this.translateOnAxis(Wr, e)
                    },
                    translateY: function(e) {
                        return this.translateOnAxis(qr, e)
                    },
                    translateZ: function(e) {
                        return this.translateOnAxis(Xr, e)
                    },
                    localToWorld: function(e) {
                        return e.applyMatrix4(this.matrixWorld)
                    },
                    worldToLocal: function(e) {
                        return e.applyMatrix4(Ur.copy(this.matrixWorld).invert())
                    },
                    lookAt: function(e, t, n) {
                        e.isVector3 ? Hr.copy(e) : Hr.set(e, t, n);
                        const r = this.parent;
                        this.updateWorldMatrix(!0, !1),
                        Gr.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? Ur.lookAt(Gr, Hr, this.up) : Ur.lookAt(Hr, Gr, this.up),
                        this.quaternion.setFromRotationMatrix(Ur),
                        r && (Ur.extractRotation(r.matrixWorld),
                        zr.setFromRotationMatrix(Ur),
                        this.quaternion.premultiply(zr.invert()))
                    },
                    add: function(e) {
                        if (arguments.length > 1) {
                            for (let e = 0; e < arguments.length; e++)
                                this.add(arguments[e]);
                            return this
                        }
                        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                        this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
                        e.parent = this,
                        this.children.push(e),
                        e.dispatchEvent(Yr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                        this)
                    },
                    remove: function(e) {
                        if (arguments.length > 1) {
                            for (let e = 0; e < arguments.length; e++)
                                this.remove(arguments[e]);
                            return this
                        }
                        const t = this.children.indexOf(e);
                        return -1 !== t && (e.parent = null,
                        this.children.splice(t, 1),
                        e.dispatchEvent(Zr)),
                        this
                    },
                    clear: function() {
                        for (let e = 0; e < this.children.length; e++) {
                            const t = this.children[e];
                            t.parent = null,
                            t.dispatchEvent(Zr)
                        }
                        return this.children.length = 0,
                        this
                    },
                    attach: function(e) {
                        return this.updateWorldMatrix(!0, !1),
                        Ur.copy(this.matrixWorld).invert(),
                        null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                        Ur.multiply(e.parent.matrixWorld)),
                        e.applyMatrix4(Ur),
                        e.updateWorldMatrix(!1, !1),
                        this.add(e),
                        this
                    },
                    getObjectById: function(e) {
                        return this.getObjectByProperty("id", e)
                    },
                    getObjectByName: function(e) {
                        return this.getObjectByProperty("name", e)
                    },
                    getObjectByProperty: function(e, t) {
                        if (this[e] === t)
                            return this;
                        for (let n = 0, r = this.children.length; n < r; n++) {
                            const r = this.children[n].getObjectByProperty(e, t);
                            if (void 0 !== r)
                                return r
                        }
                    },
                    getWorldPosition: function(e) {
                        return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
                        e = new Kn),
                        this.updateWorldMatrix(!0, !1),
                        e.setFromMatrixPosition(this.matrixWorld)
                    },
                    getWorldQuaternion: function(e) {
                        return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
                        e = new Jn),
                        this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(Gr, e, jr),
                        e
                    },
                    getWorldScale: function(e) {
                        return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                        e = new Kn),
                        this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(Gr, Vr, e),
                        e
                    },
                    getWorldDirection: function(e) {
                        void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
                        e = new Kn),
                        this.updateWorldMatrix(!0, !1);
                        const t = this.matrixWorld.elements;
                        return e.set(t[8], t[9], t[10]).normalize()
                    },
                    raycast: function() {},
                    traverse: function(e) {
                        e(this);
                        const t = this.children;
                        for (let n = 0, r = t.length; n < r; n++)
                            t[n].traverse(e)
                    },
                    traverseVisible: function(e) {
                        if (!1 === this.visible)
                            return;
                        e(this);
                        const t = this.children;
                        for (let n = 0, r = t.length; n < r; n++)
                            t[n].traverseVisible(e)
                    },
                    traverseAncestors: function(e) {
                        const t = this.parent;
                        null !== t && (e(t),
                        t.traverseAncestors(e))
                    },
                    updateMatrix: function() {
                        this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                    },
                    updateMatrixWorld: function(e) {
                        this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        this.matrixWorldNeedsUpdate = !1,
                        e = !0);
                        const t = this.children;
                        for (let n = 0, r = t.length; n < r; n++)
                            t[n].updateMatrixWorld(e)
                    },
                    updateWorldMatrix: function(e, t) {
                        const n = this.parent;
                        if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        !0 === t) {
                            const e = this.children;
                            for (let t = 0, n = e.length; t < n; t++)
                                e[t].updateWorldMatrix(!1, !0)
                        }
                    },
                    toJSON: function(e) {
                        const t = void 0 === e || "string" == typeof e
                          , n = {};
                        t && (e = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {}
                        },
                        n.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const r = {};
                        function i(t, n) {
                            return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                            n.uuid
                        }
                        if (r.uuid = this.uuid,
                        r.type = this.type,
                        "" !== this.name && (r.name = this.name),
                        !0 === this.castShadow && (r.castShadow = !0),
                        !0 === this.receiveShadow && (r.receiveShadow = !0),
                        !1 === this.visible && (r.visible = !1),
                        !1 === this.frustumCulled && (r.frustumCulled = !1),
                        0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
                        "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
                        r.layers = this.layers.mask,
                        r.matrix = this.matrix.toArray(),
                        !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                        this.isInstancedMesh && (r.type = "InstancedMesh",
                        r.count = this.count,
                        r.instanceMatrix = this.instanceMatrix.toJSON()),
                        this.isMesh || this.isLine || this.isPoints) {
                            r.geometry = i(e.geometries, this.geometry);
                            const t = this.geometry.parameters;
                            if (void 0 !== t && void 0 !== t.shapes) {
                                const n = t.shapes;
                                if (Array.isArray(n))
                                    for (let t = 0, r = n.length; t < r; t++) {
                                        const r = n[t];
                                        i(e.shapes, r)
                                    }
                                else
                                    i(e.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
                        r.bindMatrix = this.bindMatrix.toArray(),
                        void 0 !== this.skeleton && (i(e.skeletons, this.skeleton),
                        r.skeleton = this.skeleton.uuid)),
                        void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const t = [];
                                for (let n = 0, r = this.material.length; n < r; n++)
                                    t.push(i(e.materials, this.material[n]));
                                r.material = t
                            } else
                                r.material = i(e.materials, this.material);
                        if (this.children.length > 0) {
                            r.children = [];
                            for (let t = 0; t < this.children.length; t++)
                                r.children.push(this.children[t].toJSON(e).object)
                        }
                        if (this.animations.length > 0) {
                            r.animations = [];
                            for (let t = 0; t < this.animations.length; t++) {
                                const n = this.animations[t];
                                r.animations.push(i(e.animations, n))
                            }
                        }
                        if (t) {
                            const t = a(e.geometries)
                              , r = a(e.materials)
                              , i = a(e.textures)
                              , o = a(e.images)
                              , s = a(e.shapes)
                              , l = a(e.skeletons)
                              , c = a(e.animations);
                            t.length > 0 && (n.geometries = t),
                            r.length > 0 && (n.materials = r),
                            i.length > 0 && (n.textures = i),
                            o.length > 0 && (n.images = o),
                            s.length > 0 && (n.shapes = s),
                            l.length > 0 && (n.skeletons = l),
                            c.length > 0 && (n.animations = c)
                        }
                        return n.object = r,
                        n;
                        function a(e) {
                            const t = [];
                            for (const n in e) {
                                const r = e[n];
                                delete r.metadata,
                                t.push(r)
                            }
                            return t
                        }
                    },
                    clone: function(e) {
                        return (new this.constructor).copy(this, e)
                    },
                    copy: function(e, t=!0) {
                        if (this.name = e.name,
                        this.up.copy(e.up),
                        this.position.copy(e.position),
                        this.rotation.order = e.rotation.order,
                        this.quaternion.copy(e.quaternion),
                        this.scale.copy(e.scale),
                        this.matrix.copy(e.matrix),
                        this.matrixWorld.copy(e.matrixWorld),
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                        this.layers.mask = e.layers.mask,
                        this.visible = e.visible,
                        this.castShadow = e.castShadow,
                        this.receiveShadow = e.receiveShadow,
                        this.frustumCulled = e.frustumCulled,
                        this.renderOrder = e.renderOrder,
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        !0 === t)
                            for (let t = 0; t < e.children.length; t++) {
                                const n = e.children[t];
                                this.add(n.clone())
                            }
                        return this
                    }
                });
                const Kr = new Kn
                  , Qr = new Kn
                  , $r = new Hn;
                class ei {
                    constructor(e, t) {
                        Object.defineProperty(this, "isPlane", {
                            value: !0
                        }),
                        this.normal = void 0 !== e ? e : new Kn(1,0,0),
                        this.constant = void 0 !== t ? t : 0
                    }
                    set(e, t) {
                        return this.normal.copy(e),
                        this.constant = t,
                        this
                    }
                    setComponents(e, t, n, r) {
                        return this.normal.set(e, t, n),
                        this.constant = r,
                        this
                    }
                    setFromNormalAndCoplanarPoint(e, t) {
                        return this.normal.copy(e),
                        this.constant = -t.dot(this.normal),
                        this
                    }
                    setFromCoplanarPoints(e, t, n) {
                        const r = Kr.subVectors(n, t).cross(Qr.subVectors(e, t)).normalize();
                        return this.setFromNormalAndCoplanarPoint(r, e),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.normal.copy(e.normal),
                        this.constant = e.constant,
                        this
                    }
                    normalize() {
                        const e = 1 / this.normal.length();
                        return this.normal.multiplyScalar(e),
                        this.constant *= e,
                        this
                    }
                    negate() {
                        return this.constant *= -1,
                        this.normal.negate(),
                        this
                    }
                    distanceToPoint(e) {
                        return this.normal.dot(e) + this.constant
                    }
                    distanceToSphere(e) {
                        return this.distanceToPoint(e.center) - e.radius
                    }
                    projectPoint(e, t) {
                        return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"),
                        t = new Kn),
                        t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                    }
                    intersectLine(e, t) {
                        void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                        t = new Kn);
                        const n = e.delta(Kr)
                          , r = this.normal.dot(n);
                        if (0 === r)
                            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                        const i = -(e.start.dot(this.normal) + this.constant) / r;
                        return i < 0 || i > 1 ? void 0 : t.copy(n).multiplyScalar(i).add(e.start)
                    }
                    intersectsLine(e) {
                        const t = this.distanceToPoint(e.start)
                          , n = this.distanceToPoint(e.end);
                        return t < 0 && n > 0 || n < 0 && t > 0
                    }
                    intersectsBox(e) {
                        return e.intersectsPlane(this)
                    }
                    intersectsSphere(e) {
                        return e.intersectsPlane(this)
                    }
                    coplanarPoint(e) {
                        return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
                        e = new Kn),
                        e.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(e, t) {
                        const n = t || $r.getNormalMatrix(e)
                          , r = this.coplanarPoint(Kr).applyMatrix4(e)
                          , i = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -r.dot(i),
                        this
                    }
                    translate(e) {
                        return this.constant -= e.dot(this.normal),
                        this
                    }
                    equals(e) {
                        return e.normal.equals(this.normal) && e.constant === this.constant
                    }
                }
                const ti = new Kn
                  , ni = new Kn
                  , ri = new Kn
                  , ii = new Kn
                  , ai = new Kn
                  , oi = new Kn
                  , si = new Kn
                  , li = new Kn
                  , ci = new Kn
                  , ui = new Kn;
                class hi {
                    constructor(e, t, n) {
                        this.a = void 0 !== e ? e : new Kn,
                        this.b = void 0 !== t ? t : new Kn,
                        this.c = void 0 !== n ? n : new Kn
                    }
                    static getNormal(e, t, n, r) {
                        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"),
                        r = new Kn),
                        r.subVectors(n, t),
                        ti.subVectors(e, t),
                        r.cross(ti);
                        const i = r.lengthSq();
                        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                    }
                    static getBarycoord(e, t, n, r, i) {
                        ti.subVectors(r, t),
                        ni.subVectors(n, t),
                        ri.subVectors(e, t);
                        const a = ti.dot(ti)
                          , o = ti.dot(ni)
                          , s = ti.dot(ri)
                          , l = ni.dot(ni)
                          , c = ni.dot(ri)
                          , u = a * l - o * o;
                        if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
                        i = new Kn),
                        0 === u)
                            return i.set(-2, -1, -1);
                        const h = 1 / u
                          , d = (l * s - o * c) * h
                          , p = (a * c - o * s) * h;
                        return i.set(1 - d - p, p, d)
                    }
                    static containsPoint(e, t, n, r) {
                        return this.getBarycoord(e, t, n, r, ii),
                        ii.x >= 0 && ii.y >= 0 && ii.x + ii.y <= 1
                    }
                    static getUV(e, t, n, r, i, a, o, s) {
                        return this.getBarycoord(e, t, n, r, ii),
                        s.set(0, 0),
                        s.addScaledVector(i, ii.x),
                        s.addScaledVector(a, ii.y),
                        s.addScaledVector(o, ii.z),
                        s
                    }
                    static isFrontFacing(e, t, n, r) {
                        return ti.subVectors(n, t),
                        ni.subVectors(e, t),
                        ti.cross(ni).dot(r) < 0
                    }
                    set(e, t, n) {
                        return this.a.copy(e),
                        this.b.copy(t),
                        this.c.copy(n),
                        this
                    }
                    setFromPointsAndIndices(e, t, n, r) {
                        return this.a.copy(e[t]),
                        this.b.copy(e[n]),
                        this.c.copy(e[r]),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.a.copy(e.a),
                        this.b.copy(e.b),
                        this.c.copy(e.c),
                        this
                    }
                    getArea() {
                        return ti.subVectors(this.c, this.b),
                        ni.subVectors(this.a, this.b),
                        .5 * ti.cross(ni).length()
                    }
                    getMidpoint(e) {
                        return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
                        e = new Kn),
                        e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(e) {
                        return hi.getNormal(this.a, this.b, this.c, e)
                    }
                    getPlane(e) {
                        return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"),
                        e = new ei),
                        e.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(e, t) {
                        return hi.getBarycoord(e, this.a, this.b, this.c, t)
                    }
                    getUV(e, t, n, r, i) {
                        return hi.getUV(e, this.a, this.b, this.c, t, n, r, i)
                    }
                    containsPoint(e) {
                        return hi.containsPoint(e, this.a, this.b, this.c)
                    }
                    isFrontFacing(e) {
                        return hi.isFrontFacing(this.a, this.b, this.c, e)
                    }
                    intersectsBox(e) {
                        return e.intersectsTriangle(this)
                    }
                    closestPointToPoint(e, t) {
                        void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
                        t = new Kn);
                        const n = this.a
                          , r = this.b
                          , i = this.c;
                        let a, o;
                        ai.subVectors(r, n),
                        oi.subVectors(i, n),
                        li.subVectors(e, n);
                        const s = ai.dot(li)
                          , l = oi.dot(li);
                        if (s <= 0 && l <= 0)
                            return t.copy(n);
                        ci.subVectors(e, r);
                        const c = ai.dot(ci)
                          , u = oi.dot(ci);
                        if (c >= 0 && u <= c)
                            return t.copy(r);
                        const h = s * u - c * l;
                        if (h <= 0 && s >= 0 && c <= 0)
                            return a = s / (s - c),
                            t.copy(n).addScaledVector(ai, a);
                        ui.subVectors(e, i);
                        const d = ai.dot(ui)
                          , p = oi.dot(ui);
                        if (p >= 0 && d <= p)
                            return t.copy(i);
                        const f = d * l - s * p;
                        if (f <= 0 && l >= 0 && p <= 0)
                            return o = l / (l - p),
                            t.copy(n).addScaledVector(oi, o);
                        const m = c * p - d * u;
                        if (m <= 0 && u - c >= 0 && d - p >= 0)
                            return si.subVectors(i, r),
                            o = (u - c) / (u - c + (d - p)),
                            t.copy(r).addScaledVector(si, o);
                        const g = 1 / (m + f + h);
                        return a = f * g,
                        o = h * g,
                        t.copy(n).addScaledVector(ai, a).addScaledVector(oi, o)
                    }
                    equals(e) {
                        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                    }
                }
                const di = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                }
                  , pi = {
                    h: 0,
                    s: 0,
                    l: 0
                }
                  , fi = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                function mi(e, t, n) {
                    return n < 0 && (n += 1),
                    n > 1 && (n -= 1),
                    n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
                }
                function gi(e) {
                    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
                }
                function vi(e) {
                    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
                }
                class yi {
                    constructor(e, t, n) {
                        return Object.defineProperty(this, "isColor", {
                            value: !0
                        }),
                        void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
                    }
                    set(e) {
                        return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
                        this
                    }
                    setScalar(e) {
                        return this.r = e,
                        this.g = e,
                        this.b = e,
                        this
                    }
                    setHex(e) {
                        return e = Math.floor(e),
                        this.r = (e >> 16 & 255) / 255,
                        this.g = (e >> 8 & 255) / 255,
                        this.b = (255 & e) / 255,
                        this
                    }
                    setRGB(e, t, n) {
                        return this.r = e,
                        this.g = t,
                        this.b = n,
                        this
                    }
                    setHSL(e, t, n) {
                        if (e = zn.euclideanModulo(e, 1),
                        t = zn.clamp(t, 0, 1),
                        n = zn.clamp(n, 0, 1),
                        0 === t)
                            this.r = this.g = this.b = n;
                        else {
                            const r = n <= .5 ? n * (1 + t) : n + t - n * t
                              , i = 2 * n - r;
                            this.r = mi(i, r, e + 1 / 3),
                            this.g = mi(i, r, e),
                            this.b = mi(i, r, e - 1 / 3)
                        }
                        return this
                    }
                    setStyle(e) {
                        function t(t) {
                            void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                        }
                        let n;
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                            let e;
                            const r = n[1]
                              , i = n[2];
                            switch (r) {
                            case "rgb":
                            case "rgba":
                                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                                    return this.r = Math.min(255, parseInt(e[1], 10)) / 255,
                                    this.g = Math.min(255, parseInt(e[2], 10)) / 255,
                                    this.b = Math.min(255, parseInt(e[3], 10)) / 255,
                                    t(e[4]),
                                    this;
                                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                                    return this.r = Math.min(100, parseInt(e[1], 10)) / 100,
                                    this.g = Math.min(100, parseInt(e[2], 10)) / 100,
                                    this.b = Math.min(100, parseInt(e[3], 10)) / 100,
                                    t(e[4]),
                                    this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                                    const n = parseFloat(e[1]) / 360
                                      , r = parseInt(e[2], 10) / 100
                                      , i = parseInt(e[3], 10) / 100;
                                    return t(e[4]),
                                    this.setHSL(n, r, i)
                                }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                            const e = n[1]
                              , t = e.length;
                            if (3 === t)
                                return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255,
                                this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255,
                                this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255,
                                this;
                            if (6 === t)
                                return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255,
                                this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255,
                                this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255,
                                this
                        }
                        return e && e.length > 0 ? this.setColorName(e) : this
                    }
                    setColorName(e) {
                        const t = di[e];
                        return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e),
                        this
                    }
                    clone() {
                        return new this.constructor(this.r,this.g,this.b)
                    }
                    copy(e) {
                        return this.r = e.r,
                        this.g = e.g,
                        this.b = e.b,
                        this
                    }
                    copyGammaToLinear(e, t=2) {
                        return this.r = Math.pow(e.r, t),
                        this.g = Math.pow(e.g, t),
                        this.b = Math.pow(e.b, t),
                        this
                    }
                    copyLinearToGamma(e, t=2) {
                        const n = t > 0 ? 1 / t : 1;
                        return this.r = Math.pow(e.r, n),
                        this.g = Math.pow(e.g, n),
                        this.b = Math.pow(e.b, n),
                        this
                    }
                    convertGammaToLinear(e) {
                        return this.copyGammaToLinear(this, e),
                        this
                    }
                    convertLinearToGamma(e) {
                        return this.copyLinearToGamma(this, e),
                        this
                    }
                    copySRGBToLinear(e) {
                        return this.r = gi(e.r),
                        this.g = gi(e.g),
                        this.b = gi(e.b),
                        this
                    }
                    copyLinearToSRGB(e) {
                        return this.r = vi(e.r),
                        this.g = vi(e.g),
                        this.b = vi(e.b),
                        this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this),
                        this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this),
                        this
                    }
                    getHex() {
                        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                    }
                    getHexString() {
                        return ("000000" + this.getHex().toString(16)).slice(-6)
                    }
                    getHSL(e) {
                        void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"),
                        e = {
                            h: 0,
                            s: 0,
                            l: 0
                        });
                        const t = this.r
                          , n = this.g
                          , r = this.b
                          , i = Math.max(t, n, r)
                          , a = Math.min(t, n, r);
                        let o, s;
                        const l = (a + i) / 2;
                        if (a === i)
                            o = 0,
                            s = 0;
                        else {
                            const e = i - a;
                            switch (s = l <= .5 ? e / (i + a) : e / (2 - i - a),
                            i) {
                            case t:
                                o = (n - r) / e + (n < r ? 6 : 0);
                                break;
                            case n:
                                o = (r - t) / e + 2;
                                break;
                            case r:
                                o = (t - n) / e + 4
                            }
                            o /= 6
                        }
                        return e.h = o,
                        e.s = s,
                        e.l = l,
                        e
                    }
                    getStyle() {
                        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                    }
                    offsetHSL(e, t, n) {
                        return this.getHSL(pi),
                        pi.h += e,
                        pi.s += t,
                        pi.l += n,
                        this.setHSL(pi.h, pi.s, pi.l),
                        this
                    }
                    add(e) {
                        return this.r += e.r,
                        this.g += e.g,
                        this.b += e.b,
                        this
                    }
                    addColors(e, t) {
                        return this.r = e.r + t.r,
                        this.g = e.g + t.g,
                        this.b = e.b + t.b,
                        this
                    }
                    addScalar(e) {
                        return this.r += e,
                        this.g += e,
                        this.b += e,
                        this
                    }
                    sub(e) {
                        return this.r = Math.max(0, this.r - e.r),
                        this.g = Math.max(0, this.g - e.g),
                        this.b = Math.max(0, this.b - e.b),
                        this
                    }
                    multiply(e) {
                        return this.r *= e.r,
                        this.g *= e.g,
                        this.b *= e.b,
                        this
                    }
                    multiplyScalar(e) {
                        return this.r *= e,
                        this.g *= e,
                        this.b *= e,
                        this
                    }
                    lerp(e, t) {
                        return this.r += (e.r - this.r) * t,
                        this.g += (e.g - this.g) * t,
                        this.b += (e.b - this.b) * t,
                        this
                    }
                    lerpColors(e, t, n) {
                        return this.r = e.r + (t.r - e.r) * n,
                        this.g = e.g + (t.g - e.g) * n,
                        this.b = e.b + (t.b - e.b) * n,
                        this
                    }
                    lerpHSL(e, t) {
                        this.getHSL(pi),
                        e.getHSL(fi);
                        const n = zn.lerp(pi.h, fi.h, t)
                          , r = zn.lerp(pi.s, fi.s, t)
                          , i = zn.lerp(pi.l, fi.l, t);
                        return this.setHSL(n, r, i),
                        this
                    }
                    equals(e) {
                        return e.r === this.r && e.g === this.g && e.b === this.b
                    }
                    fromArray(e, t=0) {
                        return this.r = e[t],
                        this.g = e[t + 1],
                        this.b = e[t + 2],
                        this
                    }
                    toArray(e=[], t=0) {
                        return e[t] = this.r,
                        e[t + 1] = this.g,
                        e[t + 2] = this.b,
                        e
                    }
                    fromBufferAttribute(e, t) {
                        return this.r = e.getX(t),
                        this.g = e.getY(t),
                        this.b = e.getZ(t),
                        !0 === e.normalized && (this.r /= 255,
                        this.g /= 255,
                        this.b /= 255),
                        this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                }
                yi.NAMES = di,
                yi.prototype.r = 1,
                yi.prototype.g = 1,
                yi.prototype.b = 1;
                class _i {
                    constructor(e, t, n, r, i, a=0) {
                        this.a = e,
                        this.b = t,
                        this.c = n,
                        this.normal = r && r.isVector3 ? r : new Kn,
                        this.vertexNormals = Array.isArray(r) ? r : [],
                        this.color = i && i.isColor ? i : new yi,
                        this.vertexColors = Array.isArray(i) ? i : [],
                        this.materialIndex = a
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        this.a = e.a,
                        this.b = e.b,
                        this.c = e.c,
                        this.normal.copy(e.normal),
                        this.color.copy(e.color),
                        this.materialIndex = e.materialIndex;
                        for (let t = 0, n = e.vertexNormals.length; t < n; t++)
                            this.vertexNormals[t] = e.vertexNormals[t].clone();
                        for (let t = 0, n = e.vertexColors.length; t < n; t++)
                            this.vertexColors[t] = e.vertexColors[t].clone();
                        return this
                    }
                }
                let xi = 0;
                function bi() {
                    Object.defineProperty(this, "id", {
                        value: xi++
                    }),
                    this.uuid = zn.generateUUID(),
                    this.name = "",
                    this.type = "Material",
                    this.fog = !0,
                    this.blending = x,
                    this.side = f,
                    this.flatShading = !1,
                    this.vertexColors = !1,
                    this.opacity = 1,
                    this.transparent = !1,
                    this.blendSrc = F,
                    this.blendDst = I,
                    this.blendEquation = T,
                    this.blendSrcAlpha = null,
                    this.blendDstAlpha = null,
                    this.blendEquationAlpha = null,
                    this.depthFunc = V,
                    this.depthTest = !0,
                    this.depthWrite = !0,
                    this.stencilWriteMask = 255,
                    this.stencilFunc = Sn,
                    this.stencilRef = 0,
                    this.stencilFuncMask = 255,
                    this.stencilFail = un,
                    this.stencilZFail = un,
                    this.stencilZPass = un,
                    this.stencilWrite = !1,
                    this.clippingPlanes = null,
                    this.clipIntersection = !1,
                    this.clipShadows = !1,
                    this.shadowSide = null,
                    this.colorWrite = !0,
                    this.precision = null,
                    this.polygonOffset = !1,
                    this.polygonOffsetFactor = 0,
                    this.polygonOffsetUnits = 0,
                    this.dithering = !1,
                    this.alphaTest = 0,
                    this.premultipliedAlpha = !1,
                    this.visible = !0,
                    this.toneMapped = !0,
                    this.userData = {},
                    this.version = 0
                }
                function wi(e) {
                    bi.call(this),
                    this.type = "MeshBasicMaterial",
                    this.color = new yi(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = Z,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.setValues(e)
                }
                bi.prototype = Object.assign(Object.create(Nn.prototype), {
                    constructor: bi,
                    isMaterial: !0,
                    onBeforeCompile: function() {},
                    customProgramCacheKey: function() {
                        return this.onBeforeCompile.toString()
                    },
                    setValues: function(e) {
                        if (void 0 !== e)
                            for (const t in e) {
                                const n = e[t];
                                if (void 0 === n) {
                                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                    continue
                                }
                                if ("shading" === t) {
                                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                                    this.flatShading = n === v;
                                    continue
                                }
                                const r = this[t];
                                void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                            }
                    },
                    toJSON: function(e) {
                        const t = void 0 === e || "string" == typeof e;
                        t && (e = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        function r(e) {
                            const t = [];
                            for (const n in e) {
                                const r = e[n];
                                delete r.metadata,
                                t.push(r)
                            }
                            return t
                        }
                        if (n.uuid = this.uuid,
                        n.type = this.type,
                        "" !== this.name && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        void 0 !== this.roughness && (n.roughness = this.roughness),
                        void 0 !== this.metalness && (n.metalness = this.metalness),
                        this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        void 0 !== this.shininess && (n.shininess = this.shininess),
                        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                        void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid),
                        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                        n.aoMapIntensity = this.aoMapIntensity),
                        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                        n.bumpScale = this.bumpScale),
                        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                        n.normalMapType = this.normalMapType,
                        n.normalScale = this.normalScale.toArray()),
                        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                        n.displacementScale = this.displacementScale,
                        n.displacementBias = this.displacementBias),
                        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                        n.reflectivity = this.reflectivity,
                        n.refractionRatio = this.refractionRatio,
                        void 0 !== this.combine && (n.combine = this.combine),
                        void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
                        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                        void 0 !== this.size && (n.size = this.size),
                        void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== x && (n.blending = this.blending),
                        !0 === this.flatShading && (n.flatShading = this.flatShading),
                        this.side !== f && (n.side = this.side),
                        this.vertexColors && (n.vertexColors = !0),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        !0 === this.transparent && (n.transparent = this.transparent),
                        n.depthFunc = this.depthFunc,
                        n.depthTest = this.depthTest,
                        n.depthWrite = this.depthWrite,
                        n.stencilWrite = this.stencilWrite,
                        n.stencilWriteMask = this.stencilWriteMask,
                        n.stencilFunc = this.stencilFunc,
                        n.stencilRef = this.stencilRef,
                        n.stencilFuncMask = this.stencilFuncMask,
                        n.stencilFail = this.stencilFail,
                        n.stencilZFail = this.stencilZFail,
                        n.stencilZPass = this.stencilZPass,
                        this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                        !0 === this.polygonOffset && (n.polygonOffset = !0),
                        0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                        0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                        void 0 !== this.scale && (n.scale = this.scale),
                        !0 === this.dithering && (n.dithering = !0),
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                        !0 === this.wireframe && (n.wireframe = this.wireframe),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                        "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                        !0 === this.morphTargets && (n.morphTargets = !0),
                        !0 === this.morphNormals && (n.morphNormals = !0),
                        !0 === this.skinning && (n.skinning = !0),
                        !1 === this.visible && (n.visible = !1),
                        !1 === this.toneMapped && (n.toneMapped = !1),
                        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                        t) {
                            const t = r(e.textures)
                              , i = r(e.images);
                            t.length > 0 && (n.textures = t),
                            i.length > 0 && (n.images = i)
                        }
                        return n
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(e) {
                        this.name = e.name,
                        this.fog = e.fog,
                        this.blending = e.blending,
                        this.side = e.side,
                        this.flatShading = e.flatShading,
                        this.vertexColors = e.vertexColors,
                        this.opacity = e.opacity,
                        this.transparent = e.transparent,
                        this.blendSrc = e.blendSrc,
                        this.blendDst = e.blendDst,
                        this.blendEquation = e.blendEquation,
                        this.blendSrcAlpha = e.blendSrcAlpha,
                        this.blendDstAlpha = e.blendDstAlpha,
                        this.blendEquationAlpha = e.blendEquationAlpha,
                        this.depthFunc = e.depthFunc,
                        this.depthTest = e.depthTest,
                        this.depthWrite = e.depthWrite,
                        this.stencilWriteMask = e.stencilWriteMask,
                        this.stencilFunc = e.stencilFunc,
                        this.stencilRef = e.stencilRef,
                        this.stencilFuncMask = e.stencilFuncMask,
                        this.stencilFail = e.stencilFail,
                        this.stencilZFail = e.stencilZFail,
                        this.stencilZPass = e.stencilZPass,
                        this.stencilWrite = e.stencilWrite;
                        const t = e.clippingPlanes;
                        let n = null;
                        if (null !== t) {
                            const e = t.length;
                            n = new Array(e);
                            for (let r = 0; r !== e; ++r)
                                n[r] = t[r].clone()
                        }
                        return this.clippingPlanes = n,
                        this.clipIntersection = e.clipIntersection,
                        this.clipShadows = e.clipShadows,
                        this.shadowSide = e.shadowSide,
                        this.colorWrite = e.colorWrite,
                        this.precision = e.precision,
                        this.polygonOffset = e.polygonOffset,
                        this.polygonOffsetFactor = e.polygonOffsetFactor,
                        this.polygonOffsetUnits = e.polygonOffsetUnits,
                        this.dithering = e.dithering,
                        this.alphaTest = e.alphaTest,
                        this.premultipliedAlpha = e.premultipliedAlpha,
                        this.visible = e.visible,
                        this.toneMapped = e.toneMapped,
                        this.userData = JSON.parse(JSON.stringify(e.userData)),
                        this
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }),
                Object.defineProperty(bi.prototype, "needsUpdate", {
                    set: function(e) {
                        !0 === e && this.version++
                    }
                }),
                wi.prototype = Object.create(bi.prototype),
                wi.prototype.constructor = wi,
                wi.prototype.isMeshBasicMaterial = !0,
                wi.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.specularMap = e.specularMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.combine = e.combine,
                    this.reflectivity = e.reflectivity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this
                }
                ;
                const Mi = new Kn
                  , Si = new Un;
                function Ti(e, t, n) {
                    if (Array.isArray(e))
                        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "",
                    this.array = e,
                    this.itemSize = t,
                    this.count = void 0 !== e ? e.length / t : 0,
                    this.normalized = !0 === n,
                    this.usage = Tn,
                    this.updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.version = 0
                }
                function Ei(e, t, n) {
                    Ti.call(this, new Int8Array(e), t, n)
                }
                function Ai(e, t, n) {
                    Ti.call(this, new Uint8Array(e), t, n)
                }
                function Ci(e, t, n) {
                    Ti.call(this, new Uint8ClampedArray(e), t, n)
                }
                function Pi(e, t, n) {
                    Ti.call(this, new Int16Array(e), t, n)
                }
                function Ri(e, t, n) {
                    Ti.call(this, new Uint16Array(e), t, n)
                }
                function Li(e, t, n) {
                    Ti.call(this, new Int32Array(e), t, n)
                }
                function Di(e, t, n) {
                    Ti.call(this, new Uint32Array(e), t, n)
                }
                function Oi(e, t, n) {
                    Ti.call(this, new Uint16Array(e), t, n)
                }
                function Fi(e, t, n) {
                    Ti.call(this, new Float32Array(e), t, n)
                }
                function Ii(e, t, n) {
                    Ti.call(this, new Float64Array(e), t, n)
                }
                function Ni(e) {
                    if (0 === e.length)
                        return -1 / 0;
                    let t = e[0];
                    for (let n = 1, r = e.length; n < r; ++n)
                        e[n] > t && (t = e[n]);
                    return t
                }
                Object.defineProperty(Ti.prototype, "needsUpdate", {
                    set: function(e) {
                        !0 === e && this.version++
                    }
                }),
                Object.assign(Ti.prototype, {
                    isBufferAttribute: !0,
                    onUploadCallback: function() {},
                    setUsage: function(e) {
                        return this.usage = e,
                        this
                    },
                    copy: function(e) {
                        return this.name = e.name,
                        this.array = new e.array.constructor(e.array),
                        this.itemSize = e.itemSize,
                        this.count = e.count,
                        this.normalized = e.normalized,
                        this.usage = e.usage,
                        this
                    },
                    copyAt: function(e, t, n) {
                        e *= this.itemSize,
                        n *= t.itemSize;
                        for (let r = 0, i = this.itemSize; r < i; r++)
                            this.array[e + r] = t.array[n + r];
                        return this
                    },
                    copyArray: function(e) {
                        return this.array.set(e),
                        this
                    },
                    copyColorsArray: function(e) {
                        const t = this.array;
                        let n = 0;
                        for (let r = 0, i = e.length; r < i; r++) {
                            let i = e[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r),
                            i = new yi),
                            t[n++] = i.r,
                            t[n++] = i.g,
                            t[n++] = i.b
                        }
                        return this
                    },
                    copyVector2sArray: function(e) {
                        const t = this.array;
                        let n = 0;
                        for (let r = 0, i = e.length; r < i; r++) {
                            let i = e[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r),
                            i = new Un),
                            t[n++] = i.x,
                            t[n++] = i.y
                        }
                        return this
                    },
                    copyVector3sArray: function(e) {
                        const t = this.array;
                        let n = 0;
                        for (let r = 0, i = e.length; r < i; r++) {
                            let i = e[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r),
                            i = new Kn),
                            t[n++] = i.x,
                            t[n++] = i.y,
                            t[n++] = i.z
                        }
                        return this
                    },
                    copyVector4sArray: function(e) {
                        const t = this.array;
                        let n = 0;
                        for (let r = 0, i = e.length; r < i; r++) {
                            let i = e[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r),
                            i = new Xn),
                            t[n++] = i.x,
                            t[n++] = i.y,
                            t[n++] = i.z,
                            t[n++] = i.w
                        }
                        return this
                    },
                    applyMatrix3: function(e) {
                        if (2 === this.itemSize)
                            for (let t = 0, n = this.count; t < n; t++)
                                Si.fromBufferAttribute(this, t),
                                Si.applyMatrix3(e),
                                this.setXY(t, Si.x, Si.y);
                        else if (3 === this.itemSize)
                            for (let t = 0, n = this.count; t < n; t++)
                                Mi.fromBufferAttribute(this, t),
                                Mi.applyMatrix3(e),
                                this.setXYZ(t, Mi.x, Mi.y, Mi.z);
                        return this
                    },
                    applyMatrix4: function(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            Mi.x = this.getX(t),
                            Mi.y = this.getY(t),
                            Mi.z = this.getZ(t),
                            Mi.applyMatrix4(e),
                            this.setXYZ(t, Mi.x, Mi.y, Mi.z);
                        return this
                    },
                    applyNormalMatrix: function(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            Mi.x = this.getX(t),
                            Mi.y = this.getY(t),
                            Mi.z = this.getZ(t),
                            Mi.applyNormalMatrix(e),
                            this.setXYZ(t, Mi.x, Mi.y, Mi.z);
                        return this
                    },
                    transformDirection: function(e) {
                        for (let t = 0, n = this.count; t < n; t++)
                            Mi.x = this.getX(t),
                            Mi.y = this.getY(t),
                            Mi.z = this.getZ(t),
                            Mi.transformDirection(e),
                            this.setXYZ(t, Mi.x, Mi.y, Mi.z);
                        return this
                    },
                    set: function(e, t=0) {
                        return this.array.set(e, t),
                        this
                    },
                    getX: function(e) {
                        return this.array[e * this.itemSize]
                    },
                    setX: function(e, t) {
                        return this.array[e * this.itemSize] = t,
                        this
                    },
                    getY: function(e) {
                        return this.array[e * this.itemSize + 1]
                    },
                    setY: function(e, t) {
                        return this.array[e * this.itemSize + 1] = t,
                        this
                    },
                    getZ: function(e) {
                        return this.array[e * this.itemSize + 2]
                    },
                    setZ: function(e, t) {
                        return this.array[e * this.itemSize + 2] = t,
                        this
                    },
                    getW: function(e) {
                        return this.array[e * this.itemSize + 3]
                    },
                    setW: function(e, t) {
                        return this.array[e * this.itemSize + 3] = t,
                        this
                    },
                    setXY: function(e, t, n) {
                        return e *= this.itemSize,
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this
                    },
                    setXYZ: function(e, t, n, r) {
                        return e *= this.itemSize,
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = r,
                        this
                    },
                    setXYZW: function(e, t, n, r, i) {
                        return e *= this.itemSize,
                        this.array[e + 0] = t,
                        this.array[e + 1] = n,
                        this.array[e + 2] = r,
                        this.array[e + 3] = i,
                        this
                    },
                    onUpload: function(e) {
                        return this.onUploadCallback = e,
                        this
                    },
                    clone: function() {
                        return new this.constructor(this.array,this.itemSize).copy(this)
                    },
                    toJSON: function() {
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.prototype.slice.call(this.array),
                            normalized: this.normalized
                        }
                    }
                }),
                Ei.prototype = Object.create(Ti.prototype),
                Ei.prototype.constructor = Ei,
                Ai.prototype = Object.create(Ti.prototype),
                Ai.prototype.constructor = Ai,
                Ci.prototype = Object.create(Ti.prototype),
                Ci.prototype.constructor = Ci,
                Pi.prototype = Object.create(Ti.prototype),
                Pi.prototype.constructor = Pi,
                Ri.prototype = Object.create(Ti.prototype),
                Ri.prototype.constructor = Ri,
                Li.prototype = Object.create(Ti.prototype),
                Li.prototype.constructor = Li,
                Di.prototype = Object.create(Ti.prototype),
                Di.prototype.constructor = Di,
                Oi.prototype = Object.create(Ti.prototype),
                Oi.prototype.constructor = Oi,
                Oi.prototype.isFloat16BufferAttribute = !0,
                Fi.prototype = Object.create(Ti.prototype),
                Fi.prototype.constructor = Fi,
                Ii.prototype = Object.create(Ti.prototype),
                Ii.prototype.constructor = Ii;
                const Bi = {
                    Int8Array,
                    Uint8Array,
                    Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                };
                function ki(e, t) {
                    return new Bi[e](t)
                }
                let zi = 0;
                const Ui = new Tr
                  , Hi = new Jr
                  , Gi = new Kn
                  , ji = new er
                  , Vi = new er
                  , Wi = new Kn;
                function qi() {
                    Object.defineProperty(this, "id", {
                        value: zi++
                    }),
                    this.uuid = zn.generateUUID(),
                    this.name = "",
                    this.type = "BufferGeometry",
                    this.index = null,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.morphTargetsRelative = !1,
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    },
                    this.userData = {}
                }
                qi.prototype = Object.assign(Object.create(Nn.prototype), {
                    constructor: qi,
                    isBufferGeometry: !0,
                    getIndex: function() {
                        return this.index
                    },
                    setIndex: function(e) {
                        return Array.isArray(e) ? this.index = new (Ni(e) > 65535 ? Di : Ri)(e,1) : this.index = e,
                        this
                    },
                    getAttribute: function(e) {
                        return this.attributes[e]
                    },
                    setAttribute: function(e, t) {
                        return this.attributes[e] = t,
                        this
                    },
                    deleteAttribute: function(e) {
                        return delete this.attributes[e],
                        this
                    },
                    hasAttribute: function(e) {
                        return void 0 !== this.attributes[e]
                    },
                    addGroup: function(e, t, n=0) {
                        this.groups.push({
                            start: e,
                            count: t,
                            materialIndex: n
                        })
                    },
                    clearGroups: function() {
                        this.groups = []
                    },
                    setDrawRange: function(e, t) {
                        this.drawRange.start = e,
                        this.drawRange.count = t
                    },
                    applyMatrix4: function(e) {
                        const t = this.attributes.position;
                        void 0 !== t && (t.applyMatrix4(e),
                        t.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const t = (new Hn).getNormalMatrix(e);
                            n.applyNormalMatrix(t),
                            n.needsUpdate = !0
                        }
                        const r = this.attributes.tangent;
                        return void 0 !== r && (r.transformDirection(e),
                        r.needsUpdate = !0),
                        null !== this.boundingBox && this.computeBoundingBox(),
                        null !== this.boundingSphere && this.computeBoundingSphere(),
                        this
                    },
                    rotateX: function(e) {
                        return Ui.makeRotationX(e),
                        this.applyMatrix4(Ui),
                        this
                    },
                    rotateY: function(e) {
                        return Ui.makeRotationY(e),
                        this.applyMatrix4(Ui),
                        this
                    },
                    rotateZ: function(e) {
                        return Ui.makeRotationZ(e),
                        this.applyMatrix4(Ui),
                        this
                    },
                    translate: function(e, t, n) {
                        return Ui.makeTranslation(e, t, n),
                        this.applyMatrix4(Ui),
                        this
                    },
                    scale: function(e, t, n) {
                        return Ui.makeScale(e, t, n),
                        this.applyMatrix4(Ui),
                        this
                    },
                    lookAt: function(e) {
                        return Hi.lookAt(e),
                        Hi.updateMatrix(),
                        this.applyMatrix4(Hi.matrix),
                        this
                    },
                    center: function() {
                        return this.computeBoundingBox(),
                        this.boundingBox.getCenter(Gi).negate(),
                        this.translate(Gi.x, Gi.y, Gi.z),
                        this
                    },
                    setFromPoints: function(e) {
                        const t = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t.push(r.x, r.y, r.z || 0)
                        }
                        return this.setAttribute("position", new Fi(t,3)),
                        this
                    },
                    computeBoundingBox: function() {
                        null === this.boundingBox && (this.boundingBox = new er);
                        const e = this.attributes.position
                          , t = this.morphAttributes.position;
                        if (e && e.isGLBufferAttribute)
                            return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                            void this.boundingBox.set(new Kn(-1 / 0,-1 / 0,-1 / 0), new Kn(1 / 0,1 / 0,1 / 0));
                        if (void 0 !== e) {
                            if (this.boundingBox.setFromBufferAttribute(e),
                            t)
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e];
                                    ji.setFromBufferAttribute(n),
                                    this.morphTargetsRelative ? (Wi.addVectors(this.boundingBox.min, ji.min),
                                    this.boundingBox.expandByPoint(Wi),
                                    Wi.addVectors(this.boundingBox.max, ji.max),
                                    this.boundingBox.expandByPoint(Wi)) : (this.boundingBox.expandByPoint(ji.min),
                                    this.boundingBox.expandByPoint(ji.max))
                                }
                        } else
                            this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    },
                    computeBoundingSphere: function() {
                        null === this.boundingSphere && (this.boundingSphere = new gr);
                        const e = this.attributes.position
                          , t = this.morphAttributes.position;
                        if (e && e.isGLBufferAttribute)
                            return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                            void this.boundingSphere.set(new Kn, 1 / 0);
                        if (e) {
                            const n = this.boundingSphere.center;
                            if (ji.setFromBufferAttribute(e),
                            t)
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e];
                                    Vi.setFromBufferAttribute(n),
                                    this.morphTargetsRelative ? (Wi.addVectors(ji.min, Vi.min),
                                    ji.expandByPoint(Wi),
                                    Wi.addVectors(ji.max, Vi.max),
                                    ji.expandByPoint(Wi)) : (ji.expandByPoint(Vi.min),
                                    ji.expandByPoint(Vi.max))
                                }
                            ji.getCenter(n);
                            let r = 0;
                            for (let t = 0, i = e.count; t < i; t++)
                                Wi.fromBufferAttribute(e, t),
                                r = Math.max(r, n.distanceToSquared(Wi));
                            if (t)
                                for (let i = 0, a = t.length; i < a; i++) {
                                    const a = t[i]
                                      , o = this.morphTargetsRelative;
                                    for (let t = 0, i = a.count; t < i; t++)
                                        Wi.fromBufferAttribute(a, t),
                                        o && (Gi.fromBufferAttribute(e, t),
                                        Wi.add(Gi)),
                                        r = Math.max(r, n.distanceToSquared(Wi))
                                }
                            this.boundingSphere.radius = Math.sqrt(r),
                            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    },
                    computeFaceNormals: function() {},
                    computeTangents: function() {
                        const e = this.index
                          , t = this.attributes;
                        if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                            return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = e.array
                          , r = t.position.array
                          , i = t.normal.array
                          , a = t.uv.array
                          , o = r.length / 3;
                        void 0 === t.tangent && this.setAttribute("tangent", new Ti(new Float32Array(4 * o),4));
                        const s = t.tangent.array
                          , l = []
                          , c = [];
                        for (let e = 0; e < o; e++)
                            l[e] = new Kn,
                            c[e] = new Kn;
                        const u = new Kn
                          , h = new Kn
                          , d = new Kn
                          , p = new Un
                          , f = new Un
                          , m = new Un
                          , g = new Kn
                          , v = new Kn;
                        function y(e, t, n) {
                            u.fromArray(r, 3 * e),
                            h.fromArray(r, 3 * t),
                            d.fromArray(r, 3 * n),
                            p.fromArray(a, 2 * e),
                            f.fromArray(a, 2 * t),
                            m.fromArray(a, 2 * n),
                            h.sub(u),
                            d.sub(u),
                            f.sub(p),
                            m.sub(p);
                            const i = 1 / (f.x * m.y - m.x * f.y);
                            isFinite(i) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(i),
                            v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(i),
                            l[e].add(g),
                            l[t].add(g),
                            l[n].add(g),
                            c[e].add(v),
                            c[t].add(v),
                            c[n].add(v))
                        }
                        let _ = this.groups;
                        0 === _.length && (_ = [{
                            start: 0,
                            count: n.length
                        }]);
                        for (let e = 0, t = _.length; e < t; ++e) {
                            const t = _[e]
                              , r = t.start;
                            for (let e = r, i = r + t.count; e < i; e += 3)
                                y(n[e + 0], n[e + 1], n[e + 2])
                        }
                        const x = new Kn
                          , b = new Kn
                          , w = new Kn
                          , M = new Kn;
                        function S(e) {
                            w.fromArray(i, 3 * e),
                            M.copy(w);
                            const t = l[e];
                            x.copy(t),
                            x.sub(w.multiplyScalar(w.dot(t))).normalize(),
                            b.crossVectors(M, t);
                            const n = b.dot(c[e]) < 0 ? -1 : 1;
                            s[4 * e] = x.x,
                            s[4 * e + 1] = x.y,
                            s[4 * e + 2] = x.z,
                            s[4 * e + 3] = n
                        }
                        for (let e = 0, t = _.length; e < t; ++e) {
                            const t = _[e]
                              , r = t.start;
                            for (let e = r, i = r + t.count; e < i; e += 3)
                                S(n[e + 0]),
                                S(n[e + 1]),
                                S(n[e + 2])
                        }
                    },
                    computeVertexNormals: function() {
                        const e = this.index
                          , t = this.getAttribute("position");
                        if (void 0 !== t) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n)
                                n = new Ti(new Float32Array(3 * t.count),3),
                                this.setAttribute("normal", n);
                            else
                                for (let e = 0, t = n.count; e < t; e++)
                                    n.setXYZ(e, 0, 0, 0);
                            const r = new Kn
                              , i = new Kn
                              , a = new Kn
                              , o = new Kn
                              , s = new Kn
                              , l = new Kn
                              , c = new Kn
                              , u = new Kn;
                            if (e)
                                for (let h = 0, d = e.count; h < d; h += 3) {
                                    const d = e.getX(h + 0)
                                      , p = e.getX(h + 1)
                                      , f = e.getX(h + 2);
                                    r.fromBufferAttribute(t, d),
                                    i.fromBufferAttribute(t, p),
                                    a.fromBufferAttribute(t, f),
                                    c.subVectors(a, i),
                                    u.subVectors(r, i),
                                    c.cross(u),
                                    o.fromBufferAttribute(n, d),
                                    s.fromBufferAttribute(n, p),
                                    l.fromBufferAttribute(n, f),
                                    o.add(c),
                                    s.add(c),
                                    l.add(c),
                                    n.setXYZ(d, o.x, o.y, o.z),
                                    n.setXYZ(p, s.x, s.y, s.z),
                                    n.setXYZ(f, l.x, l.y, l.z)
                                }
                            else
                                for (let e = 0, o = t.count; e < o; e += 3)
                                    r.fromBufferAttribute(t, e + 0),
                                    i.fromBufferAttribute(t, e + 1),
                                    a.fromBufferAttribute(t, e + 2),
                                    c.subVectors(a, i),
                                    u.subVectors(r, i),
                                    c.cross(u),
                                    n.setXYZ(e + 0, c.x, c.y, c.z),
                                    n.setXYZ(e + 1, c.x, c.y, c.z),
                                    n.setXYZ(e + 2, c.x, c.y, c.z);
                            this.normalizeNormals(),
                            n.needsUpdate = !0
                        }
                    },
                    merge: function(e, t) {
                        if (!e || !e.isBufferGeometry)
                            return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                        void 0 === t && (t = 0,
                        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        const n = this.attributes;
                        for (const r in n) {
                            if (void 0 === e.attributes[r])
                                continue;
                            const i = n[r].array
                              , a = e.attributes[r]
                              , o = a.array
                              , s = a.itemSize * t
                              , l = Math.min(o.length, i.length - s);
                            for (let e = 0, t = s; e < l; e++,
                            t++)
                                i[t] = o[e]
                        }
                        return this
                    },
                    normalizeNormals: function() {
                        const e = this.attributes.normal;
                        for (let t = 0, n = e.count; t < n; t++)
                            Wi.fromBufferAttribute(e, t),
                            Wi.normalize(),
                            e.setXYZ(t, Wi.x, Wi.y, Wi.z)
                    },
                    toNonIndexed: function() {
                        function e(e, t) {
                            const n = e.array
                              , r = e.itemSize
                              , i = e.normalized
                              , a = new n.constructor(t.length * r);
                            let o = 0
                              , s = 0;
                            for (let e = 0, i = t.length; e < i; e++) {
                                o = t[e] * r;
                                for (let e = 0; e < r; e++)
                                    a[s++] = n[o++]
                            }
                            return new Ti(a,r,i)
                        }
                        if (null === this.index)
                            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                            this;
                        const t = new qi
                          , n = this.index.array
                          , r = this.attributes;
                        for (const i in r) {
                            const a = e(r[i], n);
                            t.setAttribute(i, a)
                        }
                        const i = this.morphAttributes;
                        for (const r in i) {
                            const a = []
                              , o = i[r];
                            for (let t = 0, r = o.length; t < r; t++) {
                                const r = e(o[t], n);
                                a.push(r)
                            }
                            t.morphAttributes[r] = a
                        }
                        t.morphTargetsRelative = this.morphTargetsRelative;
                        const a = this.groups;
                        for (let e = 0, n = a.length; e < n; e++) {
                            const n = a[e];
                            t.addGroup(n.start, n.count, n.materialIndex)
                        }
                        return t
                    },
                    toJSON: function() {
                        const e = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (e.uuid = this.uuid,
                        e.type = this.type,
                        "" !== this.name && (e.name = this.name),
                        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                        void 0 !== this.parameters) {
                            const t = this.parameters;
                            for (const n in t)
                                void 0 !== t[n] && (e[n] = t[n]);
                            return e
                        }
                        e.data = {
                            attributes: {}
                        };
                        const t = this.index;
                        null !== t && (e.data.index = {
                            type: t.array.constructor.name,
                            array: Array.prototype.slice.call(t.array)
                        });
                        const n = this.attributes;
                        for (const t in n) {
                            const r = n[t]
                              , i = r.toJSON(e.data);
                            "" !== r.name && (i.name = r.name),
                            e.data.attributes[t] = i
                        }
                        const r = {};
                        let i = !1;
                        for (const t in this.morphAttributes) {
                            const n = this.morphAttributes[t]
                              , a = [];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t]
                                  , i = r.toJSON(e.data);
                                "" !== r.name && (i.name = r.name),
                                a.push(i)
                            }
                            a.length > 0 && (r[t] = a,
                            i = !0)
                        }
                        i && (e.data.morphAttributes = r,
                        e.data.morphTargetsRelative = this.morphTargetsRelative);
                        const a = this.groups;
                        a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                        const o = this.boundingSphere;
                        return null !== o && (e.data.boundingSphere = {
                            center: o.center.toArray(),
                            radius: o.radius
                        }),
                        e
                    },
                    clone: function() {
                        return (new qi).copy(this)
                    },
                    copy: function(e) {
                        this.index = null,
                        this.attributes = {},
                        this.morphAttributes = {},
                        this.groups = [],
                        this.boundingBox = null,
                        this.boundingSphere = null;
                        const t = {};
                        this.name = e.name;
                        const n = e.index;
                        null !== n && this.setIndex(n.clone(t));
                        const r = e.attributes;
                        for (const e in r) {
                            const n = r[e];
                            this.setAttribute(e, n.clone(t))
                        }
                        const i = e.morphAttributes;
                        for (const e in i) {
                            const n = []
                              , r = i[e];
                            for (let e = 0, i = r.length; e < i; e++)
                                n.push(r[e].clone(t));
                            this.morphAttributes[e] = n
                        }
                        this.morphTargetsRelative = e.morphTargetsRelative;
                        const a = e.groups;
                        for (let e = 0, t = a.length; e < t; e++) {
                            const t = a[e];
                            this.addGroup(t.start, t.count, t.materialIndex)
                        }
                        const o = e.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const s = e.boundingSphere;
                        return null !== s && (this.boundingSphere = s.clone()),
                        this.drawRange.start = e.drawRange.start,
                        this.drawRange.count = e.drawRange.count,
                        this.userData = e.userData,
                        this
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                });
                const Xi = new Tr
                  , Yi = new Sr
                  , Zi = new gr
                  , Ji = new Kn
                  , Ki = new Kn
                  , Qi = new Kn
                  , $i = new Kn
                  , ea = new Kn
                  , ta = new Kn
                  , na = new Kn
                  , ra = new Kn
                  , ia = new Kn
                  , aa = new Un
                  , oa = new Un
                  , sa = new Un
                  , la = new Kn
                  , ca = new Kn;
                function ua(e=new qi, t=new wi) {
                    Jr.call(this),
                    this.type = "Mesh",
                    this.geometry = e,
                    this.material = t,
                    this.updateMorphTargets()
                }
                function ha(e, t, n, r, i, a, o, s, l, c, u, h) {
                    Ji.fromBufferAttribute(i, c),
                    Ki.fromBufferAttribute(i, u),
                    Qi.fromBufferAttribute(i, h);
                    const d = e.morphTargetInfluences;
                    if (t.morphTargets && a && d) {
                        na.set(0, 0, 0),
                        ra.set(0, 0, 0),
                        ia.set(0, 0, 0);
                        for (let e = 0, t = a.length; e < t; e++) {
                            const t = d[e]
                              , n = a[e];
                            0 !== t && ($i.fromBufferAttribute(n, c),
                            ea.fromBufferAttribute(n, u),
                            ta.fromBufferAttribute(n, h),
                            o ? (na.addScaledVector($i, t),
                            ra.addScaledVector(ea, t),
                            ia.addScaledVector(ta, t)) : (na.addScaledVector($i.sub(Ji), t),
                            ra.addScaledVector(ea.sub(Ki), t),
                            ia.addScaledVector(ta.sub(Qi), t)))
                        }
                        Ji.add(na),
                        Ki.add(ra),
                        Qi.add(ia)
                    }
                    e.isSkinnedMesh && (e.boneTransform(c, Ji),
                    e.boneTransform(u, Ki),
                    e.boneTransform(h, Qi));
                    const p = function(e, t, n, r, i, a, o, s) {
                        let l;
                        if (l = t.side === m ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side !== g, s),
                        null === l)
                            return null;
                        ca.copy(s),
                        ca.applyMatrix4(e.matrixWorld);
                        const c = n.ray.origin.distanceTo(ca);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: ca.clone(),
                            object: e
                        }
                    }(e, t, n, r, Ji, Ki, Qi, la);
                    if (p) {
                        s && (aa.fromBufferAttribute(s, c),
                        oa.fromBufferAttribute(s, u),
                        sa.fromBufferAttribute(s, h),
                        p.uv = hi.getUV(la, Ji, Ki, Qi, aa, oa, sa, new Un)),
                        l && (aa.fromBufferAttribute(l, c),
                        oa.fromBufferAttribute(l, u),
                        sa.fromBufferAttribute(l, h),
                        p.uv2 = hi.getUV(la, Ji, Ki, Qi, aa, oa, sa, new Un));
                        const e = new _i(c,u,h);
                        hi.getNormal(Ji, Ki, Qi, e.normal),
                        p.face = e
                    }
                    return p
                }
                ua.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: ua,
                    isMesh: !0,
                    copy: function(e) {
                        return Jr.prototype.copy.call(this, e),
                        void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                        void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                        this.material = e.material,
                        this.geometry = e.geometry,
                        this
                    },
                    updateMorphTargets: function() {
                        const e = this.geometry;
                        if (e.isBufferGeometry) {
                            const t = e.morphAttributes
                              , n = Object.keys(t);
                            if (n.length > 0) {
                                const e = t[n[0]];
                                if (void 0 !== e) {
                                    this.morphTargetInfluences = [],
                                    this.morphTargetDictionary = {};
                                    for (let t = 0, n = e.length; t < n; t++) {
                                        const n = e[t].name || String(t);
                                        this.morphTargetInfluences.push(0),
                                        this.morphTargetDictionary[n] = t
                                    }
                                }
                            }
                        } else {
                            const t = e.morphTargets;
                            void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    },
                    raycast: function(e, t) {
                        const n = this.geometry
                          , r = this.material
                          , i = this.matrixWorld;
                        if (void 0 === r)
                            return;
                        if (null === n.boundingSphere && n.computeBoundingSphere(),
                        Zi.copy(n.boundingSphere),
                        Zi.applyMatrix4(i),
                        !1 === e.ray.intersectsSphere(Zi))
                            return;
                        if (Xi.copy(i).invert(),
                        Yi.copy(e.ray).applyMatrix4(Xi),
                        null !== n.boundingBox && !1 === Yi.intersectsBox(n.boundingBox))
                            return;
                        let a;
                        if (n.isBufferGeometry) {
                            const i = n.index
                              , o = n.attributes.position
                              , s = n.morphAttributes.position
                              , l = n.morphTargetsRelative
                              , c = n.attributes.uv
                              , u = n.attributes.uv2
                              , h = n.groups
                              , d = n.drawRange;
                            if (null !== i)
                                if (Array.isArray(r))
                                    for (let n = 0, p = h.length; n < p; n++) {
                                        const p = h[n]
                                          , f = r[p.materialIndex];
                                        for (let n = Math.max(p.start, d.start), r = Math.min(p.start + p.count, d.start + d.count); n < r; n += 3) {
                                            const r = i.getX(n)
                                              , h = i.getX(n + 1)
                                              , d = i.getX(n + 2);
                                            a = ha(this, f, e, Yi, o, s, l, c, u, r, h, d),
                                            a && (a.faceIndex = Math.floor(n / 3),
                                            a.face.materialIndex = p.materialIndex,
                                            t.push(a))
                                        }
                                    }
                                else
                                    for (let n = Math.max(0, d.start), h = Math.min(i.count, d.start + d.count); n < h; n += 3) {
                                        const h = i.getX(n)
                                          , d = i.getX(n + 1)
                                          , p = i.getX(n + 2);
                                        a = ha(this, r, e, Yi, o, s, l, c, u, h, d, p),
                                        a && (a.faceIndex = Math.floor(n / 3),
                                        t.push(a))
                                    }
                            else if (void 0 !== o)
                                if (Array.isArray(r))
                                    for (let n = 0, i = h.length; n < i; n++) {
                                        const i = h[n]
                                          , p = r[i.materialIndex];
                                        for (let n = Math.max(i.start, d.start), r = Math.min(i.start + i.count, d.start + d.count); n < r; n += 3)
                                            a = ha(this, p, e, Yi, o, s, l, c, u, n, n + 1, n + 2),
                                            a && (a.faceIndex = Math.floor(n / 3),
                                            a.face.materialIndex = i.materialIndex,
                                            t.push(a))
                                    }
                                else
                                    for (let n = Math.max(0, d.start), i = Math.min(o.count, d.start + d.count); n < i; n += 3)
                                        a = ha(this, r, e, Yi, o, s, l, c, u, n, n + 1, n + 2),
                                        a && (a.faceIndex = Math.floor(n / 3),
                                        t.push(a))
                        } else
                            n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                });
                class da extends qi {
                    constructor(e=1, t=1, n=1, r=1, i=1, a=1) {
                        super(),
                        this.type = "BoxGeometry",
                        this.parameters = {
                            width: e,
                            height: t,
                            depth: n,
                            widthSegments: r,
                            heightSegments: i,
                            depthSegments: a
                        };
                        const o = this;
                        r = Math.floor(r),
                        i = Math.floor(i),
                        a = Math.floor(a);
                        const s = []
                          , l = []
                          , c = []
                          , u = [];
                        let h = 0
                          , d = 0;
                        function p(e, t, n, r, i, a, p, f, m, g, v) {
                            const y = a / m
                              , _ = p / g
                              , x = a / 2
                              , b = p / 2
                              , w = f / 2
                              , M = m + 1
                              , S = g + 1;
                            let T = 0
                              , E = 0;
                            const A = new Kn;
                            for (let a = 0; a < S; a++) {
                                const o = a * _ - b;
                                for (let s = 0; s < M; s++) {
                                    const h = s * y - x;
                                    A[e] = h * r,
                                    A[t] = o * i,
                                    A[n] = w,
                                    l.push(A.x, A.y, A.z),
                                    A[e] = 0,
                                    A[t] = 0,
                                    A[n] = f > 0 ? 1 : -1,
                                    c.push(A.x, A.y, A.z),
                                    u.push(s / m),
                                    u.push(1 - a / g),
                                    T += 1
                                }
                            }
                            for (let e = 0; e < g; e++)
                                for (let t = 0; t < m; t++) {
                                    const n = h + t + M * e
                                      , r = h + t + M * (e + 1)
                                      , i = h + (t + 1) + M * (e + 1)
                                      , a = h + (t + 1) + M * e;
                                    s.push(n, r, a),
                                    s.push(r, i, a),
                                    E += 6
                                }
                            o.addGroup(d, E, v),
                            d += E,
                            h += T
                        }
                        p("z", "y", "x", -1, -1, n, t, e, a, i, 0),
                        p("z", "y", "x", 1, -1, n, t, -e, a, i, 1),
                        p("x", "z", "y", 1, 1, e, n, t, r, a, 2),
                        p("x", "z", "y", 1, -1, e, n, -t, r, a, 3),
                        p("x", "y", "z", 1, -1, e, t, n, r, i, 4),
                        p("x", "y", "z", -1, -1, e, t, -n, r, i, 5),
                        this.setIndex(s),
                        this.setAttribute("position", new Fi(l,3)),
                        this.setAttribute("normal", new Fi(c,3)),
                        this.setAttribute("uv", new Fi(u,2))
                    }
                }
                function pa(e) {
                    const t = {};
                    for (const n in e) {
                        t[n] = {};
                        for (const r in e[n]) {
                            const i = e[n][r];
                            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                        }
                    }
                    return t
                }
                function fa(e) {
                    const t = {};
                    for (let n = 0; n < e.length; n++) {
                        const r = pa(e[n]);
                        for (const e in r)
                            t[e] = r[e]
                    }
                    return t
                }
                const ma = {
                    clone: pa,
                    merge: fa
                };
                function ga(e) {
                    bi.call(this),
                    this.type = "ShaderMaterial",
                    this.defines = {},
                    this.uniforms = {},
                    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                    this.linewidth = 1,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.clipping = !1,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    },
                    this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    },
                    this.index0AttributeName = void 0,
                    this.uniformsNeedUpdate = !1,
                    this.glslVersion = null,
                    void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                    this.setValues(e))
                }
                function va() {
                    Jr.call(this),
                    this.type = "Camera",
                    this.matrixWorldInverse = new Tr,
                    this.projectionMatrix = new Tr,
                    this.projectionMatrixInverse = new Tr
                }
                function ya(e=50, t=1, n=.1, r=2e3) {
                    va.call(this),
                    this.type = "PerspectiveCamera",
                    this.fov = e,
                    this.zoom = 1,
                    this.near = n,
                    this.far = r,
                    this.focus = 10,
                    this.aspect = t,
                    this.view = null,
                    this.filmGauge = 35,
                    this.filmOffset = 0,
                    this.updateProjectionMatrix()
                }
                ga.prototype = Object.create(bi.prototype),
                ga.prototype.constructor = ga,
                ga.prototype.isShaderMaterial = !0,
                ga.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.fragmentShader = e.fragmentShader,
                    this.vertexShader = e.vertexShader,
                    this.uniforms = pa(e.uniforms),
                    this.defines = Object.assign({}, e.defines),
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.lights = e.lights,
                    this.clipping = e.clipping,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this.extensions = Object.assign({}, e.extensions),
                    this.glslVersion = e.glslVersion,
                    this
                }
                ,
                ga.prototype.toJSON = function(e) {
                    const t = bi.prototype.toJSON.call(this, e);
                    t.glslVersion = this.glslVersion,
                    t.uniforms = {};
                    for (const n in this.uniforms) {
                        const r = this.uniforms[n].value;
                        r && r.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: r.toJSON(e).uuid
                        } : r && r.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: r.getHex()
                        } : r && r.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: r.toArray()
                        } : r && r.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: r.toArray()
                        } : r && r.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: r.toArray()
                        } : r && r.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: r.toArray()
                        } : r && r.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: r.toArray()
                        } : t.uniforms[n] = {
                            value: r
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                    t.vertexShader = this.vertexShader,
                    t.fragmentShader = this.fragmentShader;
                    const n = {};
                    for (const e in this.extensions)
                        !0 === this.extensions[e] && (n[e] = !0);
                    return Object.keys(n).length > 0 && (t.extensions = n),
                    t
                }
                ,
                va.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: va,
                    isCamera: !0,
                    copy: function(e, t) {
                        return Jr.prototype.copy.call(this, e, t),
                        this.matrixWorldInverse.copy(e.matrixWorldInverse),
                        this.projectionMatrix.copy(e.projectionMatrix),
                        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                        this
                    },
                    getWorldDirection: function(e) {
                        void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
                        e = new Kn),
                        this.updateWorldMatrix(!0, !1);
                        const t = this.matrixWorld.elements;
                        return e.set(-t[8], -t[9], -t[10]).normalize()
                    },
                    updateMatrixWorld: function(e) {
                        Jr.prototype.updateMatrixWorld.call(this, e),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    },
                    updateWorldMatrix: function(e, t) {
                        Jr.prototype.updateWorldMatrix.call(this, e, t),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                }),
                ya.prototype = Object.assign(Object.create(va.prototype), {
                    constructor: ya,
                    isPerspectiveCamera: !0,
                    copy: function(e, t) {
                        return va.prototype.copy.call(this, e, t),
                        this.fov = e.fov,
                        this.zoom = e.zoom,
                        this.near = e.near,
                        this.far = e.far,
                        this.focus = e.focus,
                        this.aspect = e.aspect,
                        this.view = null === e.view ? null : Object.assign({}, e.view),
                        this.filmGauge = e.filmGauge,
                        this.filmOffset = e.filmOffset,
                        this
                    },
                    setFocalLength: function(e) {
                        const t = .5 * this.getFilmHeight() / e;
                        this.fov = 2 * zn.RAD2DEG * Math.atan(t),
                        this.updateProjectionMatrix()
                    },
                    getFocalLength: function() {
                        const e = Math.tan(.5 * zn.DEG2RAD * this.fov);
                        return .5 * this.getFilmHeight() / e
                    },
                    getEffectiveFOV: function() {
                        return 2 * zn.RAD2DEG * Math.atan(Math.tan(.5 * zn.DEG2RAD * this.fov) / this.zoom)
                    },
                    getFilmWidth: function() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    },
                    getFilmHeight: function() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    },
                    setViewOffset: function(e, t, n, r, i, a) {
                        this.aspect = e / t,
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = r,
                        this.view.width = i,
                        this.view.height = a,
                        this.updateProjectionMatrix()
                    },
                    clearViewOffset: function() {
                        null !== this.view && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    },
                    updateProjectionMatrix: function() {
                        const e = this.near;
                        let t = e * Math.tan(.5 * zn.DEG2RAD * this.fov) / this.zoom
                          , n = 2 * t
                          , r = this.aspect * n
                          , i = -.5 * r;
                        const a = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const e = a.fullWidth
                              , o = a.fullHeight;
                            i += a.offsetX * r / e,
                            t -= a.offsetY * n / o,
                            r *= a.width / e,
                            n *= a.height / o
                        }
                        const o = this.filmOffset;
                        0 !== o && (i += e * o / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    },
                    toJSON: function(e) {
                        const t = Jr.prototype.toJSON.call(this, e);
                        return t.object.fov = this.fov,
                        t.object.zoom = this.zoom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        t.object.focus = this.focus,
                        t.object.aspect = this.aspect,
                        null !== this.view && (t.object.view = Object.assign({}, this.view)),
                        t.object.filmGauge = this.filmGauge,
                        t.object.filmOffset = this.filmOffset,
                        t
                    }
                });
                const _a = 90;
                function xa(e, t, n) {
                    if (Jr.call(this),
                    this.type = "CubeCamera",
                    !0 !== n.isWebGLCubeRenderTarget)
                        return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = n;
                    const r = new ya(_a,1,e,t);
                    r.layers = this.layers,
                    r.up.set(0, -1, 0),
                    r.lookAt(new Kn(1,0,0)),
                    this.add(r);
                    const i = new ya(_a,1,e,t);
                    i.layers = this.layers,
                    i.up.set(0, -1, 0),
                    i.lookAt(new Kn(-1,0,0)),
                    this.add(i);
                    const a = new ya(_a,1,e,t);
                    a.layers = this.layers,
                    a.up.set(0, 0, 1),
                    a.lookAt(new Kn(0,1,0)),
                    this.add(a);
                    const o = new ya(_a,1,e,t);
                    o.layers = this.layers,
                    o.up.set(0, 0, -1),
                    o.lookAt(new Kn(0,-1,0)),
                    this.add(o);
                    const s = new ya(_a,1,e,t);
                    s.layers = this.layers,
                    s.up.set(0, -1, 0),
                    s.lookAt(new Kn(0,0,1)),
                    this.add(s);
                    const l = new ya(_a,1,e,t);
                    l.layers = this.layers,
                    l.up.set(0, -1, 0),
                    l.lookAt(new Kn(0,0,-1)),
                    this.add(l),
                    this.update = function(e, t) {
                        null === this.parent && this.updateMatrixWorld();
                        const c = e.xr.enabled
                          , u = e.getRenderTarget();
                        e.xr.enabled = !1;
                        const h = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1,
                        e.setRenderTarget(n, 0),
                        e.render(t, r),
                        e.setRenderTarget(n, 1),
                        e.render(t, i),
                        e.setRenderTarget(n, 2),
                        e.render(t, a),
                        e.setRenderTarget(n, 3),
                        e.render(t, o),
                        e.setRenderTarget(n, 4),
                        e.render(t, s),
                        n.texture.generateMipmaps = h,
                        e.setRenderTarget(n, 5),
                        e.render(t, l),
                        e.setRenderTarget(u),
                        e.xr.enabled = c
                    }
                }
                function ba(e, t, n, r, i, a, o, s, l, c) {
                    e = void 0 !== e ? e : [],
                    t = void 0 !== t ? t : ae,
                    o = void 0 !== o ? o : Be,
                    Wn.call(this, e, t, n, r, i, a, o, s, l, c),
                    this.flipY = !1,
                    this._needsFlipEnvMap = !0
                }
                xa.prototype = Object.create(Jr.prototype),
                xa.prototype.constructor = xa,
                ba.prototype = Object.create(Wn.prototype),
                ba.prototype.constructor = ba,
                ba.prototype.isCubeTexture = !0,
                Object.defineProperty(ba.prototype, "images", {
                    get: function() {
                        return this.image
                    },
                    set: function(e) {
                        this.image = e
                    }
                });
                class wa extends Yn {
                    constructor(e, t, n) {
                        Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
                        t = n),
                        super(e, e, t),
                        Object.defineProperty(this, "isWebGLCubeRenderTarget", {
                            value: !0
                        }),
                        t = t || {},
                        this.texture = new ba(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
                        this.texture._needsFlipEnvMap = !1
                    }
                    fromEquirectangularTexture(e, t) {
                        this.texture.type = t.type,
                        this.texture.format = ke,
                        this.texture.encoding = t.encoding,
                        this.texture.generateMipmaps = t.generateMipmaps,
                        this.texture.minFilter = t.minFilter,
                        this.texture.magFilter = t.magFilter;
                        const n = {
                            tEquirect: {
                                value: null
                            }
                        }
                          , r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
                          , i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                          , a = new da(5,5,5)
                          , o = new ga({
                            name: "CubemapFromEquirect",
                            uniforms: pa(n),
                            vertexShader: r,
                            fragmentShader: i,
                            side: m,
                            blending: _
                        });
                        o.uniforms.tEquirect.value = t;
                        const s = new ua(a,o)
                          , l = t.minFilter;
                        return t.minFilter === we && (t.minFilter = _e),
                        new xa(1,10,this).update(e, s),
                        t.minFilter = l,
                        s.geometry.dispose(),
                        s.material.dispose(),
                        this
                    }
                    clear(e, t, n, r) {
                        const i = e.getRenderTarget();
                        for (let i = 0; i < 6; i++)
                            e.setRenderTarget(this, i),
                            e.clear(t, n, r);
                        e.setRenderTarget(i)
                    }
                }
                function Ma(e, t, n, r, i, a, o, s, l, c, u, h) {
                    Wn.call(this, null, a, o, s, l, c, r, i, u, h),
                    this.image = {
                        data: e || null,
                        width: t || 1,
                        height: n || 1
                    },
                    this.magFilter = void 0 !== l ? l : fe,
                    this.minFilter = void 0 !== c ? c : fe,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1,
                    this.needsUpdate = !0
                }
                Ma.prototype = Object.create(Wn.prototype),
                Ma.prototype.constructor = Ma,
                Ma.prototype.isDataTexture = !0;
                const Sa = new gr
                  , Ta = new Kn;
                class Ea {
                    constructor(e, t, n, r, i, a) {
                        this.planes = [void 0 !== e ? e : new ei, void 0 !== t ? t : new ei, void 0 !== n ? n : new ei, void 0 !== r ? r : new ei, void 0 !== i ? i : new ei, void 0 !== a ? a : new ei]
                    }
                    set(e, t, n, r, i, a) {
                        const o = this.planes;
                        return o[0].copy(e),
                        o[1].copy(t),
                        o[2].copy(n),
                        o[3].copy(r),
                        o[4].copy(i),
                        o[5].copy(a),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            t[n].copy(e.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(e) {
                        const t = this.planes
                          , n = e.elements
                          , r = n[0]
                          , i = n[1]
                          , a = n[2]
                          , o = n[3]
                          , s = n[4]
                          , l = n[5]
                          , c = n[6]
                          , u = n[7]
                          , h = n[8]
                          , d = n[9]
                          , p = n[10]
                          , f = n[11]
                          , m = n[12]
                          , g = n[13]
                          , v = n[14]
                          , y = n[15];
                        return t[0].setComponents(o - r, u - s, f - h, y - m).normalize(),
                        t[1].setComponents(o + r, u + s, f + h, y + m).normalize(),
                        t[2].setComponents(o + i, u + l, f + d, y + g).normalize(),
                        t[3].setComponents(o - i, u - l, f - d, y - g).normalize(),
                        t[4].setComponents(o - a, u - c, f - p, y - v).normalize(),
                        t[5].setComponents(o + a, u + c, f + p, y + v).normalize(),
                        this
                    }
                    intersectsObject(e) {
                        const t = e.geometry;
                        return null === t.boundingSphere && t.computeBoundingSphere(),
                        Sa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(Sa)
                    }
                    intersectsSprite(e) {
                        return Sa.center.set(0, 0, 0),
                        Sa.radius = .7071067811865476,
                        Sa.applyMatrix4(e.matrixWorld),
                        this.intersectsSphere(Sa)
                    }
                    intersectsSphere(e) {
                        const t = this.planes
                          , n = e.center
                          , r = -e.radius;
                        for (let e = 0; e < 6; e++)
                            if (t[e].distanceToPoint(n) < r)
                                return !1;
                        return !0
                    }
                    intersectsBox(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const r = t[n];
                            if (Ta.x = r.normal.x > 0 ? e.max.x : e.min.x,
                            Ta.y = r.normal.y > 0 ? e.max.y : e.min.y,
                            Ta.z = r.normal.z > 0 ? e.max.z : e.min.z,
                            r.distanceToPoint(Ta) < 0)
                                return !1
                        }
                        return !0
                    }
                    containsPoint(e) {
                        const t = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (t[n].distanceToPoint(e) < 0)
                                return !1;
                        return !0
                    }
                }
                function Aa() {
                    let e = null
                      , t = !1
                      , n = null
                      , r = null;
                    function i(t, a) {
                        n(t, a),
                        r = e.requestAnimationFrame(i)
                    }
                    return {
                        start: function() {
                            !0 !== t && null !== n && (r = e.requestAnimationFrame(i),
                            t = !0)
                        },
                        stop: function() {
                            e.cancelAnimationFrame(r),
                            t = !1
                        },
                        setAnimationLoop: function(e) {
                            n = e
                        },
                        setContext: function(t) {
                            e = t
                        }
                    }
                }
                function Ca(e, t) {
                    const n = t.isWebGL2
                      , r = new WeakMap;
                    return {
                        get: function(e) {
                            return e.isInterleavedBufferAttribute && (e = e.data),
                            r.get(e)
                        },
                        remove: function(t) {
                            t.isInterleavedBufferAttribute && (t = t.data);
                            const n = r.get(t);
                            n && (e.deleteBuffer(n.buffer),
                            r.delete(t))
                        },
                        update: function(t, i) {
                            if (t.isGLBufferAttribute) {
                                const e = r.get(t);
                                return void ((!e || e.version < t.version) && r.set(t, {
                                    buffer: t.buffer,
                                    type: t.type,
                                    bytesPerElement: t.elementSize,
                                    version: t.version
                                }))
                            }
                            t.isInterleavedBufferAttribute && (t = t.data);
                            const a = r.get(t);
                            void 0 === a ? r.set(t, function(t, r) {
                                const i = t.array
                                  , a = t.usage
                                  , o = e.createBuffer();
                                e.bindBuffer(r, o),
                                e.bufferData(r, i, a),
                                t.onUploadCallback();
                                let s = 5126;
                                return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? s = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && (s = 5121),
                                {
                                    buffer: o,
                                    type: s,
                                    bytesPerElement: i.BYTES_PER_ELEMENT,
                                    version: t.version
                                }
                            }(t, i)) : a.version < t.version && (function(t, r, i) {
                                const a = r.array
                                  , o = r.updateRange;
                                e.bindBuffer(i, t),
                                -1 === o.count ? e.bufferSubData(i, 0, a) : (n ? e.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)),
                                o.count = -1)
                            }(a.buffer, t, i),
                            a.version = t.version)
                        }
                    }
                }
                class Pa extends qi {
                    constructor(e=1, t=1, n=1, r=1) {
                        super(),
                        this.type = "PlaneGeometry",
                        this.parameters = {
                            width: e,
                            height: t,
                            widthSegments: n,
                            heightSegments: r
                        };
                        const i = e / 2
                          , a = t / 2
                          , o = Math.floor(n)
                          , s = Math.floor(r)
                          , l = o + 1
                          , c = s + 1
                          , u = e / o
                          , h = t / s
                          , d = []
                          , p = []
                          , f = []
                          , m = [];
                        for (let e = 0; e < c; e++) {
                            const t = e * h - a;
                            for (let n = 0; n < l; n++) {
                                const r = n * u - i;
                                p.push(r, -t, 0),
                                f.push(0, 0, 1),
                                m.push(n / o),
                                m.push(1 - e / s)
                            }
                        }
                        for (let e = 0; e < s; e++)
                            for (let t = 0; t < o; t++) {
                                const n = t + l * e
                                  , r = t + l * (e + 1)
                                  , i = t + 1 + l * (e + 1)
                                  , a = t + 1 + l * e;
                                d.push(n, r, a),
                                d.push(r, i, a)
                            }
                        this.setIndex(d),
                        this.setAttribute("position", new Fi(p,3)),
                        this.setAttribute("normal", new Fi(f,3)),
                        this.setAttribute("uv", new Fi(m,2))
                    }
                }
                const Ra = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                    transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                }
                  , La = {
                    common: {
                        diffuse: {
                            value: new yi(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Hn
                        },
                        uv2Transform: {
                            value: new Hn
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Un(1,1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new yi(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new yi(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Hn
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new yi(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Un(.5,.5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new Hn
                        }
                    }
                }
                  , Da = {
                    basic: {
                        uniforms: fa([La.common, La.specularmap, La.envmap, La.aomap, La.lightmap, La.fog]),
                        vertexShader: Ra.meshbasic_vert,
                        fragmentShader: Ra.meshbasic_frag
                    },
                    lambert: {
                        uniforms: fa([La.common, La.specularmap, La.envmap, La.aomap, La.lightmap, La.emissivemap, La.fog, La.lights, {
                            emissive: {
                                value: new yi(0)
                            }
                        }]),
                        vertexShader: Ra.meshlambert_vert,
                        fragmentShader: Ra.meshlambert_frag
                    },
                    phong: {
                        uniforms: fa([La.common, La.specularmap, La.envmap, La.aomap, La.lightmap, La.emissivemap, La.bumpmap, La.normalmap, La.displacementmap, La.fog, La.lights, {
                            emissive: {
                                value: new yi(0)
                            },
                            specular: {
                                value: new yi(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Ra.meshphong_vert,
                        fragmentShader: Ra.meshphong_frag
                    },
                    standard: {
                        uniforms: fa([La.common, La.envmap, La.aomap, La.lightmap, La.emissivemap, La.bumpmap, La.normalmap, La.displacementmap, La.roughnessmap, La.metalnessmap, La.fog, La.lights, {
                            emissive: {
                                value: new yi(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ra.meshphysical_vert,
                        fragmentShader: Ra.meshphysical_frag
                    },
                    toon: {
                        uniforms: fa([La.common, La.aomap, La.lightmap, La.emissivemap, La.bumpmap, La.normalmap, La.displacementmap, La.gradientmap, La.fog, La.lights, {
                            emissive: {
                                value: new yi(0)
                            }
                        }]),
                        vertexShader: Ra.meshtoon_vert,
                        fragmentShader: Ra.meshtoon_frag
                    },
                    matcap: {
                        uniforms: fa([La.common, La.bumpmap, La.normalmap, La.displacementmap, La.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Ra.meshmatcap_vert,
                        fragmentShader: Ra.meshmatcap_frag
                    },
                    points: {
                        uniforms: fa([La.points, La.fog]),
                        vertexShader: Ra.points_vert,
                        fragmentShader: Ra.points_frag
                    },
                    dashed: {
                        uniforms: fa([La.common, La.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Ra.linedashed_vert,
                        fragmentShader: Ra.linedashed_frag
                    },
                    depth: {
                        uniforms: fa([La.common, La.displacementmap]),
                        vertexShader: Ra.depth_vert,
                        fragmentShader: Ra.depth_frag
                    },
                    normal: {
                        uniforms: fa([La.common, La.bumpmap, La.normalmap, La.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ra.normal_vert,
                        fragmentShader: Ra.normal_frag
                    },
                    sprite: {
                        uniforms: fa([La.sprite, La.fog]),
                        vertexShader: Ra.sprite_vert,
                        fragmentShader: Ra.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Hn
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Ra.background_vert,
                        fragmentShader: Ra.background_frag
                    },
                    cube: {
                        uniforms: fa([La.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ra.cube_vert,
                        fragmentShader: Ra.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Ra.equirect_vert,
                        fragmentShader: Ra.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: fa([La.common, La.displacementmap, {
                            referencePosition: {
                                value: new Kn
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Ra.distanceRGBA_vert,
                        fragmentShader: Ra.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: fa([La.lights, La.fog, {
                            color: {
                                value: new yi(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ra.shadow_vert,
                        fragmentShader: Ra.shadow_frag
                    }
                };
                function Oa(e, t, n, r, i) {
                    const a = new yi(0);
                    let o, s, l = 0, c = null, u = 0, h = null;
                    function d(e, t) {
                        n.buffers.color.setClear(e.r, e.g, e.b, t, i)
                    }
                    return {
                        getClearColor: function() {
                            return a
                        },
                        setClearColor: function(e, t=1) {
                            a.set(e),
                            l = t,
                            d(a, l)
                        },
                        getClearAlpha: function() {
                            return l
                        },
                        setClearAlpha: function(e) {
                            l = e,
                            d(a, l)
                        },
                        render: function(n, i, p, g) {
                            let v = !0 === i.isScene ? i.background : null;
                            v && v.isTexture && (v = t.get(v));
                            const y = e.xr
                              , _ = y.getSession && y.getSession();
                            _ && "additive" === _.environmentBlendMode && (v = null),
                            null === v ? d(a, l) : v && v.isColor && (d(v, 1),
                            g = !0),
                            (e.autoClear || g) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                            v && (v.isCubeTexture || v.isWebGLCubeRenderTarget || v.mapping === ce) ? (void 0 === s && (s = new ua(new da(1,1,1),new ga({
                                name: "BackgroundCubeMaterial",
                                uniforms: pa(Da.cube.uniforms),
                                vertexShader: Da.cube.vertexShader,
                                fragmentShader: Da.cube.fragmentShader,
                                side: m,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })),
                            s.geometry.deleteAttribute("normal"),
                            s.geometry.deleteAttribute("uv"),
                            s.onBeforeRender = function(e, t, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }
                            ,
                            Object.defineProperty(s.material, "envMap", {
                                get: function() {
                                    return this.uniforms.envMap.value
                                }
                            }),
                            r.update(s)),
                            v.isWebGLCubeRenderTarget && (v = v.texture),
                            s.material.uniforms.envMap.value = v,
                            s.material.uniforms.flipEnvMap.value = v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1,
                            c === v && u === v.version && h === e.toneMapping || (s.material.needsUpdate = !0,
                            c = v,
                            u = v.version,
                            h = e.toneMapping),
                            n.unshift(s, s.geometry, s.material, 0, 0, null)) : v && v.isTexture && (void 0 === o && (o = new ua(new Pa(2,2),new ga({
                                name: "BackgroundMaterial",
                                uniforms: pa(Da.background.uniforms),
                                vertexShader: Da.background.vertexShader,
                                fragmentShader: Da.background.fragmentShader,
                                side: f,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })),
                            o.geometry.deleteAttribute("normal"),
                            Object.defineProperty(o.material, "map", {
                                get: function() {
                                    return this.uniforms.t2D.value
                                }
                            }),
                            r.update(o)),
                            o.material.uniforms.t2D.value = v,
                            !0 === v.matrixAutoUpdate && v.updateMatrix(),
                            o.material.uniforms.uvTransform.value.copy(v.matrix),
                            c === v && u === v.version && h === e.toneMapping || (o.material.needsUpdate = !0,
                            c = v,
                            u = v.version,
                            h = e.toneMapping),
                            n.unshift(o, o.geometry, o.material, 0, 0, null))
                        }
                    }
                }
                function Fa(e, t, n, r) {
                    const i = e.getParameter(34921)
                      , a = r.isWebGL2 ? null : t.get("OES_vertex_array_object")
                      , o = r.isWebGL2 || null !== a
                      , s = {}
                      , l = d(null);
                    let c = l;
                    function u(t) {
                        return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                    }
                    function h(t) {
                        return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                    }
                    function d(e) {
                        const t = []
                          , n = []
                          , r = [];
                        for (let e = 0; e < i; e++)
                            t[e] = 0,
                            n[e] = 0,
                            r[e] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: t,
                            enabledAttributes: n,
                            attributeDivisors: r,
                            object: e,
                            attributes: {},
                            index: null
                        }
                    }
                    function p() {
                        const e = c.newAttributes;
                        for (let t = 0, n = e.length; t < n; t++)
                            e[t] = 0
                    }
                    function f(e) {
                        m(e, 0)
                    }
                    function m(n, i) {
                        const a = c.newAttributes
                          , o = c.enabledAttributes
                          , s = c.attributeDivisors;
                        a[n] = 1,
                        0 === o[n] && (e.enableVertexAttribArray(n),
                        o[n] = 1),
                        s[n] !== i && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i),
                        s[n] = i)
                    }
                    function g() {
                        const t = c.newAttributes
                          , n = c.enabledAttributes;
                        for (let r = 0, i = n.length; r < i; r++)
                            n[r] !== t[r] && (e.disableVertexAttribArray(r),
                            n[r] = 0)
                    }
                    function v(t, n, i, a, o, s) {
                        !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, a, o, s) : e.vertexAttribIPointer(t, n, i, o, s)
                    }
                    function y() {
                        _(),
                        c !== l && (c = l,
                        u(c.object))
                    }
                    function _() {
                        l.geometry = null,
                        l.program = null,
                        l.wireframe = !1
                    }
                    return {
                        setup: function(i, l, h, y, _) {
                            let x = !1;
                            if (o) {
                                const t = function(t, n, i) {
                                    const o = !0 === i.wireframe;
                                    let l = s[t.id];
                                    void 0 === l && (l = {},
                                    s[t.id] = l);
                                    let c = l[n.id];
                                    void 0 === c && (c = {},
                                    l[n.id] = c);
                                    let u = c[o];
                                    return void 0 === u && (u = d(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()),
                                    c[o] = u),
                                    u
                                }(y, h, l);
                                c !== t && (c = t,
                                u(c.object)),
                                x = function(e, t) {
                                    const n = c.attributes
                                      , r = e.attributes;
                                    let i = 0;
                                    for (const e in r) {
                                        const t = n[e]
                                          , a = r[e];
                                        if (void 0 === t)
                                            return !0;
                                        if (t.attribute !== a)
                                            return !0;
                                        if (t.data !== a.data)
                                            return !0;
                                        i++
                                    }
                                    return c.attributesNum !== i || c.index !== t
                                }(y, _),
                                x && function(e, t) {
                                    const n = {}
                                      , r = e.attributes;
                                    let i = 0;
                                    for (const e in r) {
                                        const t = r[e]
                                          , a = {};
                                        a.attribute = t,
                                        t.data && (a.data = t.data),
                                        n[e] = a,
                                        i++
                                    }
                                    c.attributes = n,
                                    c.attributesNum = i,
                                    c.index = t
                                }(y, _)
                            } else {
                                const e = !0 === l.wireframe;
                                c.geometry === y.id && c.program === h.id && c.wireframe === e || (c.geometry = y.id,
                                c.program = h.id,
                                c.wireframe = e,
                                x = !0)
                            }
                            !0 === i.isInstancedMesh && (x = !0),
                            null !== _ && n.update(_, 34963),
                            x && (function(i, a, o, s) {
                                if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                                    return;
                                p();
                                const l = s.attributes
                                  , c = o.getAttributes()
                                  , u = a.defaultAttributeValues;
                                for (const t in c) {
                                    const r = c[t];
                                    if (r >= 0) {
                                        const a = l[t];
                                        if (void 0 !== a) {
                                            const t = a.normalized
                                              , i = a.itemSize
                                              , o = n.get(a);
                                            if (void 0 === o)
                                                continue;
                                            const l = o.buffer
                                              , c = o.type
                                              , u = o.bytesPerElement;
                                            if (a.isInterleavedBufferAttribute) {
                                                const n = a.data
                                                  , o = n.stride
                                                  , h = a.offset;
                                                n && n.isInstancedInterleavedBuffer ? (m(r, n.meshPerAttribute),
                                                void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)) : f(r),
                                                e.bindBuffer(34962, l),
                                                v(r, i, c, t, o * u, h * u)
                                            } else
                                                a.isInstancedBufferAttribute ? (m(r, a.meshPerAttribute),
                                                void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)) : f(r),
                                                e.bindBuffer(34962, l),
                                                v(r, i, c, t, 0, 0)
                                        } else if ("instanceMatrix" === t) {
                                            const t = n.get(i.instanceMatrix);
                                            if (void 0 === t)
                                                continue;
                                            const a = t.buffer
                                              , o = t.type;
                                            m(r + 0, 1),
                                            m(r + 1, 1),
                                            m(r + 2, 1),
                                            m(r + 3, 1),
                                            e.bindBuffer(34962, a),
                                            e.vertexAttribPointer(r + 0, 4, o, !1, 64, 0),
                                            e.vertexAttribPointer(r + 1, 4, o, !1, 64, 16),
                                            e.vertexAttribPointer(r + 2, 4, o, !1, 64, 32),
                                            e.vertexAttribPointer(r + 3, 4, o, !1, 64, 48)
                                        } else if ("instanceColor" === t) {
                                            const t = n.get(i.instanceColor);
                                            if (void 0 === t)
                                                continue;
                                            const a = t.buffer
                                              , o = t.type;
                                            m(r, 1),
                                            e.bindBuffer(34962, a),
                                            e.vertexAttribPointer(r, 3, o, !1, 12, 0)
                                        } else if (void 0 !== u) {
                                            const n = u[t];
                                            if (void 0 !== n)
                                                switch (n.length) {
                                                case 2:
                                                    e.vertexAttrib2fv(r, n);
                                                    break;
                                                case 3:
                                                    e.vertexAttrib3fv(r, n);
                                                    break;
                                                case 4:
                                                    e.vertexAttrib4fv(r, n);
                                                    break;
                                                default:
                                                    e.vertexAttrib1fv(r, n)
                                                }
                                        }
                                    }
                                }
                                g()
                            }(i, l, h, y),
                            null !== _ && e.bindBuffer(34963, n.get(_).buffer))
                        },
                        reset: y,
                        resetDefaultState: _,
                        dispose: function() {
                            y();
                            for (const e in s) {
                                const t = s[e];
                                for (const e in t) {
                                    const n = t[e];
                                    for (const e in n)
                                        h(n[e].object),
                                        delete n[e];
                                    delete t[e]
                                }
                                delete s[e]
                            }
                        },
                        releaseStatesOfGeometry: function(e) {
                            if (void 0 === s[e.id])
                                return;
                            const t = s[e.id];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n)
                                    h(n[e].object),
                                    delete n[e];
                                delete t[e]
                            }
                            delete s[e.id]
                        },
                        releaseStatesOfProgram: function(e) {
                            for (const t in s) {
                                const n = s[t];
                                if (void 0 === n[e.id])
                                    continue;
                                const r = n[e.id];
                                for (const e in r)
                                    h(r[e].object),
                                    delete r[e];
                                delete n[e.id]
                            }
                        },
                        initAttributes: p,
                        enableAttribute: f,
                        disableUnusedAttributes: g
                    }
                }
                function Ia(e, t, n, r) {
                    const i = r.isWebGL2;
                    let a;
                    this.setMode = function(e) {
                        a = e
                    }
                    ,
                    this.render = function(t, r) {
                        e.drawArrays(a, t, r),
                        n.update(r, a, 1)
                    }
                    ,
                    this.renderInstances = function(r, o, s) {
                        if (0 === s)
                            return;
                        let l, c;
                        if (i)
                            l = e,
                            c = "drawArraysInstanced";
                        else if (l = t.get("ANGLE_instanced_arrays"),
                        c = "drawArraysInstancedANGLE",
                        null === l)
                            return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[c](a, r, o, s),
                        n.update(o, a, s)
                    }
                }
                function Na(e, t, n) {
                    let r;
                    function i(t) {
                        if ("highp" === t) {
                            if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                                return "highp";
                            t = "mediump"
                        }
                        return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                    }
                    const a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
                    let o = void 0 !== n.precision ? n.precision : "highp";
                    const s = i(o);
                    s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."),
                    o = s);
                    const l = !0 === n.logarithmicDepthBuffer
                      , c = e.getParameter(34930)
                      , u = e.getParameter(35660)
                      , h = e.getParameter(3379)
                      , d = e.getParameter(34076)
                      , p = e.getParameter(34921)
                      , f = e.getParameter(36347)
                      , m = e.getParameter(36348)
                      , g = e.getParameter(36349)
                      , v = u > 0
                      , y = a || !!t.get("OES_texture_float");
                    return {
                        isWebGL2: a,
                        getMaxAnisotropy: function() {
                            if (void 0 !== r)
                                return r;
                            const n = t.get("EXT_texture_filter_anisotropic");
                            return r = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
                            r
                        },
                        getMaxPrecision: i,
                        precision: o,
                        logarithmicDepthBuffer: l,
                        maxTextures: c,
                        maxVertexTextures: u,
                        maxTextureSize: h,
                        maxCubemapSize: d,
                        maxAttributes: p,
                        maxVertexUniforms: f,
                        maxVaryings: m,
                        maxFragmentUniforms: g,
                        vertexTextures: v,
                        floatFragmentTextures: y,
                        floatVertexTextures: v && y,
                        maxSamples: a ? e.getParameter(36183) : 0
                    }
                }
                function Ba(e) {
                    const t = this;
                    let n = null
                      , r = 0
                      , i = !1
                      , a = !1;
                    const o = new ei
                      , s = new Hn
                      , l = {
                        value: null,
                        needsUpdate: !1
                    };
                    function c() {
                        l.value !== n && (l.value = n,
                        l.needsUpdate = r > 0),
                        t.numPlanes = r,
                        t.numIntersection = 0
                    }
                    function u(e, n, r, i) {
                        const a = null !== e ? e.length : 0;
                        let c = null;
                        if (0 !== a) {
                            if (c = l.value,
                            !0 !== i || null === c) {
                                const t = r + 4 * a
                                  , i = n.matrixWorldInverse;
                                s.getNormalMatrix(i),
                                (null === c || c.length < t) && (c = new Float32Array(t));
                                for (let t = 0, n = r; t !== a; ++t,
                                n += 4)
                                    o.copy(e[t]).applyMatrix4(i, s),
                                    o.normal.toArray(c, n),
                                    c[n + 3] = o.constant
                            }
                            l.value = c,
                            l.needsUpdate = !0
                        }
                        return t.numPlanes = a,
                        t.numIntersection = 0,
                        c
                    }
                    this.uniform = l,
                    this.numPlanes = 0,
                    this.numIntersection = 0,
                    this.init = function(e, t, a) {
                        const o = 0 !== e.length || t || 0 !== r || i;
                        return i = t,
                        n = u(e, a, 0),
                        r = e.length,
                        o
                    }
                    ,
                    this.beginShadows = function() {
                        a = !0,
                        u(null)
                    }
                    ,
                    this.endShadows = function() {
                        a = !1,
                        c()
                    }
                    ,
                    this.setState = function(t, o, s) {
                        const h = t.clippingPlanes
                          , d = t.clipIntersection
                          , p = t.clipShadows
                          , f = e.get(t);
                        if (!i || null === h || 0 === h.length || a && !p)
                            a ? u(null) : c();
                        else {
                            const e = a ? 0 : r
                              , t = 4 * e;
                            let i = f.clippingState || null;
                            l.value = i,
                            i = u(h, o, t, s);
                            for (let e = 0; e !== t; ++e)
                                i[e] = n[e];
                            f.clippingState = i,
                            this.numIntersection = d ? this.numPlanes : 0,
                            this.numPlanes += e
                        }
                    }
                }
                function ka(e) {
                    let t = new WeakMap;
                    function n(e, t) {
                        return t === se ? e.mapping = ae : t === le && (e.mapping = oe),
                        e
                    }
                    function r(e) {
                        const n = e.target;
                        n.removeEventListener("dispose", r);
                        const i = t.get(n);
                        void 0 !== i && (t.delete(n),
                        i.dispose())
                    }
                    return {
                        get: function(i) {
                            if (i && i.isTexture) {
                                const a = i.mapping;
                                if (a === se || a === le) {
                                    if (t.has(i))
                                        return n(t.get(i).texture, i.mapping);
                                    {
                                        const a = i.image;
                                        if (a && a.height > 0) {
                                            const o = e.getRenderList()
                                              , s = e.getRenderTarget()
                                              , l = new wa(a.height / 2);
                                            return l.fromEquirectangularTexture(e, i),
                                            t.set(i, l),
                                            e.setRenderTarget(s),
                                            e.setRenderList(o),
                                            i.addEventListener("dispose", r),
                                            n(l.texture, i.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return i
                        },
                        dispose: function() {
                            t = new WeakMap
                        }
                    }
                }
                function za(e) {
                    const t = {};
                    function n(n) {
                        if (void 0 !== t[n])
                            return t[n];
                        let r;
                        switch (n) {
                        case "WEBGL_depth_texture":
                            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                        }
                        return t[n] = r,
                        r
                    }
                    return {
                        has: function(e) {
                            return null !== n(e)
                        },
                        init: function(e) {
                            e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                            n("OES_texture_float"),
                            n("OES_texture_half_float"),
                            n("OES_texture_half_float_linear"),
                            n("OES_standard_derivatives"),
                            n("OES_element_index_uint"),
                            n("OES_vertex_array_object"),
                            n("ANGLE_instanced_arrays")),
                            n("OES_texture_float_linear"),
                            n("EXT_color_buffer_half_float")
                        },
                        get: function(e) {
                            const t = n(e);
                            return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                            t
                        }
                    }
                }
                function Ua(e, t, n, r) {
                    const i = {}
                      , a = new WeakMap;
                    function o(e) {
                        const s = e.target;
                        null !== s.index && t.remove(s.index);
                        for (const e in s.attributes)
                            t.remove(s.attributes[e]);
                        s.removeEventListener("dispose", o),
                        delete i[s.id];
                        const l = a.get(s);
                        l && (t.remove(l),
                        a.delete(s)),
                        r.releaseStatesOfGeometry(s),
                        !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
                        n.memory.geometries--
                    }
                    function s(e) {
                        const n = []
                          , r = e.index
                          , i = e.attributes.position;
                        let o = 0;
                        if (null !== r) {
                            const e = r.array;
                            o = r.version;
                            for (let t = 0, r = e.length; t < r; t += 3) {
                                const r = e[t + 0]
                                  , i = e[t + 1]
                                  , a = e[t + 2];
                                n.push(r, i, i, a, a, r)
                            }
                        } else {
                            const e = i.array;
                            o = i.version;
                            for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                                const e = t + 0
                                  , r = t + 1
                                  , i = t + 2;
                                n.push(e, r, r, i, i, e)
                            }
                        }
                        const s = new (Ni(n) > 65535 ? Di : Ri)(n,1);
                        s.version = o;
                        const l = a.get(e);
                        l && t.remove(l),
                        a.set(e, s)
                    }
                    return {
                        get: function(e, t) {
                            return !0 === i[t.id] || (t.addEventListener("dispose", o),
                            i[t.id] = !0,
                            n.memory.geometries++),
                            t
                        },
                        update: function(e) {
                            const n = e.attributes;
                            for (const e in n)
                                t.update(n[e], 34962);
                            const r = e.morphAttributes;
                            for (const e in r) {
                                const n = r[e];
                                for (let e = 0, r = n.length; e < r; e++)
                                    t.update(n[e], 34962)
                            }
                        },
                        getWireframeAttribute: function(e) {
                            const t = a.get(e);
                            if (t) {
                                const n = e.index;
                                null !== n && t.version < n.version && s(e)
                            } else
                                s(e);
                            return a.get(e)
                        }
                    }
                }
                function Ha(e, t, n, r) {
                    const i = r.isWebGL2;
                    let a, o, s;
                    this.setMode = function(e) {
                        a = e
                    }
                    ,
                    this.setIndex = function(e) {
                        o = e.type,
                        s = e.bytesPerElement
                    }
                    ,
                    this.render = function(t, r) {
                        e.drawElements(a, r, o, t * s),
                        n.update(r, a, 1)
                    }
                    ,
                    this.renderInstances = function(r, l, c) {
                        if (0 === c)
                            return;
                        let u, h;
                        if (i)
                            u = e,
                            h = "drawElementsInstanced";
                        else if (u = t.get("ANGLE_instanced_arrays"),
                        h = "drawElementsInstancedANGLE",
                        null === u)
                            return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        u[h](a, l, o, r * s, c),
                        n.update(l, a, c)
                    }
                }
                function Ga(e) {
                    const t = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    return {
                        memory: {
                            geometries: 0,
                            textures: 0
                        },
                        render: t,
                        programs: null,
                        autoReset: !0,
                        reset: function() {
                            t.frame++,
                            t.calls = 0,
                            t.triangles = 0,
                            t.points = 0,
                            t.lines = 0
                        },
                        update: function(e, n, r) {
                            switch (t.calls++,
                            n) {
                            case 4:
                                t.triangles += r * (e / 3);
                                break;
                            case 1:
                                t.lines += r * (e / 2);
                                break;
                            case 3:
                                t.lines += r * (e - 1);
                                break;
                            case 2:
                                t.lines += r * e;
                                break;
                            case 0:
                                t.points += r * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                            }
                        }
                    }
                }
                function ja(e, t) {
                    return e[0] - t[0]
                }
                function Va(e, t) {
                    return Math.abs(t[1]) - Math.abs(e[1])
                }
                function Wa(e) {
                    const t = {}
                      , n = new Float32Array(8)
                      , r = [];
                    for (let e = 0; e < 8; e++)
                        r[e] = [e, 0];
                    return {
                        update: function(i, a, o, s) {
                            const l = i.morphTargetInfluences
                              , c = void 0 === l ? 0 : l.length;
                            let u = t[a.id];
                            if (void 0 === u) {
                                u = [];
                                for (let e = 0; e < c; e++)
                                    u[e] = [e, 0];
                                t[a.id] = u
                            }
                            for (let e = 0; e < c; e++) {
                                const t = u[e];
                                t[0] = e,
                                t[1] = l[e]
                            }
                            u.sort(Va);
                            for (let e = 0; e < 8; e++)
                                e < c && u[e][1] ? (r[e][0] = u[e][0],
                                r[e][1] = u[e][1]) : (r[e][0] = Number.MAX_SAFE_INTEGER,
                                r[e][1] = 0);
                            r.sort(ja);
                            const h = o.morphTargets && a.morphAttributes.position
                              , d = o.morphNormals && a.morphAttributes.normal;
                            let p = 0;
                            for (let e = 0; e < 8; e++) {
                                const t = r[e]
                                  , i = t[0]
                                  , o = t[1];
                                i !== Number.MAX_SAFE_INTEGER && o ? (h && a.getAttribute("morphTarget" + e) !== h[i] && a.setAttribute("morphTarget" + e, h[i]),
                                d && a.getAttribute("morphNormal" + e) !== d[i] && a.setAttribute("morphNormal" + e, d[i]),
                                n[e] = o,
                                p += o) : (h && !0 === a.hasAttribute("morphTarget" + e) && a.deleteAttribute("morphTarget" + e),
                                d && !0 === a.hasAttribute("morphNormal" + e) && a.deleteAttribute("morphNormal" + e),
                                n[e] = 0)
                            }
                            const f = a.morphTargetsRelative ? 1 : 1 - p;
                            s.getUniforms().setValue(e, "morphTargetBaseInfluence", f),
                            s.getUniforms().setValue(e, "morphTargetInfluences", n)
                        }
                    }
                }
                function qa(e, t, n, r) {
                    let i = new WeakMap;
                    function a(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", a),
                        n.remove(t.instanceMatrix),
                        null !== t.instanceColor && n.remove(t.instanceColor)
                    }
                    return {
                        update: function(e) {
                            const o = r.render.frame
                              , s = e.geometry
                              , l = t.get(e, s);
                            return i.get(l) !== o && (t.update(l),
                            i.set(l, o)),
                            e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a),
                            n.update(e.instanceMatrix, 34962),
                            null !== e.instanceColor && n.update(e.instanceColor, 34962)),
                            l
                        },
                        dispose: function() {
                            i = new WeakMap
                        }
                    }
                }
                function Xa(e=null, t=1, n=1, r=1) {
                    Wn.call(this, null),
                    this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    },
                    this.magFilter = fe,
                    this.minFilter = fe,
                    this.wrapR = de,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.needsUpdate = !0
                }
                function Ya(e=null, t=1, n=1, r=1) {
                    Wn.call(this, null),
                    this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    },
                    this.magFilter = fe,
                    this.minFilter = fe,
                    this.wrapR = de,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.needsUpdate = !0
                }
                Da.physical = {
                    uniforms: fa([Da.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatNormalScale: {
                            value: new Un(1,1)
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        sheen: {
                            value: new yi(0)
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        }
                    }]),
                    vertexShader: Ra.meshphysical_vert,
                    fragmentShader: Ra.meshphysical_frag
                },
                Xa.prototype = Object.create(Wn.prototype),
                Xa.prototype.constructor = Xa,
                Xa.prototype.isDataTexture2DArray = !0,
                Ya.prototype = Object.create(Wn.prototype),
                Ya.prototype.constructor = Ya,
                Ya.prototype.isDataTexture3D = !0;
                const Za = new Wn
                  , Ja = new Xa
                  , Ka = new Ya
                  , Qa = new ba
                  , $a = []
                  , eo = []
                  , to = new Float32Array(16)
                  , no = new Float32Array(9)
                  , ro = new Float32Array(4);
                function io(e, t, n) {
                    const r = e[0];
                    if (r <= 0 || r > 0)
                        return e;
                    const i = t * n;
                    let a = $a[i];
                    if (void 0 === a && (a = new Float32Array(i),
                    $a[i] = a),
                    0 !== t) {
                        r.toArray(a, 0);
                        for (let r = 1, i = 0; r !== t; ++r)
                            i += n,
                            e[r].toArray(a, i)
                    }
                    return a
                }
                function ao(e, t) {
                    if (e.length !== t.length)
                        return !1;
                    for (let n = 0, r = e.length; n < r; n++)
                        if (e[n] !== t[n])
                            return !1;
                    return !0
                }
                function oo(e, t) {
                    for (let n = 0, r = t.length; n < r; n++)
                        e[n] = t[n]
                }
                function so(e, t) {
                    let n = eo[t];
                    void 0 === n && (n = new Int32Array(t),
                    eo[t] = n);
                    for (let r = 0; r !== t; ++r)
                        n[r] = e.allocateTextureUnit();
                    return n
                }
                function lo(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1f(this.addr, t),
                    n[0] = t)
                }
                function co(e, t) {
                    const n = this.cache;
                    if (void 0 !== t.x)
                        n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                        n[0] = t.x,
                        n[1] = t.y);
                    else {
                        if (ao(n, t))
                            return;
                        e.uniform2fv(this.addr, t),
                        oo(n, t)
                    }
                }
                function uo(e, t) {
                    const n = this.cache;
                    if (void 0 !== t.x)
                        n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z);
                    else if (void 0 !== t.r)
                        n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                        n[0] = t.r,
                        n[1] = t.g,
                        n[2] = t.b);
                    else {
                        if (ao(n, t))
                            return;
                        e.uniform3fv(this.addr, t),
                        oo(n, t)
                    }
                }
                function ho(e, t) {
                    const n = this.cache;
                    if (void 0 !== t.x)
                        n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                        n[0] = t.x,
                        n[1] = t.y,
                        n[2] = t.z,
                        n[3] = t.w);
                    else {
                        if (ao(n, t))
                            return;
                        e.uniform4fv(this.addr, t),
                        oo(n, t)
                    }
                }
                function po(e, t) {
                    const n = this.cache
                      , r = t.elements;
                    if (void 0 === r) {
                        if (ao(n, t))
                            return;
                        e.uniformMatrix2fv(this.addr, !1, t),
                        oo(n, t)
                    } else {
                        if (ao(n, r))
                            return;
                        ro.set(r),
                        e.uniformMatrix2fv(this.addr, !1, ro),
                        oo(n, r)
                    }
                }
                function fo(e, t) {
                    const n = this.cache
                      , r = t.elements;
                    if (void 0 === r) {
                        if (ao(n, t))
                            return;
                        e.uniformMatrix3fv(this.addr, !1, t),
                        oo(n, t)
                    } else {
                        if (ao(n, r))
                            return;
                        no.set(r),
                        e.uniformMatrix3fv(this.addr, !1, no),
                        oo(n, r)
                    }
                }
                function mo(e, t) {
                    const n = this.cache
                      , r = t.elements;
                    if (void 0 === r) {
                        if (ao(n, t))
                            return;
                        e.uniformMatrix4fv(this.addr, !1, t),
                        oo(n, t)
                    } else {
                        if (ao(n, r))
                            return;
                        to.set(r),
                        e.uniformMatrix4fv(this.addr, !1, to),
                        oo(n, r)
                    }
                }
                function go(e, t, n) {
                    const r = this.cache
                      , i = n.allocateTextureUnit();
                    r[0] !== i && (e.uniform1i(this.addr, i),
                    r[0] = i),
                    n.safeSetTexture2D(t || Za, i)
                }
                function vo(e, t, n) {
                    const r = this.cache
                      , i = n.allocateTextureUnit();
                    r[0] !== i && (e.uniform1i(this.addr, i),
                    r[0] = i),
                    n.setTexture2DArray(t || Ja, i)
                }
                function yo(e, t, n) {
                    const r = this.cache
                      , i = n.allocateTextureUnit();
                    r[0] !== i && (e.uniform1i(this.addr, i),
                    r[0] = i),
                    n.setTexture3D(t || Ka, i)
                }
                function _o(e, t, n) {
                    const r = this.cache
                      , i = n.allocateTextureUnit();
                    r[0] !== i && (e.uniform1i(this.addr, i),
                    r[0] = i),
                    n.safeSetTextureCube(t || Qa, i)
                }
                function xo(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1i(this.addr, t),
                    n[0] = t)
                }
                function bo(e, t) {
                    const n = this.cache;
                    ao(n, t) || (e.uniform2iv(this.addr, t),
                    oo(n, t))
                }
                function wo(e, t) {
                    const n = this.cache;
                    ao(n, t) || (e.uniform3iv(this.addr, t),
                    oo(n, t))
                }
                function Mo(e, t) {
                    const n = this.cache;
                    ao(n, t) || (e.uniform4iv(this.addr, t),
                    oo(n, t))
                }
                function So(e, t) {
                    const n = this.cache;
                    n[0] !== t && (e.uniform1ui(this.addr, t),
                    n[0] = t)
                }
                function To(e, t) {
                    e.uniform1fv(this.addr, t)
                }
                function Eo(e, t) {
                    e.uniform1iv(this.addr, t)
                }
                function Ao(e, t) {
                    e.uniform2iv(this.addr, t)
                }
                function Co(e, t) {
                    e.uniform3iv(this.addr, t)
                }
                function Po(e, t) {
                    e.uniform4iv(this.addr, t)
                }
                function Ro(e, t) {
                    const n = io(t, this.size, 2);
                    e.uniform2fv(this.addr, n)
                }
                function Lo(e, t) {
                    const n = io(t, this.size, 3);
                    e.uniform3fv(this.addr, n)
                }
                function Do(e, t) {
                    const n = io(t, this.size, 4);
                    e.uniform4fv(this.addr, n)
                }
                function Oo(e, t) {
                    const n = io(t, this.size, 4);
                    e.uniformMatrix2fv(this.addr, !1, n)
                }
                function Fo(e, t) {
                    const n = io(t, this.size, 9);
                    e.uniformMatrix3fv(this.addr, !1, n)
                }
                function Io(e, t) {
                    const n = io(t, this.size, 16);
                    e.uniformMatrix4fv(this.addr, !1, n)
                }
                function No(e, t, n) {
                    const r = t.length
                      , i = so(n, r);
                    e.uniform1iv(this.addr, i);
                    for (let e = 0; e !== r; ++e)
                        n.safeSetTexture2D(t[e] || Za, i[e])
                }
                function Bo(e, t, n) {
                    const r = t.length
                      , i = so(n, r);
                    e.uniform1iv(this.addr, i);
                    for (let e = 0; e !== r; ++e)
                        n.safeSetTextureCube(t[e] || Qa, i[e])
                }
                function ko(e, t, n) {
                    this.id = e,
                    this.addr = n,
                    this.cache = [],
                    this.setValue = function(e) {
                        switch (e) {
                        case 5126:
                            return lo;
                        case 35664:
                            return co;
                        case 35665:
                            return uo;
                        case 35666:
                            return ho;
                        case 35674:
                            return po;
                        case 35675:
                            return fo;
                        case 35676:
                            return mo;
                        case 5124:
                        case 35670:
                            return xo;
                        case 35667:
                        case 35671:
                            return bo;
                        case 35668:
                        case 35672:
                            return wo;
                        case 35669:
                        case 35673:
                            return Mo;
                        case 5125:
                            return So;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return go;
                        case 35679:
                        case 36299:
                        case 36307:
                            return yo;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return _o;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return vo
                        }
                    }(t.type)
                }
                function zo(e, t, n) {
                    this.id = e,
                    this.addr = n,
                    this.cache = [],
                    this.size = t.size,
                    this.setValue = function(e) {
                        switch (e) {
                        case 5126:
                            return To;
                        case 35664:
                            return Ro;
                        case 35665:
                            return Lo;
                        case 35666:
                            return Do;
                        case 35674:
                            return Oo;
                        case 35675:
                            return Fo;
                        case 35676:
                            return Io;
                        case 5124:
                        case 35670:
                            return Eo;
                        case 35667:
                        case 35671:
                            return Ao;
                        case 35668:
                        case 35672:
                            return Co;
                        case 35669:
                        case 35673:
                            return Po;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return No;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Bo
                        }
                    }(t.type)
                }
                function Uo(e) {
                    this.id = e,
                    this.seq = [],
                    this.map = {}
                }
                zo.prototype.updateCache = function(e) {
                    const t = this.cache;
                    e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
                    oo(t, e)
                }
                ,
                Uo.prototype.setValue = function(e, t, n) {
                    const r = this.seq;
                    for (let i = 0, a = r.length; i !== a; ++i) {
                        const a = r[i];
                        a.setValue(e, t[a.id], n)
                    }
                }
                ;
                const Ho = /(\w+)(\])?(\[|\.)?/g;
                function Go(e, t) {
                    e.seq.push(t),
                    e.map[t.id] = t
                }
                function jo(e, t, n) {
                    const r = e.name
                      , i = r.length;
                    for (Ho.lastIndex = 0; ; ) {
                        const a = Ho.exec(r)
                          , o = Ho.lastIndex;
                        let s = a[1];
                        const l = "]" === a[2]
                          , c = a[3];
                        if (l && (s |= 0),
                        void 0 === c || "[" === c && o + 2 === i) {
                            Go(n, void 0 === c ? new ko(s,e,t) : new zo(s,e,t));
                            break
                        }
                        {
                            let e = n.map[s];
                            void 0 === e && (e = new Uo(s),
                            Go(n, e)),
                            n = e
                        }
                    }
                }
                function Vo(e, t) {
                    this.seq = [],
                    this.map = {};
                    const n = e.getProgramParameter(t, 35718);
                    for (let r = 0; r < n; ++r) {
                        const n = e.getActiveUniform(t, r);
                        jo(n, e.getUniformLocation(t, n.name), this)
                    }
                }
                function Wo(e, t, n) {
                    const r = e.createShader(t);
                    return e.shaderSource(r, n),
                    e.compileShader(r),
                    r
                }
                Vo.prototype.setValue = function(e, t, n, r) {
                    const i = this.map[t];
                    void 0 !== i && i.setValue(e, n, r)
                }
                ,
                Vo.prototype.setOptional = function(e, t, n) {
                    const r = t[n];
                    void 0 !== r && this.setValue(e, n, r)
                }
                ,
                Vo.upload = function(e, t, n, r) {
                    for (let i = 0, a = t.length; i !== a; ++i) {
                        const a = t[i]
                          , o = n[a.id];
                        !1 !== o.needsUpdate && a.setValue(e, o.value, r)
                    }
                }
                ,
                Vo.seqWithValue = function(e, t) {
                    const n = [];
                    for (let r = 0, i = e.length; r !== i; ++r) {
                        const i = e[r];
                        i.id in t && n.push(i)
                    }
                    return n
                }
                ;
                let qo = 0;
                function Xo(e) {
                    switch (e) {
                    case Jt:
                        return ["Linear", "( value )"];
                    case Kt:
                        return ["sRGB", "( value )"];
                    case $t:
                        return ["RGBE", "( value )"];
                    case tn:
                        return ["RGBM", "( value, 7.0 )"];
                    case nn:
                        return ["RGBM", "( value, 16.0 )"];
                    case rn:
                        return ["RGBD", "( value, 256.0 )"];
                    case Qt:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case en:
                        return ["LogLuv", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
                        ["Linear", "( value )"]
                    }
                }
                function Yo(e, t, n) {
                    const r = e.getShaderParameter(t, 35713)
                      , i = e.getShaderInfoLog(t).trim();
                    return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(e) {
                        const t = e.split("\n");
                        for (let e = 0; e < t.length; e++)
                            t[e] = e + 1 + ": " + t[e];
                        return t.join("\n")
                    }(e.getShaderSource(t))
                }
                function Zo(e, t) {
                    const n = Xo(t);
                    return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
                }
                function Jo(e, t) {
                    const n = Xo(t);
                    return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                }
                function Ko(e, t) {
                    let n;
                    switch (t) {
                    case $:
                        n = "Linear";
                        break;
                    case ee:
                        n = "Reinhard";
                        break;
                    case te:
                        n = "OptimizedCineon";
                        break;
                    case ne:
                        n = "ACESFilmic";
                        break;
                    case re:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                        n = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }
                function Qo(e) {
                    return "" !== e
                }
                function $o(e, t) {
                    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
                }
                function es(e, t) {
                    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
                }
                const ts = /^[ \t]*#include +<([\w\d./]+)>/gm;
                function ns(e) {
                    return e.replace(ts, rs)
                }
                function rs(e, t) {
                    const n = Ra[t];
                    if (void 0 === n)
                        throw new Error("Can not resolve #include <" + t + ">");
                    return ns(n)
                }
                const is = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
                  , as = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                function os(e) {
                    return e.replace(as, ls).replace(is, ss)
                }
                function ss(e, t, n, r) {
                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
                    ls(0, t, n, r)
                }
                function ls(e, t, n, r) {
                    let i = "";
                    for (let e = parseInt(t); e < parseInt(n); e++)
                        i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                    return i
                }
                function cs(e) {
                    let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                    return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
                    t
                }
                function us(e, t, n, r) {
                    const i = e.getContext()
                      , a = n.defines;
                    let o = n.vertexShader
                      , s = n.fragmentShader;
                    const l = function(e) {
                        let t = "SHADOWMAP_TYPE_BASIC";
                        return e.shadowMapType === h ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === d ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === p && (t = "SHADOWMAP_TYPE_VSM"),
                        t
                    }(n)
                      , c = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap)
                            switch (e.envMapMode) {
                            case ae:
                            case oe:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case ce:
                            case ue:
                                t = "ENVMAP_TYPE_CUBE_UV"
                            }
                        return t
                    }(n)
                      , u = function(e) {
                        let t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap)
                            switch (e.envMapMode) {
                            case oe:
                            case ue:
                                t = "ENVMAP_MODE_REFRACTION"
                            }
                        return t
                    }(n)
                      , f = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap)
                            switch (e.combine) {
                            case Z:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case J:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case K:
                                t = "ENVMAP_BLENDING_ADD"
                            }
                        return t
                    }(n)
                      , m = e.gammaFactor > 0 ? e.gammaFactor : 1
                      , g = n.isWebGL2 ? "" : function(e) {
                        return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qo).join("\n")
                    }(n)
                      , v = function(e) {
                        const t = [];
                        for (const n in e) {
                            const r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(a)
                      , y = i.createProgram();
                    let _, x, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (_ = [v].filter(Qo).join("\n"),
                    _.length > 0 && (_ += "\n"),
                    x = [g, v].filter(Qo).join("\n"),
                    x.length > 0 && (x += "\n")) : (_ = [cs(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qo).join("\n"),
                    x = [g, cs(n), "#define SHADER_NAME " + n.shaderName, v, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Q ? "#define TONE_MAPPING" : "", n.toneMapping !== Q ? Ra.tonemapping_pars_fragment : "", n.toneMapping !== Q ? Ko("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Ra.encodings_pars_fragment, n.map ? Zo("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Zo("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Zo("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Zo("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Zo("lightMapTexelToLinear", n.lightMapEncoding) : "", Jo("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Qo).join("\n")),
                    o = ns(o),
                    o = $o(o, n),
                    o = es(o, n),
                    s = ns(s),
                    s = $o(s, n),
                    s = es(s, n),
                    o = os(o),
                    s = os(s),
                    n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n",
                    _ = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + _,
                    x = ["#define varying in", n.glslVersion === In ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === In ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
                    const w = b + x + s
                      , M = Wo(i, 35633, b + _ + o)
                      , S = Wo(i, 35632, w);
                    if (i.attachShader(y, M),
                    i.attachShader(y, S),
                    void 0 !== n.index0AttributeName ? i.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(y, 0, "position"),
                    i.linkProgram(y),
                    e.debug.checkShaderErrors) {
                        const e = i.getProgramInfoLog(y).trim()
                          , t = i.getShaderInfoLog(M).trim()
                          , n = i.getShaderInfoLog(S).trim();
                        let r = !0
                          , a = !0;
                        if (!1 === i.getProgramParameter(y, 35714)) {
                            r = !1;
                            const t = Yo(i, M, "vertex")
                              , n = Yo(i, S, "fragment");
                            console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(y, 35715), "gl.getProgramInfoLog", e, t, n)
                        } else
                            "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== t && "" !== n || (a = !1);
                        a && (this.diagnostics = {
                            runnable: r,
                            programLog: e,
                            vertexShader: {
                                log: t,
                                prefix: _
                            },
                            fragmentShader: {
                                log: n,
                                prefix: x
                            }
                        })
                    }
                    let T, E;
                    return i.deleteShader(M),
                    i.deleteShader(S),
                    this.getUniforms = function() {
                        return void 0 === T && (T = new Vo(i,y)),
                        T
                    }
                    ,
                    this.getAttributes = function() {
                        return void 0 === E && (E = function(e, t) {
                            const n = {}
                              , r = e.getProgramParameter(t, 35721);
                            for (let i = 0; i < r; i++) {
                                const r = e.getActiveAttrib(t, i).name;
                                n[r] = e.getAttribLocation(t, r)
                            }
                            return n
                        }(i, y)),
                        E
                    }
                    ,
                    this.destroy = function() {
                        r.releaseStatesOfProgram(this),
                        i.deleteProgram(y),
                        this.program = void 0
                    }
                    ,
                    this.name = n.shaderName,
                    this.id = qo++,
                    this.cacheKey = t,
                    this.usedTimes = 1,
                    this.program = y,
                    this.vertexShader = M,
                    this.fragmentShader = S,
                    this
                }
                function hs(e, t, n, r, i, a) {
                    const o = []
                      , s = r.isWebGL2
                      , l = r.logarithmicDepthBuffer
                      , c = r.floatVertexTextures
                      , u = r.maxVertexUniforms
                      , h = r.vertexTextures;
                    let d = r.precision;
                    const p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    }
                      , f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
                    function v(e) {
                        let t;
                        return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                        t = e.texture.encoding) : t = Jt,
                        t
                    }
                    return {
                        getParameters: function(i, o, f, y, _) {
                            const x = y.fog
                              , b = i.isMeshStandardMaterial ? y.environment : null
                              , w = t.get(i.envMap || b)
                              , M = p[i.type]
                              , S = _.isSkinnedMesh ? function(e) {
                                const t = e.skeleton.bones;
                                if (c)
                                    return 1024;
                                {
                                    const e = u
                                      , n = Math.floor((e - 20) / 4)
                                      , r = Math.min(n, t.length);
                                    return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."),
                                    0) : r
                                }
                            }(_) : 0;
                            let T, E;
                            if (null !== i.precision && (d = r.getMaxPrecision(i.precision),
                            d !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", d, "instead.")),
                            M) {
                                const e = Da[M];
                                T = e.vertexShader,
                                E = e.fragmentShader
                            } else
                                T = i.vertexShader,
                                E = i.fragmentShader;
                            const A = e.getRenderTarget();
                            return {
                                isWebGL2: s,
                                shaderID: M,
                                shaderName: i.type,
                                vertexShader: T,
                                fragmentShader: E,
                                defines: i.defines,
                                isRawShaderMaterial: !0 === i.isRawShaderMaterial,
                                glslVersion: i.glslVersion,
                                precision: d,
                                instancing: !0 === _.isInstancedMesh,
                                instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                                supportsVertexTextures: h,
                                outputEncoding: null !== A ? v(A.texture) : e.outputEncoding,
                                map: !!i.map,
                                mapEncoding: v(i.map),
                                matcap: !!i.matcap,
                                matcapEncoding: v(i.matcap),
                                envMap: !!w,
                                envMapMode: w && w.mapping,
                                envMapEncoding: v(w),
                                envMapCubeUV: !!w && (w.mapping === ce || w.mapping === ue),
                                lightMap: !!i.lightMap,
                                lightMapEncoding: v(i.lightMap),
                                aoMap: !!i.aoMap,
                                emissiveMap: !!i.emissiveMap,
                                emissiveMapEncoding: v(i.emissiveMap),
                                bumpMap: !!i.bumpMap,
                                normalMap: !!i.normalMap,
                                objectSpaceNormalMap: i.normalMapType === ln,
                                tangentSpaceNormalMap: i.normalMapType === sn,
                                clearcoatMap: !!i.clearcoatMap,
                                clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                                clearcoatNormalMap: !!i.clearcoatNormalMap,
                                displacementMap: !!i.displacementMap,
                                roughnessMap: !!i.roughnessMap,
                                metalnessMap: !!i.metalnessMap,
                                specularMap: !!i.specularMap,
                                alphaMap: !!i.alphaMap,
                                gradientMap: !!i.gradientMap,
                                sheen: !!i.sheen,
                                transmissionMap: !!i.transmissionMap,
                                combine: i.combine,
                                vertexTangents: i.normalMap && i.vertexTangents,
                                vertexColors: i.vertexColors,
                                vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap),
                                uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap),
                                fog: !!x,
                                useFog: i.fog,
                                fogExp2: x && x.isFogExp2,
                                flatShading: i.flatShading,
                                sizeAttenuation: i.sizeAttenuation,
                                logarithmicDepthBuffer: l,
                                skinning: i.skinning && S > 0,
                                maxBones: S,
                                useVertexTexture: c,
                                morphTargets: i.morphTargets,
                                morphNormals: i.morphNormals,
                                maxMorphTargets: e.maxMorphTargets,
                                maxMorphNormals: e.maxMorphNormals,
                                numDirLights: o.directional.length,
                                numPointLights: o.point.length,
                                numSpotLights: o.spot.length,
                                numRectAreaLights: o.rectArea.length,
                                numHemiLights: o.hemi.length,
                                numDirLightShadows: o.directionalShadowMap.length,
                                numPointLightShadows: o.pointShadowMap.length,
                                numSpotLightShadows: o.spotShadowMap.length,
                                numClippingPlanes: a.numPlanes,
                                numClipIntersection: a.numIntersection,
                                dithering: i.dithering,
                                shadowMapEnabled: e.shadowMap.enabled && f.length > 0,
                                shadowMapType: e.shadowMap.type,
                                toneMapping: i.toneMapped ? e.toneMapping : Q,
                                physicallyCorrectLights: e.physicallyCorrectLights,
                                premultipliedAlpha: i.premultipliedAlpha,
                                alphaTest: i.alphaTest,
                                doubleSided: i.side === g,
                                flipSided: i.side === m,
                                depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                                index0AttributeName: i.index0AttributeName,
                                extensionDerivatives: i.extensions && i.extensions.derivatives,
                                extensionFragDepth: i.extensions && i.extensions.fragDepth,
                                extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                                extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth: s || n.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers: s || n.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod: s || n.has("EXT_shader_texture_lod"),
                                customProgramCacheKey: i.customProgramCacheKey()
                            }
                        },
                        getProgramCacheKey: function(t) {
                            const n = [];
                            if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader),
                            n.push(t.vertexShader)),
                            void 0 !== t.defines)
                                for (const e in t.defines)
                                    n.push(e),
                                    n.push(t.defines[e]);
                            if (!1 === t.isRawShaderMaterial) {
                                for (let e = 0; e < f.length; e++)
                                    n.push(t[f[e]]);
                                n.push(e.outputEncoding),
                                n.push(e.gammaFactor)
                            }
                            return n.push(t.customProgramCacheKey),
                            n.join()
                        },
                        getUniforms: function(e) {
                            const t = p[e.type];
                            let n;
                            if (t) {
                                const e = Da[t];
                                n = ma.clone(e.uniforms)
                            } else
                                n = e.uniforms;
                            return n
                        },
                        acquireProgram: function(t, n) {
                            let r;
                            for (let e = 0, t = o.length; e < t; e++) {
                                const t = o[e];
                                if (t.cacheKey === n) {
                                    r = t,
                                    ++r.usedTimes;
                                    break
                                }
                            }
                            return void 0 === r && (r = new us(e,n,t,i),
                            o.push(r)),
                            r
                        },
                        releaseProgram: function(e) {
                            if (0 == --e.usedTimes) {
                                const t = o.indexOf(e);
                                o[t] = o[o.length - 1],
                                o.pop(),
                                e.destroy()
                            }
                        },
                        programs: o
                    }
                }
                function ds() {
                    let e = new WeakMap;
                    return {
                        get: function(t) {
                            let n = e.get(t);
                            return void 0 === n && (n = {},
                            e.set(t, n)),
                            n
                        },
                        remove: function(t) {
                            e.delete(t)
                        },
                        update: function(t, n, r) {
                            e.get(t)[n] = r
                        },
                        dispose: function() {
                            e = new WeakMap
                        }
                    }
                }
                function ps(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                }
                function fs(e, t) {
                    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                }
                function ms(e) {
                    const t = [];
                    let n = 0;
                    const r = []
                      , i = []
                      , a = {
                        id: -1
                    };
                    function o(r, i, o, s, l, c) {
                        let u = t[n];
                        const h = e.get(o);
                        return void 0 === u ? (u = {
                            id: r.id,
                            object: r,
                            geometry: i,
                            material: o,
                            program: h.program || a,
                            groupOrder: s,
                            renderOrder: r.renderOrder,
                            z: l,
                            group: c
                        },
                        t[n] = u) : (u.id = r.id,
                        u.object = r,
                        u.geometry = i,
                        u.material = o,
                        u.program = h.program || a,
                        u.groupOrder = s,
                        u.renderOrder = r.renderOrder,
                        u.z = l,
                        u.group = c),
                        n++,
                        u
                    }
                    return {
                        opaque: r,
                        transparent: i,
                        init: function() {
                            n = 0,
                            r.length = 0,
                            i.length = 0
                        },
                        push: function(e, t, n, a, s, l) {
                            const c = o(e, t, n, a, s, l);
                            (!0 === n.transparent ? i : r).push(c)
                        },
                        unshift: function(e, t, n, a, s, l) {
                            const c = o(e, t, n, a, s, l);
                            (!0 === n.transparent ? i : r).unshift(c)
                        },
                        finish: function() {
                            for (let e = n, r = t.length; e < r; e++) {
                                const n = t[e];
                                if (null === n.id)
                                    break;
                                n.id = null,
                                n.object = null,
                                n.geometry = null,
                                n.material = null,
                                n.program = null,
                                n.group = null
                            }
                        },
                        sort: function(e, t) {
                            r.length > 1 && r.sort(e || ps),
                            i.length > 1 && i.sort(t || fs)
                        }
                    }
                }
                function gs(e) {
                    let t = new WeakMap;
                    return {
                        get: function(n, r) {
                            const i = t.get(n);
                            let a;
                            return void 0 === i ? (a = new ms(e),
                            t.set(n, new WeakMap),
                            t.get(n).set(r, a)) : (a = i.get(r),
                            void 0 === a && (a = new ms(e),
                            i.set(r, a))),
                            a
                        },
                        dispose: function() {
                            t = new WeakMap
                        }
                    }
                }
                function vs() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (void 0 !== e[t.id])
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Kn,
                                    color: new yi
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Kn,
                                    direction: new Kn,
                                    color: new yi,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Kn,
                                    color: new yi,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Kn,
                                    skyColor: new yi,
                                    groundColor: new yi
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new yi,
                                    position: new Kn,
                                    halfWidth: new Kn,
                                    halfHeight: new Kn
                                }
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }
                let ys = 0;
                function _s(e, t) {
                    return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
                }
                function xs(e, t) {
                    const n = new vs
                      , r = function() {
                        const e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id])
                                    return e[t.id];
                                let n;
                                switch (t.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Un
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Un,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                                }
                                return e[t.id] = n,
                                n
                            }
                        }
                    }()
                      , i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                    for (let e = 0; e < 9; e++)
                        i.probe.push(new Kn);
                    const a = new Kn
                      , o = new Tr
                      , s = new Tr;
                    return {
                        setup: function(a) {
                            let o = 0
                              , s = 0
                              , l = 0;
                            for (let e = 0; e < 9; e++)
                                i.probe[e].set(0, 0, 0);
                            let c = 0
                              , u = 0
                              , h = 0
                              , d = 0
                              , p = 0
                              , f = 0
                              , m = 0
                              , g = 0;
                            a.sort(_s);
                            for (let e = 0, t = a.length; e < t; e++) {
                                const t = a[e]
                                  , v = t.color
                                  , y = t.intensity
                                  , _ = t.distance
                                  , x = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                                if (t.isAmbientLight)
                                    o += v.r * y,
                                    s += v.g * y,
                                    l += v.b * y;
                                else if (t.isLightProbe)
                                    for (let e = 0; e < 9; e++)
                                        i.probe[e].addScaledVector(t.sh.coefficients[e], y);
                                else if (t.isDirectionalLight) {
                                    const e = n.get(t);
                                    if (e.color.copy(t.color).multiplyScalar(t.intensity),
                                    t.castShadow) {
                                        const e = t.shadow
                                          , n = r.get(t);
                                        n.shadowBias = e.bias,
                                        n.shadowNormalBias = e.normalBias,
                                        n.shadowRadius = e.radius,
                                        n.shadowMapSize = e.mapSize,
                                        i.directionalShadow[c] = n,
                                        i.directionalShadowMap[c] = x,
                                        i.directionalShadowMatrix[c] = t.shadow.matrix,
                                        f++
                                    }
                                    i.directional[c] = e,
                                    c++
                                } else if (t.isSpotLight) {
                                    const e = n.get(t);
                                    if (e.position.setFromMatrixPosition(t.matrixWorld),
                                    e.color.copy(v).multiplyScalar(y),
                                    e.distance = _,
                                    e.coneCos = Math.cos(t.angle),
                                    e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                                    e.decay = t.decay,
                                    t.castShadow) {
                                        const e = t.shadow
                                          , n = r.get(t);
                                        n.shadowBias = e.bias,
                                        n.shadowNormalBias = e.normalBias,
                                        n.shadowRadius = e.radius,
                                        n.shadowMapSize = e.mapSize,
                                        i.spotShadow[h] = n,
                                        i.spotShadowMap[h] = x,
                                        i.spotShadowMatrix[h] = t.shadow.matrix,
                                        g++
                                    }
                                    i.spot[h] = e,
                                    h++
                                } else if (t.isRectAreaLight) {
                                    const e = n.get(t);
                                    e.color.copy(v).multiplyScalar(y),
                                    e.halfWidth.set(.5 * t.width, 0, 0),
                                    e.halfHeight.set(0, .5 * t.height, 0),
                                    i.rectArea[d] = e,
                                    d++
                                } else if (t.isPointLight) {
                                    const e = n.get(t);
                                    if (e.color.copy(t.color).multiplyScalar(t.intensity),
                                    e.distance = t.distance,
                                    e.decay = t.decay,
                                    t.castShadow) {
                                        const e = t.shadow
                                          , n = r.get(t);
                                        n.shadowBias = e.bias,
                                        n.shadowNormalBias = e.normalBias,
                                        n.shadowRadius = e.radius,
                                        n.shadowMapSize = e.mapSize,
                                        n.shadowCameraNear = e.camera.near,
                                        n.shadowCameraFar = e.camera.far,
                                        i.pointShadow[u] = n,
                                        i.pointShadowMap[u] = x,
                                        i.pointShadowMatrix[u] = t.shadow.matrix,
                                        m++
                                    }
                                    i.point[u] = e,
                                    u++
                                } else if (t.isHemisphereLight) {
                                    const e = n.get(t);
                                    e.skyColor.copy(t.color).multiplyScalar(y),
                                    e.groundColor.copy(t.groundColor).multiplyScalar(y),
                                    i.hemi[p] = e,
                                    p++
                                }
                            }
                            d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = La.LTC_FLOAT_1,
                            i.rectAreaLTC2 = La.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = La.LTC_HALF_1,
                            i.rectAreaLTC2 = La.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                            i.ambient[0] = o,
                            i.ambient[1] = s,
                            i.ambient[2] = l;
                            const v = i.hash;
                            v.directionalLength === c && v.pointLength === u && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (i.directional.length = c,
                            i.spot.length = h,
                            i.rectArea.length = d,
                            i.point.length = u,
                            i.hemi.length = p,
                            i.directionalShadow.length = f,
                            i.directionalShadowMap.length = f,
                            i.pointShadow.length = m,
                            i.pointShadowMap.length = m,
                            i.spotShadow.length = g,
                            i.spotShadowMap.length = g,
                            i.directionalShadowMatrix.length = f,
                            i.pointShadowMatrix.length = m,
                            i.spotShadowMatrix.length = g,
                            v.directionalLength = c,
                            v.pointLength = u,
                            v.spotLength = h,
                            v.rectAreaLength = d,
                            v.hemiLength = p,
                            v.numDirectionalShadows = f,
                            v.numPointShadows = m,
                            v.numSpotShadows = g,
                            i.version = ys++)
                        },
                        setupView: function(e, t) {
                            let n = 0
                              , r = 0
                              , l = 0
                              , c = 0
                              , u = 0;
                            const h = t.matrixWorldInverse;
                            for (let t = 0, d = e.length; t < d; t++) {
                                const d = e[t];
                                if (d.isDirectionalLight) {
                                    const e = i.directional[n];
                                    e.direction.setFromMatrixPosition(d.matrixWorld),
                                    a.setFromMatrixPosition(d.target.matrixWorld),
                                    e.direction.sub(a),
                                    e.direction.transformDirection(h),
                                    n++
                                } else if (d.isSpotLight) {
                                    const e = i.spot[l];
                                    e.position.setFromMatrixPosition(d.matrixWorld),
                                    e.position.applyMatrix4(h),
                                    e.direction.setFromMatrixPosition(d.matrixWorld),
                                    a.setFromMatrixPosition(d.target.matrixWorld),
                                    e.direction.sub(a),
                                    e.direction.transformDirection(h),
                                    l++
                                } else if (d.isRectAreaLight) {
                                    const e = i.rectArea[c];
                                    e.position.setFromMatrixPosition(d.matrixWorld),
                                    e.position.applyMatrix4(h),
                                    s.identity(),
                                    o.copy(d.matrixWorld),
                                    o.premultiply(h),
                                    s.extractRotation(o),
                                    e.halfWidth.set(.5 * d.width, 0, 0),
                                    e.halfHeight.set(0, .5 * d.height, 0),
                                    e.halfWidth.applyMatrix4(s),
                                    e.halfHeight.applyMatrix4(s),
                                    c++
                                } else if (d.isPointLight) {
                                    const e = i.point[r];
                                    e.position.setFromMatrixPosition(d.matrixWorld),
                                    e.position.applyMatrix4(h),
                                    r++
                                } else if (d.isHemisphereLight) {
                                    const e = i.hemi[u];
                                    e.direction.setFromMatrixPosition(d.matrixWorld),
                                    e.direction.transformDirection(h),
                                    e.direction.normalize(),
                                    u++
                                }
                            }
                        },
                        state: i
                    }
                }
                function bs(e, t) {
                    const n = new xs(e,t)
                      , r = []
                      , i = [];
                    return {
                        init: function() {
                            r.length = 0,
                            i.length = 0
                        },
                        state: {
                            lightsArray: r,
                            shadowsArray: i,
                            lights: n
                        },
                        setupLights: function() {
                            n.setup(r)
                        },
                        setupLightsView: function(e) {
                            n.setupView(r, e)
                        },
                        pushLight: function(e) {
                            r.push(e)
                        },
                        pushShadow: function(e) {
                            i.push(e)
                        }
                    }
                }
                function ws(e, t) {
                    let n = new WeakMap;
                    return {
                        get: function(r, i=0) {
                            let a;
                            return !1 === n.has(r) ? (a = new bs(e,t),
                            n.set(r, []),
                            n.get(r).push(a)) : i >= n.get(r).length ? (a = new bs(e,t),
                            n.get(r).push(a)) : a = n.get(r)[i],
                            a
                        },
                        dispose: function() {
                            n = new WeakMap
                        }
                    }
                }
                function Ms(e) {
                    bi.call(this),
                    this.type = "MeshDepthMaterial",
                    this.depthPacking = an,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.setValues(e)
                }
                function Ss(e) {
                    bi.call(this),
                    this.type = "MeshDistanceMaterial",
                    this.referencePosition = new Kn,
                    this.nearDistance = 1,
                    this.farDistance = 1e3,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.fog = !1,
                    this.setValues(e)
                }
                function Ts(e, t, n) {
                    let r = new Ea;
                    const i = new Un
                      , a = new Un
                      , o = new Xn
                      , s = []
                      , l = []
                      , c = {}
                      , u = {
                        0: m,
                        1: f,
                        2: g
                    }
                      , d = new ga({
                        defines: {
                            SAMPLE_RATE: 2 / 8,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Un
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    })
                      , v = d.clone();
                    v.defines.HORIZONTAL_PASS = 1;
                    const y = new qi;
                    y.setAttribute("position", new Ti(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                    const x = new ua(y,d)
                      , b = this;
                    function w(n, r) {
                        const i = t.update(x);
                        d.uniforms.shadow_pass.value = n.map.texture,
                        d.uniforms.resolution.value = n.mapSize,
                        d.uniforms.radius.value = n.radius,
                        e.setRenderTarget(n.mapPass),
                        e.clear(),
                        e.renderBufferDirect(r, null, i, d, x, null),
                        v.uniforms.shadow_pass.value = n.mapPass.texture,
                        v.uniforms.resolution.value = n.mapSize,
                        v.uniforms.radius.value = n.radius,
                        e.setRenderTarget(n.map),
                        e.clear(),
                        e.renderBufferDirect(r, null, i, v, x, null)
                    }
                    function M(e, t, n) {
                        const r = e << 0 | t << 1 | n << 2;
                        let i = s[r];
                        return void 0 === i && (i = new Ms({
                            depthPacking: on,
                            morphTargets: e,
                            skinning: t
                        }),
                        s[r] = i),
                        i
                    }
                    function S(e, t, n) {
                        const r = e << 0 | t << 1 | n << 2;
                        let i = l[r];
                        return void 0 === i && (i = new Ss({
                            morphTargets: e,
                            skinning: t
                        }),
                        l[r] = i),
                        i
                    }
                    function T(t, n, r, i, a, o, s) {
                        let l = null
                          , h = M
                          , d = t.customDepthMaterial;
                        if (!0 === i.isPointLight && (h = S,
                        d = t.customDistanceMaterial),
                        void 0 === d) {
                            let e = !1;
                            !0 === r.morphTargets && (e = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                            let i = !1;
                            !0 === t.isSkinnedMesh && (!0 === r.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)),
                            l = h(e, i, !0 === t.isInstancedMesh)
                        } else
                            l = d;
                        if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
                            const e = l.uuid
                              , t = r.uuid;
                            let n = c[e];
                            void 0 === n && (n = {},
                            c[e] = n);
                            let i = n[t];
                            void 0 === i && (i = l.clone(),
                            n[t] = i),
                            l = i
                        }
                        return l.visible = r.visible,
                        l.wireframe = r.wireframe,
                        l.side = s === p ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : u[r.side],
                        l.clipShadows = r.clipShadows,
                        l.clippingPlanes = r.clippingPlanes,
                        l.clipIntersection = r.clipIntersection,
                        l.wireframeLinewidth = r.wireframeLinewidth,
                        l.linewidth = r.linewidth,
                        !0 === i.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(i.matrixWorld),
                        l.nearDistance = a,
                        l.farDistance = o),
                        l
                    }
                    function E(n, i, a, o, s) {
                        if (!1 === n.visible)
                            return;
                        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === p) && (!n.frustumCulled || r.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                            const r = t.update(n)
                              , i = n.material;
                            if (Array.isArray(i)) {
                                const t = r.groups;
                                for (let l = 0, c = t.length; l < c; l++) {
                                    const c = t[l]
                                      , u = i[c.materialIndex];
                                    if (u && u.visible) {
                                        const t = T(n, r, u, o, a.near, a.far, s);
                                        e.renderBufferDirect(a, null, r, t, n, c)
                                    }
                                }
                            } else if (i.visible) {
                                const t = T(n, r, i, o, a.near, a.far, s);
                                e.renderBufferDirect(a, null, r, t, n, null)
                            }
                        }
                        const l = n.children;
                        for (let e = 0, t = l.length; e < t; e++)
                            E(l[e], i, a, o, s)
                    }
                    this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = h,
                    this.render = function(t, s, l) {
                        if (!1 === b.enabled)
                            return;
                        if (!1 === b.autoUpdate && !1 === b.needsUpdate)
                            return;
                        if (0 === t.length)
                            return;
                        const c = e.getRenderTarget()
                          , u = e.getActiveCubeFace()
                          , h = e.getActiveMipmapLevel()
                          , d = e.state;
                        d.setBlending(_),
                        d.buffers.color.setClear(1, 1, 1, 1),
                        d.buffers.depth.setTest(!0),
                        d.setScissorTest(!1);
                        for (let c = 0, u = t.length; c < u; c++) {
                            const u = t[c]
                              , h = u.shadow;
                            if (void 0 === h) {
                                console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                                continue
                            }
                            if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                                continue;
                            i.copy(h.mapSize);
                            const f = h.getFrameExtents();
                            if (i.multiply(f),
                            a.copy(h.mapSize),
                            (i.x > n || i.y > n) && (i.x > n && (a.x = Math.floor(n / f.x),
                            i.x = a.x * f.x,
                            h.mapSize.x = a.x),
                            i.y > n && (a.y = Math.floor(n / f.y),
                            i.y = a.y * f.y,
                            h.mapSize.y = a.y)),
                            null === h.map && !h.isPointLightShadow && this.type === p) {
                                const e = {
                                    minFilter: _e,
                                    magFilter: _e,
                                    format: ke
                                };
                                h.map = new Yn(i.x,i.y,e),
                                h.map.texture.name = u.name + ".shadowMap",
                                h.mapPass = new Yn(i.x,i.y,e),
                                h.camera.updateProjectionMatrix()
                            }
                            if (null === h.map) {
                                const e = {
                                    minFilter: fe,
                                    magFilter: fe,
                                    format: ke
                                };
                                h.map = new Yn(i.x,i.y,e),
                                h.map.texture.name = u.name + ".shadowMap",
                                h.camera.updateProjectionMatrix()
                            }
                            e.setRenderTarget(h.map),
                            e.clear();
                            const m = h.getViewportCount();
                            for (let e = 0; e < m; e++) {
                                const t = h.getViewport(e);
                                o.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w),
                                d.viewport(o),
                                h.updateMatrices(u, e),
                                r = h.getFrustum(),
                                E(s, l, h.camera, u, this.type)
                            }
                            h.isPointLightShadow || this.type !== p || w(h, l),
                            h.needsUpdate = !1
                        }
                        b.needsUpdate = !1,
                        e.setRenderTarget(c, u, h)
                    }
                }
                function Es(e, t, n) {
                    const r = n.isWebGL2
                      , i = new function() {
                        let t = !1;
                        const n = new Xn;
                        let r = null;
                        const i = new Xn(0,0,0,0);
                        return {
                            setMask: function(n) {
                                r === n || t || (e.colorMask(n, n, n, n),
                                r = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, r, a, o, s) {
                                !0 === s && (t *= o,
                                r *= o,
                                a *= o),
                                n.set(t, r, a, o),
                                !1 === i.equals(n) && (e.clearColor(t, r, a, o),
                                i.copy(n))
                            },
                            reset: function() {
                                t = !1,
                                r = null,
                                i.set(-1, 0, 0, 0)
                            }
                        }
                    }
                      , a = new function() {
                        let t = !1
                          , n = null
                          , r = null
                          , i = null;
                        return {
                            setTest: function(e) {
                                e ? fe(2929) : me(2929)
                            },
                            setMask: function(r) {
                                n === r || t || (e.depthMask(r),
                                n = r)
                            },
                            setFunc: function(t) {
                                if (r !== t) {
                                    if (t)
                                        switch (t) {
                                        case H:
                                            e.depthFunc(512);
                                            break;
                                        case G:
                                            e.depthFunc(519);
                                            break;
                                        case j:
                                            e.depthFunc(513);
                                            break;
                                        default:
                                            e.depthFunc(515);
                                            break;
                                        case W:
                                            e.depthFunc(514);
                                            break;
                                        case q:
                                            e.depthFunc(518);
                                            break;
                                        case X:
                                            e.depthFunc(516);
                                            break;
                                        case Y:
                                            e.depthFunc(517)
                                        }
                                    else
                                        e.depthFunc(515);
                                    r = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                i !== t && (e.clearDepth(t),
                                i = t)
                            },
                            reset: function() {
                                t = !1,
                                n = null,
                                r = null,
                                i = null
                            }
                        }
                    }
                      , c = new function() {
                        let t = !1
                          , n = null
                          , r = null
                          , i = null
                          , a = null
                          , o = null
                          , s = null
                          , l = null
                          , c = null;
                        return {
                            setTest: function(e) {
                                t || (e ? fe(2960) : me(2960))
                            },
                            setMask: function(r) {
                                n === r || t || (e.stencilMask(r),
                                n = r)
                            },
                            setFunc: function(t, n, o) {
                                r === t && i === n && a === o || (e.stencilFunc(t, n, o),
                                r = t,
                                i = n,
                                a = o)
                            },
                            setOp: function(t, n, r) {
                                o === t && s === n && l === r || (e.stencilOp(t, n, r),
                                o = t,
                                s = n,
                                l = r)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                c !== t && (e.clearStencil(t),
                                c = t)
                            },
                            reset: function() {
                                t = !1,
                                n = null,
                                r = null,
                                i = null,
                                a = null,
                                o = null,
                                s = null,
                                l = null,
                                c = null
                            }
                        }
                    }
                    ;
                    let u = {}
                      , h = null
                      , d = null
                      , p = null
                      , f = null
                      , v = null
                      , y = null
                      , Z = null
                      , J = null
                      , K = null
                      , Q = !1
                      , $ = null
                      , ee = null
                      , te = null
                      , ne = null
                      , re = null;
                    const ie = e.getParameter(35661);
                    let ae = !1
                      , oe = 0;
                    const se = e.getParameter(7938);
                    -1 !== se.indexOf("WebGL") ? (oe = parseFloat(/^WebGL (\d)/.exec(se)[1]),
                    ae = oe >= 1) : -1 !== se.indexOf("OpenGL ES") && (oe = parseFloat(/^OpenGL ES (\d)/.exec(se)[1]),
                    ae = oe >= 2);
                    let le = null
                      , ce = {};
                    const ue = new Xn
                      , he = new Xn;
                    function de(t, n, r) {
                        const i = new Uint8Array(4)
                          , a = e.createTexture();
                        e.bindTexture(t, a),
                        e.texParameteri(t, 10241, 9728),
                        e.texParameteri(t, 10240, 9728);
                        for (let t = 0; t < r; t++)
                            e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i);
                        return a
                    }
                    const pe = {};
                    function fe(t) {
                        !0 !== u[t] && (e.enable(t),
                        u[t] = !0)
                    }
                    function me(t) {
                        !1 !== u[t] && (e.disable(t),
                        u[t] = !1)
                    }
                    pe[3553] = de(3553, 3553, 1),
                    pe[34067] = de(34067, 34069, 6),
                    i.setClear(0, 0, 0, 1),
                    a.setClear(1),
                    c.setClear(0),
                    fe(2929),
                    a.setFunc(V),
                    _e(!1),
                    xe(s),
                    fe(2884),
                    ye(_);
                    const ge = {
                        [T]: 32774,
                        [E]: 32778,
                        [A]: 32779
                    };
                    if (r)
                        ge[C] = 32775,
                        ge[P] = 32776;
                    else {
                        const e = t.get("EXT_blend_minmax");
                        null !== e && (ge[C] = e.MIN_EXT,
                        ge[P] = e.MAX_EXT)
                    }
                    const ve = {
                        [R]: 0,
                        [L]: 1,
                        [D]: 768,
                        [F]: 770,
                        [U]: 776,
                        [k]: 774,
                        [N]: 772,
                        [O]: 769,
                        [I]: 771,
                        [z]: 775,
                        [B]: 773
                    };
                    function ye(t, n, r, i, a, o, s, l) {
                        if (t !== _) {
                            if (d || (fe(3042),
                            d = !0),
                            t === S)
                                a = a || n,
                                o = o || r,
                                s = s || i,
                                n === f && a === Z || (e.blendEquationSeparate(ge[n], ge[a]),
                                f = n,
                                Z = a),
                                r === v && i === y && o === J && s === K || (e.blendFuncSeparate(ve[r], ve[i], ve[o], ve[s]),
                                v = r,
                                y = i,
                                J = o,
                                K = s),
                                p = t,
                                Q = null;
                            else if (t !== p || l !== Q) {
                                if (f === T && Z === T || (e.blendEquation(32774),
                                f = T,
                                Z = T),
                                l)
                                    switch (t) {
                                    case x:
                                        e.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case b:
                                        e.blendFunc(1, 1);
                                        break;
                                    case w:
                                        e.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case M:
                                        e.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", t)
                                    }
                                else
                                    switch (t) {
                                    case x:
                                        e.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case b:
                                        e.blendFunc(770, 1);
                                        break;
                                    case w:
                                        e.blendFunc(0, 769);
                                        break;
                                    case M:
                                        e.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", t)
                                    }
                                v = null,
                                y = null,
                                J = null,
                                K = null,
                                p = t,
                                Q = l
                            }
                        } else
                            d && (me(3042),
                            d = !1)
                    }
                    function _e(t) {
                        $ !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
                        $ = t)
                    }
                    function xe(t) {
                        t !== o ? (fe(2884),
                        t !== ee && (t === s ? e.cullFace(1029) : t === l ? e.cullFace(1028) : e.cullFace(1032))) : me(2884),
                        ee = t
                    }
                    function be(t, n, r) {
                        t ? (fe(32823),
                        ne === n && re === r || (e.polygonOffset(n, r),
                        ne = n,
                        re = r)) : me(32823)
                    }
                    function we(t) {
                        void 0 === t && (t = 33984 + ie - 1),
                        le !== t && (e.activeTexture(t),
                        le = t)
                    }
                    return {
                        buffers: {
                            color: i,
                            depth: a,
                            stencil: c
                        },
                        enable: fe,
                        disable: me,
                        useProgram: function(t) {
                            return h !== t && (e.useProgram(t),
                            h = t,
                            !0)
                        },
                        setBlending: ye,
                        setMaterial: function(e, t) {
                            e.side === g ? me(2884) : fe(2884);
                            let n = e.side === m;
                            t && (n = !n),
                            _e(n),
                            e.blending === x && !1 === e.transparent ? ye(_) : ye(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                            a.setFunc(e.depthFunc),
                            a.setTest(e.depthTest),
                            a.setMask(e.depthWrite),
                            i.setMask(e.colorWrite);
                            const r = e.stencilWrite;
                            c.setTest(r),
                            r && (c.setMask(e.stencilWriteMask),
                            c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                            c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                            be(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                        },
                        setFlipSided: _e,
                        setCullFace: xe,
                        setLineWidth: function(t) {
                            t !== te && (ae && e.lineWidth(t),
                            te = t)
                        },
                        setPolygonOffset: be,
                        setScissorTest: function(e) {
                            e ? fe(3089) : me(3089)
                        },
                        activeTexture: we,
                        bindTexture: function(t, n) {
                            null === le && we();
                            let r = ce[le];
                            void 0 === r && (r = {
                                type: void 0,
                                texture: void 0
                            },
                            ce[le] = r),
                            r.type === t && r.texture === n || (e.bindTexture(t, n || pe[t]),
                            r.type = t,
                            r.texture = n)
                        },
                        unbindTexture: function() {
                            const t = ce[le];
                            void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                            t.type = void 0,
                            t.texture = void 0)
                        },
                        compressedTexImage2D: function() {
                            try {
                                e.compressedTexImage2D.apply(e, arguments)
                            } catch (e) {
                                console.error("THREE.WebGLState:", e)
                            }
                        },
                        texImage2D: function() {
                            try {
                                e.texImage2D.apply(e, arguments)
                            } catch (e) {
                                console.error("THREE.WebGLState:", e)
                            }
                        },
                        texImage3D: function() {
                            try {
                                e.texImage3D.apply(e, arguments)
                            } catch (e) {
                                console.error("THREE.WebGLState:", e)
                            }
                        },
                        scissor: function(t) {
                            !1 === ue.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                            ue.copy(t))
                        },
                        viewport: function(t) {
                            !1 === he.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                            he.copy(t))
                        },
                        reset: function() {
                            u = {},
                            le = null,
                            ce = {},
                            h = null,
                            d = null,
                            p = null,
                            f = null,
                            v = null,
                            y = null,
                            Z = null,
                            J = null,
                            K = null,
                            Q = !1,
                            $ = null,
                            ee = null,
                            te = null,
                            ne = null,
                            re = null,
                            i.reset(),
                            a.reset(),
                            c.reset()
                        }
                    }
                }
                function As(e, t, n, r, i, a, o) {
                    const s = i.isWebGL2
                      , l = i.maxTextures
                      , c = i.maxCubemapSize
                      , u = i.maxTextureSize
                      , h = i.maxSamples
                      , d = new WeakMap;
                    let p, f = !1;
                    try {
                        f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
                    } catch (e) {}
                    function m(e, t) {
                        return f ? new OffscreenCanvas(e,t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                    }
                    function g(e, t, n, r) {
                        let i = 1;
                        if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)),
                        i < 1 || !0 === t) {
                            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                                const r = t ? zn.floorPowerOfTwo : Math.floor
                                  , a = r(i * e.width)
                                  , o = r(i * e.height);
                                void 0 === p && (p = m(a, o));
                                const s = n ? m(a, o) : p;
                                return s.width = a,
                                s.height = o,
                                s.getContext("2d").drawImage(e, 0, 0, a, o),
                                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + o + ")."),
                                s
                            }
                            return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                            e
                        }
                        return e
                    }
                    function v(e) {
                        return zn.isPowerOfTwo(e.width) && zn.isPowerOfTwo(e.height)
                    }
                    function y(e, t) {
                        return e.generateMipmaps && t && e.minFilter !== fe && e.minFilter !== _e
                    }
                    function _(t, n, i, a) {
                        e.generateMipmap(t),
                        r.get(n).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E
                    }
                    function x(n, r, i) {
                        if (!1 === s)
                            return r;
                        if (null !== n) {
                            if (void 0 !== e[n])
                                return e[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let a = r;
                        return 6403 === r && (5126 === i && (a = 33326),
                        5131 === i && (a = 33325),
                        5121 === i && (a = 33321)),
                        6407 === r && (5126 === i && (a = 34837),
                        5131 === i && (a = 34843),
                        5121 === i && (a = 32849)),
                        6408 === r && (5126 === i && (a = 34836),
                        5131 === i && (a = 34842),
                        5121 === i && (a = 32856)),
                        33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"),
                        a
                    }
                    function b(e) {
                        return e === fe || e === me || e === ve ? 9728 : 9729
                    }
                    function w(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", w),
                        function(t) {
                            const n = r.get(t);
                            void 0 !== n.__webglInit && (e.deleteTexture(n.__webglTexture),
                            r.remove(t))
                        }(n),
                        n.isVideoTexture && d.delete(n),
                        o.memory.textures--
                    }
                    function M(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", M),
                        function(t) {
                            const n = r.get(t)
                              , i = r.get(t.texture);
                            if (t) {
                                if (void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture),
                                t.depthTexture && t.depthTexture.dispose(),
                                t.isWebGLCubeRenderTarget)
                                    for (let t = 0; t < 6; t++)
                                        e.deleteFramebuffer(n.__webglFramebuffer[t]),
                                        n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t]);
                                else
                                    e.deleteFramebuffer(n.__webglFramebuffer),
                                    n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                                    n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                                    n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer),
                                    n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                                r.remove(t.texture),
                                r.remove(t)
                            }
                        }(n),
                        o.memory.textures--
                    }
                    let S = 0;
                    function T(e, t) {
                        const i = r.get(e);
                        if (e.isVideoTexture && function(e) {
                            const t = o.render.frame;
                            d.get(e) !== t && (d.set(e, t),
                            e.update())
                        }(e),
                        e.version > 0 && i.__version !== e.version) {
                            const n = e.image;
                            if (void 0 === n)
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== n.complete)
                                    return void L(i, e, t);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.activeTexture(33984 + t),
                        n.bindTexture(3553, i.__webglTexture)
                    }
                    function E(t, i) {
                        const o = r.get(t);
                        t.version > 0 && o.__version !== t.version ? function(t, r, i) {
                            if (6 !== r.image.length)
                                return;
                            R(t, r),
                            n.activeTexture(33984 + i),
                            n.bindTexture(34067, t.__webglTexture),
                            e.pixelStorei(37440, r.flipY),
                            e.pixelStorei(37441, r.premultiplyAlpha),
                            e.pixelStorei(3317, r.unpackAlignment);
                            const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture)
                              , l = r.image[0] && r.image[0].isDataTexture
                              , u = [];
                            for (let e = 0; e < 6; e++)
                                u[e] = o || l ? l ? r.image[e].image : r.image[e] : g(r.image[e], !1, !0, c);
                            const h = u[0]
                              , d = v(h) || s
                              , p = a.convert(r.format)
                              , f = a.convert(r.type)
                              , m = x(r.internalFormat, p, f);
                            let b;
                            if (P(34067, r, d),
                            o) {
                                for (let e = 0; e < 6; e++) {
                                    b = u[e].mipmaps;
                                    for (let t = 0; t < b.length; t++) {
                                        const i = b[t];
                                        r.format !== ke && r.format !== Be ? null !== p ? n.compressedTexImage2D(34069 + e, t, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + e, t, m, i.width, i.height, 0, p, f, i.data)
                                    }
                                }
                                t.__maxMipLevel = b.length - 1
                            } else {
                                b = r.mipmaps;
                                for (let e = 0; e < 6; e++)
                                    if (l) {
                                        n.texImage2D(34069 + e, 0, m, u[e].width, u[e].height, 0, p, f, u[e].data);
                                        for (let t = 0; t < b.length; t++) {
                                            const r = b[t].image[e].image;
                                            n.texImage2D(34069 + e, t + 1, m, r.width, r.height, 0, p, f, r.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + e, 0, m, p, f, u[e]);
                                        for (let t = 0; t < b.length; t++) {
                                            const r = b[t];
                                            n.texImage2D(34069 + e, t + 1, m, p, f, r.image[e])
                                        }
                                    }
                                t.__maxMipLevel = b.length
                            }
                            y(r, d) && _(34067, r, h.width, h.height),
                            t.__version = r.version,
                            r.onUpdate && r.onUpdate(r)
                        }(o, t, i) : (n.activeTexture(33984 + i),
                        n.bindTexture(34067, o.__webglTexture))
                    }
                    const A = {
                        [he]: 10497,
                        [de]: 33071,
                        [pe]: 33648
                    }
                      , C = {
                        [fe]: 9728,
                        [me]: 9984,
                        [ve]: 9986,
                        [_e]: 9729,
                        [xe]: 9985,
                        [we]: 9987
                    };
                    function P(n, a, o) {
                        o ? (e.texParameteri(n, 10242, A[a.wrapS]),
                        e.texParameteri(n, 10243, A[a.wrapT]),
                        32879 !== n && 35866 !== n || e.texParameteri(n, 32882, A[a.wrapR]),
                        e.texParameteri(n, 10240, C[a.magFilter]),
                        e.texParameteri(n, 10241, C[a.minFilter])) : (e.texParameteri(n, 10242, 33071),
                        e.texParameteri(n, 10243, 33071),
                        32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071),
                        a.wrapS === de && a.wrapT === de || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                        e.texParameteri(n, 10240, b(a.magFilter)),
                        e.texParameteri(n, 10241, b(a.minFilter)),
                        a.minFilter !== fe && a.minFilter !== _e && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                        const l = t.get("EXT_texture_filter_anisotropic");
                        if (l) {
                            if (a.type === Re && null === t.get("OES_texture_float_linear"))
                                return;
                            if (a.type === Le && null === (s || t.get("OES_texture_half_float_linear")))
                                return;
                            (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())),
                            r.get(a).__currentAnisotropy = a.anisotropy)
                        }
                    }
                    function R(t, n) {
                        void 0 === t.__webglInit && (t.__webglInit = !0,
                        n.addEventListener("dispose", w),
                        t.__webglTexture = e.createTexture(),
                        o.memory.textures++)
                    }
                    function L(t, r, i) {
                        let o = 3553;
                        r.isDataTexture2DArray && (o = 35866),
                        r.isDataTexture3D && (o = 32879),
                        R(t, r),
                        n.activeTexture(33984 + i),
                        n.bindTexture(o, t.__webglTexture),
                        e.pixelStorei(37440, r.flipY),
                        e.pixelStorei(37441, r.premultiplyAlpha),
                        e.pixelStorei(3317, r.unpackAlignment);
                        const l = function(e) {
                            return !s && (e.wrapS !== de || e.wrapT !== de || e.minFilter !== fe && e.minFilter !== _e)
                        }(r) && !1 === v(r.image)
                          , c = g(r.image, l, !1, u)
                          , h = v(c) || s
                          , d = a.convert(r.format);
                        let p, f = a.convert(r.type), m = x(r.internalFormat, d, f);
                        P(o, r, h);
                        const b = r.mipmaps;
                        if (r.isDepthTexture)
                            m = 6402,
                            s ? m = r.type === Re ? 36012 : r.type === Pe ? 33190 : r.type === Ie ? 35056 : 33189 : r.type === Re && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                            r.format === Ge && 6402 === m && r.type !== Ae && r.type !== Pe && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                            r.type = Ae,
                            f = a.convert(r.type)),
                            r.format === je && 6402 === m && (m = 34041,
                            r.type !== Ie && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                            r.type = Ie,
                            f = a.convert(r.type))),
                            n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
                        else if (r.isDataTexture)
                            if (b.length > 0 && h) {
                                for (let e = 0, t = b.length; e < t; e++)
                                    p = b[e],
                                    n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                                r.generateMipmaps = !1,
                                t.__maxMipLevel = b.length - 1
                            } else
                                n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                                t.__maxMipLevel = 0;
                        else if (r.isCompressedTexture) {
                            for (let e = 0, t = b.length; e < t; e++)
                                p = b[e],
                                r.format !== ke && r.format !== Be ? null !== d ? n.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                            t.__maxMipLevel = b.length - 1
                        } else if (r.isDataTexture2DArray)
                            n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                            t.__maxMipLevel = 0;
                        else if (r.isDataTexture3D)
                            n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                            t.__maxMipLevel = 0;
                        else if (b.length > 0 && h) {
                            for (let e = 0, t = b.length; e < t; e++)
                                p = b[e],
                                n.texImage2D(3553, e, m, d, f, p);
                            r.generateMipmaps = !1,
                            t.__maxMipLevel = b.length - 1
                        } else
                            n.texImage2D(3553, 0, m, d, f, c),
                            t.__maxMipLevel = 0;
                        y(r, h) && _(o, r, c.width, c.height),
                        t.__version = r.version,
                        r.onUpdate && r.onUpdate(r)
                    }
                    function D(t, i, o, s) {
                        const l = a.convert(i.texture.format)
                          , c = a.convert(i.texture.type)
                          , u = x(i.texture.internalFormat, l, c);
                        n.texImage2D(s, 0, u, i.width, i.height, 0, l, c, null),
                        e.bindFramebuffer(36160, t),
                        e.framebufferTexture2D(36160, o, s, r.get(i.texture).__webglTexture, 0),
                        e.bindFramebuffer(36160, null)
                    }
                    function O(t, n, r) {
                        if (e.bindRenderbuffer(36161, t),
                        n.depthBuffer && !n.stencilBuffer) {
                            let i = 33189;
                            if (r) {
                                const t = n.depthTexture;
                                t && t.isDepthTexture && (t.type === Re ? i = 36012 : t.type === Pe && (i = 33190));
                                const r = F(n);
                                e.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
                            } else
                                e.renderbufferStorage(36161, i, n.width, n.height);
                            e.framebufferRenderbuffer(36160, 36096, 36161, t)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            if (r) {
                                const t = F(n);
                                e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height)
                            } else
                                e.renderbufferStorage(36161, 34041, n.width, n.height);
                            e.framebufferRenderbuffer(36160, 33306, 36161, t)
                        } else {
                            const t = a.convert(n.texture.format)
                              , i = a.convert(n.texture.type)
                              , o = x(n.texture.internalFormat, t, i);
                            if (r) {
                                const t = F(n);
                                e.renderbufferStorageMultisample(36161, t, o, n.width, n.height)
                            } else
                                e.renderbufferStorage(36161, o, n.width, n.height)
                        }
                        e.bindRenderbuffer(36161, null)
                    }
                    function F(e) {
                        return s && e.isWebGLMultisampleRenderTarget ? Math.min(h, e.samples) : 0
                    }
                    let I = !1
                      , N = !1;
                    this.allocateTextureUnit = function() {
                        const e = S;
                        return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l),
                        S += 1,
                        e
                    }
                    ,
                    this.resetTextureUnits = function() {
                        S = 0
                    }
                    ,
                    this.setTexture2D = T,
                    this.setTexture2DArray = function(e, t) {
                        const i = r.get(e);
                        e.version > 0 && i.__version !== e.version ? L(i, e, t) : (n.activeTexture(33984 + t),
                        n.bindTexture(35866, i.__webglTexture))
                    }
                    ,
                    this.setTexture3D = function(e, t) {
                        const i = r.get(e);
                        e.version > 0 && i.__version !== e.version ? L(i, e, t) : (n.activeTexture(33984 + t),
                        n.bindTexture(32879, i.__webglTexture))
                    }
                    ,
                    this.setTextureCube = E,
                    this.setupRenderTarget = function(t) {
                        const i = r.get(t)
                          , l = r.get(t.texture);
                        t.addEventListener("dispose", M),
                        l.__webglTexture = e.createTexture(),
                        o.memory.textures++;
                        const c = !0 === t.isWebGLCubeRenderTarget
                          , u = !0 === t.isWebGLMultisampleRenderTarget
                          , h = v(t) || s;
                        if (!s || t.texture.format !== Be || t.texture.type !== Re && t.texture.type !== Le || (t.texture.format = ke,
                        console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
                        c) {
                            i.__webglFramebuffer = [];
                            for (let t = 0; t < 6; t++)
                                i.__webglFramebuffer[t] = e.createFramebuffer()
                        } else if (i.__webglFramebuffer = e.createFramebuffer(),
                        u)
                            if (s) {
                                i.__webglMultisampledFramebuffer = e.createFramebuffer(),
                                i.__webglColorRenderbuffer = e.createRenderbuffer(),
                                e.bindRenderbuffer(36161, i.__webglColorRenderbuffer);
                                const n = a.convert(t.texture.format)
                                  , r = a.convert(t.texture.type)
                                  , o = x(t.texture.internalFormat, n, r)
                                  , s = F(t);
                                e.renderbufferStorageMultisample(36161, s, o, t.width, t.height),
                                e.bindFramebuffer(36160, i.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer),
                                e.bindRenderbuffer(36161, null),
                                t.depthBuffer && (i.__webglDepthRenderbuffer = e.createRenderbuffer(),
                                O(i.__webglDepthRenderbuffer, t, !0)),
                                e.bindFramebuffer(36160, null)
                            } else
                                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        if (c) {
                            n.bindTexture(34067, l.__webglTexture),
                            P(34067, t.texture, h);
                            for (let e = 0; e < 6; e++)
                                D(i.__webglFramebuffer[e], t, 36064, 34069 + e);
                            y(t.texture, h) && _(34067, t.texture, t.width, t.height),
                            n.bindTexture(34067, null)
                        } else
                            n.bindTexture(3553, l.__webglTexture),
                            P(3553, t.texture, h),
                            D(i.__webglFramebuffer, t, 36064, 3553),
                            y(t.texture, h) && _(3553, t.texture, t.width, t.height),
                            n.bindTexture(3553, null);
                        t.depthBuffer && function(t) {
                            const n = r.get(t)
                              , i = !0 === t.isWebGLCubeRenderTarget;
                            if (t.depthTexture) {
                                if (i)
                                    throw new Error("target.depthTexture not supported in Cube render targets");
                                !function(t, n) {
                                    if (n && n.isWebGLCubeRenderTarget)
                                        throw new Error("Depth Texture with cube render targets is not supported");
                                    if (e.bindFramebuffer(36160, t),
                                    !n.depthTexture || !n.depthTexture.isDepthTexture)
                                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                    r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
                                    n.depthTexture.image.height = n.height,
                                    n.depthTexture.needsUpdate = !0),
                                    T(n.depthTexture, 0);
                                    const i = r.get(n.depthTexture).__webglTexture;
                                    if (n.depthTexture.format === Ge)
                                        e.framebufferTexture2D(36160, 36096, 3553, i, 0);
                                    else {
                                        if (n.depthTexture.format !== je)
                                            throw new Error("Unknown depthTexture format");
                                        e.framebufferTexture2D(36160, 33306, 3553, i, 0)
                                    }
                                }(n.__webglFramebuffer, t)
                            } else if (i) {
                                n.__webglDepthbuffer = [];
                                for (let r = 0; r < 6; r++)
                                    e.bindFramebuffer(36160, n.__webglFramebuffer[r]),
                                    n.__webglDepthbuffer[r] = e.createRenderbuffer(),
                                    O(n.__webglDepthbuffer[r], t, !1)
                            } else
                                e.bindFramebuffer(36160, n.__webglFramebuffer),
                                n.__webglDepthbuffer = e.createRenderbuffer(),
                                O(n.__webglDepthbuffer, t, !1);
                            e.bindFramebuffer(36160, null)
                        }(t)
                    }
                    ,
                    this.updateRenderTargetMipmap = function(e) {
                        const t = e.texture;
                        if (y(t, v(e) || s)) {
                            const i = e.isWebGLCubeRenderTarget ? 34067 : 3553
                              , a = r.get(t).__webglTexture;
                            n.bindTexture(i, a),
                            _(i, t, e.width, e.height),
                            n.bindTexture(i, null)
                        }
                    }
                    ,
                    this.updateMultisampleRenderTarget = function(t) {
                        if (t.isWebGLMultisampleRenderTarget)
                            if (s) {
                                const n = r.get(t);
                                e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                                e.bindFramebuffer(36009, n.__webglFramebuffer);
                                const i = t.width
                                  , a = t.height;
                                let o = 16384;
                                t.depthBuffer && (o |= 256),
                                t.stencilBuffer && (o |= 1024),
                                e.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728),
                                e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                            } else
                                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }
                    ,
                    this.safeSetTexture2D = function(e, t) {
                        e && e.isWebGLRenderTarget && (!1 === I && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                        I = !0),
                        e = e.texture),
                        T(e, t)
                    }
                    ,
                    this.safeSetTextureCube = function(e, t) {
                        e && e.isWebGLCubeRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                        N = !0),
                        e = e.texture),
                        E(e, t)
                    }
                }
                function Cs(e, t, n) {
                    const r = n.isWebGL2;
                    return {
                        convert: function(e) {
                            let n;
                            if (e === Se)
                                return 5121;
                            if (e === De)
                                return 32819;
                            if (e === Oe)
                                return 32820;
                            if (e === Fe)
                                return 33635;
                            if (e === Te)
                                return 5120;
                            if (e === Ee)
                                return 5122;
                            if (e === Ae)
                                return 5123;
                            if (e === Ce)
                                return 5124;
                            if (e === Pe)
                                return 5125;
                            if (e === Re)
                                return 5126;
                            if (e === Le)
                                return r ? 5131 : (n = t.get("OES_texture_half_float"),
                                null !== n ? n.HALF_FLOAT_OES : null);
                            if (e === Ne)
                                return 6406;
                            if (e === Be)
                                return 6407;
                            if (e === ke)
                                return 6408;
                            if (e === ze)
                                return 6409;
                            if (e === Ue)
                                return 6410;
                            if (e === Ge)
                                return 6402;
                            if (e === je)
                                return 34041;
                            if (e === Ve)
                                return 6403;
                            if (e === We)
                                return 36244;
                            if (e === qe)
                                return 33319;
                            if (e === Xe)
                                return 33320;
                            if (e === Ye)
                                return 36248;
                            if (e === Ze)
                                return 36249;
                            if (e === Je || e === Ke || e === Qe || e === $e) {
                                if (n = t.get("WEBGL_compressed_texture_s3tc"),
                                null === n)
                                    return null;
                                if (e === Je)
                                    return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (e === Ke)
                                    return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (e === Qe)
                                    return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (e === $e)
                                    return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                            if (e === et || e === tt || e === nt || e === rt) {
                                if (n = t.get("WEBGL_compressed_texture_pvrtc"),
                                null === n)
                                    return null;
                                if (e === et)
                                    return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (e === tt)
                                    return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (e === nt)
                                    return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (e === rt)
                                    return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            }
                            if (e === it)
                                return n = t.get("WEBGL_compressed_texture_etc1"),
                                null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                            if ((e === at || e === ot) && (n = t.get("WEBGL_compressed_texture_etc"),
                            null !== n)) {
                                if (e === at)
                                    return n.COMPRESSED_RGB8_ETC2;
                                if (e === ot)
                                    return n.COMPRESSED_RGBA8_ETC2_EAC
                            }
                            return e === st || e === lt || e === ct || e === ut || e === ht || e === dt || e === pt || e === ft || e === mt || e === gt || e === vt || e === yt || e === _t || e === xt || e === wt || e === Mt || e === St || e === Tt || e === Et || e === At || e === Ct || e === Pt || e === Rt || e === Lt || e === Dt || e === Ot || e === Ft || e === It ? (n = t.get("WEBGL_compressed_texture_astc"),
                            null !== n ? e : null) : e === bt ? (n = t.get("EXT_texture_compression_bptc"),
                            null !== n ? e : null) : e === Ie ? r ? 34042 : (n = t.get("WEBGL_depth_texture"),
                            null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                        }
                    }
                }
                function Ps(e=[]) {
                    ya.call(this),
                    this.cameras = e
                }
                function Rs() {
                    Jr.call(this),
                    this.type = "Group"
                }
                function Ls() {
                    this._targetRay = null,
                    this._grip = null,
                    this._hand = null
                }
                function Ds(e, t) {
                    const n = this;
                    let r = null
                      , i = 1
                      , a = null
                      , o = "local-floor"
                      , s = null;
                    const l = []
                      , c = new Map
                      , u = new ya;
                    u.layers.enable(1),
                    u.viewport = new Xn;
                    const h = new ya;
                    h.layers.enable(2),
                    h.viewport = new Xn;
                    const d = [u, h]
                      , p = new Ps;
                    p.layers.enable(1),
                    p.layers.enable(2);
                    let f = null
                      , m = null;
                    function g(e) {
                        const t = c.get(e.inputSource);
                        t && t.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }
                    function v() {
                        c.forEach((function(e, t) {
                            e.disconnect(t)
                        }
                        )),
                        c.clear(),
                        f = null,
                        m = null,
                        e.setFramebuffer(null),
                        e.setRenderTarget(e.getRenderTarget()),
                        M.stop(),
                        n.isPresenting = !1,
                        n.dispatchEvent({
                            type: "sessionend"
                        })
                    }
                    function y(e) {
                        const t = r.inputSources;
                        for (let e = 0; e < l.length; e++)
                            c.set(t[e], l[e]);
                        for (let t = 0; t < e.removed.length; t++) {
                            const n = e.removed[t]
                              , r = c.get(n);
                            r && (r.dispatchEvent({
                                type: "disconnected",
                                data: n
                            }),
                            c.delete(n))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const n = e.added[t]
                              , r = c.get(n);
                            r && r.dispatchEvent({
                                type: "connected",
                                data: n
                            })
                        }
                    }
                    this.enabled = !1,
                    this.isPresenting = !1,
                    this.getController = function(e) {
                        let t = l[e];
                        return void 0 === t && (t = new Ls,
                        l[e] = t),
                        t.getTargetRaySpace()
                    }
                    ,
                    this.getControllerGrip = function(e) {
                        let t = l[e];
                        return void 0 === t && (t = new Ls,
                        l[e] = t),
                        t.getGripSpace()
                    }
                    ,
                    this.getHand = function(e) {
                        let t = l[e];
                        return void 0 === t && (t = new Ls,
                        l[e] = t),
                        t.getHandSpace()
                    }
                    ,
                    this.setFramebufferScaleFactor = function(e) {
                        i = e,
                        !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }
                    ,
                    this.setReferenceSpaceType = function(e) {
                        o = e,
                        !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }
                    ,
                    this.getReferenceSpace = function() {
                        return a
                    }
                    ,
                    this.getSession = function() {
                        return r
                    }
                    ,
                    this.setSession = async function(e) {
                        if (r = e,
                        null !== r) {
                            r.addEventListener("select", g),
                            r.addEventListener("selectstart", g),
                            r.addEventListener("selectend", g),
                            r.addEventListener("squeeze", g),
                            r.addEventListener("squeezestart", g),
                            r.addEventListener("squeezeend", g),
                            r.addEventListener("end", v),
                            r.addEventListener("inputsourceschange", y);
                            const e = t.getContextAttributes();
                            !0 !== e.xrCompatible && await t.makeXRCompatible();
                            const s = {
                                antialias: e.antialias,
                                alpha: e.alpha,
                                depth: e.depth,
                                stencil: e.stencil,
                                framebufferScaleFactor: i
                            }
                              , l = new XRWebGLLayer(r,t,s);
                            r.updateRenderState({
                                baseLayer: l
                            }),
                            a = await r.requestReferenceSpace(o),
                            M.setContext(r),
                            M.start(),
                            n.isPresenting = !0,
                            n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    }
                    ;
                    const _ = new Kn
                      , x = new Kn;
                    function b(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.getCamera = function(e) {
                        p.near = h.near = u.near = e.near,
                        p.far = h.far = u.far = e.far,
                        f === p.near && m === p.far || (r.updateRenderState({
                            depthNear: p.near,
                            depthFar: p.far
                        }),
                        f = p.near,
                        m = p.far);
                        const t = e.parent
                          , n = p.cameras;
                        b(p, t);
                        for (let e = 0; e < n.length; e++)
                            b(n[e], t);
                        e.matrixWorld.copy(p.matrixWorld),
                        e.matrix.copy(p.matrix),
                        e.matrix.decompose(e.position, e.quaternion, e.scale);
                        const i = e.children;
                        for (let e = 0, t = i.length; e < t; e++)
                            i[e].updateMatrixWorld(!0);
                        return 2 === n.length ? function(e, t, n) {
                            _.setFromMatrixPosition(t.matrixWorld),
                            x.setFromMatrixPosition(n.matrixWorld);
                            const r = _.distanceTo(x)
                              , i = t.projectionMatrix.elements
                              , a = n.projectionMatrix.elements
                              , o = i[14] / (i[10] - 1)
                              , s = i[14] / (i[10] + 1)
                              , l = (i[9] + 1) / i[5]
                              , c = (i[9] - 1) / i[5]
                              , u = (i[8] - 1) / i[0]
                              , h = (a[8] + 1) / a[0]
                              , d = o * u
                              , p = o * h
                              , f = r / (-u + h)
                              , m = f * -u;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                            e.translateX(m),
                            e.translateZ(f),
                            e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                            e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const g = o + f
                              , v = s + f
                              , y = d - m
                              , b = p + (r - m)
                              , w = l * s / v * g
                              , M = c * s / v * g;
                            e.projectionMatrix.makePerspective(y, b, w, M, g, v)
                        }(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix),
                        p
                    }
                    ;
                    let w = null;
                    const M = new Aa;
                    M.setAnimationLoop((function(t, n) {
                        if (s = n.getViewerPose(a),
                        null !== s) {
                            const t = s.views
                              , n = r.renderState.baseLayer;
                            e.setFramebuffer(n.framebuffer);
                            let i = !1;
                            t.length !== p.cameras.length && (p.cameras.length = 0,
                            i = !0);
                            for (let e = 0; e < t.length; e++) {
                                const r = t[e]
                                  , a = n.getViewport(r)
                                  , o = d[e];
                                o.matrix.fromArray(r.transform.matrix),
                                o.projectionMatrix.fromArray(r.projectionMatrix),
                                o.viewport.set(a.x, a.y, a.width, a.height),
                                0 === e && p.matrix.copy(o.matrix),
                                !0 === i && p.cameras.push(o)
                            }
                        }
                        const i = r.inputSources;
                        for (let e = 0; e < l.length; e++) {
                            const t = l[e]
                              , r = i[e];
                            t.update(r, n, a)
                        }
                        w && w(t, n)
                    }
                    )),
                    this.setAnimationLoop = function(e) {
                        w = e
                    }
                    ,
                    this.dispose = function() {}
                }
                function Os(e) {
                    function t(t, n) {
                        t.opacity.value = n.opacity,
                        n.color && t.diffuse.value.copy(n.color),
                        n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                        n.map && (t.map.value = n.map),
                        n.alphaMap && (t.alphaMap.value = n.alphaMap),
                        n.specularMap && (t.specularMap.value = n.specularMap);
                        const r = e.get(n).envMap;
                        if (r) {
                            t.envMap.value = r,
                            t.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1,
                            t.reflectivity.value = n.reflectivity,
                            t.refractionRatio.value = n.refractionRatio;
                            const i = e.get(r).__maxMipLevel;
                            void 0 !== i && (t.maxMipLevel.value = i)
                        }
                        let i, a;
                        n.lightMap && (t.lightMap.value = n.lightMap,
                        t.lightMapIntensity.value = n.lightMapIntensity),
                        n.aoMap && (t.aoMap.value = n.aoMap,
                        t.aoMapIntensity.value = n.aoMapIntensity),
                        n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap),
                        void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture),
                        !0 === i.matrixAutoUpdate && i.updateMatrix(),
                        t.uvTransform.value.copy(i.matrix)),
                        n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap),
                        void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture),
                        !0 === a.matrixAutoUpdate && a.updateMatrix(),
                        t.uv2Transform.value.copy(a.matrix))
                    }
                    function n(t, n) {
                        t.roughness.value = n.roughness,
                        t.metalness.value = n.metalness,
                        n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
                        n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
                        n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
                        n.bumpMap && (t.bumpMap.value = n.bumpMap,
                        t.bumpScale.value = n.bumpScale,
                        n.side === m && (t.bumpScale.value *= -1)),
                        n.normalMap && (t.normalMap.value = n.normalMap,
                        t.normalScale.value.copy(n.normalScale),
                        n.side === m && t.normalScale.value.negate()),
                        n.displacementMap && (t.displacementMap.value = n.displacementMap,
                        t.displacementScale.value = n.displacementScale,
                        t.displacementBias.value = n.displacementBias),
                        e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
                    }
                    return {
                        refreshFogUniforms: function(e, t) {
                            e.fogColor.value.copy(t.color),
                            t.isFog ? (e.fogNear.value = t.near,
                            e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                        },
                        refreshMaterialUniforms: function(e, r, i, a) {
                            r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r),
                            function(e, t) {
                                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                            }(e, r)) : r.isMeshToonMaterial ? (t(e, r),
                            function(e, t) {
                                t.gradientMap && (e.gradientMap.value = t.gradientMap),
                                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                                e.bumpScale.value = t.bumpScale,
                                t.side === m && (e.bumpScale.value *= -1)),
                                t.normalMap && (e.normalMap.value = t.normalMap,
                                e.normalScale.value.copy(t.normalScale),
                                t.side === m && e.normalScale.value.negate()),
                                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                                e.displacementScale.value = t.displacementScale,
                                e.displacementBias.value = t.displacementBias)
                            }(e, r)) : r.isMeshPhongMaterial ? (t(e, r),
                            function(e, t) {
                                e.specular.value.copy(t.specular),
                                e.shininess.value = Math.max(t.shininess, 1e-4),
                                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                                e.bumpScale.value = t.bumpScale,
                                t.side === m && (e.bumpScale.value *= -1)),
                                t.normalMap && (e.normalMap.value = t.normalMap,
                                e.normalScale.value.copy(t.normalScale),
                                t.side === m && e.normalScale.value.negate()),
                                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                                e.displacementScale.value = t.displacementScale,
                                e.displacementBias.value = t.displacementBias)
                            }(e, r)) : r.isMeshStandardMaterial ? (t(e, r),
                            r.isMeshPhysicalMaterial ? function(e, t) {
                                n(e, t),
                                e.reflectivity.value = t.reflectivity,
                                e.clearcoat.value = t.clearcoat,
                                e.clearcoatRoughness.value = t.clearcoatRoughness,
                                t.sheen && e.sheen.value.copy(t.sheen),
                                t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                                t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                                t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                                e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                                t.side === m && e.clearcoatNormalScale.value.negate()),
                                e.transmission.value = t.transmission,
                                t.transmissionMap && (e.transmissionMap.value = t.transmissionMap)
                            }(e, r) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e, r),
                            function(e, t) {
                                t.matcap && (e.matcap.value = t.matcap),
                                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                                e.bumpScale.value = t.bumpScale,
                                t.side === m && (e.bumpScale.value *= -1)),
                                t.normalMap && (e.normalMap.value = t.normalMap,
                                e.normalScale.value.copy(t.normalScale),
                                t.side === m && e.normalScale.value.negate()),
                                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                                e.displacementScale.value = t.displacementScale,
                                e.displacementBias.value = t.displacementBias)
                            }(e, r)) : r.isMeshDepthMaterial ? (t(e, r),
                            function(e, t) {
                                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                                e.displacementScale.value = t.displacementScale,
                                e.displacementBias.value = t.displacementBias)
                            }(e, r)) : r.isMeshDistanceMaterial ? (t(e, r),
                            function(e, t) {
                                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                                e.displacementScale.value = t.displacementScale,
                                e.displacementBias.value = t.displacementBias),
                                e.referencePosition.value.copy(t.referencePosition),
                                e.nearDistance.value = t.nearDistance,
                                e.farDistance.value = t.farDistance
                            }(e, r)) : r.isMeshNormalMaterial ? (t(e, r),
                            function(e, t) {
                                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                                e.bumpScale.value = t.bumpScale,
                                t.side === m && (e.bumpScale.value *= -1)),
                                t.normalMap && (e.normalMap.value = t.normalMap,
                                e.normalScale.value.copy(t.normalScale),
                                t.side === m && e.normalScale.value.negate()),
                                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                                e.displacementScale.value = t.displacementScale,
                                e.displacementBias.value = t.displacementBias)
                            }(e, r)) : r.isLineBasicMaterial ? (function(e, t) {
                                e.diffuse.value.copy(t.color),
                                e.opacity.value = t.opacity
                            }(e, r),
                            r.isLineDashedMaterial && function(e, t) {
                                e.dashSize.value = t.dashSize,
                                e.totalSize.value = t.dashSize + t.gapSize,
                                e.scale.value = t.scale
                            }(e, r)) : r.isPointsMaterial ? function(e, t, n, r) {
                                let i;
                                e.diffuse.value.copy(t.color),
                                e.opacity.value = t.opacity,
                                e.size.value = t.size * n,
                                e.scale.value = .5 * r,
                                t.map && (e.map.value = t.map),
                                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                                t.map ? i = t.map : t.alphaMap && (i = t.alphaMap),
                                void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                                e.uvTransform.value.copy(i.matrix))
                            }(e, r, i, a) : r.isSpriteMaterial ? function(e, t) {
                                let n;
                                e.diffuse.value.copy(t.color),
                                e.opacity.value = t.opacity,
                                e.rotation.value = t.rotation,
                                t.map && (e.map.value = t.map),
                                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                                t.map ? n = t.map : t.alphaMap && (n = t.alphaMap),
                                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                                e.uvTransform.value.copy(n.matrix))
                            }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
                            e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                        }
                    }
                }
                function Fs(e) {
                    const t = void 0 !== (e = e || {}).canvas ? e.canvas : function() {
                        const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return e.style.display = "block",
                        e
                    }()
                      , n = void 0 !== e.context ? e.context : null
                      , r = void 0 !== e.alpha && e.alpha
                      , i = void 0 === e.depth || e.depth
                      , a = void 0 === e.stencil || e.stencil
                      , o = void 0 !== e.antialias && e.antialias
                      , s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
                      , l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
                      , c = void 0 !== e.powerPreference ? e.powerPreference : "default"
                      , u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
                    let h = null
                      , d = null;
                    const p = [];
                    this.domElement = t,
                    this.debug = {
                        checkShaderErrors: !0
                    },
                    this.autoClear = !0,
                    this.autoClearColor = !0,
                    this.autoClearDepth = !0,
                    this.autoClearStencil = !0,
                    this.sortObjects = !0,
                    this.clippingPlanes = [],
                    this.localClippingEnabled = !1,
                    this.gammaFactor = 2,
                    this.outputEncoding = Jt,
                    this.physicallyCorrectLights = !1,
                    this.toneMapping = Q,
                    this.toneMappingExposure = 1,
                    this.maxMorphTargets = 8,
                    this.maxMorphNormals = 4;
                    const f = this;
                    let m = !1
                      , g = null
                      , v = 0
                      , y = 0
                      , _ = null
                      , x = null
                      , b = -1
                      , w = null;
                    const M = new Xn
                      , S = new Xn;
                    let T = null
                      , E = t.width
                      , A = t.height
                      , C = 1
                      , P = null
                      , R = null;
                    const L = new Xn(0,0,E,A)
                      , D = new Xn(0,0,E,A);
                    let O = !1;
                    const F = new Ea;
                    let I = !1
                      , N = !1;
                    const B = new Tr
                      , k = new Kn
                      , z = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };
                    function U() {
                        return null === _ ? C : 1
                    }
                    let H, G, j, V, W, q, X, Y, Z, J, K, $, ee, te, ne, re, ie, ae, oe, se, le, ce = n;
                    function ue(e, n) {
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r]
                              , a = t.getContext(i, n);
                            if (null !== a)
                                return a
                        }
                        return null
                    }
                    try {
                        const e = {
                            alpha: r,
                            depth: i,
                            stencil: a,
                            antialias: o,
                            premultipliedAlpha: s,
                            preserveDrawingBuffer: l,
                            powerPreference: c,
                            failIfMajorPerformanceCaveat: u
                        };
                        if (t.addEventListener("webglcontextlost", fe, !1),
                        t.addEventListener("webglcontextrestored", me, !1),
                        null === ce) {
                            const t = ["webgl2", "webgl", "experimental-webgl"];
                            if (!0 === f.isWebGL1Renderer && t.shift(),
                            ce = ue(t, e),
                            null === ce)
                                throw ue(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                        }
                        void 0 === ce.getShaderPrecisionFormat && (ce.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        }
                        )
                    } catch (e) {
                        throw console.error("THREE.WebGLRenderer: " + e.message),
                        e
                    }
                    function he() {
                        H = new za(ce),
                        G = new Na(ce,H,e),
                        H.init(G),
                        se = new Cs(ce,H,G),
                        j = new Es(ce,H,G),
                        j.scissor(S.copy(D).multiplyScalar(C).floor()),
                        j.viewport(M.copy(L).multiplyScalar(C).floor()),
                        V = new Ga(ce),
                        W = new ds,
                        q = new As(ce,H,j,W,G,se,V),
                        X = new ka(f),
                        Y = new Ca(ce,G),
                        le = new Fa(ce,H,Y,G),
                        Z = new Ua(ce,Y,V,le),
                        J = new qa(ce,Z,Y,V),
                        ie = new Wa(ce),
                        ne = new Ba(W),
                        K = new hs(f,X,H,G,le,ne),
                        $ = new Os(W),
                        ee = new gs(W),
                        te = new ws(H,G),
                        re = new Oa(f,X,j,J,s),
                        ae = new Ia(ce,H,V,G),
                        oe = new Ha(ce,H,V,G),
                        V.programs = K.programs,
                        f.capabilities = G,
                        f.extensions = H,
                        f.properties = W,
                        f.renderLists = ee,
                        f.state = j,
                        f.info = V
                    }
                    he();
                    const de = new Ds(f,ce);
                    this.xr = de;
                    const pe = new Ts(f,J,G.maxTextureSize);
                    function fe(e) {
                        e.preventDefault(),
                        console.log("THREE.WebGLRenderer: Context Lost."),
                        m = !0
                    }
                    function me() {
                        console.log("THREE.WebGLRenderer: Context Restored."),
                        m = !1,
                        he()
                    }
                    function ge(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", ge),
                        function(e) {
                            ve(e),
                            W.remove(e)
                        }(t)
                    }
                    function ve(e) {
                        const t = W.get(e).program;
                        void 0 !== t && K.releaseProgram(t)
                    }
                    this.shadowMap = pe,
                    this.getContext = function() {
                        return ce
                    }
                    ,
                    this.getContextAttributes = function() {
                        return ce.getContextAttributes()
                    }
                    ,
                    this.forceContextLoss = function() {
                        const e = H.get("WEBGL_lose_context");
                        e && e.loseContext()
                    }
                    ,
                    this.forceContextRestore = function() {
                        const e = H.get("WEBGL_lose_context");
                        e && e.restoreContext()
                    }
                    ,
                    this.getPixelRatio = function() {
                        return C
                    }
                    ,
                    this.setPixelRatio = function(e) {
                        void 0 !== e && (C = e,
                        this.setSize(E, A, !1))
                    }
                    ,
                    this.getSize = function(e) {
                        return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
                        e = new Un),
                        e.set(E, A)
                    }
                    ,
                    this.setSize = function(e, n, r) {
                        de.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = e,
                        A = n,
                        t.width = Math.floor(e * C),
                        t.height = Math.floor(n * C),
                        !1 !== r && (t.style.width = e + "px",
                        t.style.height = n + "px"),
                        this.setViewport(0, 0, e, n))
                    }
                    ,
                    this.getDrawingBufferSize = function(e) {
                        return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
                        e = new Un),
                        e.set(E * C, A * C).floor()
                    }
                    ,
                    this.setDrawingBufferSize = function(e, n, r) {
                        E = e,
                        A = n,
                        C = r,
                        t.width = Math.floor(e * r),
                        t.height = Math.floor(n * r),
                        this.setViewport(0, 0, e, n)
                    }
                    ,
                    this.getCurrentViewport = function(e) {
                        return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
                        e = new Xn),
                        e.copy(M)
                    }
                    ,
                    this.getViewport = function(e) {
                        return e.copy(L)
                    }
                    ,
                    this.setViewport = function(e, t, n, r) {
                        e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, r),
                        j.viewport(M.copy(L).multiplyScalar(C).floor())
                    }
                    ,
                    this.getScissor = function(e) {
                        return e.copy(D)
                    }
                    ,
                    this.setScissor = function(e, t, n, r) {
                        e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r),
                        j.scissor(S.copy(D).multiplyScalar(C).floor())
                    }
                    ,
                    this.getScissorTest = function() {
                        return O
                    }
                    ,
                    this.setScissorTest = function(e) {
                        j.setScissorTest(O = e)
                    }
                    ,
                    this.setOpaqueSort = function(e) {
                        P = e
                    }
                    ,
                    this.setTransparentSort = function(e) {
                        R = e
                    }
                    ,
                    this.getClearColor = function(e) {
                        return void 0 === e && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
                        e = new yi),
                        e.copy(re.getClearColor())
                    }
                    ,
                    this.setClearColor = function() {
                        re.setClearColor.apply(re, arguments)
                    }
                    ,
                    this.getClearAlpha = function() {
                        return re.getClearAlpha()
                    }
                    ,
                    this.setClearAlpha = function() {
                        re.setClearAlpha.apply(re, arguments)
                    }
                    ,
                    this.clear = function(e, t, n) {
                        let r = 0;
                        (void 0 === e || e) && (r |= 16384),
                        (void 0 === t || t) && (r |= 256),
                        (void 0 === n || n) && (r |= 1024),
                        ce.clear(r)
                    }
                    ,
                    this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }
                    ,
                    this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }
                    ,
                    this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }
                    ,
                    this.dispose = function() {
                        t.removeEventListener("webglcontextlost", fe, !1),
                        t.removeEventListener("webglcontextrestored", me, !1),
                        ee.dispose(),
                        te.dispose(),
                        W.dispose(),
                        X.dispose(),
                        J.dispose(),
                        le.dispose(),
                        de.dispose(),
                        _e.stop()
                    }
                    ,
                    this.renderBufferImmediate = function(e, t) {
                        le.initAttributes();
                        const n = W.get(e);
                        e.hasPositions && !n.position && (n.position = ce.createBuffer()),
                        e.hasNormals && !n.normal && (n.normal = ce.createBuffer()),
                        e.hasUvs && !n.uv && (n.uv = ce.createBuffer()),
                        e.hasColors && !n.color && (n.color = ce.createBuffer());
                        const r = t.getAttributes();
                        e.hasPositions && (ce.bindBuffer(34962, n.position),
                        ce.bufferData(34962, e.positionArray, 35048),
                        le.enableAttribute(r.position),
                        ce.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
                        e.hasNormals && (ce.bindBuffer(34962, n.normal),
                        ce.bufferData(34962, e.normalArray, 35048),
                        le.enableAttribute(r.normal),
                        ce.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
                        e.hasUvs && (ce.bindBuffer(34962, n.uv),
                        ce.bufferData(34962, e.uvArray, 35048),
                        le.enableAttribute(r.uv),
                        ce.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
                        e.hasColors && (ce.bindBuffer(34962, n.color),
                        ce.bufferData(34962, e.colorArray, 35048),
                        le.enableAttribute(r.color),
                        ce.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
                        le.disableUnusedAttributes(),
                        ce.drawArrays(4, 0, e.count),
                        e.count = 0
                    }
                    ,
                    this.renderBufferDirect = function(e, t, n, r, i, a) {
                        null === t && (t = z);
                        const o = i.isMesh && i.matrixWorld.determinant() < 0
                          , s = Te(e, t, r, i);
                        j.setMaterial(r, o);
                        let l = n.index;
                        const c = n.attributes.position;
                        if (null === l) {
                            if (void 0 === c || 0 === c.count)
                                return
                        } else if (0 === l.count)
                            return;
                        let u, h = 1;
                        !0 === r.wireframe && (l = Z.getWireframeAttribute(n),
                        h = 2),
                        (r.morphTargets || r.morphNormals) && ie.update(i, n, r, s),
                        le.setup(i, r, s, n, l);
                        let d = ae;
                        null !== l && (u = Y.get(l),
                        d = oe,
                        d.setIndex(u));
                        const p = null !== l ? l.count : c.count
                          , f = n.drawRange.start * h
                          , m = n.drawRange.count * h
                          , g = null !== a ? a.start * h : 0
                          , v = null !== a ? a.count * h : 1 / 0
                          , y = Math.max(f, g)
                          , _ = Math.min(p, f + m, g + v) - 1
                          , x = Math.max(0, _ - y + 1);
                        if (0 !== x) {
                            if (i.isMesh)
                                !0 === r.wireframe ? (j.setLineWidth(r.wireframeLinewidth * U()),
                                d.setMode(1)) : d.setMode(4);
                            else if (i.isLine) {
                                let e = r.linewidth;
                                void 0 === e && (e = 1),
                                j.setLineWidth(e * U()),
                                i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else
                                i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
                            if (i.isInstancedMesh)
                                d.renderInstances(y, x, i.count);
                            else if (n.isInstancedBufferGeometry) {
                                const e = Math.min(n.instanceCount, n._maxInstanceCount);
                                d.renderInstances(y, x, e)
                            } else
                                d.render(y, x)
                        }
                    }
                    ,
                    this.compile = function(e, t) {
                        d = te.get(e),
                        d.init(),
                        e.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (d.pushLight(e),
                            e.castShadow && d.pushShadow(e))
                        }
                        )),
                        d.setupLights();
                        const n = new WeakMap;
                        e.traverse((function(t) {
                            const r = t.material;
                            if (r)
                                if (Array.isArray(r))
                                    for (let i = 0; i < r.length; i++) {
                                        const a = r[i];
                                        !1 === n.has(a) && (Me(a, e, t),
                                        n.set(a))
                                    }
                                else
                                    !1 === n.has(r) && (Me(r, e, t),
                                    n.set(r))
                        }
                        ))
                    }
                    ;
                    let ye = null;
                    const _e = new Aa;
                    function xe(e, t, n, r) {
                        if (!1 === e.visible)
                            return;
                        if (e.layers.test(t.layers))
                            if (e.isGroup)
                                n = e.renderOrder;
                            else if (e.isLOD)
                                !0 === e.autoUpdate && e.update(t);
                            else if (e.isLight)
                                d.pushLight(e),
                                e.castShadow && d.pushShadow(e);
                            else if (e.isSprite) {
                                if (!e.frustumCulled || F.intersectsSprite(e)) {
                                    r && k.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B);
                                    const t = J.update(e)
                                      , i = e.material;
                                    i.visible && h.push(e, t, i, n, k.z, null)
                                }
                            } else if (e.isImmediateRenderObject)
                                r && k.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B),
                                h.push(e, null, e.material, n, k.z, null);
                            else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== V.render.frame && (e.skeleton.update(),
                            e.skeleton.frame = V.render.frame),
                            !e.frustumCulled || F.intersectsObject(e))) {
                                r && k.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B);
                                const t = J.update(e)
                                  , i = e.material;
                                if (Array.isArray(i)) {
                                    const r = t.groups;
                                    for (let a = 0, o = r.length; a < o; a++) {
                                        const o = r[a]
                                          , s = i[o.materialIndex];
                                        s && s.visible && h.push(e, t, s, n, k.z, o)
                                    }
                                } else
                                    i.visible && h.push(e, t, i, n, k.z, null)
                            }
                        const i = e.children;
                        for (let e = 0, a = i.length; e < a; e++)
                            xe(i[e], t, n, r)
                    }
                    function be(e, t, n) {
                        const r = !0 === t.isScene ? t.overrideMaterial : null;
                        for (let i = 0, a = e.length; i < a; i++) {
                            const a = e[i]
                              , o = a.object
                              , s = a.geometry
                              , l = null === r ? a.material : r
                              , c = a.group;
                            if (n.isArrayCamera) {
                                const e = n.cameras;
                                for (let n = 0, r = e.length; n < r; n++) {
                                    const r = e[n];
                                    o.layers.test(r.layers) && (j.viewport(M.copy(r.viewport)),
                                    d.setupLightsView(r),
                                    we(o, t, r, s, l, c))
                                }
                            } else
                                we(o, t, n, s, l, c)
                        }
                    }
                    function we(e, t, n, r, i, a) {
                        if (e.onBeforeRender(f, t, n, r, i, a),
                        e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                        e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                        e.isImmediateRenderObject) {
                            const r = Te(n, t, i, e);
                            j.setMaterial(i),
                            le.reset(),
                            function(e, t) {
                                e.render((function(e) {
                                    f.renderBufferImmediate(e, t)
                                }
                                ))
                            }(e, r)
                        } else
                            f.renderBufferDirect(n, t, r, i, e, a);
                        e.onAfterRender(f, t, n, r, i, a)
                    }
                    function Me(e, t, n) {
                        !0 !== t.isScene && (t = z);
                        const r = W.get(e)
                          , i = d.state.lights
                          , a = d.state.shadowsArray
                          , o = i.state.version
                          , s = K.getParameters(e, i.state, a, t, n)
                          , l = K.getProgramCacheKey(s);
                        let c = r.program
                          , u = !0;
                        if (r.environment = e.isMeshStandardMaterial ? t.environment : null,
                        r.fog = t.fog,
                        r.envMap = X.get(e.envMap || r.environment),
                        void 0 === c)
                            e.addEventListener("dispose", ge);
                        else if (c.cacheKey !== l)
                            ve(e);
                        else if (r.lightsStateVersion !== o)
                            u = !1;
                        else {
                            if (void 0 !== s.shaderID)
                                return;
                            u = !1
                        }
                        u && (s.uniforms = K.getUniforms(e),
                        e.onBeforeCompile(s, f),
                        c = K.acquireProgram(s, l),
                        r.program = c,
                        r.uniforms = s.uniforms,
                        r.outputEncoding = s.outputEncoding);
                        const h = r.uniforms;
                        (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = ne.numPlanes,
                        r.numIntersection = ne.numIntersection,
                        h.clippingPlanes = ne.uniform),
                        r.needsLights = function(e) {
                            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                        }(e),
                        r.lightsStateVersion = o,
                        r.needsLights && (h.ambientLightColor.value = i.state.ambient,
                        h.lightProbe.value = i.state.probe,
                        h.directionalLights.value = i.state.directional,
                        h.directionalLightShadows.value = i.state.directionalShadow,
                        h.spotLights.value = i.state.spot,
                        h.spotLightShadows.value = i.state.spotShadow,
                        h.rectAreaLights.value = i.state.rectArea,
                        h.ltc_1.value = i.state.rectAreaLTC1,
                        h.ltc_2.value = i.state.rectAreaLTC2,
                        h.pointLights.value = i.state.point,
                        h.pointLightShadows.value = i.state.pointShadow,
                        h.hemisphereLights.value = i.state.hemi,
                        h.directionalShadowMap.value = i.state.directionalShadowMap,
                        h.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
                        h.spotShadowMap.value = i.state.spotShadowMap,
                        h.spotShadowMatrix.value = i.state.spotShadowMatrix,
                        h.pointShadowMap.value = i.state.pointShadowMap,
                        h.pointShadowMatrix.value = i.state.pointShadowMatrix);
                        const p = r.program.getUniforms()
                          , m = Vo.seqWithValue(p.seq, h);
                        r.uniformsList = m
                    }
                    function Te(e, t, n, r) {
                        !0 !== t.isScene && (t = z),
                        q.resetTextureUnits();
                        const i = t.fog
                          , a = n.isMeshStandardMaterial ? t.environment : null
                          , o = null === _ ? f.outputEncoding : _.texture.encoding
                          , s = X.get(n.envMap || a)
                          , l = W.get(n)
                          , c = d.state.lights;
                        if (!0 === I && (!0 === N || e !== w)) {
                            const t = e === w && n.id === b;
                            ne.setState(n, e, t)
                        }
                        n.version === l.__version ? n.fog && l.fog !== i || l.environment !== a || l.needsLights && l.lightsStateVersion !== c.state.version ? Me(n, t, r) : void 0 === l.numClippingPlanes || l.numClippingPlanes === ne.numPlanes && l.numIntersection === ne.numIntersection ? (l.outputEncoding !== o || l.envMap !== s) && Me(n, t, r) : Me(n, t, r) : (Me(n, t, r),
                        l.__version = n.version);
                        let u = !1
                          , h = !1
                          , p = !1;
                        const m = l.program
                          , g = m.getUniforms()
                          , v = l.uniforms;
                        if (j.useProgram(m.program) && (u = !0,
                        h = !0,
                        p = !0),
                        n.id !== b && (b = n.id,
                        h = !0),
                        u || w !== e) {
                            if (g.setValue(ce, "projectionMatrix", e.projectionMatrix),
                            G.logarithmicDepthBuffer && g.setValue(ce, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                            w !== e && (w = e,
                            h = !0,
                            p = !0),
                            n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                                const t = g.map.cameraPosition;
                                void 0 !== t && t.setValue(ce, k.setFromMatrixPosition(e.matrixWorld))
                            }
                            (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(ce, "isOrthographic", !0 === e.isOrthographicCamera),
                            (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(ce, "viewMatrix", e.matrixWorldInverse)
                        }
                        if (n.skinning) {
                            g.setOptional(ce, r, "bindMatrix"),
                            g.setOptional(ce, r, "bindMatrixInverse");
                            const e = r.skeleton;
                            if (e) {
                                const t = e.bones;
                                if (G.floatVertexTextures) {
                                    if (null === e.boneTexture) {
                                        let n = Math.sqrt(4 * t.length);
                                        n = zn.ceilPowerOfTwo(n),
                                        n = Math.max(n, 4);
                                        const r = new Float32Array(n * n * 4);
                                        r.set(e.boneMatrices);
                                        const i = new Ma(r,n,n,ke,Re);
                                        e.boneMatrices = r,
                                        e.boneTexture = i,
                                        e.boneTextureSize = n
                                    }
                                    g.setValue(ce, "boneTexture", e.boneTexture, q),
                                    g.setValue(ce, "boneTextureSize", e.boneTextureSize)
                                } else
                                    g.setOptional(ce, e, "boneMatrices")
                            }
                        }
                        var y, x;
                        return (h || l.receiveShadow !== r.receiveShadow) && (l.receiveShadow = r.receiveShadow,
                        g.setValue(ce, "receiveShadow", r.receiveShadow)),
                        h && (g.setValue(ce, "toneMappingExposure", f.toneMappingExposure),
                        l.needsLights && (x = p,
                        (y = v).ambientLightColor.needsUpdate = x,
                        y.lightProbe.needsUpdate = x,
                        y.directionalLights.needsUpdate = x,
                        y.directionalLightShadows.needsUpdate = x,
                        y.pointLights.needsUpdate = x,
                        y.pointLightShadows.needsUpdate = x,
                        y.spotLights.needsUpdate = x,
                        y.spotLightShadows.needsUpdate = x,
                        y.rectAreaLights.needsUpdate = x,
                        y.hemisphereLights.needsUpdate = x),
                        i && n.fog && $.refreshFogUniforms(v, i),
                        $.refreshMaterialUniforms(v, n, C, A),
                        Vo.upload(ce, l.uniformsList, v, q)),
                        n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Vo.upload(ce, l.uniformsList, v, q),
                        n.uniformsNeedUpdate = !1),
                        n.isSpriteMaterial && g.setValue(ce, "center", r.center),
                        g.setValue(ce, "modelViewMatrix", r.modelViewMatrix),
                        g.setValue(ce, "normalMatrix", r.normalMatrix),
                        g.setValue(ce, "modelMatrix", r.matrixWorld),
                        m
                    }
                    _e.setAnimationLoop((function(e) {
                        de.isPresenting || ye && ye(e)
                    }
                    )),
                    "undefined" != typeof window && _e.setContext(window),
                    this.setAnimationLoop = function(e) {
                        ye = e,
                        de.setAnimationLoop(e),
                        null === e ? _e.stop() : _e.start()
                    }
                    ,
                    this.render = function(e, t) {
                        let n, r;
                        if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
                        n = arguments[2]),
                        void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
                        r = arguments[3]),
                        void 0 !== t && !0 !== t.isCamera)
                            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === m)
                            return;
                        le.resetDefaultState(),
                        b = -1,
                        w = null,
                        !0 === e.autoUpdate && e.updateMatrixWorld(),
                        null === t.parent && t.updateMatrixWorld(),
                        !0 === de.enabled && !0 === de.isPresenting && (t = de.getCamera(t)),
                        !0 === e.isScene && e.onBeforeRender(f, e, t, n || _),
                        d = te.get(e, p.length),
                        d.init(),
                        p.push(d),
                        B.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        F.setFromProjectionMatrix(B),
                        N = this.localClippingEnabled,
                        I = ne.init(this.clippingPlanes, N, t),
                        h = ee.get(e, t),
                        h.init(),
                        xe(e, t, 0, f.sortObjects),
                        h.finish(),
                        !0 === f.sortObjects && h.sort(P, R),
                        !0 === I && ne.beginShadows();
                        const i = d.state.shadowsArray;
                        pe.render(i, e, t),
                        d.setupLights(),
                        d.setupLightsView(t),
                        !0 === I && ne.endShadows(),
                        !0 === this.info.autoReset && this.info.reset(),
                        void 0 !== n && this.setRenderTarget(n),
                        re.render(h, e, t, r);
                        const a = h.opaque
                          , o = h.transparent;
                        a.length > 0 && be(a, e, t),
                        o.length > 0 && be(o, e, t),
                        !0 === e.isScene && e.onAfterRender(f, e, t),
                        null !== _ && (q.updateRenderTargetMipmap(_),
                        q.updateMultisampleRenderTarget(_)),
                        j.buffers.depth.setTest(!0),
                        j.buffers.depth.setMask(!0),
                        j.buffers.color.setMask(!0),
                        j.setPolygonOffset(!1),
                        p.pop(),
                        d = p.length > 0 ? p[p.length - 1] : null,
                        h = null
                    }
                    ,
                    this.setFramebuffer = function(e) {
                        g !== e && null === _ && ce.bindFramebuffer(36160, e),
                        g = e
                    }
                    ,
                    this.getActiveCubeFace = function() {
                        return v
                    }
                    ,
                    this.getActiveMipmapLevel = function() {
                        return y
                    }
                    ,
                    this.getRenderList = function() {
                        return h
                    }
                    ,
                    this.setRenderList = function(e) {
                        h = e
                    }
                    ,
                    this.getRenderTarget = function() {
                        return _
                    }
                    ,
                    this.setRenderTarget = function(e, t=0, n=0) {
                        _ = e,
                        v = t,
                        y = n,
                        e && void 0 === W.get(e).__webglFramebuffer && q.setupRenderTarget(e);
                        let r = g
                          , i = !1;
                        if (e) {
                            const n = W.get(e).__webglFramebuffer;
                            e.isWebGLCubeRenderTarget ? (r = n[t],
                            i = !0) : r = e.isWebGLMultisampleRenderTarget ? W.get(e).__webglMultisampledFramebuffer : n,
                            M.copy(e.viewport),
                            S.copy(e.scissor),
                            T = e.scissorTest
                        } else
                            M.copy(L).multiplyScalar(C).floor(),
                            S.copy(D).multiplyScalar(C).floor(),
                            T = O;
                        if (x !== r && (ce.bindFramebuffer(36160, r),
                        x = r),
                        j.viewport(M),
                        j.scissor(S),
                        j.setScissorTest(T),
                        i) {
                            const r = W.get(e.texture);
                            ce.framebufferTexture2D(36160, 36064, 34069 + t, r.__webglTexture, n)
                        }
                    }
                    ,
                    this.readRenderTargetPixels = function(e, t, n, r, i, a, o) {
                        if (!e || !e.isWebGLRenderTarget)
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let s = W.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]),
                        s) {
                            let o = !1;
                            s !== x && (ce.bindFramebuffer(36160, s),
                            o = !0);
                            try {
                                const s = e.texture
                                  , l = s.format
                                  , c = s.type;
                                if (l !== ke && se.convert(l) !== ce.getParameter(35739))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const u = c === Le && (H.has("EXT_color_buffer_half_float") || G.isWebGL2 && H.has("EXT_color_buffer_float"));
                                if (!(c === Se || se.convert(c) === ce.getParameter(35738) || c === Re && (G.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || u))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === ce.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ce.readPixels(t, n, r, i, se.convert(l), se.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                o && ce.bindFramebuffer(36160, x)
                            }
                        }
                    }
                    ,
                    this.copyFramebufferToTexture = function(e, t, n=0) {
                        const r = Math.pow(2, -n)
                          , i = Math.floor(t.image.width * r)
                          , a = Math.floor(t.image.height * r)
                          , o = se.convert(t.format);
                        q.setTexture2D(t, 0),
                        ce.copyTexImage2D(3553, n, o, e.x, e.y, i, a, 0),
                        j.unbindTexture()
                    }
                    ,
                    this.copyTextureToTexture = function(e, t, n, r=0) {
                        const i = t.image.width
                          , a = t.image.height
                          , o = se.convert(n.format)
                          , s = se.convert(n.type);
                        q.setTexture2D(n, 0),
                        ce.pixelStorei(37440, n.flipY),
                        ce.pixelStorei(37441, n.premultiplyAlpha),
                        ce.pixelStorei(3317, n.unpackAlignment),
                        t.isDataTexture ? ce.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data) : t.isCompressedTexture ? ce.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : ce.texSubImage2D(3553, r, e.x, e.y, o, s, t.image),
                        0 === r && n.generateMipmaps && ce.generateMipmap(3553),
                        j.unbindTexture()
                    }
                    ,
                    this.initTexture = function(e) {
                        q.setTexture2D(e, 0),
                        j.unbindTexture()
                    }
                    ,
                    this.resetState = function() {
                        j.reset(),
                        le.reset()
                    }
                    ,
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                        detail: this
                    }))
                }
                function Is(e) {
                    Fs.call(this, e)
                }
                Ms.prototype = Object.create(bi.prototype),
                Ms.prototype.constructor = Ms,
                Ms.prototype.isMeshDepthMaterial = !0,
                Ms.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.depthPacking = e.depthPacking,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this
                }
                ,
                Ss.prototype = Object.create(bi.prototype),
                Ss.prototype.constructor = Ss,
                Ss.prototype.isMeshDistanceMaterial = !0,
                Ss.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.referencePosition.copy(e.referencePosition),
                    this.nearDistance = e.nearDistance,
                    this.farDistance = e.farDistance,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this
                }
                ,
                Ps.prototype = Object.assign(Object.create(ya.prototype), {
                    constructor: Ps,
                    isArrayCamera: !0
                }),
                Rs.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: Rs,
                    isGroup: !0
                }),
                Object.assign(Ls.prototype, {
                    constructor: Ls,
                    getHandSpace: function() {
                        return null === this._hand && (this._hand = new Rs,
                        this._hand.matrixAutoUpdate = !1,
                        this._hand.visible = !1,
                        this._hand.joints = {},
                        this._hand.inputState = {
                            pinching: !1
                        }),
                        this._hand
                    },
                    getTargetRaySpace: function() {
                        return null === this._targetRay && (this._targetRay = new Rs,
                        this._targetRay.matrixAutoUpdate = !1,
                        this._targetRay.visible = !1),
                        this._targetRay
                    },
                    getGripSpace: function() {
                        return null === this._grip && (this._grip = new Rs,
                        this._grip.matrixAutoUpdate = !1,
                        this._grip.visible = !1),
                        this._grip
                    },
                    dispatchEvent: function(e) {
                        return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                        null !== this._grip && this._grip.dispatchEvent(e),
                        null !== this._hand && this._hand.dispatchEvent(e),
                        this
                    },
                    disconnect: function(e) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }),
                        null !== this._targetRay && (this._targetRay.visible = !1),
                        null !== this._grip && (this._grip.visible = !1),
                        null !== this._hand && (this._hand.visible = !1),
                        this
                    },
                    update: function(e, t, n) {
                        let r = null
                          , i = null
                          , a = null;
                        const o = this._targetRay
                          , s = this._grip
                          , l = this._hand;
                        if (e && "visible-blurred" !== t.session.visibilityState)
                            if (l && e.hand) {
                                a = !0;
                                for (const r of e.hand.values()) {
                                    const e = t.getJointPose(r, n);
                                    if (void 0 === l.joints[r.jointName]) {
                                        const e = new Rs;
                                        e.matrixAutoUpdate = !1,
                                        e.visible = !1,
                                        l.joints[r.jointName] = e,
                                        l.add(e)
                                    }
                                    const i = l.joints[r.jointName];
                                    null !== e && (i.matrix.fromArray(e.transform.matrix),
                                    i.matrix.decompose(i.position, i.rotation, i.scale),
                                    i.jointRadius = e.radius),
                                    i.visible = null !== e
                                }
                                const r = l.joints["index-finger-tip"]
                                  , i = l.joints["thumb-tip"]
                                  , o = r.position.distanceTo(i.position)
                                  , s = .02
                                  , c = .005;
                                l.inputState.pinching && o > s + c ? (l.inputState.pinching = !1,
                                this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: e.handedness,
                                    target: this
                                })) : !l.inputState.pinching && o <= s - c && (l.inputState.pinching = !0,
                                this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: e.handedness,
                                    target: this
                                }))
                            } else
                                null !== o && (r = t.getPose(e.targetRaySpace, n),
                                null !== r && (o.matrix.fromArray(r.transform.matrix),
                                o.matrix.decompose(o.position, o.rotation, o.scale))),
                                null !== s && e.gripSpace && (i = t.getPose(e.gripSpace, n),
                                null !== i && (s.matrix.fromArray(i.transform.matrix),
                                s.matrix.decompose(s.position, s.rotation, s.scale)));
                        return null !== o && (o.visible = null !== r),
                        null !== s && (s.visible = null !== i),
                        null !== l && (l.visible = null !== a),
                        this
                    }
                }),
                Object.assign(Ds.prototype, Nn.prototype),
                Is.prototype = Object.assign(Object.create(Fs.prototype), {
                    constructor: Is,
                    isWebGL1Renderer: !0
                });
                class Ns {
                    constructor(e, t) {
                        Object.defineProperty(this, "isFogExp2", {
                            value: !0
                        }),
                        this.name = "",
                        this.color = new yi(e),
                        this.density = void 0 !== t ? t : 25e-5
                    }
                    clone() {
                        return new Ns(this.color,this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                class Bs {
                    constructor(e, t, n) {
                        Object.defineProperty(this, "isFog", {
                            value: !0
                        }),
                        this.name = "",
                        this.color = new yi(e),
                        this.near = void 0 !== t ? t : 1,
                        this.far = void 0 !== n ? n : 1e3
                    }
                    clone() {
                        return new Bs(this.color,this.near,this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                class ks extends Jr {
                    constructor() {
                        super(),
                        Object.defineProperty(this, "isScene", {
                            value: !0
                        }),
                        this.type = "Scene",
                        this.background = null,
                        this.environment = null,
                        this.fog = null,
                        this.overrideMaterial = null,
                        this.autoUpdate = !0,
                        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                            detail: this
                        }))
                    }
                    copy(e, t) {
                        return super.copy(e, t),
                        null !== e.background && (this.background = e.background.clone()),
                        null !== e.environment && (this.environment = e.environment.clone()),
                        null !== e.fog && (this.fog = e.fog.clone()),
                        null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                        this.autoUpdate = e.autoUpdate,
                        this.matrixAutoUpdate = e.matrixAutoUpdate,
                        this
                    }
                    toJSON(e) {
                        const t = super.toJSON(e);
                        return null !== this.background && (t.object.background = this.background.toJSON(e)),
                        null !== this.environment && (t.object.environment = this.environment.toJSON(e)),
                        null !== this.fog && (t.object.fog = this.fog.toJSON()),
                        t
                    }
                }
                function zs(e, t) {
                    this.array = e,
                    this.stride = t,
                    this.count = void 0 !== e ? e.length / t : 0,
                    this.usage = Tn,
                    this.updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.version = 0,
                    this.uuid = zn.generateUUID()
                }
                Object.defineProperty(zs.prototype, "needsUpdate", {
                    set: function(e) {
                        !0 === e && this.version++
                    }
                }),
                Object.assign(zs.prototype, {
                    isInterleavedBuffer: !0,
                    onUploadCallback: function() {},
                    setUsage: function(e) {
                        return this.usage = e,
                        this
                    },
                    copy: function(e) {
                        return this.array = new e.array.constructor(e.array),
                        this.count = e.count,
                        this.stride = e.stride,
                        this.usage = e.usage,
                        this
                    },
                    copyAt: function(e, t, n) {
                        e *= this.stride,
                        n *= t.stride;
                        for (let r = 0, i = this.stride; r < i; r++)
                            this.array[e + r] = t.array[n + r];
                        return this
                    },
                    set: function(e, t=0) {
                        return this.array.set(e, t),
                        this
                    },
                    clone: function(e) {
                        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = zn.generateUUID()),
                        void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const t = new zs(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);
                        return t.setUsage(this.usage),
                        t
                    },
                    onUpload: function(e) {
                        return this.onUploadCallback = e,
                        this
                    },
                    toJSON: function(e) {
                        return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = zn.generateUUID()),
                        void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                });
                const Us = new Kn;
                function Hs(e, t, n, r) {
                    this.name = "",
                    this.data = e,
                    this.itemSize = t,
                    this.offset = n,
                    this.normalized = !0 === r
                }
                function Gs(e) {
                    bi.call(this),
                    this.type = "SpriteMaterial",
                    this.color = new yi(16777215),
                    this.map = null,
                    this.alphaMap = null,
                    this.rotation = 0,
                    this.sizeAttenuation = !0,
                    this.transparent = !0,
                    this.setValues(e)
                }
                let js;
                Object.defineProperties(Hs.prototype, {
                    count: {
                        get: function() {
                            return this.data.count
                        }
                    },
                    array: {
                        get: function() {
                            return this.data.array
                        }
                    },
                    needsUpdate: {
                        set: function(e) {
                            this.data.needsUpdate = e
                        }
                    }
                }),
                Object.assign(Hs.prototype, {
                    isInterleavedBufferAttribute: !0,
                    applyMatrix4: function(e) {
                        for (let t = 0, n = this.data.count; t < n; t++)
                            Us.x = this.getX(t),
                            Us.y = this.getY(t),
                            Us.z = this.getZ(t),
                            Us.applyMatrix4(e),
                            this.setXYZ(t, Us.x, Us.y, Us.z);
                        return this
                    },
                    setX: function(e, t) {
                        return this.data.array[e * this.data.stride + this.offset] = t,
                        this
                    },
                    setY: function(e, t) {
                        return this.data.array[e * this.data.stride + this.offset + 1] = t,
                        this
                    },
                    setZ: function(e, t) {
                        return this.data.array[e * this.data.stride + this.offset + 2] = t,
                        this
                    },
                    setW: function(e, t) {
                        return this.data.array[e * this.data.stride + this.offset + 3] = t,
                        this
                    },
                    getX: function(e) {
                        return this.data.array[e * this.data.stride + this.offset]
                    },
                    getY: function(e) {
                        return this.data.array[e * this.data.stride + this.offset + 1]
                    },
                    getZ: function(e) {
                        return this.data.array[e * this.data.stride + this.offset + 2]
                    },
                    getW: function(e) {
                        return this.data.array[e * this.data.stride + this.offset + 3]
                    },
                    setXY: function(e, t, n) {
                        return e = e * this.data.stride + this.offset,
                        this.data.array[e + 0] = t,
                        this.data.array[e + 1] = n,
                        this
                    },
                    setXYZ: function(e, t, n, r) {
                        return e = e * this.data.stride + this.offset,
                        this.data.array[e + 0] = t,
                        this.data.array[e + 1] = n,
                        this.data.array[e + 2] = r,
                        this
                    },
                    setXYZW: function(e, t, n, r, i) {
                        return e = e * this.data.stride + this.offset,
                        this.data.array[e + 0] = t,
                        this.data.array[e + 1] = n,
                        this.data.array[e + 2] = r,
                        this.data.array[e + 3] = i,
                        this
                    },
                    clone: function(e) {
                        if (void 0 === e) {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                            const e = [];
                            for (let t = 0; t < this.count; t++) {
                                const n = t * this.data.stride + this.offset;
                                for (let t = 0; t < this.itemSize; t++)
                                    e.push(this.data.array[n + t])
                            }
                            return new Ti(new this.array.constructor(e),this.itemSize,this.normalized)
                        }
                        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                        void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                        new Hs(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                    },
                    toJSON: function(e) {
                        if (void 0 === e) {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                            const e = [];
                            for (let t = 0; t < this.count; t++) {
                                const n = t * this.data.stride + this.offset;
                                for (let t = 0; t < this.itemSize; t++)
                                    e.push(this.data.array[n + t])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: e,
                                normalized: this.normalized
                            }
                        }
                        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                        void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                        {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized
                        }
                    }
                }),
                Gs.prototype = Object.create(bi.prototype),
                Gs.prototype.constructor = Gs,
                Gs.prototype.isSpriteMaterial = !0,
                Gs.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.rotation = e.rotation,
                    this.sizeAttenuation = e.sizeAttenuation,
                    this
                }
                ;
                const Vs = new Kn
                  , Ws = new Kn
                  , qs = new Kn
                  , Xs = new Un
                  , Ys = new Un
                  , Zs = new Tr
                  , Js = new Kn
                  , Ks = new Kn
                  , Qs = new Kn
                  , $s = new Un
                  , el = new Un
                  , tl = new Un;
                function nl(e) {
                    if (Jr.call(this),
                    this.type = "Sprite",
                    void 0 === js) {
                        js = new qi;
                        const e = new zs(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
                        js.setIndex([0, 1, 2, 0, 2, 3]),
                        js.setAttribute("position", new Hs(e,3,0,!1)),
                        js.setAttribute("uv", new Hs(e,2,3,!1))
                    }
                    this.geometry = js,
                    this.material = void 0 !== e ? e : new Gs,
                    this.center = new Un(.5,.5)
                }
                function rl(e, t, n, r, i, a) {
                    Xs.subVectors(e, n).addScalar(.5).multiply(r),
                    void 0 !== i ? (Ys.x = a * Xs.x - i * Xs.y,
                    Ys.y = i * Xs.x + a * Xs.y) : Ys.copy(Xs),
                    e.copy(t),
                    e.x += Ys.x,
                    e.y += Ys.y,
                    e.applyMatrix4(Zs)
                }
                nl.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: nl,
                    isSprite: !0,
                    raycast: function(e, t) {
                        null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                        Ws.setFromMatrixScale(this.matrixWorld),
                        Zs.copy(e.camera.matrixWorld),
                        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                        qs.setFromMatrixPosition(this.modelViewMatrix),
                        e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ws.multiplyScalar(-qs.z);
                        const n = this.material.rotation;
                        let r, i;
                        0 !== n && (i = Math.cos(n),
                        r = Math.sin(n));
                        const a = this.center;
                        rl(Js.set(-.5, -.5, 0), qs, a, Ws, r, i),
                        rl(Ks.set(.5, -.5, 0), qs, a, Ws, r, i),
                        rl(Qs.set(.5, .5, 0), qs, a, Ws, r, i),
                        $s.set(0, 0),
                        el.set(1, 0),
                        tl.set(1, 1);
                        let o = e.ray.intersectTriangle(Js, Ks, Qs, !1, Vs);
                        if (null === o && (rl(Ks.set(-.5, .5, 0), qs, a, Ws, r, i),
                        el.set(0, 1),
                        o = e.ray.intersectTriangle(Js, Qs, Ks, !1, Vs),
                        null === o))
                            return;
                        const s = e.ray.origin.distanceTo(Vs);
                        s < e.near || s > e.far || t.push({
                            distance: s,
                            point: Vs.clone(),
                            uv: hi.getUV(Vs, Js, Ks, Qs, $s, el, tl, new Un),
                            face: null,
                            object: this
                        })
                    },
                    copy: function(e) {
                        return Jr.prototype.copy.call(this, e),
                        void 0 !== e.center && this.center.copy(e.center),
                        this.material = e.material,
                        this
                    }
                });
                const il = new Kn
                  , al = new Kn;
                function ol() {
                    Jr.call(this),
                    this._currentLevel = 0,
                    this.type = "LOD",
                    Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        }
                    }),
                    this.autoUpdate = !0
                }
                ol.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: ol,
                    isLOD: !0,
                    copy: function(e) {
                        Jr.prototype.copy.call(this, e, !1);
                        const t = e.levels;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            this.addLevel(n.object.clone(), n.distance)
                        }
                        return this.autoUpdate = e.autoUpdate,
                        this
                    },
                    addLevel: function(e, t=0) {
                        t = Math.abs(t);
                        const n = this.levels;
                        let r;
                        for (r = 0; r < n.length && !(t < n[r].distance); r++)
                            ;
                        return n.splice(r, 0, {
                            distance: t,
                            object: e
                        }),
                        this.add(e),
                        this
                    },
                    getCurrentLevel: function() {
                        return this._currentLevel
                    },
                    getObjectForDistance: function(e) {
                        const t = this.levels;
                        if (t.length > 0) {
                            let n, r;
                            for (n = 1,
                            r = t.length; n < r && !(e < t[n].distance); n++)
                                ;
                            return t[n - 1].object
                        }
                        return null
                    },
                    raycast: function(e, t) {
                        if (this.levels.length > 0) {
                            il.setFromMatrixPosition(this.matrixWorld);
                            const n = e.ray.origin.distanceTo(il);
                            this.getObjectForDistance(n).raycast(e, t)
                        }
                    },
                    update: function(e) {
                        const t = this.levels;
                        if (t.length > 1) {
                            il.setFromMatrixPosition(e.matrixWorld),
                            al.setFromMatrixPosition(this.matrixWorld);
                            const n = il.distanceTo(al) / e.zoom;
                            let r, i;
                            for (t[0].object.visible = !0,
                            r = 1,
                            i = t.length; r < i && n >= t[r].distance; r++)
                                t[r - 1].object.visible = !1,
                                t[r].object.visible = !0;
                            for (this._currentLevel = r - 1; r < i; r++)
                                t[r].object.visible = !1
                        }
                    },
                    toJSON: function(e) {
                        const t = Jr.prototype.toJSON.call(this, e);
                        !1 === this.autoUpdate && (t.object.autoUpdate = !1),
                        t.object.levels = [];
                        const n = this.levels;
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = n[e];
                            t.object.levels.push({
                                object: r.object.uuid,
                                distance: r.distance
                            })
                        }
                        return t
                    }
                });
                const sl = new Kn
                  , ll = new Xn
                  , cl = new Xn
                  , ul = new Kn
                  , hl = new Tr;
                function dl(e, t) {
                    e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
                    ua.call(this, e, t),
                    this.type = "SkinnedMesh",
                    this.bindMode = "attached",
                    this.bindMatrix = new Tr,
                    this.bindMatrixInverse = new Tr
                }
                function pl() {
                    Jr.call(this),
                    this.type = "Bone"
                }
                dl.prototype = Object.assign(Object.create(ua.prototype), {
                    constructor: dl,
                    isSkinnedMesh: !0,
                    copy: function(e) {
                        return ua.prototype.copy.call(this, e),
                        this.bindMode = e.bindMode,
                        this.bindMatrix.copy(e.bindMatrix),
                        this.bindMatrixInverse.copy(e.bindMatrixInverse),
                        this.skeleton = e.skeleton,
                        this
                    },
                    bind: function(e, t) {
                        this.skeleton = e,
                        void 0 === t && (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        t = this.matrixWorld),
                        this.bindMatrix.copy(t),
                        this.bindMatrixInverse.copy(t).invert()
                    },
                    pose: function() {
                        this.skeleton.pose()
                    },
                    normalizeSkinWeights: function() {
                        const e = new Xn
                          , t = this.geometry.attributes.skinWeight;
                        for (let n = 0, r = t.count; n < r; n++) {
                            e.x = t.getX(n),
                            e.y = t.getY(n),
                            e.z = t.getZ(n),
                            e.w = t.getW(n);
                            const r = 1 / e.manhattanLength();
                            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                            t.setXYZW(n, e.x, e.y, e.z, e.w)
                        }
                    },
                    updateMatrixWorld: function(e) {
                        ua.prototype.updateMatrixWorld.call(this, e),
                        "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    },
                    boneTransform: function(e, t) {
                        const n = this.skeleton
                          , r = this.geometry;
                        ll.fromBufferAttribute(r.attributes.skinIndex, e),
                        cl.fromBufferAttribute(r.attributes.skinWeight, e),
                        sl.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix),
                        t.set(0, 0, 0);
                        for (let e = 0; e < 4; e++) {
                            const r = cl.getComponent(e);
                            if (0 !== r) {
                                const i = ll.getComponent(e);
                                hl.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
                                t.addScaledVector(ul.copy(sl).applyMatrix4(hl), r)
                            }
                        }
                        return t.applyMatrix4(this.bindMatrixInverse)
                    }
                }),
                pl.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: pl,
                    isBone: !0
                });
                const fl = new Tr
                  , ml = new Tr;
                function gl(e=[], t=[]) {
                    this.uuid = zn.generateUUID(),
                    this.bones = e.slice(0),
                    this.boneInverses = t,
                    this.boneMatrices = null,
                    this.boneTexture = null,
                    this.boneTextureSize = 0,
                    this.frame = -1,
                    this.init()
                }
                Object.assign(gl.prototype, {
                    init: function() {
                        const e = this.bones
                          , t = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * e.length),
                        0 === t.length)
                            this.calculateInverses();
                        else if (e.length !== t.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                            this.boneInverses = [];
                            for (let e = 0, t = this.bones.length; e < t; e++)
                                this.boneInverses.push(new Tr)
                        }
                    },
                    calculateInverses: function() {
                        this.boneInverses.length = 0;
                        for (let e = 0, t = this.bones.length; e < t; e++) {
                            const t = new Tr;
                            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                            this.boneInverses.push(t)
                        }
                    },
                    pose: function() {
                        for (let e = 0, t = this.bones.length; e < t; e++) {
                            const t = this.bones[e];
                            t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                        }
                        for (let e = 0, t = this.bones.length; e < t; e++) {
                            const t = this.bones[e];
                            t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                            t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                            t.matrix.decompose(t.position, t.quaternion, t.scale))
                        }
                    },
                    update: function() {
                        const e = this.bones
                          , t = this.boneInverses
                          , n = this.boneMatrices
                          , r = this.boneTexture;
                        for (let r = 0, i = e.length; r < i; r++) {
                            const i = e[r] ? e[r].matrixWorld : ml;
                            fl.multiplyMatrices(i, t[r]),
                            fl.toArray(n, 16 * r)
                        }
                        null !== r && (r.needsUpdate = !0)
                    },
                    clone: function() {
                        return new gl(this.bones,this.boneInverses)
                    },
                    getBoneByName: function(e) {
                        for (let t = 0, n = this.bones.length; t < n; t++) {
                            const n = this.bones[t];
                            if (n.name === e)
                                return n
                        }
                    },
                    dispose: function() {
                        null !== this.boneTexture && (this.boneTexture.dispose(),
                        this.boneTexture = null)
                    },
                    fromJSON: function(e, t) {
                        this.uuid = e.uuid;
                        for (let n = 0, r = e.bones.length; n < r; n++) {
                            const r = e.bones[n];
                            let i = t[r];
                            void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
                            i = new pl),
                            this.bones.push(i),
                            this.boneInverses.push((new Tr).fromArray(e.boneInverses[n]))
                        }
                        return this.init(),
                        this
                    },
                    toJSON: function() {
                        const e = {
                            metadata: {
                                version: 4.5,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        e.uuid = this.uuid;
                        const t = this.bones
                          , n = this.boneInverses;
                        for (let r = 0, i = t.length; r < i; r++) {
                            const i = t[r];
                            e.bones.push(i.uuid);
                            const a = n[r];
                            e.boneInverses.push(a.toArray())
                        }
                        return e
                    }
                });
                const vl = new Tr
                  , yl = new Tr
                  , _l = []
                  , xl = new ua;
                function bl(e, t, n) {
                    ua.call(this, e, t),
                    this.instanceMatrix = new Ti(new Float32Array(16 * n),16),
                    this.instanceColor = null,
                    this.count = n,
                    this.frustumCulled = !1
                }
                function wl(e) {
                    bi.call(this),
                    this.type = "LineBasicMaterial",
                    this.color = new yi(16777215),
                    this.linewidth = 1,
                    this.linecap = "round",
                    this.linejoin = "round",
                    this.morphTargets = !1,
                    this.setValues(e)
                }
                bl.prototype = Object.assign(Object.create(ua.prototype), {
                    constructor: bl,
                    isInstancedMesh: !0,
                    copy: function(e) {
                        return ua.prototype.copy.call(this, e),
                        this.instanceMatrix.copy(e.instanceMatrix),
                        null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                        this.count = e.count,
                        this
                    },
                    getColorAt: function(e, t) {
                        t.fromArray(this.instanceColor.array, 3 * e)
                    },
                    getMatrixAt: function(e, t) {
                        t.fromArray(this.instanceMatrix.array, 16 * e)
                    },
                    raycast: function(e, t) {
                        const n = this.matrixWorld
                          , r = this.count;
                        if (xl.geometry = this.geometry,
                        xl.material = this.material,
                        void 0 !== xl.material)
                            for (let i = 0; i < r; i++) {
                                this.getMatrixAt(i, vl),
                                yl.multiplyMatrices(n, vl),
                                xl.matrixWorld = yl,
                                xl.raycast(e, _l);
                                for (let e = 0, n = _l.length; e < n; e++) {
                                    const n = _l[e];
                                    n.instanceId = i,
                                    n.object = this,
                                    t.push(n)
                                }
                                _l.length = 0
                            }
                    },
                    setColorAt: function(e, t) {
                        null === this.instanceColor && (this.instanceColor = new Ti(new Float32Array(3 * this.count),3)),
                        t.toArray(this.instanceColor.array, 3 * e)
                    },
                    setMatrixAt: function(e, t) {
                        t.toArray(this.instanceMatrix.array, 16 * e)
                    },
                    updateMorphTargets: function() {},
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }),
                wl.prototype = Object.create(bi.prototype),
                wl.prototype.constructor = wl,
                wl.prototype.isLineBasicMaterial = !0,
                wl.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.linewidth = e.linewidth,
                    this.linecap = e.linecap,
                    this.linejoin = e.linejoin,
                    this.morphTargets = e.morphTargets,
                    this
                }
                ;
                const Ml = new Kn
                  , Sl = new Kn
                  , Tl = new Tr
                  , El = new Sr
                  , Al = new gr;
                function Cl(e=new qi, t=new wl) {
                    Jr.call(this),
                    this.type = "Line",
                    this.geometry = e,
                    this.material = t,
                    this.updateMorphTargets()
                }
                Cl.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: Cl,
                    isLine: !0,
                    copy: function(e) {
                        return Jr.prototype.copy.call(this, e),
                        this.material = e.material,
                        this.geometry = e.geometry,
                        this
                    },
                    computeLineDistances: function() {
                        const e = this.geometry;
                        if (e.isBufferGeometry)
                            if (null === e.index) {
                                const t = e.attributes.position
                                  , n = [0];
                                for (let e = 1, r = t.count; e < r; e++)
                                    Ml.fromBufferAttribute(t, e - 1),
                                    Sl.fromBufferAttribute(t, e),
                                    n[e] = n[e - 1],
                                    n[e] += Ml.distanceTo(Sl);
                                e.setAttribute("lineDistance", new Fi(n,1))
                            } else
                                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else
                            e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    },
                    raycast: function(e, t) {
                        const n = this.geometry
                          , r = this.matrixWorld
                          , i = e.params.Line.threshold;
                        if (null === n.boundingSphere && n.computeBoundingSphere(),
                        Al.copy(n.boundingSphere),
                        Al.applyMatrix4(r),
                        Al.radius += i,
                        !1 === e.ray.intersectsSphere(Al))
                            return;
                        Tl.copy(r).invert(),
                        El.copy(e.ray).applyMatrix4(Tl);
                        const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , o = a * a
                          , s = new Kn
                          , l = new Kn
                          , c = new Kn
                          , u = new Kn
                          , h = this.isLineSegments ? 2 : 1;
                        if (n.isBufferGeometry) {
                            const r = n.index
                              , i = n.attributes.position;
                            if (null !== r) {
                                const n = r.array;
                                for (let r = 0, a = n.length - 1; r < a; r += h) {
                                    const a = n[r]
                                      , h = n[r + 1];
                                    if (s.fromBufferAttribute(i, a),
                                    l.fromBufferAttribute(i, h),
                                    El.distanceSqToSegment(s, l, u, c) > o)
                                        continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const d = e.ray.origin.distanceTo(u);
                                    d < e.near || d > e.far || t.push({
                                        distance: d,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: r,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else
                                for (let n = 0, r = i.count - 1; n < r; n += h) {
                                    if (s.fromBufferAttribute(i, n),
                                    l.fromBufferAttribute(i, n + 1),
                                    El.distanceSqToSegment(s, l, u, c) > o)
                                        continue;
                                    u.applyMatrix4(this.matrixWorld);
                                    const r = e.ray.origin.distanceTo(u);
                                    r < e.near || r > e.far || t.push({
                                        distance: r,
                                        point: c.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                        } else
                            n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    },
                    updateMorphTargets: function() {
                        const e = this.geometry;
                        if (e.isBufferGeometry) {
                            const t = e.morphAttributes
                              , n = Object.keys(t);
                            if (n.length > 0) {
                                const e = t[n[0]];
                                if (void 0 !== e) {
                                    this.morphTargetInfluences = [],
                                    this.morphTargetDictionary = {};
                                    for (let t = 0, n = e.length; t < n; t++) {
                                        const n = e[t].name || String(t);
                                        this.morphTargetInfluences.push(0),
                                        this.morphTargetDictionary[n] = t
                                    }
                                }
                            }
                        } else {
                            const t = e.morphTargets;
                            void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                });
                const Pl = new Kn
                  , Rl = new Kn;
                function Ll(e, t) {
                    Cl.call(this, e, t),
                    this.type = "LineSegments"
                }
                function Dl(e, t) {
                    Cl.call(this, e, t),
                    this.type = "LineLoop"
                }
                function Ol(e) {
                    bi.call(this),
                    this.type = "PointsMaterial",
                    this.color = new yi(16777215),
                    this.map = null,
                    this.alphaMap = null,
                    this.size = 1,
                    this.sizeAttenuation = !0,
                    this.morphTargets = !1,
                    this.setValues(e)
                }
                Ll.prototype = Object.assign(Object.create(Cl.prototype), {
                    constructor: Ll,
                    isLineSegments: !0,
                    computeLineDistances: function() {
                        const e = this.geometry;
                        if (e.isBufferGeometry)
                            if (null === e.index) {
                                const t = e.attributes.position
                                  , n = [];
                                for (let e = 0, r = t.count; e < r; e += 2)
                                    Pl.fromBufferAttribute(t, e),
                                    Rl.fromBufferAttribute(t, e + 1),
                                    n[e] = 0 === e ? 0 : n[e - 1],
                                    n[e + 1] = n[e] + Pl.distanceTo(Rl);
                                e.setAttribute("lineDistance", new Fi(n,1))
                            } else
                                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else
                            e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                }),
                Dl.prototype = Object.assign(Object.create(Cl.prototype), {
                    constructor: Dl,
                    isLineLoop: !0
                }),
                Ol.prototype = Object.create(bi.prototype),
                Ol.prototype.constructor = Ol,
                Ol.prototype.isPointsMaterial = !0,
                Ol.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.size = e.size,
                    this.sizeAttenuation = e.sizeAttenuation,
                    this.morphTargets = e.morphTargets,
                    this
                }
                ;
                const Fl = new Tr
                  , Il = new Sr
                  , Nl = new gr
                  , Bl = new Kn;
                function kl(e=new qi, t=new Ol) {
                    Jr.call(this),
                    this.type = "Points",
                    this.geometry = e,
                    this.material = t,
                    this.updateMorphTargets()
                }
                function zl(e, t, n, r, i, a, o) {
                    const s = Il.distanceSqToPoint(e);
                    if (s < n) {
                        const n = new Kn;
                        Il.closestPointToPoint(e, n),
                        n.applyMatrix4(r);
                        const l = i.ray.origin.distanceTo(n);
                        if (l < i.near || l > i.far)
                            return;
                        a.push({
                            distance: l,
                            distanceToRay: Math.sqrt(s),
                            point: n,
                            index: t,
                            face: null,
                            object: o
                        })
                    }
                }
                function Ul(e, t, n, r, i, a, o, s, l) {
                    Wn.call(this, e, t, n, r, i, a, o, s, l),
                    this.format = void 0 !== o ? o : Be,
                    this.minFilter = void 0 !== a ? a : _e,
                    this.magFilter = void 0 !== i ? i : _e,
                    this.generateMipmaps = !1;
                    const c = this;
                    "requestVideoFrameCallback"in e && e.requestVideoFrameCallback((function t() {
                        c.needsUpdate = !0,
                        e.requestVideoFrameCallback(t)
                    }
                    ))
                }
                function Hl(e, t, n, r, i, a, o, s, l, c, u, h) {
                    Wn.call(this, null, a, o, s, l, c, r, i, u, h),
                    this.image = {
                        width: t,
                        height: n
                    },
                    this.mipmaps = e,
                    this.flipY = !1,
                    this.generateMipmaps = !1
                }
                function Gl(e, t, n, r, i, a, o, s, l) {
                    Wn.call(this, e, t, n, r, i, a, o, s, l),
                    this.needsUpdate = !0
                }
                function jl(e, t, n, r, i, a, o, s, l, c) {
                    if ((c = void 0 !== c ? c : Ge) !== Ge && c !== je)
                        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && c === Ge && (n = Ae),
                    void 0 === n && c === je && (n = Ie),
                    Wn.call(this, null, r, i, a, o, s, c, n, l),
                    this.image = {
                        width: e,
                        height: t
                    },
                    this.magFilter = void 0 !== o ? o : fe,
                    this.minFilter = void 0 !== s ? s : fe,
                    this.flipY = !1,
                    this.generateMipmaps = !1
                }
                kl.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: kl,
                    isPoints: !0,
                    copy: function(e) {
                        return Jr.prototype.copy.call(this, e),
                        this.material = e.material,
                        this.geometry = e.geometry,
                        this
                    },
                    raycast: function(e, t) {
                        const n = this.geometry
                          , r = this.matrixWorld
                          , i = e.params.Points.threshold;
                        if (null === n.boundingSphere && n.computeBoundingSphere(),
                        Nl.copy(n.boundingSphere),
                        Nl.applyMatrix4(r),
                        Nl.radius += i,
                        !1 === e.ray.intersectsSphere(Nl))
                            return;
                        Fl.copy(r).invert(),
                        Il.copy(e.ray).applyMatrix4(Fl);
                        const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                          , o = a * a;
                        if (n.isBufferGeometry) {
                            const i = n.index
                              , a = n.attributes.position;
                            if (null !== i) {
                                const n = i.array;
                                for (let i = 0, s = n.length; i < s; i++) {
                                    const s = n[i];
                                    Bl.fromBufferAttribute(a, s),
                                    zl(Bl, s, o, r, e, t, this)
                                }
                            } else
                                for (let n = 0, i = a.count; n < i; n++)
                                    Bl.fromBufferAttribute(a, n),
                                    zl(Bl, n, o, r, e, t, this)
                        } else
                            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    },
                    updateMorphTargets: function() {
                        const e = this.geometry;
                        if (e.isBufferGeometry) {
                            const t = e.morphAttributes
                              , n = Object.keys(t);
                            if (n.length > 0) {
                                const e = t[n[0]];
                                if (void 0 !== e) {
                                    this.morphTargetInfluences = [],
                                    this.morphTargetDictionary = {};
                                    for (let t = 0, n = e.length; t < n; t++) {
                                        const n = e[t].name || String(t);
                                        this.morphTargetInfluences.push(0),
                                        this.morphTargetDictionary[n] = t
                                    }
                                }
                            }
                        } else {
                            const t = e.morphTargets;
                            void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }),
                Ul.prototype = Object.assign(Object.create(Wn.prototype), {
                    constructor: Ul,
                    clone: function() {
                        return new this.constructor(this.image).copy(this)
                    },
                    isVideoTexture: !0,
                    update: function() {
                        const e = this.image;
                        !1 == "requestVideoFrameCallback"in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                }),
                Hl.prototype = Object.create(Wn.prototype),
                Hl.prototype.constructor = Hl,
                Hl.prototype.isCompressedTexture = !0,
                Gl.prototype = Object.create(Wn.prototype),
                Gl.prototype.constructor = Gl,
                Gl.prototype.isCanvasTexture = !0,
                jl.prototype = Object.create(Wn.prototype),
                jl.prototype.constructor = jl,
                jl.prototype.isDepthTexture = !0;
                class Vl extends qi {
                    constructor(e=1, t=8, n=0, r=2 * Math.PI) {
                        super(),
                        this.type = "CircleGeometry",
                        this.parameters = {
                            radius: e,
                            segments: t,
                            thetaStart: n,
                            thetaLength: r
                        },
                        t = Math.max(3, t);
                        const i = []
                          , a = []
                          , o = []
                          , s = []
                          , l = new Kn
                          , c = new Un;
                        a.push(0, 0, 0),
                        o.push(0, 0, 1),
                        s.push(.5, .5);
                        for (let i = 0, u = 3; i <= t; i++,
                        u += 3) {
                            const h = n + i / t * r;
                            l.x = e * Math.cos(h),
                            l.y = e * Math.sin(h),
                            a.push(l.x, l.y, l.z),
                            o.push(0, 0, 1),
                            c.x = (a[u] / e + 1) / 2,
                            c.y = (a[u + 1] / e + 1) / 2,
                            s.push(c.x, c.y)
                        }
                        for (let e = 1; e <= t; e++)
                            i.push(e, e + 1, 0);
                        this.setIndex(i),
                        this.setAttribute("position", new Fi(a,3)),
                        this.setAttribute("normal", new Fi(o,3)),
                        this.setAttribute("uv", new Fi(s,2))
                    }
                }
                class Wl extends qi {
                    constructor(e=1, t=1, n=1, r=8, i=1, a=!1, o=0, s=2 * Math.PI) {
                        super(),
                        this.type = "CylinderGeometry",
                        this.parameters = {
                            radiusTop: e,
                            radiusBottom: t,
                            height: n,
                            radialSegments: r,
                            heightSegments: i,
                            openEnded: a,
                            thetaStart: o,
                            thetaLength: s
                        };
                        const l = this;
                        r = Math.floor(r),
                        i = Math.floor(i);
                        const c = []
                          , u = []
                          , h = []
                          , d = [];
                        let p = 0;
                        const f = []
                          , m = n / 2;
                        let g = 0;
                        function v(n) {
                            const i = p
                              , a = new Un
                              , f = new Kn;
                            let v = 0;
                            const y = !0 === n ? e : t
                              , _ = !0 === n ? 1 : -1;
                            for (let e = 1; e <= r; e++)
                                u.push(0, m * _, 0),
                                h.push(0, _, 0),
                                d.push(.5, .5),
                                p++;
                            const x = p;
                            for (let e = 0; e <= r; e++) {
                                const t = e / r * s + o
                                  , n = Math.cos(t)
                                  , i = Math.sin(t);
                                f.x = y * i,
                                f.y = m * _,
                                f.z = y * n,
                                u.push(f.x, f.y, f.z),
                                h.push(0, _, 0),
                                a.x = .5 * n + .5,
                                a.y = .5 * i * _ + .5,
                                d.push(a.x, a.y),
                                p++
                            }
                            for (let e = 0; e < r; e++) {
                                const t = i + e
                                  , r = x + e;
                                !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t),
                                v += 3
                            }
                            l.addGroup(g, v, !0 === n ? 1 : 2),
                            g += v
                        }
                        !function() {
                            const a = new Kn
                              , v = new Kn;
                            let y = 0;
                            const _ = (t - e) / n;
                            for (let l = 0; l <= i; l++) {
                                const c = []
                                  , g = l / i
                                  , y = g * (t - e) + e;
                                for (let e = 0; e <= r; e++) {
                                    const t = e / r
                                      , i = t * s + o
                                      , l = Math.sin(i)
                                      , f = Math.cos(i);
                                    v.x = y * l,
                                    v.y = -g * n + m,
                                    v.z = y * f,
                                    u.push(v.x, v.y, v.z),
                                    a.set(l, _, f).normalize(),
                                    h.push(a.x, a.y, a.z),
                                    d.push(t, 1 - g),
                                    c.push(p++)
                                }
                                f.push(c)
                            }
                            for (let e = 0; e < r; e++)
                                for (let t = 0; t < i; t++) {
                                    const n = f[t][e]
                                      , r = f[t + 1][e]
                                      , i = f[t + 1][e + 1]
                                      , a = f[t][e + 1];
                                    c.push(n, r, a),
                                    c.push(r, i, a),
                                    y += 6
                                }
                            l.addGroup(g, y, 0),
                            g += y
                        }(),
                        !1 === a && (e > 0 && v(!0),
                        t > 0 && v(!1)),
                        this.setIndex(c),
                        this.setAttribute("position", new Fi(u,3)),
                        this.setAttribute("normal", new Fi(h,3)),
                        this.setAttribute("uv", new Fi(d,2))
                    }
                }
                class ql extends Wl {
                    constructor(e=1, t=1, n=8, r=1, i=!1, a=0, o=2 * Math.PI) {
                        super(0, e, t, n, r, i, a, o),
                        this.type = "ConeGeometry",
                        this.parameters = {
                            radius: e,
                            height: t,
                            radialSegments: n,
                            heightSegments: r,
                            openEnded: i,
                            thetaStart: a,
                            thetaLength: o
                        }
                    }
                }
                class Xl extends qi {
                    constructor(e, t, n=1, r=0) {
                        super(),
                        this.type = "PolyhedronGeometry",
                        this.parameters = {
                            vertices: e,
                            indices: t,
                            radius: n,
                            detail: r
                        };
                        const i = []
                          , a = [];
                        function o(e, t, n, r) {
                            const i = r + 1
                              , a = [];
                            for (let r = 0; r <= i; r++) {
                                a[r] = [];
                                const o = e.clone().lerp(n, r / i)
                                  , s = t.clone().lerp(n, r / i)
                                  , l = i - r;
                                for (let e = 0; e <= l; e++)
                                    a[r][e] = 0 === e && r === i ? o : o.clone().lerp(s, e / l)
                            }
                            for (let e = 0; e < i; e++)
                                for (let t = 0; t < 2 * (i - e) - 1; t++) {
                                    const n = Math.floor(t / 2);
                                    t % 2 == 0 ? (s(a[e][n + 1]),
                                    s(a[e + 1][n]),
                                    s(a[e][n])) : (s(a[e][n + 1]),
                                    s(a[e + 1][n + 1]),
                                    s(a[e + 1][n]))
                                }
                        }
                        function s(e) {
                            i.push(e.x, e.y, e.z)
                        }
                        function l(t, n) {
                            const r = 3 * t;
                            n.x = e[r + 0],
                            n.y = e[r + 1],
                            n.z = e[r + 2]
                        }
                        function c(e, t, n, r) {
                            r < 0 && 1 === e.x && (a[t] = e.x - 1),
                            0 === n.x && 0 === n.z && (a[t] = r / 2 / Math.PI + .5)
                        }
                        function u(e) {
                            return Math.atan2(e.z, -e.x)
                        }
                        !function(e) {
                            const n = new Kn
                              , r = new Kn
                              , i = new Kn;
                            for (let a = 0; a < t.length; a += 3)
                                l(t[a + 0], n),
                                l(t[a + 1], r),
                                l(t[a + 2], i),
                                o(n, r, i, e)
                        }(r),
                        function(e) {
                            const t = new Kn;
                            for (let n = 0; n < i.length; n += 3)
                                t.x = i[n + 0],
                                t.y = i[n + 1],
                                t.z = i[n + 2],
                                t.normalize().multiplyScalar(e),
                                i[n + 0] = t.x,
                                i[n + 1] = t.y,
                                i[n + 2] = t.z
                        }(n),
                        function() {
                            const e = new Kn;
                            for (let n = 0; n < i.length; n += 3) {
                                e.x = i[n + 0],
                                e.y = i[n + 1],
                                e.z = i[n + 2];
                                const r = u(e) / 2 / Math.PI + .5
                                  , o = (t = e,
                                Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                                a.push(r, 1 - o)
                            }
                            var t;
                            (function() {
                                const e = new Kn
                                  , t = new Kn
                                  , n = new Kn
                                  , r = new Kn
                                  , o = new Un
                                  , s = new Un
                                  , l = new Un;
                                for (let h = 0, d = 0; h < i.length; h += 9,
                                d += 6) {
                                    e.set(i[h + 0], i[h + 1], i[h + 2]),
                                    t.set(i[h + 3], i[h + 4], i[h + 5]),
                                    n.set(i[h + 6], i[h + 7], i[h + 8]),
                                    o.set(a[d + 0], a[d + 1]),
                                    s.set(a[d + 2], a[d + 3]),
                                    l.set(a[d + 4], a[d + 5]),
                                    r.copy(e).add(t).add(n).divideScalar(3);
                                    const p = u(r);
                                    c(o, d + 0, e, p),
                                    c(s, d + 2, t, p),
                                    c(l, d + 4, n, p)
                                }
                            }
                            )(),
                            function() {
                                for (let e = 0; e < a.length; e += 6) {
                                    const t = a[e + 0]
                                      , n = a[e + 2]
                                      , r = a[e + 4]
                                      , i = Math.max(t, n, r)
                                      , o = Math.min(t, n, r);
                                    i > .9 && o < .1 && (t < .2 && (a[e + 0] += 1),
                                    n < .2 && (a[e + 2] += 1),
                                    r < .2 && (a[e + 4] += 1))
                                }
                            }()
                        }(),
                        this.setAttribute("position", new Fi(i,3)),
                        this.setAttribute("normal", new Fi(i.slice(),3)),
                        this.setAttribute("uv", new Fi(a,2)),
                        0 === r ? this.computeVertexNormals() : this.normalizeNormals()
                    }
                }
                class Yl extends Xl {
                    constructor(e=1, t=0) {
                        const n = (1 + Math.sqrt(5)) / 2
                          , r = 1 / n;
                        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
                        this.type = "DodecahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: t
                        }
                    }
                }
                const Zl = new Kn
                  , Jl = new Kn
                  , Kl = new Kn
                  , Ql = new hi;
                class $l extends qi {
                    constructor(e, t) {
                        if (super(),
                        this.type = "EdgesGeometry",
                        this.parameters = {
                            thresholdAngle: t
                        },
                        t = void 0 !== t ? t : 1,
                        !0 === e.isGeometry)
                            return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        const n = Math.pow(10, 4)
                          , r = Math.cos(zn.DEG2RAD * t)
                          , i = e.getIndex()
                          , a = e.getAttribute("position")
                          , o = i ? i.count : a.count
                          , s = [0, 0, 0]
                          , l = ["a", "b", "c"]
                          , c = new Array(3)
                          , u = {}
                          , h = [];
                        for (let e = 0; e < o; e += 3) {
                            i ? (s[0] = i.getX(e),
                            s[1] = i.getX(e + 1),
                            s[2] = i.getX(e + 2)) : (s[0] = e,
                            s[1] = e + 1,
                            s[2] = e + 2);
                            const {a: t, b: o, c: d} = Ql;
                            if (t.fromBufferAttribute(a, s[0]),
                            o.fromBufferAttribute(a, s[1]),
                            d.fromBufferAttribute(a, s[2]),
                            Ql.getNormal(Kl),
                            c[0] = `${Math.round(t.x * n)},${Math.round(t.y * n)},${Math.round(t.z * n)}`,
                            c[1] = `${Math.round(o.x * n)},${Math.round(o.y * n)},${Math.round(o.z * n)}`,
                            c[2] = `${Math.round(d.x * n)},${Math.round(d.y * n)},${Math.round(d.z * n)}`,
                            c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                                for (let e = 0; e < 3; e++) {
                                    const t = (e + 1) % 3
                                      , n = c[e]
                                      , i = c[t]
                                      , a = Ql[l[e]]
                                      , o = Ql[l[t]]
                                      , d = `${n}_${i}`
                                      , p = `${i}_${n}`;
                                    p in u && u[p] ? (Kl.dot(u[p].normal) <= r && (h.push(a.x, a.y, a.z),
                                    h.push(o.x, o.y, o.z)),
                                    u[p] = null) : d in u || (u[d] = {
                                        index0: s[e],
                                        index1: s[t],
                                        normal: Kl.clone()
                                    })
                                }
                        }
                        for (const e in u)
                            if (u[e]) {
                                const {index0: t, index1: n} = u[e];
                                Zl.fromBufferAttribute(a, t),
                                Jl.fromBufferAttribute(a, n),
                                h.push(Zl.x, Zl.y, Zl.z),
                                h.push(Jl.x, Jl.y, Jl.z)
                            }
                        this.setAttribute("position", new Fi(h,3))
                    }
                }
                function ec(e, t, n, r, i) {
                    let a, o;
                    if (i === function(e, t, n, r) {
                        let i = 0;
                        for (let a = t, o = n - r; a < n; a += r)
                            i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]),
                            o = a;
                        return i
                    }(e, t, n, r) > 0)
                        for (a = t; a < n; a += r)
                            o = bc(a, e[a], e[a + 1], o);
                    else
                        for (a = n - r; a >= t; a -= r)
                            o = bc(a, e[a], e[a + 1], o);
                    return o && mc(o, o.next) && (wc(o),
                    o = o.next),
                    o
                }
                function tc(e, t) {
                    if (!e)
                        return e;
                    t || (t = e);
                    let n, r = e;
                    do {
                        if (n = !1,
                        r.steiner || !mc(r, r.next) && 0 !== fc(r.prev, r, r.next))
                            r = r.next;
                        else {
                            if (wc(r),
                            r = t = r.prev,
                            r === r.next)
                                break;
                            n = !0
                        }
                    } while (n || r !== t);
                    return t
                }
                function nc(e, t, n, r, i, a, o) {
                    if (!e)
                        return;
                    !o && a && function(e, t, n, r) {
                        let i = e;
                        do {
                            null === i.z && (i.z = uc(i.x, i.y, t, n, r)),
                            i.prevZ = i.prev,
                            i.nextZ = i.next,
                            i = i.next
                        } while (i !== e);
                        i.prevZ.nextZ = null,
                        i.prevZ = null,
                        function(e) {
                            let t, n, r, i, a, o, s, l, c = 1;
                            do {
                                for (n = e,
                                e = null,
                                a = null,
                                o = 0; n; ) {
                                    for (o++,
                                    r = n,
                                    s = 0,
                                    t = 0; t < c && (s++,
                                    r = r.nextZ,
                                    r); t++)
                                        ;
                                    for (l = c; s > 0 || l > 0 && r; )
                                        0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n,
                                        n = n.nextZ,
                                        s--) : (i = r,
                                        r = r.nextZ,
                                        l--),
                                        a ? a.nextZ = i : e = i,
                                        i.prevZ = a,
                                        a = i;
                                    n = r
                                }
                                a.nextZ = null,
                                c *= 2
                            } while (o > 1)
                        }(i)
                    }(e, r, i, a);
                    let s, l, c = e;
                    for (; e.prev !== e.next; )
                        if (s = e.prev,
                        l = e.next,
                        a ? ic(e, r, i, a) : rc(e))
                            t.push(s.i / n),
                            t.push(e.i / n),
                            t.push(l.i / n),
                            wc(e),
                            e = l.next,
                            c = l.next;
                        else if ((e = l) === c) {
                            o ? 1 === o ? nc(e = ac(tc(e), t, n), t, n, r, i, a, 2) : 2 === o && oc(e, t, n, r, i, a) : nc(tc(e), t, n, r, i, a, 1);
                            break
                        }
                }
                function rc(e) {
                    const t = e.prev
                      , n = e
                      , r = e.next;
                    if (fc(t, n, r) >= 0)
                        return !1;
                    let i = e.next.next;
                    for (; i !== e.prev; ) {
                        if (dc(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && fc(i.prev, i, i.next) >= 0)
                            return !1;
                        i = i.next
                    }
                    return !0
                }
                function ic(e, t, n, r) {
                    const i = e.prev
                      , a = e
                      , o = e.next;
                    if (fc(i, a, o) >= 0)
                        return !1;
                    const s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x
                      , l = i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y
                      , c = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x
                      , u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y
                      , h = uc(s, l, t, n, r)
                      , d = uc(c, u, t, n, r);
                    let p = e.prevZ
                      , f = e.nextZ;
                    for (; p && p.z >= h && f && f.z <= d; ) {
                        if (p !== e.prev && p !== e.next && dc(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && fc(p.prev, p, p.next) >= 0)
                            return !1;
                        if (p = p.prevZ,
                        f !== e.prev && f !== e.next && dc(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && fc(f.prev, f, f.next) >= 0)
                            return !1;
                        f = f.nextZ
                    }
                    for (; p && p.z >= h; ) {
                        if (p !== e.prev && p !== e.next && dc(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && fc(p.prev, p, p.next) >= 0)
                            return !1;
                        p = p.prevZ
                    }
                    for (; f && f.z <= d; ) {
                        if (f !== e.prev && f !== e.next && dc(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && fc(f.prev, f, f.next) >= 0)
                            return !1;
                        f = f.nextZ
                    }
                    return !0
                }
                function ac(e, t, n) {
                    let r = e;
                    do {
                        const i = r.prev
                          , a = r.next.next;
                        !mc(i, a) && gc(i, r, r.next, a) && _c(i, a) && _c(a, i) && (t.push(i.i / n),
                        t.push(r.i / n),
                        t.push(a.i / n),
                        wc(r),
                        wc(r.next),
                        r = e = a),
                        r = r.next
                    } while (r !== e);
                    return tc(r)
                }
                function oc(e, t, n, r, i, a) {
                    let o = e;
                    do {
                        let e = o.next.next;
                        for (; e !== o.prev; ) {
                            if (o.i !== e.i && pc(o, e)) {
                                let s = xc(o, e);
                                return o = tc(o, o.next),
                                s = tc(s, s.next),
                                nc(o, t, n, r, i, a),
                                void nc(s, t, n, r, i, a)
                            }
                            e = e.next
                        }
                        o = o.next
                    } while (o !== e)
                }
                function sc(e, t) {
                    return e.x - t.x
                }
                function lc(e, t) {
                    if (t = function(e, t) {
                        let n = t;
                        const r = e.x
                          , i = e.y;
                        let a, o = -1 / 0;
                        do {
                            if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                                const e = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (e <= r && e > o) {
                                    if (o = e,
                                    e === r) {
                                        if (i === n.y)
                                            return n;
                                        if (i === n.next.y)
                                            return n.next
                                    }
                                    a = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== t);
                        if (!a)
                            return null;
                        if (r === o)
                            return a;
                        const s = a
                          , l = a.x
                          , c = a.y;
                        let u, h = 1 / 0;
                        n = a;
                        do {
                            r >= n.x && n.x >= l && r !== n.x && dc(i < c ? r : o, i, l, c, i < c ? o : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x),
                            _c(n, e) && (u < h || u === h && (n.x > a.x || n.x === a.x && cc(a, n))) && (a = n,
                            h = u)),
                            n = n.next
                        } while (n !== s);
                        return a
                    }(e, t),
                    t) {
                        const n = xc(t, e);
                        tc(t, t.next),
                        tc(n, n.next)
                    }
                }
                function cc(e, t) {
                    return fc(e.prev, e, t.prev) < 0 && fc(t.next, e, e.next) < 0
                }
                function uc(e, t, n, r, i) {
                    return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                }
                function hc(e) {
                    let t = e
                      , n = e;
                    do {
                        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                        t = t.next
                    } while (t !== e);
                    return n
                }
                function dc(e, t, n, r, i, a, o, s) {
                    return (i - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (r - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (i - o) * (r - s) >= 0
                }
                function pc(e, t) {
                    return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
                        let n = e;
                        do {
                            if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && gc(n, n.next, e, t))
                                return !0;
                            n = n.next
                        } while (n !== e);
                        return !1
                    }(e, t) && (_c(e, t) && _c(t, e) && function(e, t) {
                        let n = e
                          , r = !1;
                        const i = (e.x + t.x) / 2
                          , a = (e.y + t.y) / 2;
                        do {
                            n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r),
                            n = n.next
                        } while (n !== e);
                        return r
                    }(e, t) && (fc(e.prev, e, t.prev) || fc(e, t.prev, t)) || mc(e, t) && fc(e.prev, e, e.next) > 0 && fc(t.prev, t, t.next) > 0)
                }
                function fc(e, t, n) {
                    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
                }
                function mc(e, t) {
                    return e.x === t.x && e.y === t.y
                }
                function gc(e, t, n, r) {
                    const i = yc(fc(e, t, n))
                      , a = yc(fc(e, t, r))
                      , o = yc(fc(n, r, e))
                      , s = yc(fc(n, r, t));
                    return i !== a && o !== s || !(0 !== i || !vc(e, n, t)) || !(0 !== a || !vc(e, r, t)) || !(0 !== o || !vc(n, e, r)) || !(0 !== s || !vc(n, t, r))
                }
                function vc(e, t, n) {
                    return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
                }
                function yc(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0
                }
                function _c(e, t) {
                    return fc(e.prev, e, e.next) < 0 ? fc(e, t, e.next) >= 0 && fc(e, e.prev, t) >= 0 : fc(e, t, e.prev) < 0 || fc(e, e.next, t) < 0
                }
                function xc(e, t) {
                    const n = new Mc(e.i,e.x,e.y)
                      , r = new Mc(t.i,t.x,t.y)
                      , i = e.next
                      , a = t.prev;
                    return e.next = t,
                    t.prev = e,
                    n.next = i,
                    i.prev = n,
                    r.next = n,
                    n.prev = r,
                    a.next = r,
                    r.prev = a,
                    r
                }
                function bc(e, t, n, r) {
                    const i = new Mc(e,t,n);
                    return r ? (i.next = r.next,
                    i.prev = r,
                    r.next.prev = i,
                    r.next = i) : (i.prev = i,
                    i.next = i),
                    i
                }
                function wc(e) {
                    e.next.prev = e.prev,
                    e.prev.next = e.next,
                    e.prevZ && (e.prevZ.nextZ = e.nextZ),
                    e.nextZ && (e.nextZ.prevZ = e.prevZ)
                }
                function Mc(e, t, n) {
                    this.i = e,
                    this.x = t,
                    this.y = n,
                    this.prev = null,
                    this.next = null,
                    this.z = null,
                    this.prevZ = null,
                    this.nextZ = null,
                    this.steiner = !1
                }
                const Sc = {
                    area: function(e) {
                        const t = e.length;
                        let n = 0;
                        for (let r = t - 1, i = 0; i < t; r = i++)
                            n += e[r].x * e[i].y - e[i].x * e[r].y;
                        return .5 * n
                    },
                    isClockWise: function(e) {
                        return Sc.area(e) < 0
                    },
                    triangulateShape: function(e, t) {
                        const n = []
                          , r = []
                          , i = [];
                        Tc(e),
                        Ec(n, e);
                        let a = e.length;
                        t.forEach(Tc);
                        for (let e = 0; e < t.length; e++)
                            r.push(a),
                            a += t[e].length,
                            Ec(n, t[e]);
                        const o = function(e, t, n) {
                            n = n || 2;
                            const r = t && t.length
                              , i = r ? t[0] * n : e.length;
                            let a = ec(e, 0, i, n, !0);
                            const o = [];
                            if (!a || a.next === a.prev)
                                return o;
                            let s, l, c, u, h, d, p;
                            if (r && (a = function(e, t, n, r) {
                                const i = [];
                                let a, o, s, l, c;
                                for (a = 0,
                                o = t.length; a < o; a++)
                                    s = t[a] * r,
                                    l = a < o - 1 ? t[a + 1] * r : e.length,
                                    c = ec(e, s, l, r, !1),
                                    c === c.next && (c.steiner = !0),
                                    i.push(hc(c));
                                for (i.sort(sc),
                                a = 0; a < i.length; a++)
                                    lc(i[a], n),
                                    n = tc(n, n.next);
                                return n
                            }(e, t, a, n)),
                            e.length > 80 * n) {
                                s = c = e[0],
                                l = u = e[1];
                                for (let t = n; t < i; t += n)
                                    h = e[t],
                                    d = e[t + 1],
                                    h < s && (s = h),
                                    d < l && (l = d),
                                    h > c && (c = h),
                                    d > u && (u = d);
                                p = Math.max(c - s, u - l),
                                p = 0 !== p ? 1 / p : 0
                            }
                            return nc(a, o, n, s, l, p),
                            o
                        }(n, r);
                        for (let e = 0; e < o.length; e += 3)
                            i.push(o.slice(e, e + 3));
                        return i
                    }
                };
                function Tc(e) {
                    const t = e.length;
                    t > 2 && e[t - 1].equals(e[0]) && e.pop()
                }
                function Ec(e, t) {
                    for (let n = 0; n < t.length; n++)
                        e.push(t[n].x),
                        e.push(t[n].y)
                }
                class Ac extends qi {
                    constructor(e, t) {
                        super(),
                        this.type = "ExtrudeGeometry",
                        this.parameters = {
                            shapes: e,
                            options: t
                        },
                        e = Array.isArray(e) ? e : [e];
                        const n = this
                          , r = []
                          , i = [];
                        for (let t = 0, n = e.length; t < n; t++)
                            a(e[t]);
                        function a(e) {
                            const a = []
                              , o = void 0 !== t.curveSegments ? t.curveSegments : 12
                              , s = void 0 !== t.steps ? t.steps : 1;
                            let l = void 0 !== t.depth ? t.depth : 100
                              , c = void 0 === t.bevelEnabled || t.bevelEnabled
                              , u = void 0 !== t.bevelThickness ? t.bevelThickness : 6
                              , h = void 0 !== t.bevelSize ? t.bevelSize : u - 2
                              , d = void 0 !== t.bevelOffset ? t.bevelOffset : 0
                              , p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                            const f = t.extrudePath
                              , m = void 0 !== t.UVGenerator ? t.UVGenerator : Cc;
                            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                            l = t.amount);
                            let g, v, y, _, x, b = !1;
                            f && (g = f.getSpacedPoints(s),
                            b = !0,
                            c = !1,
                            v = f.computeFrenetFrames(s, !1),
                            y = new Kn,
                            _ = new Kn,
                            x = new Kn),
                            c || (p = 0,
                            u = 0,
                            h = 0,
                            d = 0);
                            const w = e.extractPoints(o);
                            let M = w.shape;
                            const S = w.holes;
                            if (!Sc.isClockWise(M)) {
                                M = M.reverse();
                                for (let e = 0, t = S.length; e < t; e++) {
                                    const t = S[e];
                                    Sc.isClockWise(t) && (S[e] = t.reverse())
                                }
                            }
                            const T = Sc.triangulateShape(M, S)
                              , E = M;
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = S[e];
                                M = M.concat(t)
                            }
                            function A(e, t, n) {
                                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                                t.clone().multiplyScalar(n).add(e)
                            }
                            const C = M.length
                              , P = T.length;
                            function R(e, t, n) {
                                let r, i, a;
                                const o = e.x - t.x
                                  , s = e.y - t.y
                                  , l = n.x - e.x
                                  , c = n.y - e.y
                                  , u = o * o + s * s
                                  , h = o * c - s * l;
                                if (Math.abs(h) > Number.EPSILON) {
                                    const h = Math.sqrt(u)
                                      , d = Math.sqrt(l * l + c * c)
                                      , p = t.x - s / h
                                      , f = t.y + o / h
                                      , m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (o * c - s * l);
                                    r = p + o * m - e.x,
                                    i = f + s * m - e.y;
                                    const g = r * r + i * i;
                                    if (g <= 2)
                                        return new Un(r,i);
                                    a = Math.sqrt(g / 2)
                                } else {
                                    let e = !1;
                                    o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0),
                                    e ? (r = -s,
                                    i = o,
                                    a = Math.sqrt(u)) : (r = o,
                                    i = s,
                                    a = Math.sqrt(u / 2))
                                }
                                return new Un(r / a,i / a)
                            }
                            const L = [];
                            for (let e = 0, t = E.length, n = t - 1, r = e + 1; e < t; e++,
                            n++,
                            r++)
                                n === t && (n = 0),
                                r === t && (r = 0),
                                L[e] = R(E[e], E[n], E[r]);
                            const D = [];
                            let O, F = L.concat();
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = S[e];
                                O = [];
                                for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++,
                                r++,
                                i++)
                                    r === n && (r = 0),
                                    i === n && (i = 0),
                                    O[e] = R(t[e], t[r], t[i]);
                                D.push(O),
                                F = F.concat(O)
                            }
                            for (let e = 0; e < p; e++) {
                                const t = e / p
                                  , n = u * Math.cos(t * Math.PI / 2)
                                  , r = h * Math.sin(t * Math.PI / 2) + d;
                                for (let e = 0, t = E.length; e < t; e++) {
                                    const t = A(E[e], L[e], r);
                                    B(t.x, t.y, -n)
                                }
                                for (let e = 0, t = S.length; e < t; e++) {
                                    const t = S[e];
                                    O = D[e];
                                    for (let e = 0, i = t.length; e < i; e++) {
                                        const i = A(t[e], O[e], r);
                                        B(i.x, i.y, -n)
                                    }
                                }
                            }
                            const I = h + d;
                            for (let e = 0; e < C; e++) {
                                const t = c ? A(M[e], F[e], I) : M[e];
                                b ? (_.copy(v.normals[0]).multiplyScalar(t.x),
                                y.copy(v.binormals[0]).multiplyScalar(t.y),
                                x.copy(g[0]).add(_).add(y),
                                B(x.x, x.y, x.z)) : B(t.x, t.y, 0)
                            }
                            for (let e = 1; e <= s; e++)
                                for (let t = 0; t < C; t++) {
                                    const n = c ? A(M[t], F[t], I) : M[t];
                                    b ? (_.copy(v.normals[e]).multiplyScalar(n.x),
                                    y.copy(v.binormals[e]).multiplyScalar(n.y),
                                    x.copy(g[e]).add(_).add(y),
                                    B(x.x, x.y, x.z)) : B(n.x, n.y, l / s * e)
                                }
                            for (let e = p - 1; e >= 0; e--) {
                                const t = e / p
                                  , n = u * Math.cos(t * Math.PI / 2)
                                  , r = h * Math.sin(t * Math.PI / 2) + d;
                                for (let e = 0, t = E.length; e < t; e++) {
                                    const t = A(E[e], L[e], r);
                                    B(t.x, t.y, l + n)
                                }
                                for (let e = 0, t = S.length; e < t; e++) {
                                    const t = S[e];
                                    O = D[e];
                                    for (let e = 0, i = t.length; e < i; e++) {
                                        const i = A(t[e], O[e], r);
                                        b ? B(i.x, i.y + g[s - 1].y, g[s - 1].x + n) : B(i.x, i.y, l + n)
                                    }
                                }
                            }
                            function N(e, t) {
                                let n = e.length;
                                for (; --n >= 0; ) {
                                    const r = n;
                                    let i = n - 1;
                                    i < 0 && (i = e.length - 1);
                                    for (let e = 0, n = s + 2 * p; e < n; e++) {
                                        const n = C * e
                                          , a = C * (e + 1);
                                        z(t + r + n, t + i + n, t + i + a, t + r + a)
                                    }
                                }
                            }
                            function B(e, t, n) {
                                a.push(e),
                                a.push(t),
                                a.push(n)
                            }
                            function k(e, t, i) {
                                U(e),
                                U(t),
                                U(i);
                                const a = r.length / 3
                                  , o = m.generateTopUV(n, r, a - 3, a - 2, a - 1);
                                H(o[0]),
                                H(o[1]),
                                H(o[2])
                            }
                            function z(e, t, i, a) {
                                U(e),
                                U(t),
                                U(a),
                                U(t),
                                U(i),
                                U(a);
                                const o = r.length / 3
                                  , s = m.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
                                H(s[0]),
                                H(s[1]),
                                H(s[3]),
                                H(s[1]),
                                H(s[2]),
                                H(s[3])
                            }
                            function U(e) {
                                r.push(a[3 * e + 0]),
                                r.push(a[3 * e + 1]),
                                r.push(a[3 * e + 2])
                            }
                            function H(e) {
                                i.push(e.x),
                                i.push(e.y)
                            }
                            !function() {
                                const e = r.length / 3;
                                if (c) {
                                    let e = 0
                                      , t = C * e;
                                    for (let e = 0; e < P; e++) {
                                        const n = T[e];
                                        k(n[2] + t, n[1] + t, n[0] + t)
                                    }
                                    e = s + 2 * p,
                                    t = C * e;
                                    for (let e = 0; e < P; e++) {
                                        const n = T[e];
                                        k(n[0] + t, n[1] + t, n[2] + t)
                                    }
                                } else {
                                    for (let e = 0; e < P; e++) {
                                        const t = T[e];
                                        k(t[2], t[1], t[0])
                                    }
                                    for (let e = 0; e < P; e++) {
                                        const t = T[e];
                                        k(t[0] + C * s, t[1] + C * s, t[2] + C * s)
                                    }
                                }
                                n.addGroup(e, r.length / 3 - e, 0)
                            }(),
                            function() {
                                const e = r.length / 3;
                                let t = 0;
                                N(E, t),
                                t += E.length;
                                for (let e = 0, n = S.length; e < n; e++) {
                                    const n = S[e];
                                    N(n, t),
                                    t += n.length
                                }
                                n.addGroup(e, r.length / 3 - e, 1)
                            }()
                        }
                        this.setAttribute("position", new Fi(r,3)),
                        this.setAttribute("uv", new Fi(i,2)),
                        this.computeVertexNormals()
                    }
                    toJSON() {
                        const e = qi.prototype.toJSON.call(this);
                        return function(e, t, n) {
                            if (n.shapes = [],
                            Array.isArray(e))
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = e[t];
                                    n.shapes.push(r.uuid)
                                }
                            else
                                n.shapes.push(e.uuid);
                            return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()),
                            n
                        }(this.parameters.shapes, this.parameters.options, e)
                    }
                }
                const Cc = {
                    generateTopUV: function(e, t, n, r, i) {
                        const a = t[3 * n]
                          , o = t[3 * n + 1]
                          , s = t[3 * r]
                          , l = t[3 * r + 1]
                          , c = t[3 * i]
                          , u = t[3 * i + 1];
                        return [new Un(a,o), new Un(s,l), new Un(c,u)]
                    },
                    generateSideWallUV: function(e, t, n, r, i, a) {
                        const o = t[3 * n]
                          , s = t[3 * n + 1]
                          , l = t[3 * n + 2]
                          , c = t[3 * r]
                          , u = t[3 * r + 1]
                          , h = t[3 * r + 2]
                          , d = t[3 * i]
                          , p = t[3 * i + 1]
                          , f = t[3 * i + 2]
                          , m = t[3 * a]
                          , g = t[3 * a + 1]
                          , v = t[3 * a + 2];
                        return Math.abs(s - u) < .01 ? [new Un(o,1 - l), new Un(c,1 - h), new Un(d,1 - f), new Un(m,1 - v)] : [new Un(s,1 - l), new Un(u,1 - h), new Un(p,1 - f), new Un(g,1 - v)]
                    }
                };
                class Pc extends Xl {
                    constructor(e=1, t=0) {
                        const n = (1 + Math.sqrt(5)) / 2;
                        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
                        this.type = "IcosahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: t
                        }
                    }
                }
                class Rc extends qi {
                    constructor(e, t=12, n=0, r=2 * Math.PI) {
                        super(),
                        this.type = "LatheGeometry",
                        this.parameters = {
                            points: e,
                            segments: t,
                            phiStart: n,
                            phiLength: r
                        },
                        t = Math.floor(t),
                        r = zn.clamp(r, 0, 2 * Math.PI);
                        const i = []
                          , a = []
                          , o = []
                          , s = 1 / t
                          , l = new Kn
                          , c = new Un;
                        for (let i = 0; i <= t; i++) {
                            const u = n + i * s * r
                              , h = Math.sin(u)
                              , d = Math.cos(u);
                            for (let n = 0; n <= e.length - 1; n++)
                                l.x = e[n].x * h,
                                l.y = e[n].y,
                                l.z = e[n].x * d,
                                a.push(l.x, l.y, l.z),
                                c.x = i / t,
                                c.y = n / (e.length - 1),
                                o.push(c.x, c.y)
                        }
                        for (let n = 0; n < t; n++)
                            for (let t = 0; t < e.length - 1; t++) {
                                const r = t + n * e.length
                                  , a = r
                                  , o = r + e.length
                                  , s = r + e.length + 1
                                  , l = r + 1;
                                i.push(a, o, l),
                                i.push(o, s, l)
                            }
                        if (this.setIndex(i),
                        this.setAttribute("position", new Fi(a,3)),
                        this.setAttribute("uv", new Fi(o,2)),
                        this.computeVertexNormals(),
                        r === 2 * Math.PI) {
                            const n = this.attributes.normal.array
                              , r = new Kn
                              , i = new Kn
                              , a = new Kn
                              , o = t * e.length * 3;
                            for (let t = 0, s = 0; t < e.length; t++,
                            s += 3)
                                r.x = n[s + 0],
                                r.y = n[s + 1],
                                r.z = n[s + 2],
                                i.x = n[o + s + 0],
                                i.y = n[o + s + 1],
                                i.z = n[o + s + 2],
                                a.addVectors(r, i).normalize(),
                                n[s + 0] = n[o + s + 0] = a.x,
                                n[s + 1] = n[o + s + 1] = a.y,
                                n[s + 2] = n[o + s + 2] = a.z
                        }
                    }
                }
                class Lc extends Xl {
                    constructor(e=1, t=0) {
                        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
                        this.type = "OctahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: t
                        }
                    }
                }
                function Dc(e, t, n) {
                    qi.call(this),
                    this.type = "ParametricGeometry",
                    this.parameters = {
                        func: e,
                        slices: t,
                        stacks: n
                    };
                    const r = []
                      , i = []
                      , a = []
                      , o = []
                      , s = 1e-5
                      , l = new Kn
                      , c = new Kn
                      , u = new Kn
                      , h = new Kn
                      , d = new Kn;
                    e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                    const p = t + 1;
                    for (let r = 0; r <= n; r++) {
                        const p = r / n;
                        for (let n = 0; n <= t; n++) {
                            const r = n / t;
                            e(r, p, c),
                            i.push(c.x, c.y, c.z),
                            r - s >= 0 ? (e(r - s, p, u),
                            h.subVectors(c, u)) : (e(r + s, p, u),
                            h.subVectors(u, c)),
                            p - s >= 0 ? (e(r, p - s, u),
                            d.subVectors(c, u)) : (e(r, p + s, u),
                            d.subVectors(u, c)),
                            l.crossVectors(h, d).normalize(),
                            a.push(l.x, l.y, l.z),
                            o.push(r, p)
                        }
                    }
                    for (let e = 0; e < n; e++)
                        for (let n = 0; n < t; n++) {
                            const t = e * p + n
                              , i = e * p + n + 1
                              , a = (e + 1) * p + n + 1
                              , o = (e + 1) * p + n;
                            r.push(t, i, o),
                            r.push(i, a, o)
                        }
                    this.setIndex(r),
                    this.setAttribute("position", new Fi(i,3)),
                    this.setAttribute("normal", new Fi(a,3)),
                    this.setAttribute("uv", new Fi(o,2))
                }
                Dc.prototype = Object.create(qi.prototype),
                Dc.prototype.constructor = Dc;
                class Oc extends qi {
                    constructor(e=.5, t=1, n=8, r=1, i=0, a=2 * Math.PI) {
                        super(),
                        this.type = "RingGeometry",
                        this.parameters = {
                            innerRadius: e,
                            outerRadius: t,
                            thetaSegments: n,
                            phiSegments: r,
                            thetaStart: i,
                            thetaLength: a
                        },
                        n = Math.max(3, n);
                        const o = []
                          , s = []
                          , l = []
                          , c = [];
                        let u = e;
                        const h = (t - e) / (r = Math.max(1, r))
                          , d = new Kn
                          , p = new Un;
                        for (let e = 0; e <= r; e++) {
                            for (let e = 0; e <= n; e++) {
                                const r = i + e / n * a;
                                d.x = u * Math.cos(r),
                                d.y = u * Math.sin(r),
                                s.push(d.x, d.y, d.z),
                                l.push(0, 0, 1),
                                p.x = (d.x / t + 1) / 2,
                                p.y = (d.y / t + 1) / 2,
                                c.push(p.x, p.y)
                            }
                            u += h
                        }
                        for (let e = 0; e < r; e++) {
                            const t = e * (n + 1);
                            for (let e = 0; e < n; e++) {
                                const r = e + t
                                  , i = r
                                  , a = r + n + 1
                                  , s = r + n + 2
                                  , l = r + 1;
                                o.push(i, a, l),
                                o.push(a, s, l)
                            }
                        }
                        this.setIndex(o),
                        this.setAttribute("position", new Fi(s,3)),
                        this.setAttribute("normal", new Fi(l,3)),
                        this.setAttribute("uv", new Fi(c,2))
                    }
                }
                class Fc extends qi {
                    constructor(e, t=12) {
                        super(),
                        this.type = "ShapeGeometry",
                        this.parameters = {
                            shapes: e,
                            curveSegments: t
                        };
                        const n = []
                          , r = []
                          , i = []
                          , a = [];
                        let o = 0
                          , s = 0;
                        if (!1 === Array.isArray(e))
                            l(e);
                        else
                            for (let t = 0; t < e.length; t++)
                                l(e[t]),
                                this.addGroup(o, s, t),
                                o += s,
                                s = 0;
                        function l(e) {
                            const o = r.length / 3
                              , l = e.extractPoints(t);
                            let c = l.shape;
                            const u = l.holes;
                            !1 === Sc.isClockWise(c) && (c = c.reverse());
                            for (let e = 0, t = u.length; e < t; e++) {
                                const t = u[e];
                                !0 === Sc.isClockWise(t) && (u[e] = t.reverse())
                            }
                            const h = Sc.triangulateShape(c, u);
                            for (let e = 0, t = u.length; e < t; e++) {
                                const t = u[e];
                                c = c.concat(t)
                            }
                            for (let e = 0, t = c.length; e < t; e++) {
                                const t = c[e];
                                r.push(t.x, t.y, 0),
                                i.push(0, 0, 1),
                                a.push(t.x, t.y)
                            }
                            for (let e = 0, t = h.length; e < t; e++) {
                                const t = h[e]
                                  , r = t[0] + o
                                  , i = t[1] + o
                                  , a = t[2] + o;
                                n.push(r, i, a),
                                s += 3
                            }
                        }
                        this.setIndex(n),
                        this.setAttribute("position", new Fi(r,3)),
                        this.setAttribute("normal", new Fi(i,3)),
                        this.setAttribute("uv", new Fi(a,2))
                    }
                    toJSON() {
                        const e = qi.prototype.toJSON.call(this);
                        return function(e, t) {
                            if (t.shapes = [],
                            Array.isArray(e))
                                for (let n = 0, r = e.length; n < r; n++) {
                                    const r = e[n];
                                    t.shapes.push(r.uuid)
                                }
                            else
                                t.shapes.push(e.uuid);
                            return t
                        }(this.parameters.shapes, e)
                    }
                }
                class Ic extends qi {
                    constructor(e=1, t=8, n=6, r=0, i=2 * Math.PI, a=0, o=Math.PI) {
                        super(),
                        this.type = "SphereGeometry",
                        this.parameters = {
                            radius: e,
                            widthSegments: t,
                            heightSegments: n,
                            phiStart: r,
                            phiLength: i,
                            thetaStart: a,
                            thetaLength: o
                        },
                        t = Math.max(3, Math.floor(t)),
                        n = Math.max(2, Math.floor(n));
                        const s = Math.min(a + o, Math.PI);
                        let l = 0;
                        const c = []
                          , u = new Kn
                          , h = new Kn
                          , d = []
                          , p = []
                          , f = []
                          , m = [];
                        for (let d = 0; d <= n; d++) {
                            const g = []
                              , v = d / n;
                            let y = 0;
                            0 == d && 0 == a ? y = .5 / t : d == n && s == Math.PI && (y = -.5 / t);
                            for (let n = 0; n <= t; n++) {
                                const s = n / t;
                                u.x = -e * Math.cos(r + s * i) * Math.sin(a + v * o),
                                u.y = e * Math.cos(a + v * o),
                                u.z = e * Math.sin(r + s * i) * Math.sin(a + v * o),
                                p.push(u.x, u.y, u.z),
                                h.copy(u).normalize(),
                                f.push(h.x, h.y, h.z),
                                m.push(s + y, 1 - v),
                                g.push(l++)
                            }
                            c.push(g)
                        }
                        for (let e = 0; e < n; e++)
                            for (let r = 0; r < t; r++) {
                                const t = c[e][r + 1]
                                  , i = c[e][r]
                                  , o = c[e + 1][r]
                                  , l = c[e + 1][r + 1];
                                (0 !== e || a > 0) && d.push(t, i, l),
                                (e !== n - 1 || s < Math.PI) && d.push(i, o, l)
                            }
                        this.setIndex(d),
                        this.setAttribute("position", new Fi(p,3)),
                        this.setAttribute("normal", new Fi(f,3)),
                        this.setAttribute("uv", new Fi(m,2))
                    }
                }
                class Nc extends Xl {
                    constructor(e=1, t=0) {
                        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
                        this.type = "TetrahedronGeometry",
                        this.parameters = {
                            radius: e,
                            detail: t
                        }
                    }
                }
                class Bc extends Ac {
                    constructor(e, t={}) {
                        const n = t.font;
                        if (!n || !n.isFont)
                            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
                            new qi;
                        const r = n.generateShapes(e, t.size);
                        t.depth = void 0 !== t.height ? t.height : 50,
                        void 0 === t.bevelThickness && (t.bevelThickness = 10),
                        void 0 === t.bevelSize && (t.bevelSize = 8),
                        void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
                        super(r, t),
                        this.type = "TextGeometry"
                    }
                }
                class kc extends qi {
                    constructor(e=1, t=.4, n=8, r=6, i=2 * Math.PI) {
                        super(),
                        this.type = "TorusGeometry",
                        this.parameters = {
                            radius: e,
                            tube: t,
                            radialSegments: n,
                            tubularSegments: r,
                            arc: i
                        },
                        n = Math.floor(n),
                        r = Math.floor(r);
                        const a = []
                          , o = []
                          , s = []
                          , l = []
                          , c = new Kn
                          , u = new Kn
                          , h = new Kn;
                        for (let a = 0; a <= n; a++)
                            for (let d = 0; d <= r; d++) {
                                const p = d / r * i
                                  , f = a / n * Math.PI * 2;
                                u.x = (e + t * Math.cos(f)) * Math.cos(p),
                                u.y = (e + t * Math.cos(f)) * Math.sin(p),
                                u.z = t * Math.sin(f),
                                o.push(u.x, u.y, u.z),
                                c.x = e * Math.cos(p),
                                c.y = e * Math.sin(p),
                                h.subVectors(u, c).normalize(),
                                s.push(h.x, h.y, h.z),
                                l.push(d / r),
                                l.push(a / n)
                            }
                        for (let e = 1; e <= n; e++)
                            for (let t = 1; t <= r; t++) {
                                const n = (r + 1) * e + t - 1
                                  , i = (r + 1) * (e - 1) + t - 1
                                  , o = (r + 1) * (e - 1) + t
                                  , s = (r + 1) * e + t;
                                a.push(n, i, s),
                                a.push(i, o, s)
                            }
                        this.setIndex(a),
                        this.setAttribute("position", new Fi(o,3)),
                        this.setAttribute("normal", new Fi(s,3)),
                        this.setAttribute("uv", new Fi(l,2))
                    }
                }
                class zc extends qi {
                    constructor(e=1, t=.4, n=64, r=8, i=2, a=3) {
                        super(),
                        this.type = "TorusKnotGeometry",
                        this.parameters = {
                            radius: e,
                            tube: t,
                            tubularSegments: n,
                            radialSegments: r,
                            p: i,
                            q: a
                        },
                        n = Math.floor(n),
                        r = Math.floor(r);
                        const o = []
                          , s = []
                          , l = []
                          , c = []
                          , u = new Kn
                          , h = new Kn
                          , d = new Kn
                          , p = new Kn
                          , f = new Kn
                          , m = new Kn
                          , g = new Kn;
                        for (let o = 0; o <= n; ++o) {
                            const y = o / n * i * Math.PI * 2;
                            v(y, i, a, e, d),
                            v(y + .01, i, a, e, p),
                            m.subVectors(p, d),
                            g.addVectors(p, d),
                            f.crossVectors(m, g),
                            g.crossVectors(f, m),
                            f.normalize(),
                            g.normalize();
                            for (let e = 0; e <= r; ++e) {
                                const i = e / r * Math.PI * 2
                                  , a = -t * Math.cos(i)
                                  , p = t * Math.sin(i);
                                u.x = d.x + (a * g.x + p * f.x),
                                u.y = d.y + (a * g.y + p * f.y),
                                u.z = d.z + (a * g.z + p * f.z),
                                s.push(u.x, u.y, u.z),
                                h.subVectors(u, d).normalize(),
                                l.push(h.x, h.y, h.z),
                                c.push(o / n),
                                c.push(e / r)
                            }
                        }
                        for (let e = 1; e <= n; e++)
                            for (let t = 1; t <= r; t++) {
                                const n = (r + 1) * (e - 1) + (t - 1)
                                  , i = (r + 1) * e + (t - 1)
                                  , a = (r + 1) * e + t
                                  , s = (r + 1) * (e - 1) + t;
                                o.push(n, i, s),
                                o.push(i, a, s)
                            }
                        function v(e, t, n, r, i) {
                            const a = Math.cos(e)
                              , o = Math.sin(e)
                              , s = n / t * e
                              , l = Math.cos(s);
                            i.x = r * (2 + l) * .5 * a,
                            i.y = r * (2 + l) * o * .5,
                            i.z = r * Math.sin(s) * .5
                        }
                        this.setIndex(o),
                        this.setAttribute("position", new Fi(s,3)),
                        this.setAttribute("normal", new Fi(l,3)),
                        this.setAttribute("uv", new Fi(c,2))
                    }
                }
                class Uc extends qi {
                    constructor(e, t=64, n=1, r=8, i=!1) {
                        super(),
                        this.type = "TubeGeometry",
                        this.parameters = {
                            path: e,
                            tubularSegments: t,
                            radius: n,
                            radialSegments: r,
                            closed: i
                        };
                        const a = e.computeFrenetFrames(t, i);
                        this.tangents = a.tangents,
                        this.normals = a.normals,
                        this.binormals = a.binormals;
                        const o = new Kn
                          , s = new Kn
                          , l = new Un;
                        let c = new Kn;
                        const u = []
                          , h = []
                          , d = []
                          , p = [];
                        function f(i) {
                            c = e.getPointAt(i / t, c);
                            const l = a.normals[i]
                              , d = a.binormals[i];
                            for (let e = 0; e <= r; e++) {
                                const t = e / r * Math.PI * 2
                                  , i = Math.sin(t)
                                  , a = -Math.cos(t);
                                s.x = a * l.x + i * d.x,
                                s.y = a * l.y + i * d.y,
                                s.z = a * l.z + i * d.z,
                                s.normalize(),
                                h.push(s.x, s.y, s.z),
                                o.x = c.x + n * s.x,
                                o.y = c.y + n * s.y,
                                o.z = c.z + n * s.z,
                                u.push(o.x, o.y, o.z)
                            }
                        }
                        !function() {
                            for (let e = 0; e < t; e++)
                                f(e);
                            f(!1 === i ? t : 0),
                            function() {
                                for (let e = 0; e <= t; e++)
                                    for (let n = 0; n <= r; n++)
                                        l.x = e / t,
                                        l.y = n / r,
                                        d.push(l.x, l.y)
                            }(),
                            function() {
                                for (let e = 1; e <= t; e++)
                                    for (let t = 1; t <= r; t++) {
                                        const n = (r + 1) * (e - 1) + (t - 1)
                                          , i = (r + 1) * e + (t - 1)
                                          , a = (r + 1) * e + t
                                          , o = (r + 1) * (e - 1) + t;
                                        p.push(n, i, o),
                                        p.push(i, a, o)
                                    }
                            }()
                        }(),
                        this.setIndex(p),
                        this.setAttribute("position", new Fi(u,3)),
                        this.setAttribute("normal", new Fi(h,3)),
                        this.setAttribute("uv", new Fi(d,2))
                    }
                    toJSON() {
                        const e = qi.prototype.toJSON.call(this);
                        return e.path = this.parameters.path.toJSON(),
                        e
                    }
                }
                class Hc extends qi {
                    constructor(e) {
                        if (super(),
                        this.type = "WireframeGeometry",
                        !0 === e.isGeometry)
                            return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        const t = []
                          , n = [0, 0]
                          , r = {}
                          , i = new Kn;
                        if (null !== e.index) {
                            const a = e.attributes.position
                              , o = e.index;
                            let s = e.groups;
                            0 === s.length && (s = [{
                                start: 0,
                                count: o.count,
                                materialIndex: 0
                            }]);
                            for (let e = 0, t = s.length; e < t; ++e) {
                                const t = s[e]
                                  , i = t.start;
                                for (let e = i, a = i + t.count; e < a; e += 3)
                                    for (let t = 0; t < 3; t++) {
                                        const i = o.getX(e + t)
                                          , a = o.getX(e + (t + 1) % 3);
                                        n[0] = Math.min(i, a),
                                        n[1] = Math.max(i, a);
                                        const s = n[0] + "," + n[1];
                                        void 0 === r[s] && (r[s] = {
                                            index1: n[0],
                                            index2: n[1]
                                        })
                                    }
                            }
                            for (const e in r) {
                                const n = r[e];
                                i.fromBufferAttribute(a, n.index1),
                                t.push(i.x, i.y, i.z),
                                i.fromBufferAttribute(a, n.index2),
                                t.push(i.x, i.y, i.z)
                            }
                        } else {
                            const n = e.attributes.position;
                            for (let e = 0, r = n.count / 3; e < r; e++)
                                for (let r = 0; r < 3; r++) {
                                    const a = 3 * e + r;
                                    i.fromBufferAttribute(n, a),
                                    t.push(i.x, i.y, i.z);
                                    const o = 3 * e + (r + 1) % 3;
                                    i.fromBufferAttribute(n, o),
                                    t.push(i.x, i.y, i.z)
                                }
                        }
                        this.setAttribute("position", new Fi(t,3))
                    }
                }
                var Gc = Object.freeze({
                    __proto__: null,
                    BoxGeometry: da,
                    BoxBufferGeometry: da,
                    CircleGeometry: Vl,
                    CircleBufferGeometry: Vl,
                    ConeGeometry: ql,
                    ConeBufferGeometry: ql,
                    CylinderGeometry: Wl,
                    CylinderBufferGeometry: Wl,
                    DodecahedronGeometry: Yl,
                    DodecahedronBufferGeometry: Yl,
                    EdgesGeometry: $l,
                    ExtrudeGeometry: Ac,
                    ExtrudeBufferGeometry: Ac,
                    IcosahedronGeometry: Pc,
                    IcosahedronBufferGeometry: Pc,
                    LatheGeometry: Rc,
                    LatheBufferGeometry: Rc,
                    OctahedronGeometry: Lc,
                    OctahedronBufferGeometry: Lc,
                    ParametricGeometry: Dc,
                    ParametricBufferGeometry: Dc,
                    PlaneGeometry: Pa,
                    PlaneBufferGeometry: Pa,
                    PolyhedronGeometry: Xl,
                    PolyhedronBufferGeometry: Xl,
                    RingGeometry: Oc,
                    RingBufferGeometry: Oc,
                    ShapeGeometry: Fc,
                    ShapeBufferGeometry: Fc,
                    SphereGeometry: Ic,
                    SphereBufferGeometry: Ic,
                    TetrahedronGeometry: Nc,
                    TetrahedronBufferGeometry: Nc,
                    TextGeometry: Bc,
                    TextBufferGeometry: Bc,
                    TorusGeometry: kc,
                    TorusBufferGeometry: kc,
                    TorusKnotGeometry: zc,
                    TorusKnotBufferGeometry: zc,
                    TubeGeometry: Uc,
                    TubeBufferGeometry: Uc,
                    WireframeGeometry: Hc
                });
                function jc(e) {
                    bi.call(this),
                    this.type = "ShadowMaterial",
                    this.color = new yi(0),
                    this.transparent = !0,
                    this.setValues(e)
                }
                function Vc(e) {
                    ga.call(this, e),
                    this.type = "RawShaderMaterial"
                }
                function Wc(e) {
                    bi.call(this),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.type = "MeshStandardMaterial",
                    this.color = new yi(16777215),
                    this.roughness = 1,
                    this.metalness = 0,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new yi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = sn,
                    this.normalScale = new Un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.roughnessMap = null,
                    this.metalnessMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapIntensity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.vertexTangents = !1,
                    this.setValues(e)
                }
                function qc(e) {
                    Wc.call(this),
                    this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    },
                    this.type = "MeshPhysicalMaterial",
                    this.clearcoat = 0,
                    this.clearcoatMap = null,
                    this.clearcoatRoughness = 0,
                    this.clearcoatRoughnessMap = null,
                    this.clearcoatNormalScale = new Un(1,1),
                    this.clearcoatNormalMap = null,
                    this.reflectivity = .5,
                    Object.defineProperty(this, "ior", {
                        get: function() {
                            return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                        },
                        set: function(e) {
                            this.reflectivity = zn.clamp(2.5 * (e - 1) / (e + 1), 0, 1)
                        }
                    }),
                    this.sheen = null,
                    this.transmission = 0,
                    this.transmissionMap = null,
                    this.setValues(e)
                }
                function Xc(e) {
                    bi.call(this),
                    this.type = "MeshPhongMaterial",
                    this.color = new yi(16777215),
                    this.specular = new yi(1118481),
                    this.shininess = 30,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new yi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = sn,
                    this.normalScale = new Un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = Z,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(e)
                }
                function Yc(e) {
                    bi.call(this),
                    this.defines = {
                        TOON: ""
                    },
                    this.type = "MeshToonMaterial",
                    this.color = new yi(16777215),
                    this.map = null,
                    this.gradientMap = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new yi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = sn,
                    this.normalScale = new Un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.alphaMap = null,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(e)
                }
                function Zc(e) {
                    bi.call(this),
                    this.type = "MeshNormalMaterial",
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = sn,
                    this.normalScale = new Un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(e)
                }
                function Jc(e) {
                    bi.call(this),
                    this.type = "MeshLambertMaterial",
                    this.color = new yi(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new yi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = Z,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(e)
                }
                function Kc(e) {
                    bi.call(this),
                    this.defines = {
                        MATCAP: ""
                    },
                    this.type = "MeshMatcapMaterial",
                    this.color = new yi(16777215),
                    this.matcap = null,
                    this.map = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = sn,
                    this.normalScale = new Un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.alphaMap = null,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(e)
                }
                function Qc(e) {
                    wl.call(this),
                    this.type = "LineDashedMaterial",
                    this.scale = 1,
                    this.dashSize = 3,
                    this.gapSize = 1,
                    this.setValues(e)
                }
                jc.prototype = Object.create(bi.prototype),
                jc.prototype.constructor = jc,
                jc.prototype.isShadowMaterial = !0,
                jc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this
                }
                ,
                Vc.prototype = Object.create(ga.prototype),
                Vc.prototype.constructor = Vc,
                Vc.prototype.isRawShaderMaterial = !0,
                Wc.prototype = Object.create(bi.prototype),
                Wc.prototype.constructor = Wc,
                Wc.prototype.isMeshStandardMaterial = !0,
                Wc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.color.copy(e.color),
                    this.roughness = e.roughness,
                    this.metalness = e.metalness,
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.emissive.copy(e.emissive),
                    this.emissiveMap = e.emissiveMap,
                    this.emissiveIntensity = e.emissiveIntensity,
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.roughnessMap = e.roughnessMap,
                    this.metalnessMap = e.metalnessMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.envMapIntensity = e.envMapIntensity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this.vertexTangents = e.vertexTangents,
                    this
                }
                ,
                qc.prototype = Object.create(Wc.prototype),
                qc.prototype.constructor = qc,
                qc.prototype.isMeshPhysicalMaterial = !0,
                qc.prototype.copy = function(e) {
                    return Wc.prototype.copy.call(this, e),
                    this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    },
                    this.clearcoat = e.clearcoat,
                    this.clearcoatMap = e.clearcoatMap,
                    this.clearcoatRoughness = e.clearcoatRoughness,
                    this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                    this.clearcoatNormalMap = e.clearcoatNormalMap,
                    this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                    this.reflectivity = e.reflectivity,
                    e.sheen ? this.sheen = (this.sheen || new yi).copy(e.sheen) : this.sheen = null,
                    this.transmission = e.transmission,
                    this.transmissionMap = e.transmissionMap,
                    this
                }
                ,
                Xc.prototype = Object.create(bi.prototype),
                Xc.prototype.constructor = Xc,
                Xc.prototype.isMeshPhongMaterial = !0,
                Xc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.specular.copy(e.specular),
                    this.shininess = e.shininess,
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.emissive.copy(e.emissive),
                    this.emissiveMap = e.emissiveMap,
                    this.emissiveIntensity = e.emissiveIntensity,
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.specularMap = e.specularMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.combine = e.combine,
                    this.reflectivity = e.reflectivity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this
                }
                ,
                Yc.prototype = Object.create(bi.prototype),
                Yc.prototype.constructor = Yc,
                Yc.prototype.isMeshToonMaterial = !0,
                Yc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.gradientMap = e.gradientMap,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.emissive.copy(e.emissive),
                    this.emissiveMap = e.emissiveMap,
                    this.emissiveIntensity = e.emissiveIntensity,
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.alphaMap = e.alphaMap,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this
                }
                ,
                Zc.prototype = Object.create(bi.prototype),
                Zc.prototype.constructor = Zc,
                Zc.prototype.isMeshNormalMaterial = !0,
                Zc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this
                }
                ,
                Jc.prototype = Object.create(bi.prototype),
                Jc.prototype.constructor = Jc,
                Jc.prototype.isMeshLambertMaterial = !0,
                Jc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.emissive.copy(e.emissive),
                    this.emissiveMap = e.emissiveMap,
                    this.emissiveIntensity = e.emissiveIntensity,
                    this.specularMap = e.specularMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.combine = e.combine,
                    this.reflectivity = e.reflectivity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this
                }
                ,
                Kc.prototype = Object.create(bi.prototype),
                Kc.prototype.constructor = Kc,
                Kc.prototype.isMeshMatcapMaterial = !0,
                Kc.prototype.copy = function(e) {
                    return bi.prototype.copy.call(this, e),
                    this.defines = {
                        MATCAP: ""
                    },
                    this.color.copy(e.color),
                    this.matcap = e.matcap,
                    this.map = e.map,
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.alphaMap = e.alphaMap,
                    this.skinning = e.skinning,
                    this.morphTargets = e.morphTargets,
                    this.morphNormals = e.morphNormals,
                    this
                }
                ,
                Qc.prototype = Object.create(wl.prototype),
                Qc.prototype.constructor = Qc,
                Qc.prototype.isLineDashedMaterial = !0,
                Qc.prototype.copy = function(e) {
                    return wl.prototype.copy.call(this, e),
                    this.scale = e.scale,
                    this.dashSize = e.dashSize,
                    this.gapSize = e.gapSize,
                    this
                }
                ;
                var $c = Object.freeze({
                    __proto__: null,
                    ShadowMaterial: jc,
                    SpriteMaterial: Gs,
                    RawShaderMaterial: Vc,
                    ShaderMaterial: ga,
                    PointsMaterial: Ol,
                    MeshPhysicalMaterial: qc,
                    MeshStandardMaterial: Wc,
                    MeshPhongMaterial: Xc,
                    MeshToonMaterial: Yc,
                    MeshNormalMaterial: Zc,
                    MeshLambertMaterial: Jc,
                    MeshDepthMaterial: Ms,
                    MeshDistanceMaterial: Ss,
                    MeshBasicMaterial: wi,
                    MeshMatcapMaterial: Kc,
                    LineDashedMaterial: Qc,
                    LineBasicMaterial: wl,
                    Material: bi
                });
                const eu = {
                    arraySlice: function(e, t, n) {
                        return eu.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                    },
                    convertArray: function(e, t, n) {
                        return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                    },
                    isTypedArray: function(e) {
                        return ArrayBuffer.isView(e) && !(e instanceof DataView)
                    },
                    getKeyframeOrder: function(e) {
                        const t = e.length
                          , n = new Array(t);
                        for (let e = 0; e !== t; ++e)
                            n[e] = e;
                        return n.sort((function(t, n) {
                            return e[t] - e[n]
                        }
                        )),
                        n
                    },
                    sortedArray: function(e, t, n) {
                        const r = e.length
                          , i = new e.constructor(r);
                        for (let a = 0, o = 0; o !== r; ++a) {
                            const r = n[a] * t;
                            for (let n = 0; n !== t; ++n)
                                i[o++] = e[r + n]
                        }
                        return i
                    },
                    flattenJSON: function(e, t, n, r) {
                        let i = 1
                          , a = e[0];
                        for (; void 0 !== a && void 0 === a[r]; )
                            a = e[i++];
                        if (void 0 === a)
                            return;
                        let o = a[r];
                        if (void 0 !== o)
                            if (Array.isArray(o))
                                do {
                                    o = a[r],
                                    void 0 !== o && (t.push(a.time),
                                    n.push.apply(n, o)),
                                    a = e[i++]
                                } while (void 0 !== a);
                            else if (void 0 !== o.toArray)
                                do {
                                    o = a[r],
                                    void 0 !== o && (t.push(a.time),
                                    o.toArray(n, n.length)),
                                    a = e[i++]
                                } while (void 0 !== a);
                            else
                                do {
                                    o = a[r],
                                    void 0 !== o && (t.push(a.time),
                                    n.push(o)),
                                    a = e[i++]
                                } while (void 0 !== a)
                    },
                    subclip: function(e, t, n, r, i=30) {
                        const a = e.clone();
                        a.name = t;
                        const o = [];
                        for (let e = 0; e < a.tracks.length; ++e) {
                            const t = a.tracks[e]
                              , s = t.getValueSize()
                              , l = []
                              , c = [];
                            for (let e = 0; e < t.times.length; ++e) {
                                const a = t.times[e] * i;
                                if (!(a < n || a >= r)) {
                                    l.push(t.times[e]);
                                    for (let n = 0; n < s; ++n)
                                        c.push(t.values[e * s + n])
                                }
                            }
                            0 !== l.length && (t.times = eu.convertArray(l, t.times.constructor),
                            t.values = eu.convertArray(c, t.values.constructor),
                            o.push(t))
                        }
                        a.tracks = o;
                        let s = 1 / 0;
                        for (let e = 0; e < a.tracks.length; ++e)
                            s > a.tracks[e].times[0] && (s = a.tracks[e].times[0]);
                        for (let e = 0; e < a.tracks.length; ++e)
                            a.tracks[e].shift(-1 * s);
                        return a.resetDuration(),
                        a
                    },
                    makeClipAdditive: function(e, t=0, n=e, r=30) {
                        r <= 0 && (r = 30);
                        const i = n.tracks.length
                          , a = t / r;
                        for (let t = 0; t < i; ++t) {
                            const r = n.tracks[t]
                              , i = r.ValueTypeName;
                            if ("bool" === i || "string" === i)
                                continue;
                            const o = e.tracks.find((function(e) {
                                return e.name === r.name && e.ValueTypeName === i
                            }
                            ));
                            if (void 0 === o)
                                continue;
                            let s = 0;
                            const l = r.getValueSize();
                            r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
                            let c = 0;
                            const u = o.getValueSize();
                            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                            const h = r.times.length - 1;
                            let d;
                            if (a <= r.times[0]) {
                                const e = s
                                  , t = l - s;
                                d = eu.arraySlice(r.values, e, t)
                            } else if (a >= r.times[h]) {
                                const e = h * l + s
                                  , t = e + l - s;
                                d = eu.arraySlice(r.values, e, t)
                            } else {
                                const e = r.createInterpolant()
                                  , t = s
                                  , n = l - s;
                                e.evaluate(a),
                                d = eu.arraySlice(e.resultBuffer, t, n)
                            }
                            "quaternion" === i && (new Jn).fromArray(d).normalize().conjugate().toArray(d);
                            const p = o.times.length;
                            for (let e = 0; e < p; ++e) {
                                const t = e * u + c;
                                if ("quaternion" === i)
                                    Jn.multiplyQuaternionsFlat(o.values, t, d, 0, o.values, t);
                                else {
                                    const e = u - 2 * c;
                                    for (let n = 0; n < e; ++n)
                                        o.values[t + n] -= d[n]
                                }
                            }
                        }
                        return e.blendMode = qt,
                        e
                    }
                };
                function tu(e, t, n, r) {
                    this.parameterPositions = e,
                    this._cachedIndex = 0,
                    this.resultBuffer = void 0 !== r ? r : new t.constructor(n),
                    this.sampleValues = t,
                    this.valueSize = n
                }
                function nu(e, t, n, r) {
                    tu.call(this, e, t, n, r),
                    this._weightPrev = -0,
                    this._offsetPrev = -0,
                    this._weightNext = -0,
                    this._offsetNext = -0
                }
                function ru(e, t, n, r) {
                    tu.call(this, e, t, n, r)
                }
                function iu(e, t, n, r) {
                    tu.call(this, e, t, n, r)
                }
                function au(e, t, n, r) {
                    if (void 0 === e)
                        throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length)
                        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e,
                    this.times = eu.convertArray(t, this.TimeBufferType),
                    this.values = eu.convertArray(n, this.ValueBufferType),
                    this.setInterpolation(r || this.DefaultInterpolation)
                }
                function ou(e, t, n) {
                    au.call(this, e, t, n)
                }
                function su(e, t, n, r) {
                    au.call(this, e, t, n, r)
                }
                function lu(e, t, n, r) {
                    au.call(this, e, t, n, r)
                }
                function cu(e, t, n, r) {
                    tu.call(this, e, t, n, r)
                }
                function uu(e, t, n, r) {
                    au.call(this, e, t, n, r)
                }
                function hu(e, t, n, r) {
                    au.call(this, e, t, n, r)
                }
                function du(e, t, n, r) {
                    au.call(this, e, t, n, r)
                }
                function pu(e, t=-1, n, r=Wt) {
                    this.name = e,
                    this.tracks = n,
                    this.duration = t,
                    this.blendMode = r,
                    this.uuid = zn.generateUUID(),
                    this.duration < 0 && this.resetDuration()
                }
                function fu(e) {
                    if (void 0 === e.type)
                        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const t = function(e) {
                        switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return lu;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return du;
                        case "color":
                            return su;
                        case "quaternion":
                            return uu;
                        case "bool":
                        case "boolean":
                            return ou;
                        case "string":
                            return hu
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                    }(e.type);
                    if (void 0 === e.times) {
                        const t = []
                          , n = [];
                        eu.flattenJSON(e.keys, t, n, "value"),
                        e.times = t,
                        e.values = n
                    }
                    return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
                }
                Object.assign(tu.prototype, {
                    evaluate: function(e) {
                        const t = this.parameterPositions;
                        let n = this._cachedIndex
                          , r = t[n]
                          , i = t[n - 1];
                        e: {
                            t: {
                                let a;
                                n: {
                                    r: if (!(e < r)) {
                                        for (let a = n + 2; ; ) {
                                            if (void 0 === r) {
                                                if (e < i)
                                                    break r;
                                                return n = t.length,
                                                this._cachedIndex = n,
                                                this.afterEnd_(n - 1, e, i)
                                            }
                                            if (n === a)
                                                break;
                                            if (i = r,
                                            r = t[++n],
                                            e < r)
                                                break t
                                        }
                                        a = t.length;
                                        break n
                                    }
                                    if (e >= i)
                                        break e;
                                    {
                                        const o = t[1];
                                        e < o && (n = 2,
                                        i = o);
                                        for (let a = n - 2; ; ) {
                                            if (void 0 === i)
                                                return this._cachedIndex = 0,
                                                this.beforeStart_(0, e, r);
                                            if (n === a)
                                                break;
                                            if (r = i,
                                            i = t[--n - 1],
                                            e >= i)
                                                break t
                                        }
                                        a = n,
                                        n = 0
                                    }
                                }
                                for (; n < a; ) {
                                    const r = n + a >>> 1;
                                    e < t[r] ? a = r : n = r + 1
                                }
                                if (r = t[n],
                                i = t[n - 1],
                                void 0 === i)
                                    return this._cachedIndex = 0,
                                    this.beforeStart_(0, e, r);
                                if (void 0 === r)
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, i, e)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, i, r)
                        }
                        return this.interpolate_(n, i, e, r)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(e) {
                        const t = this.resultBuffer
                          , n = this.sampleValues
                          , r = this.valueSize
                          , i = e * r;
                        for (let e = 0; e !== r; ++e)
                            t[e] = n[i + e];
                        return t
                    },
                    interpolate_: function() {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function() {}
                }),
                Object.assign(tu.prototype, {
                    beforeStart_: tu.prototype.copySampleValue_,
                    afterEnd_: tu.prototype.copySampleValue_
                }),
                nu.prototype = Object.assign(Object.create(tu.prototype), {
                    constructor: nu,
                    DefaultSettings_: {
                        endingStart: Gt,
                        endingEnd: Gt
                    },
                    intervalChanged_: function(e, t, n) {
                        const r = this.parameterPositions;
                        let i = e - 2
                          , a = e + 1
                          , o = r[i]
                          , s = r[a];
                        if (void 0 === o)
                            switch (this.getSettings_().endingStart) {
                            case jt:
                                i = e,
                                o = 2 * t - n;
                                break;
                            case Vt:
                                i = r.length - 2,
                                o = t + r[i] - r[i + 1];
                                break;
                            default:
                                i = e,
                                o = n
                            }
                        if (void 0 === s)
                            switch (this.getSettings_().endingEnd) {
                            case jt:
                                a = e,
                                s = 2 * n - t;
                                break;
                            case Vt:
                                a = 1,
                                s = n + r[1] - r[0];
                                break;
                            default:
                                a = e - 1,
                                s = t
                            }
                        const l = .5 * (n - t)
                          , c = this.valueSize;
                        this._weightPrev = l / (t - o),
                        this._weightNext = l / (s - n),
                        this._offsetPrev = i * c,
                        this._offsetNext = a * c
                    },
                    interpolate_: function(e, t, n, r) {
                        const i = this.resultBuffer
                          , a = this.sampleValues
                          , o = this.valueSize
                          , s = e * o
                          , l = s - o
                          , c = this._offsetPrev
                          , u = this._offsetNext
                          , h = this._weightPrev
                          , d = this._weightNext
                          , p = (n - t) / (r - t)
                          , f = p * p
                          , m = f * p
                          , g = -h * m + 2 * h * f - h * p
                          , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
                          , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
                          , _ = d * m - d * f;
                        for (let e = 0; e !== o; ++e)
                            i[e] = g * a[c + e] + v * a[l + e] + y * a[s + e] + _ * a[u + e];
                        return i
                    }
                }),
                ru.prototype = Object.assign(Object.create(tu.prototype), {
                    constructor: ru,
                    interpolate_: function(e, t, n, r) {
                        const i = this.resultBuffer
                          , a = this.sampleValues
                          , o = this.valueSize
                          , s = e * o
                          , l = s - o
                          , c = (n - t) / (r - t)
                          , u = 1 - c;
                        for (let e = 0; e !== o; ++e)
                            i[e] = a[l + e] * u + a[s + e] * c;
                        return i
                    }
                }),
                iu.prototype = Object.assign(Object.create(tu.prototype), {
                    constructor: iu,
                    interpolate_: function(e) {
                        return this.copySampleValue_(e - 1)
                    }
                }),
                Object.assign(au, {
                    toJSON: function(e) {
                        const t = e.constructor;
                        let n;
                        if (void 0 !== t.toJSON)
                            n = t.toJSON(e);
                        else {
                            n = {
                                name: e.name,
                                times: eu.convertArray(e.times, Array),
                                values: eu.convertArray(e.values, Array)
                            };
                            const t = e.getInterpolation();
                            t !== e.DefaultInterpolation && (n.interpolation = t)
                        }
                        return n.type = e.ValueTypeName,
                        n
                    }
                }),
                Object.assign(au.prototype, {
                    constructor: au,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: Ut,
                    InterpolantFactoryMethodDiscrete: function(e) {
                        return new iu(this.times,this.values,this.getValueSize(),e)
                    },
                    InterpolantFactoryMethodLinear: function(e) {
                        return new ru(this.times,this.values,this.getValueSize(),e)
                    },
                    InterpolantFactoryMethodSmooth: function(e) {
                        return new nu(this.times,this.values,this.getValueSize(),e)
                    },
                    setInterpolation: function(e) {
                        let t;
                        switch (e) {
                        case zt:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case Ut:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case Ht:
                            t = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === t) {
                            const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (e === this.DefaultInterpolation)
                                    throw new Error(t);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", t),
                            this
                        }
                        return this.createInterpolant = t,
                        this
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return zt;
                        case this.InterpolantFactoryMethodLinear:
                            return Ut;
                        case this.InterpolantFactoryMethodSmooth:
                            return Ht
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(e) {
                        if (0 !== e) {
                            const t = this.times;
                            for (let n = 0, r = t.length; n !== r; ++n)
                                t[n] += e
                        }
                        return this
                    },
                    scale: function(e) {
                        if (1 !== e) {
                            const t = this.times;
                            for (let n = 0, r = t.length; n !== r; ++n)
                                t[n] *= e
                        }
                        return this
                    },
                    trim: function(e, t) {
                        const n = this.times
                          , r = n.length;
                        let i = 0
                          , a = r - 1;
                        for (; i !== r && n[i] < e; )
                            ++i;
                        for (; -1 !== a && n[a] > t; )
                            --a;
                        if (++a,
                        0 !== i || a !== r) {
                            i >= a && (a = Math.max(a, 1),
                            i = a - 1);
                            const e = this.getValueSize();
                            this.times = eu.arraySlice(n, i, a),
                            this.values = eu.arraySlice(this.values, i * e, a * e)
                        }
                        return this
                    },
                    validate: function() {
                        let e = !0;
                        const t = this.getValueSize();
                        t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                        e = !1);
                        const n = this.times
                          , r = this.values
                          , i = n.length;
                        0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                        e = !1);
                        let a = null;
                        for (let t = 0; t !== i; t++) {
                            const r = n[t];
                            if ("number" == typeof r && isNaN(r)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r),
                                e = !1;
                                break
                            }
                            if (null !== a && a > r) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, a),
                                e = !1;
                                break
                            }
                            a = r
                        }
                        if (void 0 !== r && eu.isTypedArray(r))
                            for (let t = 0, n = r.length; t !== n; ++t) {
                                const n = r[t];
                                if (isNaN(n)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                                    e = !1;
                                    break
                                }
                            }
                        return e
                    },
                    optimize: function() {
                        const e = eu.arraySlice(this.times)
                          , t = eu.arraySlice(this.values)
                          , n = this.getValueSize()
                          , r = this.getInterpolation() === Ht
                          , i = e.length - 1;
                        let a = 1;
                        for (let o = 1; o < i; ++o) {
                            let i = !1;
                            const s = e[o];
                            if (s !== e[o + 1] && (1 !== o || s !== e[0]))
                                if (r)
                                    i = !0;
                                else {
                                    const e = o * n
                                      , r = e - n
                                      , a = e + n;
                                    for (let o = 0; o !== n; ++o) {
                                        const n = t[e + o];
                                        if (n !== t[r + o] || n !== t[a + o]) {
                                            i = !0;
                                            break
                                        }
                                    }
                                }
                            if (i) {
                                if (o !== a) {
                                    e[a] = e[o];
                                    const r = o * n
                                      , i = a * n;
                                    for (let e = 0; e !== n; ++e)
                                        t[i + e] = t[r + e]
                                }
                                ++a
                            }
                        }
                        if (i > 0) {
                            e[a] = e[i];
                            for (let e = i * n, r = a * n, o = 0; o !== n; ++o)
                                t[r + o] = t[e + o];
                            ++a
                        }
                        return a !== e.length ? (this.times = eu.arraySlice(e, 0, a),
                        this.values = eu.arraySlice(t, 0, a * n)) : (this.times = e,
                        this.values = t),
                        this
                    },
                    clone: function() {
                        const e = eu.arraySlice(this.times, 0)
                          , t = eu.arraySlice(this.values, 0)
                          , n = new (0,
                        this.constructor)(this.name,e,t);
                        return n.createInterpolant = this.createInterpolant,
                        n
                    }
                }),
                ou.prototype = Object.assign(Object.create(au.prototype), {
                    constructor: ou,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: zt,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }),
                su.prototype = Object.assign(Object.create(au.prototype), {
                    constructor: su,
                    ValueTypeName: "color"
                }),
                lu.prototype = Object.assign(Object.create(au.prototype), {
                    constructor: lu,
                    ValueTypeName: "number"
                }),
                cu.prototype = Object.assign(Object.create(tu.prototype), {
                    constructor: cu,
                    interpolate_: function(e, t, n, r) {
                        const i = this.resultBuffer
                          , a = this.sampleValues
                          , o = this.valueSize
                          , s = (n - t) / (r - t);
                        let l = e * o;
                        for (let e = l + o; l !== e; l += 4)
                            Jn.slerpFlat(i, 0, a, l - o, a, l, s);
                        return i
                    }
                }),
                uu.prototype = Object.assign(Object.create(au.prototype), {
                    constructor: uu,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: Ut,
                    InterpolantFactoryMethodLinear: function(e) {
                        return new cu(this.times,this.values,this.getValueSize(),e)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }),
                hu.prototype = Object.assign(Object.create(au.prototype), {
                    constructor: hu,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: zt,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }),
                du.prototype = Object.assign(Object.create(au.prototype), {
                    constructor: du,
                    ValueTypeName: "vector"
                }),
                Object.assign(pu, {
                    parse: function(e) {
                        const t = []
                          , n = e.tracks
                          , r = 1 / (e.fps || 1);
                        for (let e = 0, i = n.length; e !== i; ++e)
                            t.push(fu(n[e]).scale(r));
                        const i = new pu(e.name,e.duration,t,e.blendMode);
                        return i.uuid = e.uuid,
                        i
                    },
                    toJSON: function(e) {
                        const t = []
                          , n = e.tracks
                          , r = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                        for (let e = 0, r = n.length; e !== r; ++e)
                            t.push(au.toJSON(n[e]));
                        return r
                    },
                    CreateFromMorphTargetSequence: function(e, t, n, r) {
                        const i = t.length
                          , a = [];
                        for (let e = 0; e < i; e++) {
                            let o = []
                              , s = [];
                            o.push((e + i - 1) % i, e, (e + 1) % i),
                            s.push(0, 1, 0);
                            const l = eu.getKeyframeOrder(o);
                            o = eu.sortedArray(o, 1, l),
                            s = eu.sortedArray(s, 1, l),
                            r || 0 !== o[0] || (o.push(i),
                            s.push(s[0])),
                            a.push(new lu(".morphTargetInfluences[" + t[e].name + "]",o,s).scale(1 / n))
                        }
                        return new pu(e,-1,a)
                    },
                    findByName: function(e, t) {
                        let n = e;
                        if (!Array.isArray(e)) {
                            const t = e;
                            n = t.geometry && t.geometry.animations || t.animations
                        }
                        for (let e = 0; e < n.length; e++)
                            if (n[e].name === t)
                                return n[e];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(e, t, n) {
                        const r = {}
                          , i = /^([\w-]*?)([\d]+)$/;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t]
                              , a = n.name.match(i);
                            if (a && a.length > 1) {
                                const e = a[1];
                                let t = r[e];
                                t || (r[e] = t = []),
                                t.push(n)
                            }
                        }
                        const a = [];
                        for (const e in r)
                            a.push(pu.CreateFromMorphTargetSequence(e, r[e], t, n));
                        return a
                    },
                    parseAnimation: function(e, t) {
                        if (!e)
                            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                            null;
                        const n = function(e, t, n, r, i) {
                            if (0 !== n.length) {
                                const a = []
                                  , o = [];
                                eu.flattenJSON(n, a, o, r),
                                0 !== a.length && i.push(new e(t,a,o))
                            }
                        }
                          , r = []
                          , i = e.name || "default"
                          , a = e.fps || 30
                          , o = e.blendMode;
                        let s = e.length || -1;
                        const l = e.hierarchy || [];
                        for (let e = 0; e < l.length; e++) {
                            const i = l[e].keys;
                            if (i && 0 !== i.length)
                                if (i[0].morphTargets) {
                                    const e = {};
                                    let t;
                                    for (t = 0; t < i.length; t++)
                                        if (i[t].morphTargets)
                                            for (let n = 0; n < i[t].morphTargets.length; n++)
                                                e[i[t].morphTargets[n]] = -1;
                                    for (const n in e) {
                                        const e = []
                                          , a = [];
                                        for (let r = 0; r !== i[t].morphTargets.length; ++r) {
                                            const r = i[t];
                                            e.push(r.time),
                                            a.push(r.morphTarget === n ? 1 : 0)
                                        }
                                        r.push(new lu(".morphTargetInfluence[" + n + "]",e,a))
                                    }
                                    s = e.length * (a || 1)
                                } else {
                                    const a = ".bones[" + t[e].name + "]";
                                    n(du, a + ".position", i, "pos", r),
                                    n(uu, a + ".quaternion", i, "rot", r),
                                    n(du, a + ".scale", i, "scl", r)
                                }
                        }
                        return 0 === r.length ? null : new pu(i,s,r,o)
                    }
                }),
                Object.assign(pu.prototype, {
                    resetDuration: function() {
                        let e = 0;
                        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                            const n = this.tracks[t];
                            e = Math.max(e, n.times[n.times.length - 1])
                        }
                        return this.duration = e,
                        this
                    },
                    trim: function() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].trim(0, this.duration);
                        return this
                    },
                    validate: function() {
                        let e = !0;
                        for (let t = 0; t < this.tracks.length; t++)
                            e = e && this.tracks[t].validate();
                        return e
                    },
                    optimize: function() {
                        for (let e = 0; e < this.tracks.length; e++)
                            this.tracks[e].optimize();
                        return this
                    },
                    clone: function() {
                        const e = [];
                        for (let t = 0; t < this.tracks.length; t++)
                            e.push(this.tracks[t].clone());
                        return new pu(this.name,this.duration,e,this.blendMode)
                    },
                    toJSON: function() {
                        return pu.toJSON(this)
                    }
                });
                const mu = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        !1 !== this.enabled && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (!1 !== this.enabled)
                            return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                function gu(e, t, n) {
                    const r = this;
                    let i, a = !1, o = 0, s = 0;
                    const l = [];
                    this.onStart = void 0,
                    this.onLoad = e,
                    this.onProgress = t,
                    this.onError = n,
                    this.itemStart = function(e) {
                        s++,
                        !1 === a && void 0 !== r.onStart && r.onStart(e, o, s),
                        a = !0
                    }
                    ,
                    this.itemEnd = function(e) {
                        o++,
                        void 0 !== r.onProgress && r.onProgress(e, o, s),
                        o === s && (a = !1,
                        void 0 !== r.onLoad && r.onLoad())
                    }
                    ,
                    this.itemError = function(e) {
                        void 0 !== r.onError && r.onError(e)
                    }
                    ,
                    this.resolveURL = function(e) {
                        return i ? i(e) : e
                    }
                    ,
                    this.setURLModifier = function(e) {
                        return i = e,
                        this
                    }
                    ,
                    this.addHandler = function(e, t) {
                        return l.push(e, t),
                        this
                    }
                    ,
                    this.removeHandler = function(e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2),
                        this
                    }
                    ,
                    this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            const n = l[t]
                              , r = l[t + 1];
                            if (n.global && (n.lastIndex = 0),
                            n.test(e))
                                return r
                        }
                        return null
                    }
                }
                const vu = new gu;
                function yu(e) {
                    this.manager = void 0 !== e ? e : vu,
                    this.crossOrigin = "anonymous",
                    this.withCredentials = !1,
                    this.path = "",
                    this.resourcePath = "",
                    this.requestHeader = {}
                }
                Object.assign(yu.prototype, {
                    load: function() {},
                    loadAsync: function(e, t) {
                        const n = this;
                        return new Promise((function(r, i) {
                            n.load(e, r, t, i)
                        }
                        ))
                    },
                    parse: function() {},
                    setCrossOrigin: function(e) {
                        return this.crossOrigin = e,
                        this
                    },
                    setWithCredentials: function(e) {
                        return this.withCredentials = e,
                        this
                    },
                    setPath: function(e) {
                        return this.path = e,
                        this
                    },
                    setResourcePath: function(e) {
                        return this.resourcePath = e,
                        this
                    },
                    setRequestHeader: function(e) {
                        return this.requestHeader = e,
                        this
                    }
                });
                const _u = {};
                function xu(e) {
                    yu.call(this, e)
                }
                function bu(e) {
                    yu.call(this, e)
                }
                function wu(e) {
                    yu.call(this, e)
                }
                function Mu(e) {
                    yu.call(this, e)
                }
                function Su(e) {
                    yu.call(this, e)
                }
                function Tu(e) {
                    yu.call(this, e)
                }
                function Eu(e) {
                    yu.call(this, e)
                }
                function Au() {
                    this.type = "Curve",
                    this.arcLengthDivisions = 200
                }
                function Cu(e, t, n, r, i, a, o, s) {
                    Au.call(this),
                    this.type = "EllipseCurve",
                    this.aX = e || 0,
                    this.aY = t || 0,
                    this.xRadius = n || 1,
                    this.yRadius = r || 1,
                    this.aStartAngle = i || 0,
                    this.aEndAngle = a || 2 * Math.PI,
                    this.aClockwise = o || !1,
                    this.aRotation = s || 0
                }
                function Pu(e, t, n, r, i, a) {
                    Cu.call(this, e, t, n, n, r, i, a),
                    this.type = "ArcCurve"
                }
                function Ru() {
                    let e = 0
                      , t = 0
                      , n = 0
                      , r = 0;
                    function i(i, a, o, s) {
                        e = i,
                        t = o,
                        n = -3 * i + 3 * a - 2 * o - s,
                        r = 2 * i - 2 * a + o + s
                    }
                    return {
                        initCatmullRom: function(e, t, n, r, a) {
                            i(t, n, a * (n - e), a * (r - t))
                        },
                        initNonuniformCatmullRom: function(e, t, n, r, a, o, s) {
                            let l = (t - e) / a - (n - e) / (a + o) + (n - t) / o
                              , c = (n - t) / o - (r - t) / (o + s) + (r - n) / s;
                            l *= o,
                            c *= o,
                            i(t, n, l, c)
                        },
                        calc: function(i) {
                            const a = i * i;
                            return e + t * i + n * a + r * (a * i)
                        }
                    }
                }
                xu.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: xu,
                    load: function(e, t, n, r) {
                        void 0 === e && (e = ""),
                        void 0 !== this.path && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const i = this
                          , a = mu.get(e);
                        if (void 0 !== a)
                            return i.manager.itemStart(e),
                            setTimeout((function() {
                                t && t(a),
                                i.manager.itemEnd(e)
                            }
                            ), 0),
                            a;
                        if (void 0 !== _u[e])
                            return void _u[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: r
                            });
                        const o = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                        let s;
                        if (o) {
                            const n = o[1]
                              , a = !!o[2];
                            let s = o[3];
                            s = decodeURIComponent(s),
                            a && (s = atob(s));
                            try {
                                let r;
                                const a = (this.responseType || "").toLowerCase();
                                switch (a) {
                                case "arraybuffer":
                                case "blob":
                                    const e = new Uint8Array(s.length);
                                    for (let t = 0; t < s.length; t++)
                                        e[t] = s.charCodeAt(t);
                                    r = "blob" === a ? new Blob([e.buffer],{
                                        type: n
                                    }) : e.buffer;
                                    break;
                                case "document":
                                    const t = new DOMParser;
                                    r = t.parseFromString(s, n);
                                    break;
                                case "json":
                                    r = JSON.parse(s);
                                    break;
                                default:
                                    r = s
                                }
                                setTimeout((function() {
                                    t && t(r),
                                    i.manager.itemEnd(e)
                                }
                                ), 0)
                            } catch (t) {
                                setTimeout((function() {
                                    r && r(t),
                                    i.manager.itemError(e),
                                    i.manager.itemEnd(e)
                                }
                                ), 0)
                            }
                        } else {
                            _u[e] = [],
                            _u[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: r
                            }),
                            s = new XMLHttpRequest,
                            s.open("GET", e, !0),
                            s.addEventListener("load", (function(t) {
                                const n = this.response
                                  , r = _u[e];
                                if (delete _u[e],
                                200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                                    mu.add(e, n);
                                    for (let e = 0, t = r.length; e < t; e++) {
                                        const t = r[e];
                                        t.onLoad && t.onLoad(n)
                                    }
                                    i.manager.itemEnd(e)
                                } else {
                                    for (let e = 0, n = r.length; e < n; e++) {
                                        const n = r[e];
                                        n.onError && n.onError(t)
                                    }
                                    i.manager.itemError(e),
                                    i.manager.itemEnd(e)
                                }
                            }
                            ), !1),
                            s.addEventListener("progress", (function(t) {
                                const n = _u[e];
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    r.onProgress && r.onProgress(t)
                                }
                            }
                            ), !1),
                            s.addEventListener("error", (function(t) {
                                const n = _u[e];
                                delete _u[e];
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    r.onError && r.onError(t)
                                }
                                i.manager.itemError(e),
                                i.manager.itemEnd(e)
                            }
                            ), !1),
                            s.addEventListener("abort", (function(t) {
                                const n = _u[e];
                                delete _u[e];
                                for (let e = 0, r = n.length; e < r; e++) {
                                    const r = n[e];
                                    r.onError && r.onError(t)
                                }
                                i.manager.itemError(e),
                                i.manager.itemEnd(e)
                            }
                            ), !1),
                            void 0 !== this.responseType && (s.responseType = this.responseType),
                            void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials),
                            s.overrideMimeType && s.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                            for (const e in this.requestHeader)
                                s.setRequestHeader(e, this.requestHeader[e]);
                            s.send(null)
                        }
                        return i.manager.itemStart(e),
                        s
                    },
                    setResponseType: function(e) {
                        return this.responseType = e,
                        this
                    },
                    setMimeType: function(e) {
                        return this.mimeType = e,
                        this
                    }
                }),
                bu.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: bu,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = new xu(i.manager);
                        a.setPath(i.path),
                        a.setRequestHeader(i.requestHeader),
                        a.setWithCredentials(i.withCredentials),
                        a.load(e, (function(n) {
                            try {
                                t(i.parse(JSON.parse(n)))
                            } catch (t) {
                                r ? r(t) : console.error(t),
                                i.manager.itemError(e)
                            }
                        }
                        ), n, r)
                    },
                    parse: function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const r = pu.parse(e[n]);
                            t.push(r)
                        }
                        return t
                    }
                }),
                wu.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: wu,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = []
                          , o = new Hl
                          , s = new xu(this.manager);
                        s.setPath(this.path),
                        s.setResponseType("arraybuffer"),
                        s.setRequestHeader(this.requestHeader),
                        s.setWithCredentials(i.withCredentials);
                        let l = 0;
                        function c(c) {
                            s.load(e[c], (function(e) {
                                const n = i.parse(e, !0);
                                a[c] = {
                                    width: n.width,
                                    height: n.height,
                                    format: n.format,
                                    mipmaps: n.mipmaps
                                },
                                l += 1,
                                6 === l && (1 === n.mipmapCount && (o.minFilter = _e),
                                o.image = a,
                                o.format = n.format,
                                o.needsUpdate = !0,
                                t && t(o))
                            }
                            ), n, r)
                        }
                        if (Array.isArray(e))
                            for (let t = 0, n = e.length; t < n; ++t)
                                c(t);
                        else
                            s.load(e, (function(e) {
                                const n = i.parse(e, !0);
                                if (n.isCubemap) {
                                    const e = n.mipmaps.length / n.mipmapCount;
                                    for (let t = 0; t < e; t++) {
                                        a[t] = {
                                            mipmaps: []
                                        };
                                        for (let e = 0; e < n.mipmapCount; e++)
                                            a[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                                            a[t].format = n.format,
                                            a[t].width = n.width,
                                            a[t].height = n.height
                                    }
                                    o.image = a
                                } else
                                    o.image.width = n.width,
                                    o.image.height = n.height,
                                    o.mipmaps = n.mipmaps;
                                1 === n.mipmapCount && (o.minFilter = _e),
                                o.format = n.format,
                                o.needsUpdate = !0,
                                t && t(o)
                            }
                            ), n, r);
                        return o
                    }
                }),
                Mu.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: Mu,
                    load: function(e, t, n, r) {
                        void 0 !== this.path && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const i = this
                          , a = mu.get(e);
                        if (void 0 !== a)
                            return i.manager.itemStart(e),
                            setTimeout((function() {
                                t && t(a),
                                i.manager.itemEnd(e)
                            }
                            ), 0),
                            a;
                        const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                        function s() {
                            o.removeEventListener("load", s, !1),
                            o.removeEventListener("error", l, !1),
                            mu.add(e, this),
                            t && t(this),
                            i.manager.itemEnd(e)
                        }
                        function l(t) {
                            o.removeEventListener("load", s, !1),
                            o.removeEventListener("error", l, !1),
                            r && r(t),
                            i.manager.itemError(e),
                            i.manager.itemEnd(e)
                        }
                        return o.addEventListener("load", s, !1),
                        o.addEventListener("error", l, !1),
                        "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
                        i.manager.itemStart(e),
                        o.src = e,
                        o
                    }
                }),
                Su.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: Su,
                    load: function(e, t, n, r) {
                        const i = new ba
                          , a = new Mu(this.manager);
                        a.setCrossOrigin(this.crossOrigin),
                        a.setPath(this.path);
                        let o = 0;
                        function s(n) {
                            a.load(e[n], (function(e) {
                                i.images[n] = e,
                                o++,
                                6 === o && (i.needsUpdate = !0,
                                t && t(i))
                            }
                            ), void 0, r)
                        }
                        for (let t = 0; t < e.length; ++t)
                            s(t);
                        return i
                    }
                }),
                Tu.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: Tu,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = new Ma
                          , o = new xu(this.manager);
                        return o.setResponseType("arraybuffer"),
                        o.setRequestHeader(this.requestHeader),
                        o.setPath(this.path),
                        o.setWithCredentials(i.withCredentials),
                        o.load(e, (function(e) {
                            const n = i.parse(e);
                            n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width,
                            a.image.height = n.height,
                            a.image.data = n.data),
                            a.wrapS = void 0 !== n.wrapS ? n.wrapS : de,
                            a.wrapT = void 0 !== n.wrapT ? n.wrapT : de,
                            a.magFilter = void 0 !== n.magFilter ? n.magFilter : _e,
                            a.minFilter = void 0 !== n.minFilter ? n.minFilter : _e,
                            a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                            void 0 !== n.encoding && (a.encoding = n.encoding),
                            void 0 !== n.flipY && (a.flipY = n.flipY),
                            void 0 !== n.format && (a.format = n.format),
                            void 0 !== n.type && (a.type = n.type),
                            void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps,
                            a.minFilter = we),
                            1 === n.mipmapCount && (a.minFilter = _e),
                            a.needsUpdate = !0,
                            t && t(a, n))
                        }
                        ), n, r),
                        a
                    }
                }),
                Eu.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: Eu,
                    load: function(e, t, n, r) {
                        const i = new Wn
                          , a = new Mu(this.manager);
                        return a.setCrossOrigin(this.crossOrigin),
                        a.setPath(this.path),
                        a.load(e, (function(n) {
                            i.image = n;
                            const r = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                            i.format = r ? Be : ke,
                            i.needsUpdate = !0,
                            void 0 !== t && t(i)
                        }
                        ), n, r),
                        i
                    }
                }),
                Object.assign(Au.prototype, {
                    getPoint: function() {
                        return console.warn("THREE.Curve: .getPoint() not implemented."),
                        null
                    },
                    getPointAt: function(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getPoint(n, t)
                    },
                    getPoints: function(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return t
                    },
                    getSpacedPoints: function(e=5) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPointAt(n / e));
                        return t
                    },
                    getLength: function() {
                        const e = this.getLengths();
                        return e[e.length - 1]
                    },
                    getLengths: function(e) {
                        if (void 0 === e && (e = this.arcLengthDivisions),
                        this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const t = [];
                        let n, r = this.getPoint(0), i = 0;
                        t.push(0);
                        for (let a = 1; a <= e; a++)
                            n = this.getPoint(a / e),
                            i += n.distanceTo(r),
                            t.push(i),
                            r = n;
                        return this.cacheArcLengths = t,
                        t
                    },
                    updateArcLengths: function() {
                        this.needsUpdate = !0,
                        this.getLengths()
                    },
                    getUtoTmapping: function(e, t) {
                        const n = this.getLengths();
                        let r = 0;
                        const i = n.length;
                        let a;
                        a = t || e * n[i - 1];
                        let o, s = 0, l = i - 1;
                        for (; s <= l; )
                            if (r = Math.floor(s + (l - s) / 2),
                            o = n[r] - a,
                            o < 0)
                                s = r + 1;
                            else {
                                if (!(o > 0)) {
                                    l = r;
                                    break
                                }
                                l = r - 1
                            }
                        if (r = l,
                        n[r] === a)
                            return r / (i - 1);
                        const c = n[r];
                        return (r + (a - c) / (n[r + 1] - c)) / (i - 1)
                    },
                    getTangent: function(e, t) {
                        const n = 1e-4;
                        let r = e - n
                          , i = e + n;
                        r < 0 && (r = 0),
                        i > 1 && (i = 1);
                        const a = this.getPoint(r)
                          , o = this.getPoint(i)
                          , s = t || (a.isVector2 ? new Un : new Kn);
                        return s.copy(o).sub(a).normalize(),
                        s
                    },
                    getTangentAt: function(e, t) {
                        const n = this.getUtoTmapping(e);
                        return this.getTangent(n, t)
                    },
                    computeFrenetFrames: function(e, t) {
                        const n = new Kn
                          , r = []
                          , i = []
                          , a = []
                          , o = new Kn
                          , s = new Tr;
                        for (let t = 0; t <= e; t++) {
                            const n = t / e;
                            r[t] = this.getTangentAt(n, new Kn),
                            r[t].normalize()
                        }
                        i[0] = new Kn,
                        a[0] = new Kn;
                        let l = Number.MAX_VALUE;
                        const c = Math.abs(r[0].x)
                          , u = Math.abs(r[0].y)
                          , h = Math.abs(r[0].z);
                        c <= l && (l = c,
                        n.set(1, 0, 0)),
                        u <= l && (l = u,
                        n.set(0, 1, 0)),
                        h <= l && n.set(0, 0, 1),
                        o.crossVectors(r[0], n).normalize(),
                        i[0].crossVectors(r[0], o),
                        a[0].crossVectors(r[0], i[0]);
                        for (let t = 1; t <= e; t++) {
                            if (i[t] = i[t - 1].clone(),
                            a[t] = a[t - 1].clone(),
                            o.crossVectors(r[t - 1], r[t]),
                            o.length() > Number.EPSILON) {
                                o.normalize();
                                const e = Math.acos(zn.clamp(r[t - 1].dot(r[t]), -1, 1));
                                i[t].applyMatrix4(s.makeRotationAxis(o, e))
                            }
                            a[t].crossVectors(r[t], i[t])
                        }
                        if (!0 === t) {
                            let t = Math.acos(zn.clamp(i[0].dot(i[e]), -1, 1));
                            t /= e,
                            r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (t = -t);
                            for (let n = 1; n <= e; n++)
                                i[n].applyMatrix4(s.makeRotationAxis(r[n], t * n)),
                                a[n].crossVectors(r[n], i[n])
                        }
                        return {
                            tangents: r,
                            normals: i,
                            binormals: a
                        }
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    },
                    toJSON: function() {
                        const e = {
                            metadata: {
                                version: 4.5,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return e.arcLengthDivisions = this.arcLengthDivisions,
                        e.type = this.type,
                        e
                    },
                    fromJSON: function(e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions,
                        this
                    }
                }),
                Cu.prototype = Object.create(Au.prototype),
                Cu.prototype.constructor = Cu,
                Cu.prototype.isEllipseCurve = !0,
                Cu.prototype.getPoint = function(e, t) {
                    const n = t || new Un
                      , r = 2 * Math.PI;
                    let i = this.aEndAngle - this.aStartAngle;
                    const a = Math.abs(i) < Number.EPSILON;
                    for (; i < 0; )
                        i += r;
                    for (; i > r; )
                        i -= r;
                    i < Number.EPSILON && (i = a ? 0 : r),
                    !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
                    const o = this.aStartAngle + e * i;
                    let s = this.aX + this.xRadius * Math.cos(o)
                      , l = this.aY + this.yRadius * Math.sin(o);
                    if (0 !== this.aRotation) {
                        const e = Math.cos(this.aRotation)
                          , t = Math.sin(this.aRotation)
                          , n = s - this.aX
                          , r = l - this.aY;
                        s = n * e - r * t + this.aX,
                        l = n * t + r * e + this.aY
                    }
                    return n.set(s, l)
                }
                ,
                Cu.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.aX = e.aX,
                    this.aY = e.aY,
                    this.xRadius = e.xRadius,
                    this.yRadius = e.yRadius,
                    this.aStartAngle = e.aStartAngle,
                    this.aEndAngle = e.aEndAngle,
                    this.aClockwise = e.aClockwise,
                    this.aRotation = e.aRotation,
                    this
                }
                ,
                Cu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.aX = this.aX,
                    e.aY = this.aY,
                    e.xRadius = this.xRadius,
                    e.yRadius = this.yRadius,
                    e.aStartAngle = this.aStartAngle,
                    e.aEndAngle = this.aEndAngle,
                    e.aClockwise = this.aClockwise,
                    e.aRotation = this.aRotation,
                    e
                }
                ,
                Cu.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.aX = e.aX,
                    this.aY = e.aY,
                    this.xRadius = e.xRadius,
                    this.yRadius = e.yRadius,
                    this.aStartAngle = e.aStartAngle,
                    this.aEndAngle = e.aEndAngle,
                    this.aClockwise = e.aClockwise,
                    this.aRotation = e.aRotation,
                    this
                }
                ,
                Pu.prototype = Object.create(Cu.prototype),
                Pu.prototype.constructor = Pu,
                Pu.prototype.isArcCurve = !0;
                const Lu = new Kn
                  , Du = new Ru
                  , Ou = new Ru
                  , Fu = new Ru;
                function Iu(e=[], t=!1, n="centripetal", r=.5) {
                    Au.call(this),
                    this.type = "CatmullRomCurve3",
                    this.points = e,
                    this.closed = t,
                    this.curveType = n,
                    this.tension = r
                }
                function Nu(e, t, n, r, i) {
                    const a = .5 * (r - t)
                      , o = .5 * (i - n)
                      , s = e * e;
                    return (2 * n - 2 * r + a + o) * (e * s) + (-3 * n + 3 * r - 2 * a - o) * s + a * e + n
                }
                function Bu(e, t, n, r) {
                    return function(e, t) {
                        const n = 1 - e;
                        return n * n * t
                    }(e, t) + function(e, t) {
                        return 2 * (1 - e) * e * t
                    }(e, n) + function(e, t) {
                        return e * e * t
                    }(e, r)
                }
                function ku(e, t, n, r, i) {
                    return function(e, t) {
                        const n = 1 - e;
                        return n * n * n * t
                    }(e, t) + function(e, t) {
                        const n = 1 - e;
                        return 3 * n * n * e * t
                    }(e, n) + function(e, t) {
                        return 3 * (1 - e) * e * e * t
                    }(e, r) + function(e, t) {
                        return e * e * e * t
                    }(e, i)
                }
                function zu(e=new Un, t=new Un, n=new Un, r=new Un) {
                    Au.call(this),
                    this.type = "CubicBezierCurve",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n,
                    this.v3 = r
                }
                function Uu(e=new Kn, t=new Kn, n=new Kn, r=new Kn) {
                    Au.call(this),
                    this.type = "CubicBezierCurve3",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n,
                    this.v3 = r
                }
                function Hu(e=new Un, t=new Un) {
                    Au.call(this),
                    this.type = "LineCurve",
                    this.v1 = e,
                    this.v2 = t
                }
                function Gu(e=new Kn, t=new Kn) {
                    Au.call(this),
                    this.type = "LineCurve3",
                    this.v1 = e,
                    this.v2 = t
                }
                function ju(e=new Un, t=new Un, n=new Un) {
                    Au.call(this),
                    this.type = "QuadraticBezierCurve",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n
                }
                function Vu(e=new Kn, t=new Kn, n=new Kn) {
                    Au.call(this),
                    this.type = "QuadraticBezierCurve3",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n
                }
                function Wu(e=[]) {
                    Au.call(this),
                    this.type = "SplineCurve",
                    this.points = e
                }
                Iu.prototype = Object.create(Au.prototype),
                Iu.prototype.constructor = Iu,
                Iu.prototype.isCatmullRomCurve3 = !0,
                Iu.prototype.getPoint = function(e, t=new Kn) {
                    const n = t
                      , r = this.points
                      , i = r.length
                      , a = (i - (this.closed ? 0 : 1)) * e;
                    let o, s, l = Math.floor(a), c = a - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2,
                    c = 1),
                    this.closed || l > 0 ? o = r[(l - 1) % i] : (Lu.subVectors(r[0], r[1]).add(r[0]),
                    o = Lu);
                    const u = r[l % i]
                      , h = r[(l + 1) % i];
                    if (this.closed || l + 2 < i ? s = r[(l + 2) % i] : (Lu.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]),
                    s = Lu),
                    "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const e = "chordal" === this.curveType ? .5 : .25;
                        let t = Math.pow(o.distanceToSquared(u), e)
                          , n = Math.pow(u.distanceToSquared(h), e)
                          , r = Math.pow(h.distanceToSquared(s), e);
                        n < 1e-4 && (n = 1),
                        t < 1e-4 && (t = n),
                        r < 1e-4 && (r = n),
                        Du.initNonuniformCatmullRom(o.x, u.x, h.x, s.x, t, n, r),
                        Ou.initNonuniformCatmullRom(o.y, u.y, h.y, s.y, t, n, r),
                        Fu.initNonuniformCatmullRom(o.z, u.z, h.z, s.z, t, n, r)
                    } else
                        "catmullrom" === this.curveType && (Du.initCatmullRom(o.x, u.x, h.x, s.x, this.tension),
                        Ou.initCatmullRom(o.y, u.y, h.y, s.y, this.tension),
                        Fu.initCatmullRom(o.z, u.z, h.z, s.z, this.tension));
                    return n.set(Du.calc(c), Ou.calc(c), Fu.calc(c)),
                    n
                }
                ,
                Iu.prototype.copy = function(e) {
                    Au.prototype.copy.call(this, e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this.closed = e.closed,
                    this.curveType = e.curveType,
                    this.tension = e.tension,
                    this
                }
                ,
                Iu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e.closed = this.closed,
                    e.curveType = this.curveType,
                    e.tension = this.tension,
                    e
                }
                ,
                Iu.prototype.fromJSON = function(e) {
                    Au.prototype.fromJSON.call(this, e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new Kn).fromArray(n))
                    }
                    return this.closed = e.closed,
                    this.curveType = e.curveType,
                    this.tension = e.tension,
                    this
                }
                ,
                zu.prototype = Object.create(Au.prototype),
                zu.prototype.constructor = zu,
                zu.prototype.isCubicBezierCurve = !0,
                zu.prototype.getPoint = function(e, t=new Un) {
                    const n = t
                      , r = this.v0
                      , i = this.v1
                      , a = this.v2
                      , o = this.v3;
                    return n.set(ku(e, r.x, i.x, a.x, o.x), ku(e, r.y, i.y, a.y, o.y)),
                    n
                }
                ,
                zu.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this.v3.copy(e.v3),
                    this
                }
                ,
                zu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e.v3 = this.v3.toArray(),
                    e
                }
                ,
                zu.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this.v3.fromArray(e.v3),
                    this
                }
                ,
                Uu.prototype = Object.create(Au.prototype),
                Uu.prototype.constructor = Uu,
                Uu.prototype.isCubicBezierCurve3 = !0,
                Uu.prototype.getPoint = function(e, t=new Kn) {
                    const n = t
                      , r = this.v0
                      , i = this.v1
                      , a = this.v2
                      , o = this.v3;
                    return n.set(ku(e, r.x, i.x, a.x, o.x), ku(e, r.y, i.y, a.y, o.y), ku(e, r.z, i.z, a.z, o.z)),
                    n
                }
                ,
                Uu.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this.v3.copy(e.v3),
                    this
                }
                ,
                Uu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e.v3 = this.v3.toArray(),
                    e
                }
                ,
                Uu.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this.v3.fromArray(e.v3),
                    this
                }
                ,
                Hu.prototype = Object.create(Au.prototype),
                Hu.prototype.constructor = Hu,
                Hu.prototype.isLineCurve = !0,
                Hu.prototype.getPoint = function(e, t=new Un) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(e).add(this.v1)),
                    n
                }
                ,
                Hu.prototype.getPointAt = function(e, t) {
                    return this.getPoint(e, t)
                }
                ,
                Hu.prototype.getTangent = function(e, t) {
                    const n = t || new Un;
                    return n.copy(this.v2).sub(this.v1).normalize(),
                    n
                }
                ,
                Hu.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                ,
                Hu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                ,
                Hu.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
                ,
                Gu.prototype = Object.create(Au.prototype),
                Gu.prototype.constructor = Gu,
                Gu.prototype.isLineCurve3 = !0,
                Gu.prototype.getPoint = function(e, t=new Kn) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(e).add(this.v1)),
                    n
                }
                ,
                Gu.prototype.getPointAt = function(e, t) {
                    return this.getPoint(e, t)
                }
                ,
                Gu.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                ,
                Gu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                ,
                Gu.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
                ,
                ju.prototype = Object.create(Au.prototype),
                ju.prototype.constructor = ju,
                ju.prototype.isQuadraticBezierCurve = !0,
                ju.prototype.getPoint = function(e, t=new Un) {
                    const n = t
                      , r = this.v0
                      , i = this.v1
                      , a = this.v2;
                    return n.set(Bu(e, r.x, i.x, a.x), Bu(e, r.y, i.y, a.y)),
                    n
                }
                ,
                ju.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                ,
                ju.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                ,
                ju.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
                ,
                Vu.prototype = Object.create(Au.prototype),
                Vu.prototype.constructor = Vu,
                Vu.prototype.isQuadraticBezierCurve3 = !0,
                Vu.prototype.getPoint = function(e, t=new Kn) {
                    const n = t
                      , r = this.v0
                      , i = this.v1
                      , a = this.v2;
                    return n.set(Bu(e, r.x, i.x, a.x), Bu(e, r.y, i.y, a.y), Bu(e, r.z, i.z, a.z)),
                    n
                }
                ,
                Vu.prototype.copy = function(e) {
                    return Au.prototype.copy.call(this, e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                ,
                Vu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                ,
                Vu.prototype.fromJSON = function(e) {
                    return Au.prototype.fromJSON.call(this, e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
                ,
                Wu.prototype = Object.create(Au.prototype),
                Wu.prototype.constructor = Wu,
                Wu.prototype.isSplineCurve = !0,
                Wu.prototype.getPoint = function(e, t=new Un) {
                    const n = t
                      , r = this.points
                      , i = (r.length - 1) * e
                      , a = Math.floor(i)
                      , o = i - a
                      , s = r[0 === a ? a : a - 1]
                      , l = r[a]
                      , c = r[a > r.length - 2 ? r.length - 1 : a + 1]
                      , u = r[a > r.length - 3 ? r.length - 1 : a + 2];
                    return n.set(Nu(o, s.x, l.x, c.x, u.x), Nu(o, s.y, l.y, c.y, u.y)),
                    n
                }
                ,
                Wu.prototype.copy = function(e) {
                    Au.prototype.copy.call(this, e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this
                }
                ,
                Wu.prototype.toJSON = function() {
                    const e = Au.prototype.toJSON.call(this);
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e
                }
                ,
                Wu.prototype.fromJSON = function(e) {
                    Au.prototype.fromJSON.call(this, e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new Un).fromArray(n))
                    }
                    return this
                }
                ;
                var qu = Object.freeze({
                    __proto__: null,
                    ArcCurve: Pu,
                    CatmullRomCurve3: Iu,
                    CubicBezierCurve: zu,
                    CubicBezierCurve3: Uu,
                    EllipseCurve: Cu,
                    LineCurve: Hu,
                    LineCurve3: Gu,
                    QuadraticBezierCurve: ju,
                    QuadraticBezierCurve3: Vu,
                    SplineCurve: Wu
                });
                function Xu() {
                    Au.call(this),
                    this.type = "CurvePath",
                    this.curves = [],
                    this.autoClose = !1
                }
                function Yu(e) {
                    Xu.call(this),
                    this.type = "Path",
                    this.currentPoint = new Un,
                    e && this.setFromPoints(e)
                }
                function Zu(e) {
                    Yu.call(this, e),
                    this.uuid = zn.generateUUID(),
                    this.type = "Shape",
                    this.holes = []
                }
                function Ju(e, t=1) {
                    Jr.call(this),
                    this.type = "Light",
                    this.color = new yi(e),
                    this.intensity = t
                }
                function Ku(e, t, n) {
                    Ju.call(this, e, n),
                    this.type = "HemisphereLight",
                    this.position.copy(Jr.DefaultUp),
                    this.updateMatrix(),
                    this.groundColor = new yi(t)
                }
                function Qu(e) {
                    this.camera = e,
                    this.bias = 0,
                    this.normalBias = 0,
                    this.radius = 1,
                    this.mapSize = new Un(512,512),
                    this.map = null,
                    this.mapPass = null,
                    this.matrix = new Tr,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this._frustum = new Ea,
                    this._frameExtents = new Un(1,1),
                    this._viewportCount = 1,
                    this._viewports = [new Xn(0,0,1,1)]
                }
                function $u() {
                    Qu.call(this, new ya(50,1,.5,500)),
                    this.focus = 1
                }
                function eh(e, t, n, r, i, a) {
                    Ju.call(this, e, t),
                    this.type = "SpotLight",
                    this.position.copy(Jr.DefaultUp),
                    this.updateMatrix(),
                    this.target = new Jr,
                    Object.defineProperty(this, "power", {
                        get: function() {
                            return this.intensity * Math.PI
                        },
                        set: function(e) {
                            this.intensity = e / Math.PI
                        }
                    }),
                    this.distance = void 0 !== n ? n : 0,
                    this.angle = void 0 !== r ? r : Math.PI / 3,
                    this.penumbra = void 0 !== i ? i : 0,
                    this.decay = void 0 !== a ? a : 1,
                    this.shadow = new $u
                }
                function th() {
                    Qu.call(this, new ya(90,1,.5,500)),
                    this._frameExtents = new Un(4,2),
                    this._viewportCount = 6,
                    this._viewports = [new Xn(2,1,1,1), new Xn(0,1,1,1), new Xn(3,1,1,1), new Xn(1,1,1,1), new Xn(3,0,1,1), new Xn(1,0,1,1)],
                    this._cubeDirections = [new Kn(1,0,0), new Kn(-1,0,0), new Kn(0,0,1), new Kn(0,0,-1), new Kn(0,1,0), new Kn(0,-1,0)],
                    this._cubeUps = [new Kn(0,1,0), new Kn(0,1,0), new Kn(0,1,0), new Kn(0,1,0), new Kn(0,0,1), new Kn(0,0,-1)]
                }
                function nh(e, t, n, r) {
                    Ju.call(this, e, t),
                    this.type = "PointLight",
                    Object.defineProperty(this, "power", {
                        get: function() {
                            return 4 * this.intensity * Math.PI
                        },
                        set: function(e) {
                            this.intensity = e / (4 * Math.PI)
                        }
                    }),
                    this.distance = void 0 !== n ? n : 0,
                    this.decay = void 0 !== r ? r : 1,
                    this.shadow = new th
                }
                function rh(e=-1, t=1, n=1, r=-1, i=.1, a=2e3) {
                    va.call(this),
                    this.type = "OrthographicCamera",
                    this.zoom = 1,
                    this.view = null,
                    this.left = e,
                    this.right = t,
                    this.top = n,
                    this.bottom = r,
                    this.near = i,
                    this.far = a,
                    this.updateProjectionMatrix()
                }
                function ih() {
                    Qu.call(this, new rh(-5,5,5,-5,.5,500))
                }
                function ah(e, t) {
                    Ju.call(this, e, t),
                    this.type = "DirectionalLight",
                    this.position.copy(Jr.DefaultUp),
                    this.updateMatrix(),
                    this.target = new Jr,
                    this.shadow = new ih
                }
                function oh(e, t) {
                    Ju.call(this, e, t),
                    this.type = "AmbientLight"
                }
                function sh(e, t, n, r) {
                    Ju.call(this, e, t),
                    this.type = "RectAreaLight",
                    this.width = void 0 !== n ? n : 10,
                    this.height = void 0 !== r ? r : 10
                }
                Xu.prototype = Object.assign(Object.create(Au.prototype), {
                    constructor: Xu,
                    add: function(e) {
                        this.curves.push(e)
                    },
                    closePath: function() {
                        const e = this.curves[0].getPoint(0)
                          , t = this.curves[this.curves.length - 1].getPoint(1);
                        e.equals(t) || this.curves.push(new Hu(t,e))
                    },
                    getPoint: function(e) {
                        const t = e * this.getLength()
                          , n = this.getCurveLengths();
                        let r = 0;
                        for (; r < n.length; ) {
                            if (n[r] >= t) {
                                const e = n[r] - t
                                  , i = this.curves[r]
                                  , a = i.getLength()
                                  , o = 0 === a ? 0 : 1 - e / a;
                                return i.getPointAt(o)
                            }
                            r++
                        }
                        return null
                    },
                    getLength: function() {
                        const e = this.getCurveLengths();
                        return e[e.length - 1]
                    },
                    updateArcLengths: function() {
                        this.needsUpdate = !0,
                        this.cacheLengths = null,
                        this.getCurveLengths()
                    },
                    getCurveLengths: function() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                            return this.cacheLengths;
                        const e = [];
                        let t = 0;
                        for (let n = 0, r = this.curves.length; n < r; n++)
                            t += this.curves[n].getLength(),
                            e.push(t);
                        return this.cacheLengths = e,
                        e
                    },
                    getSpacedPoints: function(e=40) {
                        const t = [];
                        for (let n = 0; n <= e; n++)
                            t.push(this.getPoint(n / e));
                        return this.autoClose && t.push(t[0]),
                        t
                    },
                    getPoints: function(e=12) {
                        const t = [];
                        let n;
                        for (let r = 0, i = this.curves; r < i.length; r++) {
                            const a = i[r]
                              , o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e
                              , s = a.getPoints(o);
                            for (let e = 0; e < s.length; e++) {
                                const r = s[e];
                                n && n.equals(r) || (t.push(r),
                                n = r)
                            }
                        }
                        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                        t
                    },
                    copy: function(e) {
                        Au.prototype.copy.call(this, e),
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const n = e.curves[t];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = e.autoClose,
                        this
                    },
                    toJSON: function() {
                        const e = Au.prototype.toJSON.call(this);
                        e.autoClose = this.autoClose,
                        e.curves = [];
                        for (let t = 0, n = this.curves.length; t < n; t++) {
                            const n = this.curves[t];
                            e.curves.push(n.toJSON())
                        }
                        return e
                    },
                    fromJSON: function(e) {
                        Au.prototype.fromJSON.call(this, e),
                        this.autoClose = e.autoClose,
                        this.curves = [];
                        for (let t = 0, n = e.curves.length; t < n; t++) {
                            const n = e.curves[t];
                            this.curves.push((new qu[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }),
                Yu.prototype = Object.assign(Object.create(Xu.prototype), {
                    constructor: Yu,
                    setFromPoints: function(e) {
                        this.moveTo(e[0].x, e[0].y);
                        for (let t = 1, n = e.length; t < n; t++)
                            this.lineTo(e[t].x, e[t].y);
                        return this
                    },
                    moveTo: function(e, t) {
                        return this.currentPoint.set(e, t),
                        this
                    },
                    lineTo: function(e, t) {
                        const n = new Hu(this.currentPoint.clone(),new Un(e,t));
                        return this.curves.push(n),
                        this.currentPoint.set(e, t),
                        this
                    },
                    quadraticCurveTo: function(e, t, n, r) {
                        const i = new ju(this.currentPoint.clone(),new Un(e,t),new Un(n,r));
                        return this.curves.push(i),
                        this.currentPoint.set(n, r),
                        this
                    },
                    bezierCurveTo: function(e, t, n, r, i, a) {
                        const o = new zu(this.currentPoint.clone(),new Un(e,t),new Un(n,r),new Un(i,a));
                        return this.curves.push(o),
                        this.currentPoint.set(i, a),
                        this
                    },
                    splineThru: function(e) {
                        const t = new Wu([this.currentPoint.clone()].concat(e));
                        return this.curves.push(t),
                        this.currentPoint.copy(e[e.length - 1]),
                        this
                    },
                    arc: function(e, t, n, r, i, a) {
                        const o = this.currentPoint.x
                          , s = this.currentPoint.y;
                        return this.absarc(e + o, t + s, n, r, i, a),
                        this
                    },
                    absarc: function(e, t, n, r, i, a) {
                        return this.absellipse(e, t, n, n, r, i, a),
                        this
                    },
                    ellipse: function(e, t, n, r, i, a, o, s) {
                        const l = this.currentPoint.x
                          , c = this.currentPoint.y;
                        return this.absellipse(e + l, t + c, n, r, i, a, o, s),
                        this
                    },
                    absellipse: function(e, t, n, r, i, a, o, s) {
                        const l = new Cu(e,t,n,r,i,a,o,s);
                        if (this.curves.length > 0) {
                            const e = l.getPoint(0);
                            e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                        }
                        this.curves.push(l);
                        const c = l.getPoint(1);
                        return this.currentPoint.copy(c),
                        this
                    },
                    copy: function(e) {
                        return Xu.prototype.copy.call(this, e),
                        this.currentPoint.copy(e.currentPoint),
                        this
                    },
                    toJSON: function() {
                        const e = Xu.prototype.toJSON.call(this);
                        return e.currentPoint = this.currentPoint.toArray(),
                        e
                    },
                    fromJSON: function(e) {
                        return Xu.prototype.fromJSON.call(this, e),
                        this.currentPoint.fromArray(e.currentPoint),
                        this
                    }
                }),
                Zu.prototype = Object.assign(Object.create(Yu.prototype), {
                    constructor: Zu,
                    getPointsHoles: function(e) {
                        const t = [];
                        for (let n = 0, r = this.holes.length; n < r; n++)
                            t[n] = this.holes[n].getPoints(e);
                        return t
                    },
                    extractPoints: function(e) {
                        return {
                            shape: this.getPoints(e),
                            holes: this.getPointsHoles(e)
                        }
                    },
                    copy: function(e) {
                        Yu.prototype.copy.call(this, e),
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const n = e.holes[t];
                            this.holes.push(n.clone())
                        }
                        return this
                    },
                    toJSON: function() {
                        const e = Yu.prototype.toJSON.call(this);
                        e.uuid = this.uuid,
                        e.holes = [];
                        for (let t = 0, n = this.holes.length; t < n; t++) {
                            const n = this.holes[t];
                            e.holes.push(n.toJSON())
                        }
                        return e
                    },
                    fromJSON: function(e) {
                        Yu.prototype.fromJSON.call(this, e),
                        this.uuid = e.uuid,
                        this.holes = [];
                        for (let t = 0, n = e.holes.length; t < n; t++) {
                            const n = e.holes[t];
                            this.holes.push((new Yu).fromJSON(n))
                        }
                        return this
                    }
                }),
                Ju.prototype = Object.assign(Object.create(Jr.prototype), {
                    constructor: Ju,
                    isLight: !0,
                    copy: function(e) {
                        return Jr.prototype.copy.call(this, e),
                        this.color.copy(e.color),
                        this.intensity = e.intensity,
                        this
                    },
                    toJSON: function(e) {
                        const t = Jr.prototype.toJSON.call(this, e);
                        return t.object.color = this.color.getHex(),
                        t.object.intensity = this.intensity,
                        void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                        void 0 !== this.distance && (t.object.distance = this.distance),
                        void 0 !== this.angle && (t.object.angle = this.angle),
                        void 0 !== this.decay && (t.object.decay = this.decay),
                        void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                        void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                        t
                    }
                }),
                Ku.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: Ku,
                    isHemisphereLight: !0,
                    copy: function(e) {
                        return Ju.prototype.copy.call(this, e),
                        this.groundColor.copy(e.groundColor),
                        this
                    }
                }),
                Object.assign(Qu.prototype, {
                    _projScreenMatrix: new Tr,
                    _lightPositionWorld: new Kn,
                    _lookTarget: new Kn,
                    getViewportCount: function() {
                        return this._viewportCount
                    },
                    getFrustum: function() {
                        return this._frustum
                    },
                    updateMatrices: function(e) {
                        const t = this.camera
                          , n = this.matrix
                          , r = this._projScreenMatrix
                          , i = this._lookTarget
                          , a = this._lightPositionWorld;
                        a.setFromMatrixPosition(e.matrixWorld),
                        t.position.copy(a),
                        i.setFromMatrixPosition(e.target.matrixWorld),
                        t.lookAt(i),
                        t.updateMatrixWorld(),
                        r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(r),
                        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        n.multiply(t.projectionMatrix),
                        n.multiply(t.matrixWorldInverse)
                    },
                    getViewport: function(e) {
                        return this._viewports[e]
                    },
                    getFrameExtents: function() {
                        return this._frameExtents
                    },
                    copy: function(e) {
                        return this.camera = e.camera.clone(),
                        this.bias = e.bias,
                        this.radius = e.radius,
                        this.mapSize.copy(e.mapSize),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    toJSON: function() {
                        const e = {};
                        return 0 !== this.bias && (e.bias = this.bias),
                        0 !== this.normalBias && (e.normalBias = this.normalBias),
                        1 !== this.radius && (e.radius = this.radius),
                        512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                        e.camera = this.camera.toJSON(!1).object,
                        delete e.camera.matrix,
                        e
                    }
                }),
                $u.prototype = Object.assign(Object.create(Qu.prototype), {
                    constructor: $u,
                    isSpotLightShadow: !0,
                    updateMatrices: function(e) {
                        const t = this.camera
                          , n = 2 * zn.RAD2DEG * e.angle * this.focus
                          , r = this.mapSize.width / this.mapSize.height
                          , i = e.distance || t.far;
                        n === t.fov && r === t.aspect && i === t.far || (t.fov = n,
                        t.aspect = r,
                        t.far = i,
                        t.updateProjectionMatrix()),
                        Qu.prototype.updateMatrices.call(this, e)
                    }
                }),
                eh.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: eh,
                    isSpotLight: !0,
                    copy: function(e) {
                        return Ju.prototype.copy.call(this, e),
                        this.distance = e.distance,
                        this.angle = e.angle,
                        this.penumbra = e.penumbra,
                        this.decay = e.decay,
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }),
                th.prototype = Object.assign(Object.create(Qu.prototype), {
                    constructor: th,
                    isPointLightShadow: !0,
                    updateMatrices: function(e, t=0) {
                        const n = this.camera
                          , r = this.matrix
                          , i = this._lightPositionWorld
                          , a = this._lookTarget
                          , o = this._projScreenMatrix;
                        i.setFromMatrixPosition(e.matrixWorld),
                        n.position.copy(i),
                        a.copy(n.position),
                        a.add(this._cubeDirections[t]),
                        n.up.copy(this._cubeUps[t]),
                        n.lookAt(a),
                        n.updateMatrixWorld(),
                        r.makeTranslation(-i.x, -i.y, -i.z),
                        o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                        this._frustum.setFromProjectionMatrix(o)
                    }
                }),
                nh.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: nh,
                    isPointLight: !0,
                    copy: function(e) {
                        return Ju.prototype.copy.call(this, e),
                        this.distance = e.distance,
                        this.decay = e.decay,
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }),
                rh.prototype = Object.assign(Object.create(va.prototype), {
                    constructor: rh,
                    isOrthographicCamera: !0,
                    copy: function(e, t) {
                        return va.prototype.copy.call(this, e, t),
                        this.left = e.left,
                        this.right = e.right,
                        this.top = e.top,
                        this.bottom = e.bottom,
                        this.near = e.near,
                        this.far = e.far,
                        this.zoom = e.zoom,
                        this.view = null === e.view ? null : Object.assign({}, e.view),
                        this
                    },
                    setViewOffset: function(e, t, n, r, i, a) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }),
                        this.view.enabled = !0,
                        this.view.fullWidth = e,
                        this.view.fullHeight = t,
                        this.view.offsetX = n,
                        this.view.offsetY = r,
                        this.view.width = i,
                        this.view.height = a,
                        this.updateProjectionMatrix()
                    },
                    clearViewOffset: function() {
                        null !== this.view && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                    },
                    updateProjectionMatrix: function() {
                        const e = (this.right - this.left) / (2 * this.zoom)
                          , t = (this.top - this.bottom) / (2 * this.zoom)
                          , n = (this.right + this.left) / 2
                          , r = (this.top + this.bottom) / 2;
                        let i = n - e
                          , a = n + e
                          , o = r + t
                          , s = r - t;
                        if (null !== this.view && this.view.enabled) {
                            const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                              , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            i += e * this.view.offsetX,
                            a = i + e * this.view.width,
                            o -= t * this.view.offsetY,
                            s = o - t * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    },
                    toJSON: function(e) {
                        const t = Jr.prototype.toJSON.call(this, e);
                        return t.object.zoom = this.zoom,
                        t.object.left = this.left,
                        t.object.right = this.right,
                        t.object.top = this.top,
                        t.object.bottom = this.bottom,
                        t.object.near = this.near,
                        t.object.far = this.far,
                        null !== this.view && (t.object.view = Object.assign({}, this.view)),
                        t
                    }
                }),
                ih.prototype = Object.assign(Object.create(Qu.prototype), {
                    constructor: ih,
                    isDirectionalLightShadow: !0,
                    updateMatrices: function(e) {
                        Qu.prototype.updateMatrices.call(this, e)
                    }
                }),
                ah.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: ah,
                    isDirectionalLight: !0,
                    copy: function(e) {
                        return Ju.prototype.copy.call(this, e),
                        this.target = e.target.clone(),
                        this.shadow = e.shadow.clone(),
                        this
                    }
                }),
                oh.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: oh,
                    isAmbientLight: !0
                }),
                sh.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: sh,
                    isRectAreaLight: !0,
                    copy: function(e) {
                        return Ju.prototype.copy.call(this, e),
                        this.width = e.width,
                        this.height = e.height,
                        this
                    },
                    toJSON: function(e) {
                        const t = Ju.prototype.toJSON.call(this, e);
                        return t.object.width = this.width,
                        t.object.height = this.height,
                        t
                    }
                });
                class lh {
                    constructor() {
                        Object.defineProperty(this, "isSphericalHarmonics3", {
                            value: !0
                        }),
                        this.coefficients = [];
                        for (let e = 0; e < 9; e++)
                            this.coefficients.push(new Kn)
                    }
                    set(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].copy(e[t]);
                        return this
                    }
                    zero() {
                        for (let e = 0; e < 9; e++)
                            this.coefficients[e].set(0, 0, 0);
                        return this
                    }
                    getAt(e, t) {
                        const n = e.x
                          , r = e.y
                          , i = e.z
                          , a = this.coefficients;
                        return t.copy(a[0]).multiplyScalar(.282095),
                        t.addScaledVector(a[1], .488603 * r),
                        t.addScaledVector(a[2], .488603 * i),
                        t.addScaledVector(a[3], .488603 * n),
                        t.addScaledVector(a[4], n * r * 1.092548),
                        t.addScaledVector(a[5], r * i * 1.092548),
                        t.addScaledVector(a[6], .315392 * (3 * i * i - 1)),
                        t.addScaledVector(a[7], n * i * 1.092548),
                        t.addScaledVector(a[8], .546274 * (n * n - r * r)),
                        t
                    }
                    getIrradianceAt(e, t) {
                        const n = e.x
                          , r = e.y
                          , i = e.z
                          , a = this.coefficients;
                        return t.copy(a[0]).multiplyScalar(.886227),
                        t.addScaledVector(a[1], 1.023328 * r),
                        t.addScaledVector(a[2], 1.023328 * i),
                        t.addScaledVector(a[3], 1.023328 * n),
                        t.addScaledVector(a[4], .858086 * n * r),
                        t.addScaledVector(a[5], .858086 * r * i),
                        t.addScaledVector(a[6], .743125 * i * i - .247708),
                        t.addScaledVector(a[7], .858086 * n * i),
                        t.addScaledVector(a[8], .429043 * (n * n - r * r)),
                        t
                    }
                    add(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].add(e.coefficients[t]);
                        return this
                    }
                    addScaledSH(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].addScaledVector(e.coefficients[n], t);
                        return this
                    }
                    scale(e) {
                        for (let t = 0; t < 9; t++)
                            this.coefficients[t].multiplyScalar(e);
                        return this
                    }
                    lerp(e, t) {
                        for (let n = 0; n < 9; n++)
                            this.coefficients[n].lerp(e.coefficients[n], t);
                        return this
                    }
                    equals(e) {
                        for (let t = 0; t < 9; t++)
                            if (!this.coefficients[t].equals(e.coefficients[t]))
                                return !1;
                        return !0
                    }
                    copy(e) {
                        return this.set(e.coefficients)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    fromArray(e, t=0) {
                        const n = this.coefficients;
                        for (let r = 0; r < 9; r++)
                            n[r].fromArray(e, t + 3 * r);
                        return this
                    }
                    toArray(e=[], t=0) {
                        const n = this.coefficients;
                        for (let r = 0; r < 9; r++)
                            n[r].toArray(e, t + 3 * r);
                        return e
                    }
                    static getBasisAt(e, t) {
                        const n = e.x
                          , r = e.y
                          , i = e.z;
                        t[0] = .282095,
                        t[1] = .488603 * r,
                        t[2] = .488603 * i,
                        t[3] = .488603 * n,
                        t[4] = 1.092548 * n * r,
                        t[5] = 1.092548 * r * i,
                        t[6] = .315392 * (3 * i * i - 1),
                        t[7] = 1.092548 * n * i,
                        t[8] = .546274 * (n * n - r * r)
                    }
                }
                function ch(e, t) {
                    Ju.call(this, void 0, t),
                    this.type = "LightProbe",
                    this.sh = void 0 !== e ? e : new lh
                }
                function uh(e) {
                    yu.call(this, e),
                    this.textures = {}
                }
                ch.prototype = Object.assign(Object.create(Ju.prototype), {
                    constructor: ch,
                    isLightProbe: !0,
                    copy: function(e) {
                        return Ju.prototype.copy.call(this, e),
                        this.sh.copy(e.sh),
                        this
                    },
                    fromJSON: function(e) {
                        return this.intensity = e.intensity,
                        this.sh.fromArray(e.sh),
                        this
                    },
                    toJSON: function(e) {
                        const t = Ju.prototype.toJSON.call(this, e);
                        return t.object.sh = this.sh.toArray(),
                        t
                    }
                }),
                uh.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: uh,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = new xu(i.manager);
                        a.setPath(i.path),
                        a.setRequestHeader(i.requestHeader),
                        a.setWithCredentials(i.withCredentials),
                        a.load(e, (function(n) {
                            try {
                                t(i.parse(JSON.parse(n)))
                            } catch (t) {
                                r ? r(t) : console.error(t),
                                i.manager.itemError(e)
                            }
                        }
                        ), n, r)
                    },
                    parse: function(e) {
                        const t = this.textures;
                        function n(e) {
                            return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
                            t[e]
                        }
                        const r = new $c[e.type];
                        if (void 0 !== e.uuid && (r.uuid = e.uuid),
                        void 0 !== e.name && (r.name = e.name),
                        void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color),
                        void 0 !== e.roughness && (r.roughness = e.roughness),
                        void 0 !== e.metalness && (r.metalness = e.metalness),
                        void 0 !== e.sheen && (r.sheen = (new yi).setHex(e.sheen)),
                        void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive),
                        void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular),
                        void 0 !== e.shininess && (r.shininess = e.shininess),
                        void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat),
                        void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness),
                        void 0 !== e.fog && (r.fog = e.fog),
                        void 0 !== e.flatShading && (r.flatShading = e.flatShading),
                        void 0 !== e.blending && (r.blending = e.blending),
                        void 0 !== e.combine && (r.combine = e.combine),
                        void 0 !== e.side && (r.side = e.side),
                        void 0 !== e.opacity && (r.opacity = e.opacity),
                        void 0 !== e.transparent && (r.transparent = e.transparent),
                        void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest),
                        void 0 !== e.depthTest && (r.depthTest = e.depthTest),
                        void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite),
                        void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite),
                        void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite),
                        void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask),
                        void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc),
                        void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef),
                        void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask),
                        void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail),
                        void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail),
                        void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass),
                        void 0 !== e.wireframe && (r.wireframe = e.wireframe),
                        void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth),
                        void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap),
                        void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin),
                        void 0 !== e.rotation && (r.rotation = e.rotation),
                        1 !== e.linewidth && (r.linewidth = e.linewidth),
                        void 0 !== e.dashSize && (r.dashSize = e.dashSize),
                        void 0 !== e.gapSize && (r.gapSize = e.gapSize),
                        void 0 !== e.scale && (r.scale = e.scale),
                        void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset),
                        void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor),
                        void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits),
                        void 0 !== e.skinning && (r.skinning = e.skinning),
                        void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets),
                        void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals),
                        void 0 !== e.dithering && (r.dithering = e.dithering),
                        void 0 !== e.vertexTangents && (r.vertexTangents = e.vertexTangents),
                        void 0 !== e.visible && (r.visible = e.visible),
                        void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped),
                        void 0 !== e.userData && (r.userData = e.userData),
                        void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
                        void 0 !== e.uniforms)
                            for (const t in e.uniforms) {
                                const i = e.uniforms[t];
                                switch (r.uniforms[t] = {},
                                i.type) {
                                case "t":
                                    r.uniforms[t].value = n(i.value);
                                    break;
                                case "c":
                                    r.uniforms[t].value = (new yi).setHex(i.value);
                                    break;
                                case "v2":
                                    r.uniforms[t].value = (new Un).fromArray(i.value);
                                    break;
                                case "v3":
                                    r.uniforms[t].value = (new Kn).fromArray(i.value);
                                    break;
                                case "v4":
                                    r.uniforms[t].value = (new Xn).fromArray(i.value);
                                    break;
                                case "m3":
                                    r.uniforms[t].value = (new Hn).fromArray(i.value);
                                    break;
                                case "m4":
                                    r.uniforms[t].value = (new Tr).fromArray(i.value);
                                    break;
                                default:
                                    r.uniforms[t].value = i.value
                                }
                            }
                        if (void 0 !== e.defines && (r.defines = e.defines),
                        void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader),
                        void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader),
                        void 0 !== e.extensions)
                            for (const t in e.extensions)
                                r.extensions[t] = e.extensions[t];
                        if (void 0 !== e.shading && (r.flatShading = 1 === e.shading),
                        void 0 !== e.size && (r.size = e.size),
                        void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation),
                        void 0 !== e.map && (r.map = n(e.map)),
                        void 0 !== e.matcap && (r.matcap = n(e.matcap)),
                        void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)),
                        void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)),
                        void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale),
                        void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)),
                        void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType),
                        void 0 !== e.normalScale) {
                            let t = e.normalScale;
                            !1 === Array.isArray(t) && (t = [t, t]),
                            r.normalScale = (new Un).fromArray(t)
                        }
                        return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)),
                        void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale),
                        void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias),
                        void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)),
                        void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)),
                        void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)),
                        void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity),
                        void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)),
                        void 0 !== e.envMap && (r.envMap = n(e.envMap)),
                        void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity),
                        void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity),
                        void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio),
                        void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)),
                        void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity),
                        void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)),
                        void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity),
                        void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)),
                        void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)),
                        void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
                        void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)),
                        void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Un).fromArray(e.clearcoatNormalScale)),
                        void 0 !== e.transmission && (r.transmission = e.transmission),
                        void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)),
                        r
                    },
                    setTextures: function(e) {
                        return this.textures = e,
                        this
                    }
                });
                const hh = {
                    decodeText: function(e) {
                        if ("undefined" != typeof TextDecoder)
                            return (new TextDecoder).decode(e);
                        let t = "";
                        for (let n = 0, r = e.length; n < r; n++)
                            t += String.fromCharCode(e[n]);
                        try {
                            return decodeURIComponent(escape(t))
                        } catch (e) {
                            return t
                        }
                    },
                    extractUrlBase: function(e) {
                        const t = e.lastIndexOf("/");
                        return -1 === t ? "./" : e.substr(0, t + 1)
                    }
                };
                function dh() {
                    qi.call(this),
                    this.type = "InstancedBufferGeometry",
                    this.instanceCount = 1 / 0
                }
                function ph(e, t, n, r) {
                    "number" == typeof n && (r = n,
                    n = !1,
                    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
                    Ti.call(this, e, t, n),
                    this.meshPerAttribute = r || 1
                }
                function fh(e) {
                    yu.call(this, e)
                }
                dh.prototype = Object.assign(Object.create(qi.prototype), {
                    constructor: dh,
                    isInstancedBufferGeometry: !0,
                    copy: function(e) {
                        return qi.prototype.copy.call(this, e),
                        this.instanceCount = e.instanceCount,
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    toJSON: function() {
                        const e = qi.prototype.toJSON.call(this);
                        return e.instanceCount = this.instanceCount,
                        e.isInstancedBufferGeometry = !0,
                        e
                    }
                }),
                ph.prototype = Object.assign(Object.create(Ti.prototype), {
                    constructor: ph,
                    isInstancedBufferAttribute: !0,
                    copy: function(e) {
                        return Ti.prototype.copy.call(this, e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    },
                    toJSON: function() {
                        const e = Ti.prototype.toJSON.call(this);
                        return e.meshPerAttribute = this.meshPerAttribute,
                        e.isInstancedBufferAttribute = !0,
                        e
                    }
                }),
                fh.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: fh,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = new xu(i.manager);
                        a.setPath(i.path),
                        a.setRequestHeader(i.requestHeader),
                        a.setWithCredentials(i.withCredentials),
                        a.load(e, (function(n) {
                            try {
                                t(i.parse(JSON.parse(n)))
                            } catch (t) {
                                r ? r(t) : console.error(t),
                                i.manager.itemError(e)
                            }
                        }
                        ), n, r)
                    },
                    parse: function(e) {
                        const t = {}
                          , n = {};
                        function r(e, r) {
                            if (void 0 !== t[r])
                                return t[r];
                            const i = e.interleavedBuffers[r]
                              , a = function(e, t) {
                                if (void 0 !== n[t])
                                    return n[t];
                                const r = e.arrayBuffers[t]
                                  , i = new Uint32Array(r).buffer;
                                return n[t] = i,
                                i
                            }(e, i.buffer)
                              , o = new zs(ki(i.type, a),i.stride);
                            return o.uuid = i.uuid,
                            t[r] = o,
                            o
                        }
                        const i = e.isInstancedBufferGeometry ? new dh : new qi
                          , a = e.data.index;
                        if (void 0 !== a) {
                            const e = ki(a.type, a.array);
                            i.setIndex(new Ti(e,1))
                        }
                        const o = e.data.attributes;
                        for (const t in o) {
                            const n = o[t];
                            let a;
                            if (n.isInterleavedBufferAttribute)
                                a = new Hs(r(e.data, n.data),n.itemSize,n.offset,n.normalized);
                            else {
                                const e = ki(n.type, n.array);
                                a = new (n.isInstancedBufferAttribute ? ph : Ti)(e,n.itemSize,n.normalized)
                            }
                            void 0 !== n.name && (a.name = n.name),
                            i.setAttribute(t, a)
                        }
                        const s = e.data.morphAttributes;
                        if (s)
                            for (const t in s) {
                                const n = s[t]
                                  , a = [];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    let o;
                                    o = i.isInterleavedBufferAttribute ? new Hs(r(e.data, i.data),i.itemSize,i.offset,i.normalized) : new Ti(ki(i.type, i.array),i.itemSize,i.normalized),
                                    void 0 !== i.name && (o.name = i.name),
                                    a.push(o)
                                }
                                i.morphAttributes[t] = a
                            }
                        e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                        const l = e.data.groups || e.data.drawcalls || e.data.offsets;
                        if (void 0 !== l)
                            for (let e = 0, t = l.length; e !== t; ++e) {
                                const t = l[e];
                                i.addGroup(t.start, t.count, t.materialIndex)
                            }
                        const c = e.data.boundingSphere;
                        if (void 0 !== c) {
                            const e = new Kn;
                            void 0 !== c.center && e.fromArray(c.center),
                            i.boundingSphere = new gr(e,c.radius)
                        }
                        return e.name && (i.name = e.name),
                        e.userData && (i.userData = e.userData),
                        i
                    }
                });
                class mh extends yu {
                    constructor(e) {
                        super(e)
                    }
                    load(e, t, n, r) {
                        const i = this
                          , a = "" === this.path ? hh.extractUrlBase(e) : this.path;
                        this.resourcePath = this.resourcePath || a;
                        const o = new xu(this.manager);
                        o.setPath(this.path),
                        o.setRequestHeader(this.requestHeader),
                        o.setWithCredentials(this.withCredentials),
                        o.load(e, (function(n) {
                            let a = null;
                            try {
                                a = JSON.parse(n)
                            } catch (t) {
                                return void 0 !== r && r(t),
                                void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                            }
                            const o = a.metadata;
                            void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? i.parse(a, t) : console.error("THREE.ObjectLoader: Can't load " + e)
                        }
                        ), n, r)
                    }
                    parse(e, t) {
                        const n = this.parseAnimations(e.animations)
                          , r = this.parseShapes(e.shapes)
                          , i = this.parseGeometries(e.geometries, r)
                          , a = this.parseImages(e.images, (function() {
                            void 0 !== t && t(l)
                        }
                        ))
                          , o = this.parseTextures(e.textures, a)
                          , s = this.parseMaterials(e.materials, o)
                          , l = this.parseObject(e.object, i, s, n)
                          , c = this.parseSkeletons(e.skeletons, l);
                        if (this.bindSkeletons(l, c),
                        void 0 !== t) {
                            let e = !1;
                            for (const t in a)
                                if (a[t]instanceof HTMLImageElement) {
                                    e = !0;
                                    break
                                }
                            !1 === e && t(l)
                        }
                        return l
                    }
                    parseShapes(e) {
                        const t = {};
                        if (void 0 !== e)
                            for (let n = 0, r = e.length; n < r; n++) {
                                const r = (new Zu).fromJSON(e[n]);
                                t[r.uuid] = r
                            }
                        return t
                    }
                    parseSkeletons(e, t) {
                        const n = {}
                          , r = {};
                        if (t.traverse((function(e) {
                            e.isBone && (r[e.uuid] = e)
                        }
                        )),
                        void 0 !== e)
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = (new gl).fromJSON(e[t], r);
                                n[i.uuid] = i
                            }
                        return n
                    }
                    parseGeometries(e, t) {
                        const n = {};
                        let r;
                        if (void 0 !== e) {
                            const i = new fh;
                            for (let a = 0, o = e.length; a < o; a++) {
                                let o;
                                const s = e[a];
                                switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    o = new Gc[s.type](s.width,s.height,s.widthSegments,s.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                    o = new Gc[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    o = new Gc[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    o = new Gc[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    o = new Gc[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    o = new Gc[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    o = new Gc[s.type](s.radius,s.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    o = new Gc[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    o = new Gc[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    o = new Gc[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    o = new Gc[s.type]((new qu[s.path.type]).fromJSON(s.path),s.tubularSegments,s.radius,s.radialSegments,s.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    o = new Gc[s.type](s.points,s.segments,s.phiStart,s.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    o = new Gc[s.type](s.vertices,s.indices,s.radius,s.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    r = [];
                                    for (let e = 0, n = s.shapes.length; e < n; e++) {
                                        const n = t[s.shapes[e]];
                                        r.push(n)
                                    }
                                    o = new Gc[s.type](r,s.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    r = [];
                                    for (let e = 0, n = s.shapes.length; e < n; e++) {
                                        const n = t[s.shapes[e]];
                                        r.push(n)
                                    }
                                    const e = s.options.extrudePath;
                                    void 0 !== e && (s.options.extrudePath = (new qu[e.type]).fromJSON(e)),
                                    o = new Gc[s.type](r,s.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    o = i.parse(s);
                                    break;
                                case "Geometry":
                                    console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                    continue
                                }
                                o.uuid = s.uuid,
                                void 0 !== s.name && (o.name = s.name),
                                !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData),
                                n[s.uuid] = o
                            }
                        }
                        return n
                    }
                    parseMaterials(e, t) {
                        const n = {}
                          , r = {};
                        if (void 0 !== e) {
                            const i = new uh;
                            i.setTextures(t);
                            for (let t = 0, a = e.length; t < a; t++) {
                                const a = e[t];
                                if ("MultiMaterial" === a.type) {
                                    const e = [];
                                    for (let t = 0; t < a.materials.length; t++) {
                                        const r = a.materials[t];
                                        void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)),
                                        e.push(n[r.uuid])
                                    }
                                    r[a.uuid] = e
                                } else
                                    void 0 === n[a.uuid] && (n[a.uuid] = i.parse(a)),
                                    r[a.uuid] = n[a.uuid]
                            }
                        }
                        return r
                    }
                    parseAnimations(e) {
                        const t = {};
                        if (void 0 !== e)
                            for (let n = 0; n < e.length; n++) {
                                const r = e[n]
                                  , i = pu.parse(r);
                                t[i.uuid] = i
                            }
                        return t
                    }
                    parseImages(e, t) {
                        const n = this
                          , r = {};
                        let i;
                        function a(e) {
                            if ("string" == typeof e) {
                                const t = e;
                                return function(e) {
                                    return n.manager.itemStart(e),
                                    i.load(e, (function() {
                                        n.manager.itemEnd(e)
                                    }
                                    ), void 0, (function() {
                                        n.manager.itemError(e),
                                        n.manager.itemEnd(e)
                                    }
                                    ))
                                }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                            }
                            return e.data ? {
                                data: ki(e.type, e.data),
                                width: e.width,
                                height: e.height
                            } : null
                        }
                        if (void 0 !== e && e.length > 0) {
                            const n = new gu(t);
                            i = new Mu(n),
                            i.setCrossOrigin(this.crossOrigin);
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t]
                                  , i = n.url;
                                if (Array.isArray(i)) {
                                    r[n.uuid] = [];
                                    for (let e = 0, t = i.length; e < t; e++) {
                                        const t = a(i[e]);
                                        null !== t && (t instanceof HTMLImageElement ? r[n.uuid].push(t) : r[n.uuid].push(new Ma(t.data,t.width,t.height)))
                                    }
                                } else {
                                    const e = a(n.url);
                                    null !== e && (r[n.uuid] = e)
                                }
                            }
                        }
                        return r
                    }
                    parseTextures(e, t) {
                        function n(e, t) {
                            return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                            t[e])
                        }
                        const r = {};
                        if (void 0 !== e)
                            for (let i = 0, a = e.length; i < a; i++) {
                                const a = e[i];
                                let o;
                                void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                                void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                                const s = t[a.image];
                                Array.isArray(s) ? (o = new ba(s),
                                6 === s.length && (o.needsUpdate = !0)) : (o = s && s.data ? new Ma(s.data,s.width,s.height) : new Wn(s),
                                s && (o.needsUpdate = !0)),
                                o.uuid = a.uuid,
                                void 0 !== a.name && (o.name = a.name),
                                void 0 !== a.mapping && (o.mapping = n(a.mapping, gh)),
                                void 0 !== a.offset && o.offset.fromArray(a.offset),
                                void 0 !== a.repeat && o.repeat.fromArray(a.repeat),
                                void 0 !== a.center && o.center.fromArray(a.center),
                                void 0 !== a.rotation && (o.rotation = a.rotation),
                                void 0 !== a.wrap && (o.wrapS = n(a.wrap[0], vh),
                                o.wrapT = n(a.wrap[1], vh)),
                                void 0 !== a.format && (o.format = a.format),
                                void 0 !== a.type && (o.type = a.type),
                                void 0 !== a.encoding && (o.encoding = a.encoding),
                                void 0 !== a.minFilter && (o.minFilter = n(a.minFilter, yh)),
                                void 0 !== a.magFilter && (o.magFilter = n(a.magFilter, yh)),
                                void 0 !== a.anisotropy && (o.anisotropy = a.anisotropy),
                                void 0 !== a.flipY && (o.flipY = a.flipY),
                                void 0 !== a.premultiplyAlpha && (o.premultiplyAlpha = a.premultiplyAlpha),
                                void 0 !== a.unpackAlignment && (o.unpackAlignment = a.unpackAlignment),
                                r[a.uuid] = o
                            }
                        return r
                    }
                    parseObject(e, t, n, r) {
                        let i, a, o;
                        function s(e) {
                            return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                            t[e]
                        }
                        function l(e) {
                            if (void 0 !== e) {
                                if (Array.isArray(e)) {
                                    const t = [];
                                    for (let r = 0, i = e.length; r < i; r++) {
                                        const i = e[r];
                                        void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i),
                                        t.push(n[i])
                                    }
                                    return t
                                }
                                return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                                n[e]
                            }
                        }
                        switch (e.type) {
                        case "Scene":
                            i = new ks,
                            void 0 !== e.background && Number.isInteger(e.background) && (i.background = new yi(e.background)),
                            void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new Bs(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new Ns(e.fog.color,e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            i = new ya(e.fov,e.aspect,e.near,e.far),
                            void 0 !== e.focus && (i.focus = e.focus),
                            void 0 !== e.zoom && (i.zoom = e.zoom),
                            void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge),
                            void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset),
                            void 0 !== e.view && (i.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            i = new rh(e.left,e.right,e.top,e.bottom,e.near,e.far),
                            void 0 !== e.zoom && (i.zoom = e.zoom),
                            void 0 !== e.view && (i.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            i = new oh(e.color,e.intensity);
                            break;
                        case "DirectionalLight":
                            i = new ah(e.color,e.intensity);
                            break;
                        case "PointLight":
                            i = new nh(e.color,e.intensity,e.distance,e.decay);
                            break;
                        case "RectAreaLight":
                            i = new sh(e.color,e.intensity,e.width,e.height);
                            break;
                        case "SpotLight":
                            i = new eh(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                            break;
                        case "HemisphereLight":
                            i = new Ku(e.color,e.groundColor,e.intensity);
                            break;
                        case "LightProbe":
                            i = (new ch).fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            a = s(e.geometry),
                            o = l(e.material),
                            i = new dl(a,o),
                            void 0 !== e.bindMode && (i.bindMode = e.bindMode),
                            void 0 !== e.bindMatrix && i.bindMatrix.fromArray(e.bindMatrix),
                            void 0 !== e.skeleton && (i.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            a = s(e.geometry),
                            o = l(e.material),
                            i = new ua(a,o);
                            break;
                        case "InstancedMesh":
                            a = s(e.geometry),
                            o = l(e.material);
                            const t = e.count
                              , n = e.instanceMatrix;
                            i = new bl(a,o,t),
                            i.instanceMatrix = new Ti(new Float32Array(n.array),16);
                            break;
                        case "LOD":
                            i = new ol;
                            break;
                        case "Line":
                            i = new Cl(s(e.geometry),l(e.material));
                            break;
                        case "LineLoop":
                            i = new Dl(s(e.geometry),l(e.material));
                            break;
                        case "LineSegments":
                            i = new Ll(s(e.geometry),l(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            i = new kl(s(e.geometry),l(e.material));
                            break;
                        case "Sprite":
                            i = new nl(l(e.material));
                            break;
                        case "Group":
                            i = new Rs;
                            break;
                        case "Bone":
                            i = new pl;
                            break;
                        default:
                            i = new Jr
                        }
                        if (i.uuid = e.uuid,
                        void 0 !== e.name && (i.name = e.name),
                        void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix),
                        void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate),
                        i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position),
                        void 0 !== e.rotation && i.rotation.fromArray(e.rotation),
                        void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion),
                        void 0 !== e.scale && i.scale.fromArray(e.scale)),
                        void 0 !== e.castShadow && (i.castShadow = e.castShadow),
                        void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow),
                        e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias),
                        void 0 !== e.shadow.normalBias && (i.shadow.normalBias = e.shadow.normalBias),
                        void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius),
                        void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize),
                        void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))),
                        void 0 !== e.visible && (i.visible = e.visible),
                        void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled),
                        void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder),
                        void 0 !== e.userData && (i.userData = e.userData),
                        void 0 !== e.layers && (i.layers.mask = e.layers),
                        void 0 !== e.children) {
                            const a = e.children;
                            for (let e = 0; e < a.length; e++)
                                i.add(this.parseObject(a[e], t, n, r))
                        }
                        if (void 0 !== e.animations) {
                            const t = e.animations;
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e];
                                i.animations.push(r[n])
                            }
                        }
                        if ("LOD" === e.type) {
                            void 0 !== e.autoUpdate && (i.autoUpdate = e.autoUpdate);
                            const t = e.levels;
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e]
                                  , r = i.getObjectByProperty("uuid", n.object);
                                void 0 !== r && i.addLevel(r, n.distance)
                            }
                        }
                        return i
                    }
                    bindSkeletons(e, t) {
                        0 !== Object.keys(t).length && e.traverse((function(e) {
                            if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                                const n = t[e.skeleton];
                                void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                            }
                        }
                        ))
                    }
                    setTexturePath(e) {
                        return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
                        this.setResourcePath(e)
                    }
                }
                const gh = {
                    UVMapping: ie,
                    CubeReflectionMapping: ae,
                    CubeRefractionMapping: oe,
                    EquirectangularReflectionMapping: se,
                    EquirectangularRefractionMapping: le,
                    CubeUVReflectionMapping: ce,
                    CubeUVRefractionMapping: ue
                }
                  , vh = {
                    RepeatWrapping: he,
                    ClampToEdgeWrapping: de,
                    MirroredRepeatWrapping: pe
                }
                  , yh = {
                    NearestFilter: fe,
                    NearestMipmapNearestFilter: me,
                    NearestMipmapLinearFilter: ve,
                    LinearFilter: _e,
                    LinearMipmapNearestFilter: xe,
                    LinearMipmapLinearFilter: we
                };
                function _h(e) {
                    "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                    "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                    yu.call(this, e),
                    this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                function xh() {
                    this.type = "ShapePath",
                    this.color = new yi,
                    this.subPaths = [],
                    this.currentPath = null
                }
                _h.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: _h,
                    isImageBitmapLoader: !0,
                    setOptions: function(e) {
                        return this.options = e,
                        this
                    },
                    load: function(e, t, n, r) {
                        void 0 === e && (e = ""),
                        void 0 !== this.path && (e = this.path + e),
                        e = this.manager.resolveURL(e);
                        const i = this
                          , a = mu.get(e);
                        if (void 0 !== a)
                            return i.manager.itemStart(e),
                            setTimeout((function() {
                                t && t(a),
                                i.manager.itemEnd(e)
                            }
                            ), 0),
                            a;
                        const o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                        fetch(e, o).then((function(e) {
                            return e.blob()
                        }
                        )).then((function(e) {
                            return createImageBitmap(e, i.options)
                        }
                        )).then((function(n) {
                            mu.add(e, n),
                            t && t(n),
                            i.manager.itemEnd(e)
                        }
                        )).catch((function(t) {
                            r && r(t),
                            i.manager.itemError(e),
                            i.manager.itemEnd(e)
                        }
                        )),
                        i.manager.itemStart(e)
                    }
                }),
                Object.assign(xh.prototype, {
                    moveTo: function(e, t) {
                        return this.currentPath = new Yu,
                        this.subPaths.push(this.currentPath),
                        this.currentPath.moveTo(e, t),
                        this
                    },
                    lineTo: function(e, t) {
                        return this.currentPath.lineTo(e, t),
                        this
                    },
                    quadraticCurveTo: function(e, t, n, r) {
                        return this.currentPath.quadraticCurveTo(e, t, n, r),
                        this
                    },
                    bezierCurveTo: function(e, t, n, r, i, a) {
                        return this.currentPath.bezierCurveTo(e, t, n, r, i, a),
                        this
                    },
                    splineThru: function(e) {
                        return this.currentPath.splineThru(e),
                        this
                    },
                    toShapes: function(e, t) {
                        function n(e) {
                            const t = [];
                            for (let n = 0, r = e.length; n < r; n++) {
                                const r = e[n]
                                  , i = new Zu;
                                i.curves = r.curves,
                                t.push(i)
                            }
                            return t
                        }
                        function r(e, t) {
                            const n = t.length;
                            let r = !1;
                            for (let i = n - 1, a = 0; a < n; i = a++) {
                                let n = t[i]
                                  , o = t[a]
                                  , s = o.x - n.x
                                  , l = o.y - n.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (l < 0 && (n = t[a],
                                    s = -s,
                                    o = t[i],
                                    l = -l),
                                    e.y < n.y || e.y > o.y)
                                        continue;
                                    if (e.y === n.y) {
                                        if (e.x === n.x)
                                            return !0
                                    } else {
                                        const t = l * (e.x - n.x) - s * (e.y - n.y);
                                        if (0 === t)
                                            return !0;
                                        if (t < 0)
                                            continue;
                                        r = !r
                                    }
                                } else {
                                    if (e.y !== n.y)
                                        continue;
                                    if (o.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= o.x)
                                        return !0
                                }
                            }
                            return r
                        }
                        const i = Sc.isClockWise
                          , a = this.subPaths;
                        if (0 === a.length)
                            return [];
                        if (!0 === t)
                            return n(a);
                        let o, s, l;
                        const c = [];
                        if (1 === a.length)
                            return s = a[0],
                            l = new Zu,
                            l.curves = s.curves,
                            c.push(l),
                            c;
                        let u = !i(a[0].getPoints());
                        u = e ? !u : u;
                        const h = []
                          , d = [];
                        let p, f, m = [], g = 0;
                        d[g] = void 0,
                        m[g] = [];
                        for (let t = 0, n = a.length; t < n; t++)
                            s = a[t],
                            p = s.getPoints(),
                            o = i(p),
                            o = e ? !o : o,
                            o ? (!u && d[g] && g++,
                            d[g] = {
                                s: new Zu,
                                p
                            },
                            d[g].s.curves = s.curves,
                            u && g++,
                            m[g] = []) : m[g].push({
                                h: s,
                                p: p[0]
                            });
                        if (!d[0])
                            return n(a);
                        if (d.length > 1) {
                            let e = !1;
                            const t = [];
                            for (let e = 0, t = d.length; e < t; e++)
                                h[e] = [];
                            for (let n = 0, i = d.length; n < i; n++) {
                                const i = m[n];
                                for (let a = 0; a < i.length; a++) {
                                    const o = i[a];
                                    let s = !0;
                                    for (let i = 0; i < d.length; i++)
                                        r(o.p, d[i].p) && (n !== i && t.push({
                                            froms: n,
                                            tos: i,
                                            hole: a
                                        }),
                                        s ? (s = !1,
                                        h[i].push(o)) : e = !0);
                                    s && h[n].push(o)
                                }
                            }
                            t.length > 0 && (e || (m = h))
                        }
                        for (let e = 0, t = d.length; e < t; e++) {
                            l = d[e].s,
                            c.push(l),
                            f = m[e];
                            for (let e = 0, t = f.length; e < t; e++)
                                l.holes.push(f[e].h)
                        }
                        return c
                    }
                });
                class bh {
                    constructor(e) {
                        Object.defineProperty(this, "isFont", {
                            value: !0
                        }),
                        this.type = "Font",
                        this.data = e
                    }
                    generateShapes(e, t=100) {
                        const n = []
                          , r = function(e, t, n) {
                            const r = Array.from ? Array.from(e) : String(e).split("")
                              , i = t / n.resolution
                              , a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i
                              , o = [];
                            let s = 0
                              , l = 0;
                            for (let e = 0; e < r.length; e++) {
                                const t = r[e];
                                if ("\n" === t)
                                    s = 0,
                                    l -= a;
                                else {
                                    const e = wh(t, i, s, l, n);
                                    s += e.offsetX,
                                    o.push(e.path)
                                }
                            }
                            return o
                        }(e, t, this.data);
                        for (let e = 0, t = r.length; e < t; e++)
                            Array.prototype.push.apply(n, r[e].toShapes());
                        return n
                    }
                }
                function wh(e, t, n, r, i) {
                    const a = i.glyphs[e] || i.glyphs["?"];
                    if (!a)
                        return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".");
                    const o = new xh;
                    let s, l, c, u, h, d, p, f;
                    if (a.o) {
                        const e = a._cachedOutline || (a._cachedOutline = a.o.split(" "));
                        for (let i = 0, a = e.length; i < a; )
                            switch (e[i++]) {
                            case "m":
                                s = e[i++] * t + n,
                                l = e[i++] * t + r,
                                o.moveTo(s, l);
                                break;
                            case "l":
                                s = e[i++] * t + n,
                                l = e[i++] * t + r,
                                o.lineTo(s, l);
                                break;
                            case "q":
                                c = e[i++] * t + n,
                                u = e[i++] * t + r,
                                h = e[i++] * t + n,
                                d = e[i++] * t + r,
                                o.quadraticCurveTo(h, d, c, u);
                                break;
                            case "b":
                                c = e[i++] * t + n,
                                u = e[i++] * t + r,
                                h = e[i++] * t + n,
                                d = e[i++] * t + r,
                                p = e[i++] * t + n,
                                f = e[i++] * t + r,
                                o.bezierCurveTo(h, d, p, f, c, u)
                            }
                    }
                    return {
                        offsetX: a.ha * t,
                        path: o
                    }
                }
                function Mh(e) {
                    yu.call(this, e)
                }
                let Sh;
                Mh.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: Mh,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = new xu(this.manager);
                        a.setPath(this.path),
                        a.setRequestHeader(this.requestHeader),
                        a.setWithCredentials(i.withCredentials),
                        a.load(e, (function(e) {
                            let n;
                            try {
                                n = JSON.parse(e)
                            } catch (t) {
                                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                                n = JSON.parse(e.substring(65, e.length - 2))
                            }
                            const r = i.parse(n);
                            t && t(r)
                        }
                        ), n, r)
                    },
                    parse: function(e) {
                        return new bh(e)
                    }
                });
                const Th = {
                    getContext: function() {
                        return void 0 === Sh && (Sh = new (window.AudioContext || window.webkitAudioContext)),
                        Sh
                    },
                    setContext: function(e) {
                        Sh = e
                    }
                };
                function Eh(e) {
                    yu.call(this, e)
                }
                function Ah(e, t, n) {
                    ch.call(this, void 0, n);
                    const r = (new yi).set(e)
                      , i = (new yi).set(t)
                      , a = new Kn(r.r,r.g,r.b)
                      , o = new Kn(i.r,i.g,i.b)
                      , s = Math.sqrt(Math.PI)
                      , l = s * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
                    this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l)
                }
                function Ch(e, t) {
                    ch.call(this, void 0, t);
                    const n = (new yi).set(e);
                    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
                Eh.prototype = Object.assign(Object.create(yu.prototype), {
                    constructor: Eh,
                    load: function(e, t, n, r) {
                        const i = this
                          , a = new xu(i.manager);
                        a.setResponseType("arraybuffer"),
                        a.setPath(i.path),
                        a.setRequestHeader(i.requestHeader),
                        a.setWithCredentials(i.withCredentials),
                        a.load(e, (function(n) {
                            try {
                                const e = n.slice(0);
                                Th.getContext().decodeAudioData(e, (function(e) {
                                    t(e)
                                }
                                ))
                            } catch (t) {
                                r ? r(t) : console.error(t),
                                i.manager.itemError(e)
                            }
                        }
                        ), n, r)
                    }
                }),
                Ah.prototype = Object.assign(Object.create(ch.prototype), {
                    constructor: Ah,
                    isHemisphereLightProbe: !0,
                    copy: function(e) {
                        return ch.prototype.copy.call(this, e),
                        this
                    },
                    toJSON: function(e) {
                        return ch.prototype.toJSON.call(this, e)
                    }
                }),
                Ch.prototype = Object.assign(Object.create(ch.prototype), {
                    constructor: Ch,
                    isAmbientLightProbe: !0,
                    copy: function(e) {
                        return ch.prototype.copy.call(this, e),
                        this
                    },
                    toJSON: function(e) {
                        return ch.prototype.toJSON.call(this, e)
                    }
                });
                const Ph = new Tr
                  , Rh = new Tr;
                function Lh() {
                    this.type = "StereoCamera",
                    this.aspect = 1,
                    this.eyeSep = .064,
                    this.cameraL = new ya,
                    this.cameraL.layers.enable(1),
                    this.cameraL.matrixAutoUpdate = !1,
                    this.cameraR = new ya,
                    this.cameraR.layers.enable(2),
                    this.cameraR.matrixAutoUpdate = !1,
                    this._cache = {
                        focus: null,
                        fov: null,
                        aspect: null,
                        near: null,
                        far: null,
                        zoom: null,
                        eyeSep: null
                    }
                }
                Object.assign(Lh.prototype, {
                    update: function(e) {
                        const t = this._cache;
                        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                            t.focus = e.focus,
                            t.fov = e.fov,
                            t.aspect = e.aspect * this.aspect,
                            t.near = e.near,
                            t.far = e.far,
                            t.zoom = e.zoom,
                            t.eyeSep = this.eyeSep;
                            const n = e.projectionMatrix.clone()
                              , r = t.eyeSep / 2
                              , i = r * t.near / t.focus
                              , a = t.near * Math.tan(zn.DEG2RAD * t.fov * .5) / t.zoom;
                            let o, s;
                            Rh.elements[12] = -r,
                            Ph.elements[12] = r,
                            o = -a * t.aspect + i,
                            s = a * t.aspect + i,
                            n.elements[0] = 2 * t.near / (s - o),
                            n.elements[8] = (s + o) / (s - o),
                            this.cameraL.projectionMatrix.copy(n),
                            o = -a * t.aspect - i,
                            s = a * t.aspect - i,
                            n.elements[0] = 2 * t.near / (s - o),
                            n.elements[8] = (s + o) / (s - o),
                            this.cameraR.projectionMatrix.copy(n)
                        }
                        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Rh),
                        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Ph)
                    }
                });
                class Dh {
                    constructor(e) {
                        this.autoStart = void 0 === e || e,
                        this.startTime = 0,
                        this.oldTime = 0,
                        this.elapsedTime = 0,
                        this.running = !1
                    }
                    start() {
                        this.startTime = Oh(),
                        this.oldTime = this.startTime,
                        this.elapsedTime = 0,
                        this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(),
                        this.running = !1,
                        this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(),
                        this.elapsedTime
                    }
                    getDelta() {
                        let e = 0;
                        if (this.autoStart && !this.running)
                            return this.start(),
                            0;
                        if (this.running) {
                            const t = Oh();
                            e = (t - this.oldTime) / 1e3,
                            this.oldTime = t,
                            this.elapsedTime += e
                        }
                        return e
                    }
                }
                function Oh() {
                    return ("undefined" == typeof performance ? Date : performance).now()
                }
                const Fh = new Kn
                  , Ih = new Jn
                  , Nh = new Kn
                  , Bh = new Kn;
                class kh extends Jr {
                    constructor() {
                        super(),
                        this.type = "AudioListener",
                        this.context = Th.getContext(),
                        this.gain = this.context.createGain(),
                        this.gain.connect(this.context.destination),
                        this.filter = null,
                        this.timeDelta = 0,
                        this._clock = new Dh
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        return null !== this.filter && (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination),
                        this.gain.connect(this.context.destination),
                        this.filter = null),
                        this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(e) {
                        return null !== this.filter ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                        this.filter = e,
                        this.gain.connect(this.filter),
                        this.filter.connect(this.context.destination),
                        this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                    updateMatrixWorld(e) {
                        super.updateMatrixWorld(e);
                        const t = this.context.listener
                          , n = this.up;
                        if (this.timeDelta = this._clock.getDelta(),
                        this.matrixWorld.decompose(Fh, Ih, Nh),
                        Bh.set(0, 0, -1).applyQuaternion(Ih),
                        t.positionX) {
                            const e = this.context.currentTime + this.timeDelta;
                            t.positionX.linearRampToValueAtTime(Fh.x, e),
                            t.positionY.linearRampToValueAtTime(Fh.y, e),
                            t.positionZ.linearRampToValueAtTime(Fh.z, e),
                            t.forwardX.linearRampToValueAtTime(Bh.x, e),
                            t.forwardY.linearRampToValueAtTime(Bh.y, e),
                            t.forwardZ.linearRampToValueAtTime(Bh.z, e),
                            t.upX.linearRampToValueAtTime(n.x, e),
                            t.upY.linearRampToValueAtTime(n.y, e),
                            t.upZ.linearRampToValueAtTime(n.z, e)
                        } else
                            t.setPosition(Fh.x, Fh.y, Fh.z),
                            t.setOrientation(Bh.x, Bh.y, Bh.z, n.x, n.y, n.z)
                    }
                }
                class zh extends Jr {
                    constructor(e) {
                        super(),
                        this.type = "Audio",
                        this.listener = e,
                        this.context = e.context,
                        this.gain = this.context.createGain(),
                        this.gain.connect(e.getInput()),
                        this.autoplay = !1,
                        this.buffer = null,
                        this.detune = 0,
                        this.loop = !1,
                        this.loopStart = 0,
                        this.loopEnd = 0,
                        this.offset = 0,
                        this.duration = void 0,
                        this.playbackRate = 1,
                        this.isPlaying = !1,
                        this.hasPlaybackControl = !0,
                        this.source = null,
                        this.sourceType = "empty",
                        this._startedAt = 0,
                        this._progress = 0,
                        this._connected = !1,
                        this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "audioNode",
                        this.source = e,
                        this.connect(),
                        this
                    }
                    setMediaElementSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaNode",
                        this.source = this.context.createMediaElementSource(e),
                        this.connect(),
                        this
                    }
                    setMediaStreamSource(e) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "mediaStreamNode",
                        this.source = this.context.createMediaStreamSource(e),
                        this.connect(),
                        this
                    }
                    setBuffer(e) {
                        return this.buffer = e,
                        this.sourceType = "buffer",
                        this.autoplay && this.play(),
                        this
                    }
                    play(e=0) {
                        if (!0 === this.isPlaying)
                            return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl)
                            return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + e;
                        const t = this.context.createBufferSource();
                        return t.buffer = this.buffer,
                        t.loop = this.loop,
                        t.loopStart = this.loopStart,
                        t.loopEnd = this.loopEnd,
                        t.onended = this.onEnded.bind(this),
                        t.start(this._startedAt, this._progress + this.offset, this.duration),
                        this.isPlaying = !0,
                        this.source = t,
                        this.setDetune(this.detune),
                        this.setPlaybackRate(this.playbackRate),
                        this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl)
                            return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                            !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                            this.source.stop(),
                            this.source.onended = null,
                            this.isPlaying = !1),
                            this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl)
                            return this._progress = 0,
                            this.source.stop(),
                            this.source.onended = null,
                            this.isPlaying = !1,
                            this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let e = 1, t = this.filters.length; e < t; e++)
                                this.filters[e - 1].connect(this.filters[e]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else
                            this.source.connect(this.getOutput());
                        return this._connected = !0,
                        this
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let e = 1, t = this.filters.length; e < t; e++)
                                this.filters[e - 1].disconnect(this.filters[e]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else
                            this.source.disconnect(this.getOutput());
                        return this._connected = !1,
                        this
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(e) {
                        return e || (e = []),
                        !0 === this._connected ? (this.disconnect(),
                        this.filters = e.slice(),
                        this.connect()) : this.filters = e.slice(),
                        this
                    }
                    setDetune(e) {
                        if (this.detune = e,
                        void 0 !== this.source.detune)
                            return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                            this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(e) {
                        return this.setFilters(e ? [e] : [])
                    }
                    setPlaybackRate(e) {
                        if (!1 !== this.hasPlaybackControl)
                            return this.playbackRate = e,
                            !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                            this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1
                    }
                    getLoop() {
                        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
                        !1) : this.loop
                    }
                    setLoop(e) {
                        if (!1 !== this.hasPlaybackControl)
                            return this.loop = e,
                            !0 === this.isPlaying && (this.source.loop = this.loop),
                            this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(e) {
                        return this.loopStart = e,
                        this
                    }
                    setLoopEnd(e) {
                        return this.loopEnd = e,
                        this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(e) {
                        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                        this
                    }
                }
                const Uh = new Kn
                  , Hh = new Jn
                  , Gh = new Kn
                  , jh = new Kn;
                class Vh extends zh {
                    constructor(e) {
                        super(e),
                        this.panner = this.context.createPanner(),
                        this.panner.panningModel = "HRTF",
                        this.panner.connect(this.gain)
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(e) {
                        return this.panner.refDistance = e,
                        this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(e) {
                        return this.panner.rolloffFactor = e,
                        this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(e) {
                        return this.panner.distanceModel = e,
                        this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(e) {
                        return this.panner.maxDistance = e,
                        this
                    }
                    setDirectionalCone(e, t, n) {
                        return this.panner.coneInnerAngle = e,
                        this.panner.coneOuterAngle = t,
                        this.panner.coneOuterGain = n,
                        this
                    }
                    updateMatrixWorld(e) {
                        if (super.updateMatrixWorld(e),
                        !0 === this.hasPlaybackControl && !1 === this.isPlaying)
                            return;
                        this.matrixWorld.decompose(Uh, Hh, Gh),
                        jh.set(0, 0, 1).applyQuaternion(Hh);
                        const t = this.panner;
                        if (t.positionX) {
                            const e = this.context.currentTime + this.listener.timeDelta;
                            t.positionX.linearRampToValueAtTime(Uh.x, e),
                            t.positionY.linearRampToValueAtTime(Uh.y, e),
                            t.positionZ.linearRampToValueAtTime(Uh.z, e),
                            t.orientationX.linearRampToValueAtTime(jh.x, e),
                            t.orientationY.linearRampToValueAtTime(jh.y, e),
                            t.orientationZ.linearRampToValueAtTime(jh.z, e)
                        } else
                            t.setPosition(Uh.x, Uh.y, Uh.z),
                            t.setOrientation(jh.x, jh.y, jh.z)
                    }
                }
                class Wh {
                    constructor(e, t=2048) {
                        this.analyser = e.context.createAnalyser(),
                        this.analyser.fftSize = t,
                        this.data = new Uint8Array(this.analyser.frequencyBinCount),
                        e.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data),
                        this.data
                    }
                    getAverageFrequency() {
                        let e = 0;
                        const t = this.getFrequencyData();
                        for (let n = 0; n < t.length; n++)
                            e += t[n];
                        return e / t.length
                    }
                }
                function qh(e, t, n) {
                    let r, i, a;
                    switch (this.binding = e,
                    this.valueSize = n,
                    t) {
                    case "quaternion":
                        r = this._slerp,
                        i = this._slerpAdditive,
                        a = this._setAdditiveIdentityQuaternion,
                        this.buffer = new Float64Array(6 * n),
                        this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        r = this._select,
                        i = this._select,
                        a = this._setAdditiveIdentityOther,
                        this.buffer = new Array(5 * n);
                        break;
                    default:
                        r = this._lerp,
                        i = this._lerpAdditive,
                        a = this._setAdditiveIdentityNumeric,
                        this.buffer = new Float64Array(5 * n)
                    }
                    this._mixBufferRegion = r,
                    this._mixBufferRegionAdditive = i,
                    this._setIdentity = a,
                    this._origIndex = 3,
                    this._addIndex = 4,
                    this.cumulativeWeight = 0,
                    this.cumulativeWeightAdditive = 0,
                    this.useCount = 0,
                    this.referenceCount = 0
                }
                Object.assign(qh.prototype, {
                    accumulate: function(e, t) {
                        const n = this.buffer
                          , r = this.valueSize
                          , i = e * r + r;
                        let a = this.cumulativeWeight;
                        if (0 === a) {
                            for (let e = 0; e !== r; ++e)
                                n[i + e] = n[e];
                            a = t
                        } else {
                            a += t;
                            const e = t / a;
                            this._mixBufferRegion(n, i, 0, e, r)
                        }
                        this.cumulativeWeight = a
                    },
                    accumulateAdditive: function(e) {
                        const t = this.buffer
                          , n = this.valueSize
                          , r = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(),
                        this._mixBufferRegionAdditive(t, r, 0, e, n),
                        this.cumulativeWeightAdditive += e
                    },
                    apply: function(e) {
                        const t = this.valueSize
                          , n = this.buffer
                          , r = e * t + t
                          , i = this.cumulativeWeight
                          , a = this.cumulativeWeightAdditive
                          , o = this.binding;
                        if (this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0,
                        i < 1) {
                            const e = t * this._origIndex;
                            this._mixBufferRegion(n, r, e, 1 - i, t)
                        }
                        a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                        for (let e = t, i = t + t; e !== i; ++e)
                            if (n[e] !== n[e + t]) {
                                o.setValue(n, r);
                                break
                            }
                    },
                    saveOriginalState: function() {
                        const e = this.binding
                          , t = this.buffer
                          , n = this.valueSize
                          , r = n * this._origIndex;
                        e.getValue(t, r);
                        for (let e = n, i = r; e !== i; ++e)
                            t[e] = t[r + e % n];
                        this._setIdentity(),
                        this.cumulativeWeight = 0,
                        this.cumulativeWeightAdditive = 0
                    },
                    restoreOriginalState: function() {
                        const e = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, e)
                    },
                    _setAdditiveIdentityNumeric: function() {
                        const e = this._addIndex * this.valueSize
                          , t = e + this.valueSize;
                        for (let n = e; n < t; n++)
                            this.buffer[n] = 0
                    },
                    _setAdditiveIdentityQuaternion: function() {
                        this._setAdditiveIdentityNumeric(),
                        this.buffer[this._addIndex * this.valueSize + 3] = 1
                    },
                    _setAdditiveIdentityOther: function() {
                        const e = this._origIndex * this.valueSize
                          , t = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++)
                            this.buffer[t + n] = this.buffer[e + n]
                    },
                    _select: function(e, t, n, r, i) {
                        if (r >= .5)
                            for (let r = 0; r !== i; ++r)
                                e[t + r] = e[n + r]
                    },
                    _slerp: function(e, t, n, r) {
                        Jn.slerpFlat(e, t, e, t, e, n, r)
                    },
                    _slerpAdditive: function(e, t, n, r, i) {
                        const a = this._workIndex * i;
                        Jn.multiplyQuaternionsFlat(e, a, e, t, e, n),
                        Jn.slerpFlat(e, t, e, t, e, a, r)
                    },
                    _lerp: function(e, t, n, r, i) {
                        const a = 1 - r;
                        for (let o = 0; o !== i; ++o) {
                            const i = t + o;
                            e[i] = e[i] * a + e[n + o] * r
                        }
                    },
                    _lerpAdditive: function(e, t, n, r, i) {
                        for (let a = 0; a !== i; ++a) {
                            const i = t + a;
                            e[i] = e[i] + e[n + a] * r
                        }
                    }
                });
                const Xh = new RegExp("[\\[\\]\\.:\\/]","g")
                  , Yh = "[^\\[\\]\\.:\\/]"
                  , Zh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
                  , Jh = /((?:WC+[\/:])*)/.source.replace("WC", Yh)
                  , Kh = /(WCOD+)?/.source.replace("WCOD", Zh)
                  , Qh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Yh)
                  , $h = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Yh)
                  , ed = new RegExp("^" + Jh + Kh + Qh + $h + "$")
                  , td = ["material", "materials", "bones"];
                function nd(e, t, n) {
                    const r = n || rd.parseTrackName(t);
                    this._targetGroup = e,
                    this._bindings = e.subscribe_(t, r)
                }
                function rd(e, t, n) {
                    this.path = t,
                    this.parsedPath = n || rd.parseTrackName(t),
                    this.node = rd.findNode(e, this.parsedPath.nodeName) || e,
                    this.rootNode = e
                }
                function id() {
                    this.uuid = zn.generateUUID(),
                    this._objects = Array.prototype.slice.call(arguments),
                    this.nCachedObjects_ = 0;
                    const e = {};
                    this._indicesByUUID = e;
                    for (let t = 0, n = arguments.length; t !== n; ++t)
                        e[arguments[t].uuid] = t;
                    this._paths = [],
                    this._parsedPaths = [],
                    this._bindings = [],
                    this._bindingsIndicesByPath = {};
                    const t = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return t._objects.length
                            },
                            get inUse() {
                                return this.total - t.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return t._bindings.length
                        }
                    }
                }
                Object.assign(nd.prototype, {
                    getValue: function(e, t) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_
                          , r = this._bindings[n];
                        void 0 !== r && r.getValue(e, t)
                    },
                    setValue: function(e, t) {
                        const n = this._bindings;
                        for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)
                            n[r].setValue(e, t)
                    },
                    bind: function() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].bind()
                    },
                    unbind: function() {
                        const e = this._bindings;
                        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                            e[t].unbind()
                    }
                }),
                Object.assign(rd, {
                    Composite: nd,
                    create: function(e, t, n) {
                        return e && e.isAnimationObjectGroup ? new rd.Composite(e,t,n) : new rd(e,t,n)
                    },
                    sanitizeNodeName: function(e) {
                        return e.replace(/\s/g, "_").replace(Xh, "")
                    },
                    parseTrackName: function(e) {
                        const t = ed.exec(e);
                        if (!t)
                            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                        const n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        }
                          , r = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== r && -1 !== r) {
                            const e = n.nodeName.substring(r + 1);
                            -1 !== td.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r),
                            n.objectName = e)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length)
                            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                        return n
                    },
                    findNode: function(e, t) {
                        if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                            return e;
                        if (e.skeleton) {
                            const n = e.skeleton.getBoneByName(t);
                            if (void 0 !== n)
                                return n
                        }
                        if (e.children) {
                            const n = function(e) {
                                for (let r = 0; r < e.length; r++) {
                                    const i = e[r];
                                    if (i.name === t || i.uuid === t)
                                        return i;
                                    const a = n(i.children);
                                    if (a)
                                        return a
                                }
                                return null
                            }
                              , r = n(e.children);
                            if (r)
                                return r
                        }
                        return null
                    }
                }),
                Object.assign(rd.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(e, t) {
                        e[t] = this.node[this.propertyName]
                    }
                    , function(e, t) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r)
                            e[t++] = n[r]
                    }
                    , function(e, t) {
                        e[t] = this.resolvedProperty[this.propertyIndex]
                    }
                    , function(e, t) {
                        this.resolvedProperty.toArray(e, t)
                    }
                    ],
                    SetterByBindingTypeAndVersioning: [[function(e, t) {
                        this.targetObject[this.propertyName] = e[t]
                    }
                    , function(e, t) {
                        this.targetObject[this.propertyName] = e[t],
                        this.targetObject.needsUpdate = !0
                    }
                    , function(e, t) {
                        this.targetObject[this.propertyName] = e[t],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ], [function(e, t) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r)
                            n[r] = e[t++]
                    }
                    , function(e, t) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r)
                            n[r] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }
                    , function(e, t) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r)
                            n[r] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ], [function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }
                    , function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t],
                        this.targetObject.needsUpdate = !0
                    }
                    , function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ], [function(e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }
                    , function(e, t) {
                        this.resolvedProperty.fromArray(e, t),
                        this.targetObject.needsUpdate = !0
                    }
                    , function(e, t) {
                        this.resolvedProperty.fromArray(e, t),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ]],
                    getValue: function(e, t) {
                        this.bind(),
                        this.getValue(e, t)
                    },
                    setValue: function(e, t) {
                        this.bind(),
                        this.setValue(e, t)
                    },
                    bind: function() {
                        let e = this.node;
                        const t = this.parsedPath
                          , n = t.objectName
                          , r = t.propertyName;
                        let i = t.propertyIndex;
                        if (e || (e = rd.findNode(this.rootNode, t.nodeName) || this.rootNode,
                        this.node = e),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !e)
                            return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        if (n) {
                            let r = t.objectIndex;
                            switch (n) {
                            case "materials":
                                if (!e.material)
                                    return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials)
                                    return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton)
                                    return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].name === r) {
                                        r = t;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[n])
                                    return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                            }
                            if (void 0 !== r) {
                                if (void 0 === e[r])
                                    return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[r]
                            }
                        }
                        const a = e[r];
                        if (void 0 === a) {
                            const n = t.nodeName;
                            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
                        }
                        let o = this.Versioning.None;
                        this.targetObject = e,
                        void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let s = this.BindingType.Direct;
                        if (void 0 !== i) {
                            if ("morphTargetInfluences" === r) {
                                if (!e.geometry)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!e.geometry.isBufferGeometry)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                if (!e.geometry.morphAttributes)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                            }
                            s = this.BindingType.ArrayElement,
                            this.resolvedProperty = a,
                            this.propertyIndex = i
                        } else
                            void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray,
                            this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray,
                            this.resolvedProperty = a) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[s],
                        this.setValue = this.SetterByBindingTypeAndVersioning[s][o]
                    },
                    unbind: function() {
                        this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                }),
                Object.assign(rd.prototype, {
                    _getValue_unbound: rd.prototype.getValue,
                    _setValue_unbound: rd.prototype.setValue
                }),
                Object.assign(id.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._paths
                          , r = this._parsedPaths
                          , i = this._bindings
                          , a = i.length;
                        let o, s = e.length, l = this.nCachedObjects_;
                        for (let c = 0, u = arguments.length; c !== u; ++c) {
                            const u = arguments[c]
                              , h = u.uuid;
                            let d = t[h];
                            if (void 0 === d) {
                                d = s++,
                                t[h] = d,
                                e.push(u);
                                for (let e = 0, t = a; e !== t; ++e)
                                    i[e].push(new rd(u,n[e],r[e]))
                            } else if (d < l) {
                                o = e[d];
                                const s = --l
                                  , c = e[s];
                                t[c.uuid] = d,
                                e[d] = c,
                                t[h] = s,
                                e[s] = u;
                                for (let e = 0, t = a; e !== t; ++e) {
                                    const t = i[e]
                                      , a = t[s];
                                    let o = t[d];
                                    t[d] = a,
                                    void 0 === o && (o = new rd(u,n[e],r[e])),
                                    t[s] = o
                                }
                            } else
                                e[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = l
                    },
                    remove: function() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , r = n.length;
                        let i = this.nCachedObjects_;
                        for (let a = 0, o = arguments.length; a !== o; ++a) {
                            const o = arguments[a]
                              , s = o.uuid
                              , l = t[s];
                            if (void 0 !== l && l >= i) {
                                const a = i++
                                  , c = e[a];
                                t[c.uuid] = l,
                                e[l] = c,
                                t[s] = a,
                                e[a] = o;
                                for (let e = 0, t = r; e !== t; ++e) {
                                    const t = n[e]
                                      , r = t[a]
                                      , i = t[l];
                                    t[l] = r,
                                    t[a] = i
                                }
                            }
                        }
                        this.nCachedObjects_ = i
                    },
                    uncache: function() {
                        const e = this._objects
                          , t = this._indicesByUUID
                          , n = this._bindings
                          , r = n.length;
                        let i = this.nCachedObjects_
                          , a = e.length;
                        for (let o = 0, s = arguments.length; o !== s; ++o) {
                            const s = arguments[o].uuid
                              , l = t[s];
                            if (void 0 !== l)
                                if (delete t[s],
                                l < i) {
                                    const o = --i
                                      , s = e[o]
                                      , c = --a
                                      , u = e[c];
                                    t[s.uuid] = l,
                                    e[l] = s,
                                    t[u.uuid] = o,
                                    e[o] = u,
                                    e.pop();
                                    for (let e = 0, t = r; e !== t; ++e) {
                                        const t = n[e]
                                          , r = t[o]
                                          , i = t[c];
                                        t[l] = r,
                                        t[o] = i,
                                        t.pop()
                                    }
                                } else {
                                    const i = --a
                                      , o = e[i];
                                    i > 0 && (t[o.uuid] = l),
                                    e[l] = o,
                                    e.pop();
                                    for (let e = 0, t = r; e !== t; ++e) {
                                        const t = n[e];
                                        t[l] = t[i],
                                        t.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = i
                    },
                    subscribe_: function(e, t) {
                        const n = this._bindingsIndicesByPath;
                        let r = n[e];
                        const i = this._bindings;
                        if (void 0 !== r)
                            return i[r];
                        const a = this._paths
                          , o = this._parsedPaths
                          , s = this._objects
                          , l = s.length
                          , c = this.nCachedObjects_
                          , u = new Array(l);
                        r = i.length,
                        n[e] = r,
                        a.push(e),
                        o.push(t),
                        i.push(u);
                        for (let n = c, r = s.length; n !== r; ++n) {
                            const r = s[n];
                            u[n] = new rd(r,e,t)
                        }
                        return u
                    },
                    unsubscribe_: function(e) {
                        const t = this._bindingsIndicesByPath
                          , n = t[e];
                        if (void 0 !== n) {
                            const r = this._paths
                              , i = this._parsedPaths
                              , a = this._bindings
                              , o = a.length - 1
                              , s = a[o];
                            t[e[o]] = n,
                            a[n] = s,
                            a.pop(),
                            i[n] = i[o],
                            i.pop(),
                            r[n] = r[o],
                            r.pop()
                        }
                    }
                });
                class ad {
                    constructor(e, t, n=null, r=t.blendMode) {
                        this._mixer = e,
                        this._clip = t,
                        this._localRoot = n,
                        this.blendMode = r;
                        const i = t.tracks
                          , a = i.length
                          , o = new Array(a)
                          , s = {
                            endingStart: Gt,
                            endingEnd: Gt
                        };
                        for (let e = 0; e !== a; ++e) {
                            const t = i[e].createInterpolant(null);
                            o[e] = t,
                            t.settings = s
                        }
                        this._interpolantSettings = s,
                        this._interpolants = o,
                        this._propertyBindings = new Array(a),
                        this._cacheIndex = null,
                        this._byClipCacheIndex = null,
                        this._timeScaleInterpolant = null,
                        this._weightInterpolant = null,
                        this.loop = Bt,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.time = 0,
                        this.timeScale = 1,
                        this._effectiveTimeScale = 1,
                        this.weight = 1,
                        this._effectiveWeight = 1,
                        this.repetitions = 1 / 0,
                        this.paused = !1,
                        this.enabled = !0,
                        this.clampWhenFinished = !1,
                        this.zeroSlopeAtStart = !0,
                        this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this),
                        this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this),
                        this.reset()
                    }
                    reset() {
                        return this.paused = !1,
                        this.enabled = !0,
                        this.time = 0,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(e) {
                        return this._startTime = e,
                        this
                    }
                    setLoop(e, t) {
                        return this.loop = e,
                        this.repetitions = t,
                        this
                    }
                    setEffectiveWeight(e) {
                        return this.weight = e,
                        this._effectiveWeight = this.enabled ? e : 0,
                        this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(e) {
                        return this._scheduleFading(e, 0, 1)
                    }
                    fadeOut(e) {
                        return this._scheduleFading(e, 1, 0)
                    }
                    crossFadeFrom(e, t, n) {
                        if (e.fadeOut(t),
                        this.fadeIn(t),
                        n) {
                            const n = this._clip.duration
                              , r = e._clip.duration
                              , i = r / n
                              , a = n / r;
                            e.warp(1, i, t),
                            this.warp(a, 1, t)
                        }
                        return this
                    }
                    crossFadeTo(e, t, n) {
                        return e.crossFadeFrom(this, t, n)
                    }
                    stopFading() {
                        const e = this._weightInterpolant;
                        return null !== e && (this._weightInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    setEffectiveTimeScale(e) {
                        return this.timeScale = e,
                        this._effectiveTimeScale = this.paused ? 0 : e,
                        this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(e) {
                        return this.timeScale = this._clip.duration / e,
                        this.stopWarping()
                    }
                    syncWith(e) {
                        return this.time = e.time,
                        this.timeScale = e.timeScale,
                        this.stopWarping()
                    }
                    halt(e) {
                        return this.warp(this._effectiveTimeScale, 0, e)
                    }
                    warp(e, t, n) {
                        const r = this._mixer
                          , i = r.time
                          , a = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        null === o && (o = r._lendControlInterpolant(),
                        this._timeScaleInterpolant = o);
                        const s = o.parameterPositions
                          , l = o.sampleValues;
                        return s[0] = i,
                        s[1] = i + n,
                        l[0] = e / a,
                        l[1] = t / a,
                        this
                    }
                    stopWarping() {
                        const e = this._timeScaleInterpolant;
                        return null !== e && (this._timeScaleInterpolant = null,
                        this._mixer._takeBackControlInterpolant(e)),
                        this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(e, t, n, r) {
                        if (!this.enabled)
                            return void this._updateWeight(e);
                        const i = this._startTime;
                        if (null !== i) {
                            const r = (e - i) * n;
                            if (r < 0 || 0 === n)
                                return;
                            this._startTime = null,
                            t = n * r
                        }
                        t *= this._updateTimeScale(e);
                        const a = this._updateTime(t)
                          , o = this._updateWeight(e);
                        if (o > 0) {
                            const e = this._interpolants
                              , t = this._propertyBindings;
                            if (this.blendMode === qt)
                                for (let n = 0, r = e.length; n !== r; ++n)
                                    e[n].evaluate(a),
                                    t[n].accumulateAdditive(o);
                            else
                                for (let n = 0, i = e.length; n !== i; ++n)
                                    e[n].evaluate(a),
                                    t[n].accumulate(r, o)
                        }
                    }
                    _updateWeight(e) {
                        let t = 0;
                        if (this.enabled) {
                            t = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const r = n.evaluate(e)[0];
                                t *= r,
                                e > n.parameterPositions[1] && (this.stopFading(),
                                0 === r && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = t,
                        t
                    }
                    _updateTimeScale(e) {
                        let t = 0;
                        if (!this.paused) {
                            t = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            null !== n && (t *= n.evaluate(e)[0],
                            e > n.parameterPositions[1] && (this.stopWarping(),
                            0 === t ? this.paused = !0 : this.timeScale = t))
                        }
                        return this._effectiveTimeScale = t,
                        t
                    }
                    _updateTime(e) {
                        const t = this._clip.duration
                          , n = this.loop;
                        let r = this.time + e
                          , i = this._loopCount;
                        const a = n === kt;
                        if (0 === e)
                            return -1 === i ? r : a && 1 == (1 & i) ? t - r : r;
                        if (n === Nt) {
                            -1 === i && (this._loopCount = 0,
                            this._setEndings(!0, !0, !1));
                            e: {
                                if (r >= t)
                                    r = t;
                                else {
                                    if (!(r < 0)) {
                                        this.time = r;
                                        break e
                                    }
                                    r = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this.time = r,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: e < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === i && (e >= 0 ? (i = 0,
                            this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)),
                            r >= t || r < 0) {
                                const n = Math.floor(r / t);
                                r -= t * n,
                                i += Math.abs(n);
                                const o = this.repetitions - i;
                                if (o <= 0)
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    r = e > 0 ? t : 0,
                                    this.time = r,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    });
                                else {
                                    if (1 === o) {
                                        const t = e < 0;
                                        this._setEndings(t, !t, a)
                                    } else
                                        this._setEndings(!1, !1, a);
                                    this._loopCount = i,
                                    this.time = r,
                                    this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: n
                                    })
                                }
                            } else
                                this.time = r;
                            if (a && 1 == (1 & i))
                                return t - r
                        }
                        return r
                    }
                    _setEndings(e, t, n) {
                        const r = this._interpolantSettings;
                        n ? (r.endingStart = jt,
                        r.endingEnd = jt) : (r.endingStart = e ? this.zeroSlopeAtStart ? jt : Gt : Vt,
                        r.endingEnd = t ? this.zeroSlopeAtEnd ? jt : Gt : Vt)
                    }
                    _scheduleFading(e, t, n) {
                        const r = this._mixer
                          , i = r.time;
                        let a = this._weightInterpolant;
                        null === a && (a = r._lendControlInterpolant(),
                        this._weightInterpolant = a);
                        const o = a.parameterPositions
                          , s = a.sampleValues;
                        return o[0] = i,
                        s[0] = t,
                        o[1] = i + e,
                        s[1] = n,
                        this
                    }
                }
                function od(e) {
                    this._root = e,
                    this._initMemoryManager(),
                    this._accuIndex = 0,
                    this.time = 0,
                    this.timeScale = 1
                }
                od.prototype = Object.assign(Object.create(Nn.prototype), {
                    constructor: od,
                    _bindAction: function(e, t) {
                        const n = e._localRoot || this._root
                          , r = e._clip.tracks
                          , i = r.length
                          , a = e._propertyBindings
                          , o = e._interpolants
                          , s = n.uuid
                          , l = this._bindingsByRootAndName;
                        let c = l[s];
                        void 0 === c && (c = {},
                        l[s] = c);
                        for (let e = 0; e !== i; ++e) {
                            const i = r[e]
                              , l = i.name;
                            let u = c[l];
                            if (void 0 !== u)
                                a[e] = u;
                            else {
                                if (u = a[e],
                                void 0 !== u) {
                                    null === u._cacheIndex && (++u.referenceCount,
                                    this._addInactiveBinding(u, s, l));
                                    continue
                                }
                                const r = t && t._propertyBindings[e].binding.parsedPath;
                                u = new qh(rd.create(n, l, r),i.ValueTypeName,i.getValueSize()),
                                ++u.referenceCount,
                                this._addInactiveBinding(u, s, l),
                                a[e] = u
                            }
                            o[e].resultBuffer = u.buffer
                        }
                    },
                    _activateAction: function(e) {
                        if (!this._isActiveAction(e)) {
                            if (null === e._cacheIndex) {
                                const t = (e._localRoot || this._root).uuid
                                  , n = e._clip.uuid
                                  , r = this._actionsByClip[n];
                                this._bindAction(e, r && r.knownActions[0]),
                                this._addInactiveAction(e, n, t)
                            }
                            const t = e._propertyBindings;
                            for (let e = 0, n = t.length; e !== n; ++e) {
                                const n = t[e];
                                0 == n.useCount++ && (this._lendBinding(n),
                                n.saveOriginalState())
                            }
                            this._lendAction(e)
                        }
                    },
                    _deactivateAction: function(e) {
                        if (this._isActiveAction(e)) {
                            const t = e._propertyBindings;
                            for (let e = 0, n = t.length; e !== n; ++e) {
                                const n = t[e];
                                0 == --n.useCount && (n.restoreOriginalState(),
                                this._takeBackBinding(n))
                            }
                            this._takeBackAction(e)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [],
                        this._nActiveActions = 0,
                        this._actionsByClip = {},
                        this._bindings = [],
                        this._nActiveBindings = 0,
                        this._bindingsByRootAndName = {},
                        this._controlInterpolants = [],
                        this._nActiveControlInterpolants = 0;
                        const e = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return e._actions.length
                                },
                                get inUse() {
                                    return e._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return e._bindings.length
                                },
                                get inUse() {
                                    return e._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return e._controlInterpolants.length
                                },
                                get inUse() {
                                    return e._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(e) {
                        const t = e._cacheIndex;
                        return null !== t && t < this._nActiveActions
                    },
                    _addInactiveAction: function(e, t, n) {
                        const r = this._actions
                          , i = this._actionsByClip;
                        let a = i[t];
                        if (void 0 === a)
                            a = {
                                knownActions: [e],
                                actionByRoot: {}
                            },
                            e._byClipCacheIndex = 0,
                            i[t] = a;
                        else {
                            const t = a.knownActions;
                            e._byClipCacheIndex = t.length,
                            t.push(e)
                        }
                        e._cacheIndex = r.length,
                        r.push(e),
                        a.actionByRoot[n] = e
                    },
                    _removeInactiveAction: function(e) {
                        const t = this._actions
                          , n = t[t.length - 1]
                          , r = e._cacheIndex;
                        n._cacheIndex = r,
                        t[r] = n,
                        t.pop(),
                        e._cacheIndex = null;
                        const i = e._clip.uuid
                          , a = this._actionsByClip
                          , o = a[i]
                          , s = o.knownActions
                          , l = s[s.length - 1]
                          , c = e._byClipCacheIndex;
                        l._byClipCacheIndex = c,
                        s[c] = l,
                        s.pop(),
                        e._byClipCacheIndex = null,
                        delete o.actionByRoot[(e._localRoot || this._root).uuid],
                        0 === s.length && delete a[i],
                        this._removeInactiveBindingsForAction(e)
                    },
                    _removeInactiveBindingsForAction: function(e) {
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == --n.referenceCount && this._removeInactiveBinding(n)
                        }
                    },
                    _lendAction: function(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , r = this._nActiveActions++
                          , i = t[r];
                        e._cacheIndex = r,
                        t[r] = e,
                        i._cacheIndex = n,
                        t[n] = i
                    },
                    _takeBackAction: function(e) {
                        const t = this._actions
                          , n = e._cacheIndex
                          , r = --this._nActiveActions
                          , i = t[r];
                        e._cacheIndex = r,
                        t[r] = e,
                        i._cacheIndex = n,
                        t[n] = i
                    },
                    _addInactiveBinding: function(e, t, n) {
                        const r = this._bindingsByRootAndName
                          , i = this._bindings;
                        let a = r[t];
                        void 0 === a && (a = {},
                        r[t] = a),
                        a[n] = e,
                        e._cacheIndex = i.length,
                        i.push(e)
                    },
                    _removeInactiveBinding: function(e) {
                        const t = this._bindings
                          , n = e.binding
                          , r = n.rootNode.uuid
                          , i = n.path
                          , a = this._bindingsByRootAndName
                          , o = a[r]
                          , s = t[t.length - 1]
                          , l = e._cacheIndex;
                        s._cacheIndex = l,
                        t[l] = s,
                        t.pop(),
                        delete o[i],
                        0 === Object.keys(o).length && delete a[r]
                    },
                    _lendBinding: function(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , r = this._nActiveBindings++
                          , i = t[r];
                        e._cacheIndex = r,
                        t[r] = e,
                        i._cacheIndex = n,
                        t[n] = i
                    },
                    _takeBackBinding: function(e) {
                        const t = this._bindings
                          , n = e._cacheIndex
                          , r = --this._nActiveBindings
                          , i = t[r];
                        e._cacheIndex = r,
                        t[r] = e,
                        i._cacheIndex = n,
                        t[n] = i
                    },
                    _lendControlInterpolant: function() {
                        const e = this._controlInterpolants
                          , t = this._nActiveControlInterpolants++;
                        let n = e[t];
                        return void 0 === n && (n = new ru(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                        n.__cacheIndex = t,
                        e[t] = n),
                        n
                    },
                    _takeBackControlInterpolant: function(e) {
                        const t = this._controlInterpolants
                          , n = e.__cacheIndex
                          , r = --this._nActiveControlInterpolants
                          , i = t[r];
                        e.__cacheIndex = r,
                        t[r] = e,
                        i.__cacheIndex = n,
                        t[n] = i
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function(e, t, n) {
                        const r = t || this._root
                          , i = r.uuid;
                        let a = "string" == typeof e ? pu.findByName(r, e) : e;
                        const o = null !== a ? a.uuid : e
                          , s = this._actionsByClip[o];
                        let l = null;
                        if (void 0 === n && (n = null !== a ? a.blendMode : Wt),
                        void 0 !== s) {
                            const e = s.actionByRoot[i];
                            if (void 0 !== e && e.blendMode === n)
                                return e;
                            l = s.knownActions[0],
                            null === a && (a = l._clip)
                        }
                        if (null === a)
                            return null;
                        const c = new ad(this,a,t,n);
                        return this._bindAction(c, l),
                        this._addInactiveAction(c, o, i),
                        c
                    },
                    existingAction: function(e, t) {
                        const n = t || this._root
                          , r = n.uuid
                          , i = "string" == typeof e ? pu.findByName(n, e) : e
                          , a = i ? i.uuid : e
                          , o = this._actionsByClip[a];
                        return void 0 !== o && o.actionByRoot[r] || null
                    },
                    stopAllAction: function() {
                        const e = this._actions;
                        for (let t = this._nActiveActions - 1; t >= 0; --t)
                            e[t].stop();
                        return this
                    },
                    update: function(e) {
                        e *= this.timeScale;
                        const t = this._actions
                          , n = this._nActiveActions
                          , r = this.time += e
                          , i = Math.sign(e)
                          , a = this._accuIndex ^= 1;
                        for (let o = 0; o !== n; ++o)
                            t[o]._update(r, e, i, a);
                        const o = this._bindings
                          , s = this._nActiveBindings;
                        for (let e = 0; e !== s; ++e)
                            o[e].apply(a);
                        return this
                    },
                    setTime: function(e) {
                        this.time = 0;
                        for (let e = 0; e < this._actions.length; e++)
                            this._actions[e].time = 0;
                        return this.update(e)
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(e) {
                        const t = this._actions
                          , n = e.uuid
                          , r = this._actionsByClip
                          , i = r[n];
                        if (void 0 !== i) {
                            const e = i.knownActions;
                            for (let n = 0, r = e.length; n !== r; ++n) {
                                const r = e[n];
                                this._deactivateAction(r);
                                const i = r._cacheIndex
                                  , a = t[t.length - 1];
                                r._cacheIndex = null,
                                r._byClipCacheIndex = null,
                                a._cacheIndex = i,
                                t[i] = a,
                                t.pop(),
                                this._removeInactiveBindingsForAction(r)
                            }
                            delete r[n]
                        }
                    },
                    uncacheRoot: function(e) {
                        const t = e.uuid
                          , n = this._actionsByClip;
                        for (const e in n) {
                            const r = n[e].actionByRoot[t];
                            void 0 !== r && (this._deactivateAction(r),
                            this._removeInactiveAction(r))
                        }
                        const r = this._bindingsByRootAndName[t];
                        if (void 0 !== r)
                            for (const e in r) {
                                const t = r[e];
                                t.restoreOriginalState(),
                                this._removeInactiveBinding(t)
                            }
                    },
                    uncacheAction: function(e, t) {
                        const n = this.existingAction(e, t);
                        null !== n && (this._deactivateAction(n),
                        this._removeInactiveAction(n))
                    }
                });
                class sd {
                    constructor(e) {
                        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                        e = arguments[1]),
                        this.value = e
                    }
                    clone() {
                        return new sd(void 0 === this.value.clone ? this.value : this.value.clone())
                    }
                }
                function ld(e, t, n) {
                    zs.call(this, e, t),
                    this.meshPerAttribute = n || 1
                }
                function cd(e, t, n, r, i) {
                    this.buffer = e,
                    this.type = t,
                    this.itemSize = n,
                    this.elementSize = r,
                    this.count = i,
                    this.version = 0
                }
                function ud(e, t, n, r) {
                    this.ray = new Sr(e,t),
                    this.near = n || 0,
                    this.far = r || 1 / 0,
                    this.camera = null,
                    this.layers = new Nr,
                    this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    },
                    Object.defineProperties(this.params, {
                        PointCloud: {
                            get: function() {
                                return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                                this.Points
                            }
                        }
                    })
                }
                function hd(e, t) {
                    return e.distance - t.distance
                }
                function dd(e, t, n, r) {
                    if (e.layers.test(t.layers) && e.raycast(t, n),
                    !0 === r) {
                        const r = e.children;
                        for (let e = 0, i = r.length; e < i; e++)
                            dd(r[e], t, n, !0)
                    }
                }
                ld.prototype = Object.assign(Object.create(zs.prototype), {
                    constructor: ld,
                    isInstancedInterleavedBuffer: !0,
                    copy: function(e) {
                        return zs.prototype.copy.call(this, e),
                        this.meshPerAttribute = e.meshPerAttribute,
                        this
                    },
                    clone: function(e) {
                        const t = zs.prototype.clone.call(this, e);
                        return t.meshPerAttribute = this.meshPerAttribute,
                        t
                    },
                    toJSON: function(e) {
                        const t = zs.prototype.toJSON.call(this, e);
                        return t.isInstancedInterleavedBuffer = !0,
                        t.meshPerAttribute = this.meshPerAttribute,
                        t
                    }
                }),
                Object.defineProperty(cd.prototype, "needsUpdate", {
                    set: function(e) {
                        !0 === e && this.version++
                    }
                }),
                Object.assign(cd.prototype, {
                    isGLBufferAttribute: !0,
                    setBuffer: function(e) {
                        return this.buffer = e,
                        this
                    },
                    setType: function(e, t) {
                        return this.type = e,
                        this.elementSize = t,
                        this
                    },
                    setItemSize: function(e) {
                        return this.itemSize = e,
                        this
                    },
                    setCount: function(e) {
                        return this.count = e,
                        this
                    }
                }),
                Object.assign(ud.prototype, {
                    set: function(e, t) {
                        this.ray.set(e, t)
                    },
                    setFromCamera: function(e, t) {
                        t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                        this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                    },
                    intersectObject: function(e, t, n) {
                        const r = n || [];
                        return dd(e, this, r, t),
                        r.sort(hd),
                        r
                    },
                    intersectObjects: function(e, t, n) {
                        const r = n || [];
                        if (!1 === Array.isArray(e))
                            return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                            r;
                        for (let n = 0, i = e.length; n < i; n++)
                            dd(e[n], this, r, t);
                        return r.sort(hd),
                        r
                    }
                });
                class pd {
                    constructor(e=1, t=0, n=0) {
                        return this.radius = e,
                        this.phi = t,
                        this.theta = n,
                        this
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.phi = t,
                        this.theta = n,
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.phi = e.phi,
                        this.theta = e.theta,
                        this
                    }
                    makeSafe() {
                        const e = 1e-6;
                        return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + t * t + n * n),
                        0 === this.radius ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(e, n),
                        this.phi = Math.acos(zn.clamp(t / this.radius, -1, 1))),
                        this
                    }
                }
                class fd {
                    constructor(e, t, n) {
                        return this.radius = void 0 !== e ? e : 1,
                        this.theta = void 0 !== t ? t : 0,
                        this.y = void 0 !== n ? n : 0,
                        this
                    }
                    set(e, t, n) {
                        return this.radius = e,
                        this.theta = t,
                        this.y = n,
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.radius = e.radius,
                        this.theta = e.theta,
                        this.y = e.y,
                        this
                    }
                    setFromVector3(e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                    setFromCartesianCoords(e, t, n) {
                        return this.radius = Math.sqrt(e * e + n * n),
                        this.theta = Math.atan2(e, n),
                        this.y = t,
                        this
                    }
                }
                const md = new Un;
                class gd {
                    constructor(e, t) {
                        Object.defineProperty(this, "isBox2", {
                            value: !0
                        }),
                        this.min = void 0 !== e ? e : new Un(1 / 0,1 / 0),
                        this.max = void 0 !== t ? t : new Un(-1 / 0,-1 / 0)
                    }
                    set(e, t) {
                        return this.min.copy(e),
                        this.max.copy(t),
                        this
                    }
                    setFromPoints(e) {
                        this.makeEmpty();
                        for (let t = 0, n = e.length; t < n; t++)
                            this.expandByPoint(e[t]);
                        return this
                    }
                    setFromCenterAndSize(e, t) {
                        const n = md.copy(t).multiplyScalar(.5);
                        return this.min.copy(e).sub(n),
                        this.max.copy(e).add(n),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.min.copy(e.min),
                        this.max.copy(e.max),
                        this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0,
                        this.max.x = this.max.y = -1 / 0,
                        this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"),
                        e = new Un),
                        this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"),
                        e = new Un),
                        this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                    }
                    expandByPoint(e) {
                        return this.min.min(e),
                        this.max.max(e),
                        this
                    }
                    expandByVector(e) {
                        return this.min.sub(e),
                        this.max.add(e),
                        this
                    }
                    expandByScalar(e) {
                        return this.min.addScalar(-e),
                        this.max.addScalar(e),
                        this
                    }
                    containsPoint(e) {
                        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                    }
                    containsBox(e) {
                        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                    }
                    getParameter(e, t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"),
                        t = new Un),
                        t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(e) {
                        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                    }
                    clampPoint(e, t) {
                        return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"),
                        t = new Un),
                        t.copy(e).clamp(this.min, this.max)
                    }
                    distanceToPoint(e) {
                        return md.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                    intersect(e) {
                        return this.min.max(e.min),
                        this.max.min(e.max),
                        this
                    }
                    union(e) {
                        return this.min.min(e.min),
                        this.max.max(e.max),
                        this
                    }
                    translate(e) {
                        return this.min.add(e),
                        this.max.add(e),
                        this
                    }
                    equals(e) {
                        return e.min.equals(this.min) && e.max.equals(this.max)
                    }
                }
                const vd = new Kn
                  , yd = new Kn;
                class _d {
                    constructor(e, t) {
                        this.start = void 0 !== e ? e : new Kn,
                        this.end = void 0 !== t ? t : new Kn
                    }
                    set(e, t) {
                        return this.start.copy(e),
                        this.end.copy(t),
                        this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(e) {
                        return this.start.copy(e.start),
                        this.end.copy(e.end),
                        this
                    }
                    getCenter(e) {
                        return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"),
                        e = new Kn),
                        e.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(e) {
                        return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"),
                        e = new Kn),
                        e.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(e, t) {
                        return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"),
                        t = new Kn),
                        this.delta(t).multiplyScalar(e).add(this.start)
                    }
                    closestPointToPointParameter(e, t) {
                        vd.subVectors(e, this.start),
                        yd.subVectors(this.end, this.start);
                        const n = yd.dot(yd);
                        let r = yd.dot(vd) / n;
                        return t && (r = zn.clamp(r, 0, 1)),
                        r
                    }
                    closestPointToPoint(e, t, n) {
                        const r = this.closestPointToPointParameter(e, t);
                        return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
                        n = new Kn),
                        this.delta(n).multiplyScalar(r).add(this.start)
                    }
                    applyMatrix4(e) {
                        return this.start.applyMatrix4(e),
                        this.end.applyMatrix4(e),
                        this
                    }
                    equals(e) {
                        return e.start.equals(this.start) && e.end.equals(this.end)
                    }
                }
                function xd(e) {
                    Jr.call(this),
                    this.material = e,
                    this.render = function() {}
                    ,
                    this.hasPositions = !1,
                    this.hasNormals = !1,
                    this.hasColors = !1,
                    this.hasUvs = !1,
                    this.positionArray = null,
                    this.normalArray = null,
                    this.colorArray = null,
                    this.uvArray = null,
                    this.count = 0
                }
                xd.prototype = Object.create(Jr.prototype),
                xd.prototype.constructor = xd,
                xd.prototype.isImmediateRenderObject = !0;
                const bd = new Kn;
                class wd extends Jr {
                    constructor(e, t) {
                        super(),
                        this.light = e,
                        this.light.updateMatrixWorld(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = t;
                        const n = new qi
                          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let e = 0, t = 1, n = 32; e < n; e++,
                        t++) {
                            const i = e / n * Math.PI * 2
                              , a = t / n * Math.PI * 2;
                            r.push(Math.cos(i), Math.sin(i), 1, Math.cos(a), Math.sin(a), 1)
                        }
                        n.setAttribute("position", new Fi(r,3));
                        const i = new wl({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new Ll(n,i),
                        this.add(this.cone),
                        this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose(),
                        this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateMatrixWorld();
                        const e = this.light.distance ? this.light.distance : 1e3
                          , t = e * Math.tan(this.light.angle);
                        this.cone.scale.set(t, t, e),
                        bd.setFromMatrixPosition(this.light.target.matrixWorld),
                        this.cone.lookAt(bd),
                        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }
                const Md = new Kn
                  , Sd = new Tr
                  , Td = new Tr;
                class Ed extends Ll {
                    constructor(e) {
                        const t = Ad(e)
                          , n = new qi
                          , r = []
                          , i = []
                          , a = new yi(0,0,1)
                          , o = new yi(0,1,0);
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            n.parent && n.parent.isBone && (r.push(0, 0, 0),
                            r.push(0, 0, 0),
                            i.push(a.r, a.g, a.b),
                            i.push(o.r, o.g, o.b))
                        }
                        n.setAttribute("position", new Fi(r,3)),
                        n.setAttribute("color", new Fi(i,3)),
                        super(n, new wl({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        })),
                        this.type = "SkeletonHelper",
                        this.isSkeletonHelper = !0,
                        this.root = e,
                        this.bones = t,
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(e) {
                        const t = this.bones
                          , n = this.geometry
                          , r = n.getAttribute("position");
                        Td.copy(this.root.matrixWorld).invert();
                        for (let e = 0, n = 0; e < t.length; e++) {
                            const i = t[e];
                            i.parent && i.parent.isBone && (Sd.multiplyMatrices(Td, i.matrixWorld),
                            Md.setFromMatrixPosition(Sd),
                            r.setXYZ(n, Md.x, Md.y, Md.z),
                            Sd.multiplyMatrices(Td, i.parent.matrixWorld),
                            Md.setFromMatrixPosition(Sd),
                            r.setXYZ(n + 1, Md.x, Md.y, Md.z),
                            n += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0,
                        super.updateMatrixWorld(e)
                    }
                }
                function Ad(e) {
                    const t = [];
                    e && e.isBone && t.push(e);
                    for (let n = 0; n < e.children.length; n++)
                        t.push.apply(t, Ad(e.children[n]));
                    return t
                }
                class Cd extends ua {
                    constructor(e, t, n) {
                        super(new Ic(t,4,2), new wi({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        })),
                        this.light = e,
                        this.light.updateMatrixWorld(),
                        this.color = n,
                        this.type = "PointLightHelper",
                        this.matrix = this.light.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    dispose() {
                        this.geometry.dispose(),
                        this.material.dispose()
                    }
                    update() {
                        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                    }
                }
                const Pd = new Kn
                  , Rd = new yi
                  , Ld = new yi;
                class Dd extends Jr {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.light.updateMatrixWorld(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n;
                        const r = new Lc(t);
                        r.rotateY(.5 * Math.PI),
                        this.material = new wi({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        }),
                        void 0 === this.color && (this.material.vertexColors = !0);
                        const i = r.getAttribute("position")
                          , a = new Float32Array(3 * i.count);
                        r.setAttribute("color", new Ti(a,3)),
                        this.add(new ua(r,this.material)),
                        this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose(),
                        this.children[0].material.dispose()
                    }
                    update() {
                        const e = this.children[0];
                        if (void 0 !== this.color)
                            this.material.color.set(this.color);
                        else {
                            const t = e.geometry.getAttribute("color");
                            Rd.copy(this.light.color),
                            Ld.copy(this.light.groundColor);
                            for (let e = 0, n = t.count; e < n; e++) {
                                const r = e < n / 2 ? Rd : Ld;
                                t.setXYZ(e, r.r, r.g, r.b)
                            }
                            t.needsUpdate = !0
                        }
                        e.lookAt(Pd.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                class Od extends Ll {
                    constructor(e=10, t=10, n=4473924, r=8947848) {
                        n = new yi(n),
                        r = new yi(r);
                        const i = t / 2
                          , a = e / t
                          , o = e / 2
                          , s = []
                          , l = [];
                        for (let e = 0, c = 0, u = -o; e <= t; e++,
                        u += a) {
                            s.push(-o, 0, u, o, 0, u),
                            s.push(u, 0, -o, u, 0, o);
                            const t = e === i ? n : r;
                            t.toArray(l, c),
                            c += 3,
                            t.toArray(l, c),
                            c += 3,
                            t.toArray(l, c),
                            c += 3,
                            t.toArray(l, c),
                            c += 3
                        }
                        const c = new qi;
                        c.setAttribute("position", new Fi(s,3)),
                        c.setAttribute("color", new Fi(l,3)),
                        super(c, new wl({
                            vertexColors: !0,
                            toneMapped: !1
                        })),
                        this.type = "GridHelper"
                    }
                }
                class Fd extends Ll {
                    constructor(e=10, t=16, n=8, r=64, i=4473924, a=8947848) {
                        i = new yi(i),
                        a = new yi(a);
                        const o = []
                          , s = [];
                        for (let n = 0; n <= t; n++) {
                            const r = n / t * (2 * Math.PI)
                              , l = Math.sin(r) * e
                              , c = Math.cos(r) * e;
                            o.push(0, 0, 0),
                            o.push(l, 0, c);
                            const u = 1 & n ? i : a;
                            s.push(u.r, u.g, u.b),
                            s.push(u.r, u.g, u.b)
                        }
                        for (let t = 0; t <= n; t++) {
                            const l = 1 & t ? i : a
                              , c = e - e / n * t;
                            for (let e = 0; e < r; e++) {
                                let t = e / r * (2 * Math.PI)
                                  , n = Math.sin(t) * c
                                  , i = Math.cos(t) * c;
                                o.push(n, 0, i),
                                s.push(l.r, l.g, l.b),
                                t = (e + 1) / r * (2 * Math.PI),
                                n = Math.sin(t) * c,
                                i = Math.cos(t) * c,
                                o.push(n, 0, i),
                                s.push(l.r, l.g, l.b)
                            }
                        }
                        const l = new qi;
                        l.setAttribute("position", new Fi(o,3)),
                        l.setAttribute("color", new Fi(s,3)),
                        super(l, new wl({
                            vertexColors: !0,
                            toneMapped: !1
                        })),
                        this.type = "PolarGridHelper"
                    }
                }
                const Id = new Kn
                  , Nd = new Kn
                  , Bd = new Kn;
                class kd extends Jr {
                    constructor(e, t, n) {
                        super(),
                        this.light = e,
                        this.light.updateMatrixWorld(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.color = n,
                        void 0 === t && (t = 1);
                        let r = new qi;
                        r.setAttribute("position", new Fi([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
                        const i = new wl({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new Cl(r,i),
                        this.add(this.lightPlane),
                        r = new qi,
                        r.setAttribute("position", new Fi([0, 0, 0, 0, 0, 1],3)),
                        this.targetLine = new Cl(r,i),
                        this.add(this.targetLine),
                        this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose(),
                        this.lightPlane.material.dispose(),
                        this.targetLine.geometry.dispose(),
                        this.targetLine.material.dispose()
                    }
                    update() {
                        Id.setFromMatrixPosition(this.light.matrixWorld),
                        Nd.setFromMatrixPosition(this.light.target.matrixWorld),
                        Bd.subVectors(Nd, Id),
                        this.lightPlane.lookAt(Nd),
                        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                        this.targetLine.lookAt(Nd),
                        this.targetLine.scale.z = Bd.length()
                    }
                }
                const zd = new Kn
                  , Ud = new va;
                class Hd extends Ll {
                    constructor(e) {
                        const t = new qi
                          , n = new wl({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        })
                          , r = []
                          , i = []
                          , a = {}
                          , o = new yi(16755200)
                          , s = new yi(16711680)
                          , l = new yi(43775)
                          , c = new yi(16777215)
                          , u = new yi(3355443);
                        function h(e, t, n) {
                            d(e, n),
                            d(t, n)
                        }
                        function d(e, t) {
                            r.push(0, 0, 0),
                            i.push(t.r, t.g, t.b),
                            void 0 === a[e] && (a[e] = []),
                            a[e].push(r.length / 3 - 1)
                        }
                        h("n1", "n2", o),
                        h("n2", "n4", o),
                        h("n4", "n3", o),
                        h("n3", "n1", o),
                        h("f1", "f2", o),
                        h("f2", "f4", o),
                        h("f4", "f3", o),
                        h("f3", "f1", o),
                        h("n1", "f1", o),
                        h("n2", "f2", o),
                        h("n3", "f3", o),
                        h("n4", "f4", o),
                        h("p", "n1", s),
                        h("p", "n2", s),
                        h("p", "n3", s),
                        h("p", "n4", s),
                        h("u1", "u2", l),
                        h("u2", "u3", l),
                        h("u3", "u1", l),
                        h("c", "t", c),
                        h("p", "c", u),
                        h("cn1", "cn2", u),
                        h("cn3", "cn4", u),
                        h("cf1", "cf2", u),
                        h("cf3", "cf4", u),
                        t.setAttribute("position", new Fi(r,3)),
                        t.setAttribute("color", new Fi(i,3)),
                        super(t, n),
                        this.type = "CameraHelper",
                        this.camera = e,
                        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                        this.matrix = e.matrixWorld,
                        this.matrixAutoUpdate = !1,
                        this.pointMap = a,
                        this.update()
                    }
                    update() {
                        const e = this.geometry
                          , t = this.pointMap;
                        Ud.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                        Gd("c", t, e, Ud, 0, 0, -1),
                        Gd("t", t, e, Ud, 0, 0, 1),
                        Gd("n1", t, e, Ud, -1, -1, -1),
                        Gd("n2", t, e, Ud, 1, -1, -1),
                        Gd("n3", t, e, Ud, -1, 1, -1),
                        Gd("n4", t, e, Ud, 1, 1, -1),
                        Gd("f1", t, e, Ud, -1, -1, 1),
                        Gd("f2", t, e, Ud, 1, -1, 1),
                        Gd("f3", t, e, Ud, -1, 1, 1),
                        Gd("f4", t, e, Ud, 1, 1, 1),
                        Gd("u1", t, e, Ud, .7, 1.1, -1),
                        Gd("u2", t, e, Ud, -.7, 1.1, -1),
                        Gd("u3", t, e, Ud, 0, 2, -1),
                        Gd("cf1", t, e, Ud, -1, 0, 1),
                        Gd("cf2", t, e, Ud, 1, 0, 1),
                        Gd("cf3", t, e, Ud, 0, -1, 1),
                        Gd("cf4", t, e, Ud, 0, 1, 1),
                        Gd("cn1", t, e, Ud, -1, 0, -1),
                        Gd("cn2", t, e, Ud, 1, 0, -1),
                        Gd("cn3", t, e, Ud, 0, -1, -1),
                        Gd("cn4", t, e, Ud, 0, 1, -1),
                        e.getAttribute("position").needsUpdate = !0
                    }
                }
                function Gd(e, t, n, r, i, a, o) {
                    zd.set(i, a, o).unproject(r);
                    const s = t[e];
                    if (void 0 !== s) {
                        const e = n.getAttribute("position");
                        for (let t = 0, n = s.length; t < n; t++)
                            e.setXYZ(s[t], zd.x, zd.y, zd.z)
                    }
                }
                const jd = new er;
                class Vd extends Ll {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , r = new Float32Array(24)
                          , i = new qi;
                        i.setIndex(new Ti(n,1)),
                        i.setAttribute("position", new Ti(r,3)),
                        super(i, new wl({
                            color: t,
                            toneMapped: !1
                        })),
                        this.object = e,
                        this.type = "BoxHelper",
                        this.matrixAutoUpdate = !1,
                        this.update()
                    }
                    update(e) {
                        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
                        void 0 !== this.object && jd.setFromObject(this.object),
                        jd.isEmpty())
                            return;
                        const t = jd.min
                          , n = jd.max
                          , r = this.geometry.attributes.position
                          , i = r.array;
                        i[0] = n.x,
                        i[1] = n.y,
                        i[2] = n.z,
                        i[3] = t.x,
                        i[4] = n.y,
                        i[5] = n.z,
                        i[6] = t.x,
                        i[7] = t.y,
                        i[8] = n.z,
                        i[9] = n.x,
                        i[10] = t.y,
                        i[11] = n.z,
                        i[12] = n.x,
                        i[13] = n.y,
                        i[14] = t.z,
                        i[15] = t.x,
                        i[16] = n.y,
                        i[17] = t.z,
                        i[18] = t.x,
                        i[19] = t.y,
                        i[20] = t.z,
                        i[21] = n.x,
                        i[22] = t.y,
                        i[23] = t.z,
                        r.needsUpdate = !0,
                        this.geometry.computeBoundingSphere()
                    }
                    setFromObject(e) {
                        return this.object = e,
                        this.update(),
                        this
                    }
                    copy(e) {
                        return Ll.prototype.copy.call(this, e),
                        this.object = e.object,
                        this
                    }
                }
                class Wd extends Ll {
                    constructor(e, t=16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                          , r = new qi;
                        r.setIndex(new Ti(n,1)),
                        r.setAttribute("position", new Fi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
                        super(r, new wl({
                            color: t,
                            toneMapped: !1
                        })),
                        this.box = e,
                        this.type = "Box3Helper",
                        this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(e) {
                        const t = this.box;
                        t.isEmpty() || (t.getCenter(this.position),
                        t.getSize(this.scale),
                        this.scale.multiplyScalar(.5),
                        super.updateMatrixWorld(e))
                    }
                }
                class qd extends Cl {
                    constructor(e, t=1, n=16776960) {
                        const r = n
                          , i = new qi;
                        i.setAttribute("position", new Fi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
                        i.computeBoundingSphere(),
                        super(i, new wl({
                            color: r,
                            toneMapped: !1
                        })),
                        this.type = "PlaneHelper",
                        this.plane = e,
                        this.size = t;
                        const a = new qi;
                        a.setAttribute("position", new Fi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
                        a.computeBoundingSphere(),
                        this.add(new ua(a,new wi({
                            color: r,
                            opacity: .2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(e) {
                        let t = -this.plane.constant;
                        Math.abs(t) < 1e-8 && (t = 1e-8),
                        this.scale.set(.5 * this.size, .5 * this.size, t),
                        this.children[0].material.side = t < 0 ? m : f,
                        this.lookAt(this.plane.normal),
                        super.updateMatrixWorld(e)
                    }
                }
                const Xd = new Kn;
                let Yd, Zd;
                class Jd extends Jr {
                    constructor(e, t, n, r, i, a) {
                        super(),
                        this.type = "ArrowHelper",
                        void 0 === e && (e = new Kn(0,0,1)),
                        void 0 === t && (t = new Kn(0,0,0)),
                        void 0 === n && (n = 1),
                        void 0 === r && (r = 16776960),
                        void 0 === i && (i = .2 * n),
                        void 0 === a && (a = .2 * i),
                        void 0 === Yd && (Yd = new qi,
                        Yd.setAttribute("position", new Fi([0, 0, 0, 0, 1, 0],3)),
                        Zd = new Wl(0,.5,1,5,1),
                        Zd.translate(0, -.5, 0)),
                        this.position.copy(t),
                        this.line = new Cl(Yd,new wl({
                            color: r,
                            toneMapped: !1
                        })),
                        this.line.matrixAutoUpdate = !1,
                        this.add(this.line),
                        this.cone = new ua(Zd,new wi({
                            color: r,
                            toneMapped: !1
                        })),
                        this.cone.matrixAutoUpdate = !1,
                        this.add(this.cone),
                        this.setDirection(e),
                        this.setLength(n, i, a)
                    }
                    setDirection(e) {
                        if (e.y > .99999)
                            this.quaternion.set(0, 0, 0, 1);
                        else if (e.y < -.99999)
                            this.quaternion.set(1, 0, 0, 0);
                        else {
                            Xd.set(e.z, 0, -e.x).normalize();
                            const t = Math.acos(e.y);
                            this.quaternion.setFromAxisAngle(Xd, t)
                        }
                    }
                    setLength(e, t, n) {
                        void 0 === t && (t = .2 * e),
                        void 0 === n && (n = .2 * t),
                        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                        this.line.updateMatrix(),
                        this.cone.scale.set(n, t, n),
                        this.cone.position.y = e,
                        this.cone.updateMatrix()
                    }
                    setColor(e) {
                        this.line.material.color.set(e),
                        this.cone.material.color.set(e)
                    }
                    copy(e) {
                        return super.copy(e, !1),
                        this.line.copy(e.line),
                        this.cone.copy(e.cone),
                        this
                    }
                }
                class Kd extends Ll {
                    constructor(e=1) {
                        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
                          , n = new qi;
                        n.setAttribute("position", new Fi(t,3)),
                        n.setAttribute("color", new Fi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
                        super(n, new wl({
                            vertexColors: !0,
                            toneMapped: !1
                        })),
                        this.type = "AxesHelper"
                    }
                }
                const Qd = new Float32Array(1)
                  , $d = new Int32Array(Qd.buffer)
                  , ep = {
                    toHalfFloat: function(e) {
                        Qd[0] = e;
                        const t = $d[0];
                        let n = t >> 16 & 32768
                          , r = t >> 12 & 2047;
                        const i = t >> 23 & 255;
                        return i < 103 ? n : i > 142 ? (n |= 31744,
                        n |= (255 == i ? 0 : 1) && 8388607 & t,
                        n) : i < 113 ? (r |= 2048,
                        n |= (r >> 114 - i) + (r >> 113 - i & 1),
                        n) : (n |= i - 112 << 10 | r >> 1,
                        n += 1 & r,
                        n)
                    }
                }
                  , tp = Math.pow(2, 8)
                  , np = [.125, .215, .35, .446, .526, .582]
                  , rp = 5 + np.length
                  , ip = {
                    [Jt]: 0,
                    [Kt]: 1,
                    [$t]: 2,
                    [tn]: 3,
                    [nn]: 4,
                    [rn]: 5,
                    [Qt]: 6
                }
                  , ap = new wi({
                    side: m,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , op = new ua(new da,ap)
                  , sp = new rh
                  , {_lodPlanes: lp, _sizeLods: cp, _sigmas: up} = _p()
                  , hp = new yi;
                let dp = null;
                const pp = (1 + Math.sqrt(5)) / 2
                  , fp = 1 / pp
                  , mp = [new Kn(1,1,1), new Kn(-1,1,1), new Kn(1,1,-1), new Kn(-1,1,-1), new Kn(0,pp,fp), new Kn(0,pp,-fp), new Kn(fp,0,pp), new Kn(-fp,0,pp), new Kn(pp,fp,0), new Kn(-pp,fp,0)];
                function gp(e) {
                    const t = Math.max(e.r, e.g, e.b)
                      , n = Math.min(Math.max(Math.ceil(Math.log2(t)), -128), 127);
                    return e.multiplyScalar(Math.pow(2, -n)),
                    (n + 128) / 255
                }
                class vp {
                    constructor(e) {
                        this._renderer = e,
                        this._pingPongRenderTarget = null,
                        this._blurMaterial = new Vc({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: new Float32Array(20)
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: new Kn(0,1,0)
                                },
                                inputEncoding: {
                                    value: ip[Jt]
                                },
                                outputEncoding: {
                                    value: ip[Jt]
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                            blending: _,
                            depthTest: !1,
                            depthWrite: !1
                        }),
                        this._equirectShader = null,
                        this._cubemapShader = null,
                        this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(e, t=0, n=.1, r=100) {
                        dp = this._renderer.getRenderTarget();
                        const i = this._allocateTargets();
                        return this._sceneToCubeUV(e, n, r, i),
                        t > 0 && this._blur(i, 0, 0, t),
                        this._applyPMREM(i),
                        this._cleanup(i),
                        i
                    }
                    fromEquirectangular(e) {
                        return this._fromTexture(e)
                    }
                    fromCubemap(e) {
                        return this._fromTexture(e)
                    }
                    compileCubemapShader() {
                        null === this._cubemapShader && (this._cubemapShader = Mp(),
                        this._compileMaterial(this._cubemapShader))
                    }
                    compileEquirectangularShader() {
                        null === this._equirectShader && (this._equirectShader = wp(),
                        this._compileMaterial(this._equirectShader))
                    }
                    dispose() {
                        this._blurMaterial.dispose(),
                        null !== this._cubemapShader && this._cubemapShader.dispose(),
                        null !== this._equirectShader && this._equirectShader.dispose();
                        for (let e = 0; e < lp.length; e++)
                            lp[e].dispose()
                    }
                    _cleanup(e) {
                        this._pingPongRenderTarget.dispose(),
                        this._renderer.setRenderTarget(dp),
                        e.scissorTest = !1,
                        bp(e, 0, 0, e.width, e.height)
                    }
                    _fromTexture(e) {
                        dp = this._renderer.getRenderTarget();
                        const t = this._allocateTargets(e);
                        return this._textureToCubeUV(e, t),
                        this._applyPMREM(t),
                        this._cleanup(t),
                        t
                    }
                    _allocateTargets(e) {
                        const t = {
                            magFilter: fe,
                            minFilter: fe,
                            generateMipmaps: !1,
                            type: Se,
                            format: He,
                            encoding: yp(e) ? e.encoding : $t,
                            depthBuffer: !1
                        }
                          , n = xp(t);
                        return n.depthBuffer = !e,
                        this._pingPongRenderTarget = xp(t),
                        n
                    }
                    _compileMaterial(e) {
                        const t = new ua(lp[0],e);
                        this._renderer.compile(t, sp)
                    }
                    _sceneToCubeUV(e, t, n, r) {
                        const i = new ya(90,1,t,n)
                          , a = [1, -1, 1, 1, 1, 1]
                          , o = [1, 1, 1, -1, -1, -1]
                          , s = this._renderer
                          , l = s.autoClear
                          , c = s.outputEncoding
                          , u = s.toneMapping;
                        s.getClearColor(hp),
                        s.toneMapping = Q,
                        s.outputEncoding = Jt,
                        s.autoClear = !1;
                        let h = !1;
                        const d = e.background;
                        if (d) {
                            if (d.isColor) {
                                ap.color.copy(d).convertSRGBToLinear(),
                                e.background = null;
                                const t = gp(ap.color);
                                ap.opacity = t,
                                h = !0
                            }
                        } else {
                            ap.color.copy(hp).convertSRGBToLinear();
                            const e = gp(ap.color);
                            ap.opacity = e,
                            h = !0
                        }
                        for (let t = 0; t < 6; t++) {
                            const n = t % 3;
                            0 == n ? (i.up.set(0, a[t], 0),
                            i.lookAt(o[t], 0, 0)) : 1 == n ? (i.up.set(0, 0, a[t]),
                            i.lookAt(0, o[t], 0)) : (i.up.set(0, a[t], 0),
                            i.lookAt(0, 0, o[t])),
                            bp(r, n * tp, t > 2 ? tp : 0, tp, tp),
                            s.setRenderTarget(r),
                            h && s.render(op, i),
                            s.render(e, i)
                        }
                        s.toneMapping = u,
                        s.outputEncoding = c,
                        s.autoClear = l
                    }
                    _textureToCubeUV(e, t) {
                        const n = this._renderer;
                        e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Mp()) : null == this._equirectShader && (this._equirectShader = wp());
                        const r = e.isCubeTexture ? this._cubemapShader : this._equirectShader
                          , i = new ua(lp[0],r)
                          , a = r.uniforms;
                        a.envMap.value = e,
                        e.isCubeTexture || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
                        a.inputEncoding.value = ip[e.encoding],
                        a.outputEncoding.value = ip[t.texture.encoding],
                        bp(t, 0, 0, 3 * tp, 2 * tp),
                        n.setRenderTarget(t),
                        n.render(i, sp)
                    }
                    _applyPMREM(e) {
                        const t = this._renderer
                          , n = t.autoClear;
                        t.autoClear = !1;
                        for (let t = 1; t < rp; t++) {
                            const n = Math.sqrt(up[t] * up[t] - up[t - 1] * up[t - 1])
                              , r = mp[(t - 1) % mp.length];
                            this._blur(e, t - 1, t, n, r)
                        }
                        t.autoClear = n
                    }
                    _blur(e, t, n, r, i) {
                        const a = this._pingPongRenderTarget;
                        this._halfBlur(e, a, t, n, r, "latitudinal", i),
                        this._halfBlur(a, e, n, n, r, "longitudinal", i)
                    }
                    _halfBlur(e, t, n, r, i, a, o) {
                        const s = this._renderer
                          , l = this._blurMaterial;
                        "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                        const c = new ua(lp[r],l)
                          , u = l.uniforms
                          , h = cp[n] - 1
                          , d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39
                          , p = i / d
                          , f = isFinite(i) ? 1 + Math.floor(3 * p) : 20;
                        f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                        const m = [];
                        let g = 0;
                        for (let e = 0; e < 20; ++e) {
                            const t = e / p
                              , n = Math.exp(-t * t / 2);
                            m.push(n),
                            0 == e ? g += n : e < f && (g += 2 * n)
                        }
                        for (let e = 0; e < m.length; e++)
                            m[e] = m[e] / g;
                        u.envMap.value = e.texture,
                        u.samples.value = f,
                        u.weights.value = m,
                        u.latitudinal.value = "latitudinal" === a,
                        o && (u.poleAxis.value = o),
                        u.dTheta.value = d,
                        u.mipInt.value = 8 - n,
                        u.inputEncoding.value = ip[e.texture.encoding],
                        u.outputEncoding.value = ip[e.texture.encoding];
                        const v = cp[r];
                        bp(t, 3 * Math.max(0, tp - 2 * v), (0 === r ? 0 : 2 * tp) + 2 * v * (r > 4 ? r - 8 + 4 : 0), 3 * v, 2 * v),
                        s.setRenderTarget(t),
                        s.render(c, sp)
                    }
                }
                function yp(e) {
                    return void 0 !== e && e.type === Se && (e.encoding === Jt || e.encoding === Kt || e.encoding === Qt)
                }
                function _p() {
                    const e = []
                      , t = []
                      , n = [];
                    let r = 8;
                    for (let i = 0; i < rp; i++) {
                        const a = Math.pow(2, r);
                        t.push(a);
                        let o = 1 / a;
                        i > 4 ? o = np[i - 8 + 4 - 1] : 0 == i && (o = 0),
                        n.push(o);
                        const s = 1 / (a - 1)
                          , l = -s / 2
                          , c = 1 + s / 2
                          , u = [l, l, c, l, c, c, l, l, c, c, l, c]
                          , h = 6
                          , d = 6
                          , p = 3
                          , f = 2
                          , m = 1
                          , g = new Float32Array(p * d * h)
                          , v = new Float32Array(f * d * h)
                          , y = new Float32Array(m * d * h);
                        for (let e = 0; e < h; e++) {
                            const t = e % 3 * 2 / 3 - 1
                              , n = e > 2 ? 0 : -1
                              , r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                            g.set(r, p * d * e),
                            v.set(u, f * d * e);
                            const i = [e, e, e, e, e, e];
                            y.set(i, m * d * e)
                        }
                        const _ = new qi;
                        _.setAttribute("position", new Ti(g,p)),
                        _.setAttribute("uv", new Ti(v,f)),
                        _.setAttribute("faceIndex", new Ti(y,m)),
                        e.push(_),
                        r > 4 && r--
                    }
                    return {
                        _lodPlanes: e,
                        _sizeLods: t,
                        _sigmas: n
                    }
                }
                function xp(e) {
                    const t = new Yn(3 * tp,3 * tp,e);
                    return t.texture.mapping = ce,
                    t.texture.name = "PMREM.cubeUv",
                    t.scissorTest = !0,
                    t
                }
                function bp(e, t, n, r, i) {
                    e.viewport.set(t, n, r, i),
                    e.scissor.set(t, n, r, i)
                }
                function wp() {
                    return new Vc({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            texelSize: {
                                value: new Un(1,1)
                            },
                            inputEncoding: {
                                value: ip[Jt]
                            },
                            outputEncoding: {
                                value: ip[Jt]
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                        blending: _,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function Mp() {
                    return new Vc({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            inputEncoding: {
                                value: ip[Jt]
                            },
                            outputEncoding: {
                                value: ip[Jt]
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                        blending: _,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }
                function Sp(e, t, n, r, i, a, o) {
                    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
                    new _i(e,t,n,i,a,o)
                }
                const Tp = 0
                  , Ep = 1
                  , Ap = 0
                  , Cp = 1
                  , Pp = 2;
                function Rp(e) {
                    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
                    e
                }
                function Lp(e=[]) {
                    return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
                    e.isMultiMaterial = !0,
                    e.materials = e,
                    e.clone = function() {
                        return e.slice()
                    }
                    ,
                    e
                }
                function Dp(e, t) {
                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
                    new kl(e,t)
                }
                function Op(e) {
                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
                    new nl(e)
                }
                function Fp(e, t) {
                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
                    new kl(e,t)
                }
                function Ip(e) {
                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
                    new Ol(e)
                }
                function Np(e) {
                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
                    new Ol(e)
                }
                function Bp(e) {
                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
                    new Ol(e)
                }
                function kp(e, t, n) {
                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
                    new Kn(e,t,n)
                }
                function zp(e, t) {
                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),
                    new Ti(e,t).setUsage(En)
                }
                function Up(e, t) {
                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
                    new Ei(e,t)
                }
                function Hp(e, t) {
                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
                    new Ai(e,t)
                }
                function Gp(e, t) {
                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
                    new Ci(e,t)
                }
                function jp(e, t) {
                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
                    new Pi(e,t)
                }
                function Vp(e, t) {
                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
                    new Ri(e,t)
                }
                function Wp(e, t) {
                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
                    new Li(e,t)
                }
                function qp(e, t) {
                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
                    new Di(e,t)
                }
                function Xp(e, t) {
                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
                    new Fi(e,t)
                }
                function Yp(e, t) {
                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
                    new Ii(e,t)
                }
                function Zp(e) {
                    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
                    Iu.call(this, e),
                    this.type = "catmullrom",
                    this.closed = !0
                }
                function Jp(e) {
                    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
                    Iu.call(this, e),
                    this.type = "catmullrom"
                }
                function Kp(e) {
                    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
                    Iu.call(this, e),
                    this.type = "catmullrom"
                }
                function Qp(e) {
                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
                    new Kd(e)
                }
                function $p(e, t) {
                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
                    new Vd(e,t)
                }
                function ef(e, t) {
                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
                    new Ll(new $l(e.geometry),new wl({
                        color: void 0 !== t ? t : 16777215
                    }))
                }
                function tf(e, t) {
                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
                    new Ll(new Hc(e.geometry),new wl({
                        color: void 0 !== t ? t : 16777215
                    }))
                }
                function nf(e) {
                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
                    new xu(e)
                }
                function rf(e) {
                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
                    new Tu(e)
                }
                function af(e, t, n) {
                    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),
                    new wa(e,n)
                }
                Au.create = function(e, t) {
                    return console.log("THREE.Curve.create() has been deprecated"),
                    e.prototype = Object.create(Au.prototype),
                    e.prototype.constructor = e,
                    e.prototype.getPoint = t,
                    e
                }
                ,
                Object.assign(Yu.prototype, {
                    fromPoints: function(e) {
                        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
                        this.setFromPoints(e)
                    }
                }),
                Zp.prototype = Object.create(Iu.prototype),
                Jp.prototype = Object.create(Iu.prototype),
                Kp.prototype = Object.create(Iu.prototype),
                Object.assign(Kp.prototype, {
                    initFromArray: function() {
                        console.error("THREE.Spline: .initFromArray() has been removed.")
                    },
                    getControlPointsArray: function() {
                        console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                    },
                    reparametrizeByArcLength: function() {
                        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                    }
                }),
                Od.prototype.setColors = function() {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                }
                ,
                Ed.prototype.update = function() {
                    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
                }
                ,
                Object.assign(yu.prototype, {
                    extractUrlBase: function(e) {
                        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
                        hh.extractUrlBase(e)
                    }
                }),
                yu.Handlers = {
                    add: function() {
                        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                    },
                    get: function() {
                        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                    }
                },
                Object.assign(gd.prototype, {
                    center: function(e) {
                        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
                        this.getCenter(e)
                    },
                    empty: function() {
                        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                    },
                    isIntersectionBox: function(e) {
                        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(e)
                    },
                    size: function(e) {
                        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
                        this.getSize(e)
                    }
                }),
                Object.assign(er.prototype, {
                    center: function(e) {
                        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
                        this.getCenter(e)
                    },
                    empty: function() {
                        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                    },
                    isIntersectionBox: function(e) {
                        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(e)
                    },
                    isIntersectionSphere: function(e) {
                        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                        this.intersectsSphere(e)
                    },
                    size: function(e) {
                        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
                        this.getSize(e)
                    }
                }),
                Object.assign(gr.prototype, {
                    empty: function() {
                        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                    }
                }),
                Ea.prototype.setFromMatrix = function(e) {
                    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
                    this.setFromProjectionMatrix(e)
                }
                ,
                _d.prototype.center = function(e) {
                    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
                    this.getCenter(e)
                }
                ,
                Object.assign(zn, {
                    random16: function() {
                        return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
                        Math.random()
                    },
                    nearestPowerOfTwo: function(e) {
                        return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
                        zn.floorPowerOfTwo(e)
                    },
                    nextPowerOfTwo: function(e) {
                        return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
                        zn.ceilPowerOfTwo(e)
                    }
                }),
                Object.assign(Hn.prototype, {
                    flattenToArrayOffset: function(e, t) {
                        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
                        this.toArray(e, t)
                    },
                    multiplyVector3: function(e) {
                        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
                        e.applyMatrix3(this)
                    },
                    multiplyVector3Array: function() {
                        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                    },
                    applyToBufferAttribute: function(e) {
                        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
                        e.applyMatrix3(this)
                    },
                    applyToVector3Array: function() {
                        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                    },
                    getInverse: function(e) {
                        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
                        this.copy(e).invert()
                    }
                }),
                Object.assign(Tr.prototype, {
                    extractPosition: function(e) {
                        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
                        this.copyPosition(e)
                    },
                    flattenToArrayOffset: function(e, t) {
                        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
                        this.toArray(e, t)
                    },
                    getPosition: function() {
                        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                        (new Kn).setFromMatrixColumn(this, 3)
                    },
                    setRotationFromQuaternion: function(e) {
                        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
                        this.makeRotationFromQuaternion(e)
                    },
                    multiplyToArray: function() {
                        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                    },
                    multiplyVector3: function(e) {
                        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        e.applyMatrix4(this)
                    },
                    multiplyVector4: function(e) {
                        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        e.applyMatrix4(this)
                    },
                    multiplyVector3Array: function() {
                        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                    },
                    rotateAxis: function(e) {
                        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
                        e.transformDirection(this)
                    },
                    crossVector: function(e) {
                        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        e.applyMatrix4(this)
                    },
                    translate: function() {
                        console.error("THREE.Matrix4: .translate() has been removed.")
                    },
                    rotateX: function() {
                        console.error("THREE.Matrix4: .rotateX() has been removed.")
                    },
                    rotateY: function() {
                        console.error("THREE.Matrix4: .rotateY() has been removed.")
                    },
                    rotateZ: function() {
                        console.error("THREE.Matrix4: .rotateZ() has been removed.")
                    },
                    rotateByAxis: function() {
                        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                    },
                    applyToBufferAttribute: function(e) {
                        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
                        e.applyMatrix4(this)
                    },
                    applyToVector3Array: function() {
                        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                    },
                    makeFrustum: function(e, t, n, r, i, a) {
                        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
                        this.makePerspective(e, t, r, n, i, a)
                    },
                    getInverse: function(e) {
                        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
                        this.copy(e).invert()
                    }
                }),
                ei.prototype.isIntersectionLine = function(e) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
                    this.intersectsLine(e)
                }
                ,
                Object.assign(Jn.prototype, {
                    multiplyVector3: function(e) {
                        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
                        e.applyQuaternion(this)
                    },
                    inverse: function() {
                        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
                        this.invert()
                    }
                }),
                Object.assign(Sr.prototype, {
                    isIntersectionBox: function(e) {
                        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(e)
                    },
                    isIntersectionPlane: function(e) {
                        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
                        this.intersectsPlane(e)
                    },
                    isIntersectionSphere: function(e) {
                        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                        this.intersectsSphere(e)
                    }
                }),
                Object.assign(hi.prototype, {
                    area: function() {
                        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
                        this.getArea()
                    },
                    barycoordFromPoint: function(e, t) {
                        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
                        this.getBarycoord(e, t)
                    },
                    midpoint: function(e) {
                        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
                        this.getMidpoint(e)
                    },
                    normal: function(e) {
                        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
                        this.getNormal(e)
                    },
                    plane: function(e) {
                        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
                        this.getPlane(e)
                    }
                }),
                Object.assign(hi, {
                    barycoordFromPoint: function(e, t, n, r, i) {
                        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
                        hi.getBarycoord(e, t, n, r, i)
                    },
                    normal: function(e, t, n, r) {
                        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
                        hi.getNormal(e, t, n, r)
                    }
                }),
                Object.assign(Zu.prototype, {
                    extractAllPoints: function(e) {
                        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
                        this.extractPoints(e)
                    },
                    extrude: function(e) {
                        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
                        new Ac(this,e)
                    },
                    makeGeometry: function(e) {
                        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
                        new Fc(this,e)
                    }
                }),
                Object.assign(Un.prototype, {
                    fromAttribute: function(e, t, n) {
                        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
                        this.fromBufferAttribute(e, t, n)
                    },
                    distanceToManhattan: function(e) {
                        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
                        this.manhattanDistanceTo(e)
                    },
                    lengthManhattan: function() {
                        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
                        this.manhattanLength()
                    }
                }),
                Object.assign(Kn.prototype, {
                    setEulerFromRotationMatrix: function() {
                        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                    },
                    setEulerFromQuaternion: function() {
                        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                    },
                    getPositionFromMatrix: function(e) {
                        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
                        this.setFromMatrixPosition(e)
                    },
                    getScaleFromMatrix: function(e) {
                        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
                        this.setFromMatrixScale(e)
                    },
                    getColumnFromMatrix: function(e, t) {
                        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
                        this.setFromMatrixColumn(t, e)
                    },
                    applyProjection: function(e) {
                        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
                        this.applyMatrix4(e)
                    },
                    fromAttribute: function(e, t, n) {
                        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
                        this.fromBufferAttribute(e, t, n)
                    },
                    distanceToManhattan: function(e) {
                        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
                        this.manhattanDistanceTo(e)
                    },
                    lengthManhattan: function() {
                        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
                        this.manhattanLength()
                    }
                }),
                Object.assign(Xn.prototype, {
                    fromAttribute: function(e, t, n) {
                        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
                        this.fromBufferAttribute(e, t, n)
                    },
                    lengthManhattan: function() {
                        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
                        this.manhattanLength()
                    }
                }),
                Object.assign(Jr.prototype, {
                    getChildByName: function(e) {
                        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
                        this.getObjectByName(e)
                    },
                    renderDepth: function() {
                        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                    },
                    translate: function(e, t) {
                        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
                        this.translateOnAxis(t, e)
                    },
                    getWorldRotation: function() {
                        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                    },
                    applyMatrix: function(e) {
                        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
                        this.applyMatrix4(e)
                    }
                }),
                Object.defineProperties(Jr.prototype, {
                    eulerOrder: {
                        get: function() {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order
                        },
                        set: function(e) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order = e
                        }
                    },
                    useQuaternion: {
                        get: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }),
                Object.assign(ua.prototype, {
                    setDrawMode: function() {
                        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }),
                Object.defineProperties(ua.prototype, {
                    drawMode: {
                        get: function() {
                            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                            Xt
                        },
                        set: function() {
                            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                        }
                    }
                }),
                Object.defineProperties(ol.prototype, {
                    objects: {
                        get: function() {
                            return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                            this.levels
                        }
                    }
                }),
                Object.defineProperty(gl.prototype, "useVertexTexture", {
                    get: function() {
                        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                    }
                }),
                dl.prototype.initBones = function() {
                    console.error("THREE.SkinnedMesh: initBones() has been removed.")
                }
                ,
                Object.defineProperty(Au.prototype, "__arcLengthDivisions", {
                    get: function() {
                        return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
                        this.arcLengthDivisions
                    },
                    set: function(e) {
                        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
                        this.arcLengthDivisions = e
                    }
                }),
                ya.prototype.setLens = function(e, t) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
                    void 0 !== t && (this.filmGauge = t),
                    this.setFocalLength(e)
                }
                ,
                Object.defineProperties(Ju.prototype, {
                    onlyShadow: {
                        set: function() {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                            this.shadow.camera.fov = e
                        }
                    },
                    shadowCameraLeft: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                            this.shadow.camera.left = e
                        }
                    },
                    shadowCameraRight: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                            this.shadow.camera.right = e
                        }
                    },
                    shadowCameraTop: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                            this.shadow.camera.top = e
                        }
                    },
                    shadowCameraBottom: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                            this.shadow.camera.bottom = e
                        }
                    },
                    shadowCameraNear: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                            this.shadow.camera.near = e
                        }
                    },
                    shadowCameraFar: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                            this.shadow.camera.far = e
                        }
                    },
                    shadowCameraVisible: {
                        set: function() {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                            this.shadow.bias = e
                        }
                    },
                    shadowDarkness: {
                        set: function() {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                            this.shadow.mapSize.width = e
                        }
                    },
                    shadowMapHeight: {
                        set: function(e) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                            this.shadow.mapSize.height = e
                        }
                    }
                }),
                Object.defineProperties(Ti.prototype, {
                    length: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                            this.array.length
                        }
                    },
                    dynamic: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                            this.usage === En
                        },
                        set: function() {
                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                            this.setUsage(En)
                        }
                    }
                }),
                Object.assign(Ti.prototype, {
                    setDynamic: function(e) {
                        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
                        this.setUsage(!0 === e ? En : Tn),
                        this
                    },
                    copyIndicesArray: function() {
                        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                    },
                    setArray: function() {
                        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                    }
                }),
                Object.assign(qi.prototype, {
                    addIndex: function(e) {
                        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
                        this.setIndex(e)
                    },
                    addAttribute: function(e, t) {
                        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
                        t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                        this.setIndex(t),
                        this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                        this.setAttribute(e, new Ti(arguments[1],arguments[2])))
                    },
                    addDrawCall: function(e, t, n) {
                        void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
                        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
                        this.addGroup(e, t)
                    },
                    clearDrawCalls: function() {
                        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
                        this.clearGroups()
                    },
                    computeOffsets: function() {
                        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                    },
                    removeAttribute: function(e) {
                        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
                        this.deleteAttribute(e)
                    },
                    applyMatrix: function(e) {
                        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
                        this.applyMatrix4(e)
                    }
                }),
                Object.defineProperties(qi.prototype, {
                    drawcalls: {
                        get: function() {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                            this.groups
                        }
                    },
                    offsets: {
                        get: function() {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                            this.groups
                        }
                    }
                }),
                Object.defineProperties(dh.prototype, {
                    maxInstancedCount: {
                        get: function() {
                            return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                            this.instanceCount
                        },
                        set: function(e) {
                            console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                            this.instanceCount = e
                        }
                    }
                }),
                Object.defineProperties(ud.prototype, {
                    linePrecision: {
                        get: function() {
                            return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                            this.params.Line.threshold
                        },
                        set: function(e) {
                            console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                            this.params.Line.threshold = e
                        }
                    }
                }),
                Object.defineProperties(zs.prototype, {
                    dynamic: {
                        get: function() {
                            return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                            this.usage === En
                        },
                        set: function(e) {
                            console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                            this.setUsage(e)
                        }
                    }
                }),
                Object.assign(zs.prototype, {
                    setDynamic: function(e) {
                        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
                        this.setUsage(!0 === e ? En : Tn),
                        this
                    },
                    setArray: function() {
                        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                    }
                }),
                Object.assign(Ac.prototype, {
                    getArrays: function() {
                        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
                    },
                    addShapeList: function() {
                        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
                    },
                    addShape: function() {
                        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
                    }
                }),
                Object.assign(ks.prototype, {
                    dispose: function() {
                        console.error("THREE.Scene: .dispose() has been removed.")
                    }
                }),
                Object.defineProperties(sd.prototype, {
                    dynamic: {
                        set: function() {
                            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                        }
                    },
                    onUpdate: {
                        value: function() {
                            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                            this
                        }
                    }
                }),
                Object.defineProperties(bi.prototype, {
                    wrapAround: {
                        get: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        }
                    },
                    overdraw: {
                        get: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        }
                    },
                    wrapRGB: {
                        get: function() {
                            return console.warn("THREE.Material: .wrapRGB has been removed."),
                            new yi
                        }
                    },
                    shading: {
                        get: function() {
                            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                        },
                        set: function(e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = e === v
                        }
                    },
                    stencilMask: {
                        get: function() {
                            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                            this.stencilFuncMask
                        },
                        set: function(e) {
                            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                            this.stencilFuncMask = e
                        }
                    }
                }),
                Object.defineProperties(Xc.prototype, {
                    metal: {
                        get: function() {
                            return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                            !1
                        },
                        set: function() {
                            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                        }
                    }
                }),
                Object.defineProperties(qc.prototype, {
                    transparency: {
                        get: function() {
                            return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                            this.transmission
                        },
                        set: function(e) {
                            console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                            this.transmission = e
                        }
                    }
                }),
                Object.defineProperties(ga.prototype, {
                    derivatives: {
                        get: function() {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                            this.extensions.derivatives
                        },
                        set: function(e) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                            this.extensions.derivatives = e
                        }
                    }
                }),
                Object.assign(Fs.prototype, {
                    clearTarget: function(e, t, n, r) {
                        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
                        this.setRenderTarget(e),
                        this.clear(t, n, r)
                    },
                    animate: function(e) {
                        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
                        this.setAnimationLoop(e)
                    },
                    getCurrentRenderTarget: function() {
                        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
                        this.getRenderTarget()
                    },
                    getMaxAnisotropy: function() {
                        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
                        this.capabilities.getMaxAnisotropy()
                    },
                    getPrecision: function() {
                        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
                        this.capabilities.precision
                    },
                    resetGLState: function() {
                        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
                        this.state.reset()
                    },
                    supportsFloatTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
                        this.extensions.get("OES_texture_float")
                    },
                    supportsHalfFloatTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
                        this.extensions.get("OES_texture_half_float")
                    },
                    supportsStandardDerivatives: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
                        this.extensions.get("OES_standard_derivatives")
                    },
                    supportsCompressedTextureS3TC: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
                        this.extensions.get("WEBGL_compressed_texture_s3tc")
                    },
                    supportsCompressedTexturePVRTC: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
                        this.extensions.get("WEBGL_compressed_texture_pvrtc")
                    },
                    supportsBlendMinMax: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
                        this.extensions.get("EXT_blend_minmax")
                    },
                    supportsVertexTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
                        this.capabilities.vertexTextures
                    },
                    supportsInstancedArrays: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
                        this.extensions.get("ANGLE_instanced_arrays")
                    },
                    enableScissorTest: function(e) {
                        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
                        this.setScissorTest(e)
                    },
                    initMaterial: function() {
                        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                    },
                    addPrePlugin: function() {
                        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                    },
                    addPostPlugin: function() {
                        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                    },
                    updateShadowMap: function() {
                        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                    },
                    setFaceCulling: function() {
                        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                    },
                    allocTextureUnit: function() {
                        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                    },
                    setTexture: function() {
                        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                    },
                    setTexture2D: function() {
                        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                    },
                    setTextureCube: function() {
                        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                    },
                    getActiveMipMapLevel: function() {
                        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
                        this.getActiveMipmapLevel()
                    }
                }),
                Object.defineProperties(Fs.prototype, {
                    shadowMapEnabled: {
                        get: function() {
                            return this.shadowMap.enabled
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                            this.shadowMap.enabled = e
                        }
                    },
                    shadowMapType: {
                        get: function() {
                            return this.shadowMap.type
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                            this.shadowMap.type = e
                        }
                    },
                    shadowMapCullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    context: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                            this.getContext()
                        }
                    },
                    vr: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                            this.xr
                        }
                    },
                    gammaInput: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                            !1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                        }
                    },
                    gammaOutput: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                            !1
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                            this.outputEncoding = !0 === e ? Kt : Jt
                        }
                    },
                    toneMappingWhitePoint: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                            1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                        }
                    }
                }),
                Object.defineProperties(Ts.prototype, {
                    cullFace: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderReverseSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderSingleSided: {
                        get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }),
                Object.defineProperties(Yn.prototype, {
                    wrapS: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                            this.texture.wrapS
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                            this.texture.wrapS = e
                        }
                    },
                    wrapT: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                            this.texture.wrapT
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                            this.texture.wrapT = e
                        }
                    },
                    magFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                            this.texture.magFilter
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                            this.texture.magFilter = e
                        }
                    },
                    minFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                            this.texture.minFilter
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                            this.texture.minFilter = e
                        }
                    },
                    anisotropy: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                            this.texture.anisotropy
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                            this.texture.anisotropy = e
                        }
                    },
                    offset: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                            this.texture.offset
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                            this.texture.offset = e
                        }
                    },
                    repeat: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                            this.texture.repeat
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                            this.texture.repeat = e
                        }
                    },
                    format: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                            this.texture.format
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                            this.texture.format = e
                        }
                    },
                    type: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                            this.texture.type
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                            this.texture.type = e
                        }
                    },
                    generateMipmaps: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                            this.texture.generateMipmaps
                        },
                        set: function(e) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                            this.texture.generateMipmaps = e
                        }
                    }
                }),
                Object.defineProperties(zh.prototype, {
                    load: {
                        value: function(e) {
                            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                            const t = this;
                            return (new Eh).load(e, (function(e) {
                                t.setBuffer(e)
                            }
                            )),
                            this
                        }
                    },
                    startTime: {
                        set: function() {
                            console.warn("THREE.Audio: .startTime is now .play( delay ).")
                        }
                    }
                }),
                Wh.prototype.getData = function() {
                    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
                    this.getFrequencyData()
                }
                ,
                xa.prototype.updateCubeMap = function(e, t) {
                    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
                    this.update(e, t)
                }
                ,
                xa.prototype.clear = function(e, t, n, r) {
                    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
                    this.renderTarget.clear(e, t, n, r)
                }
                ;
                const of = {
                    merge: function(e, t, n) {
                        let r;
                        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
                        t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(),
                        r = t.matrix,
                        t = t.geometry),
                        e.merge(t, r, n)
                    },
                    center: function(e) {
                        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
                        e.center()
                    }
                };
                function sf() {
                    console.error("THREE.CanvasRenderer has been removed")
                }
                function lf() {
                    console.error("THREE.JSONLoader has been removed.")
                }
                jn.crossOrigin = void 0,
                jn.loadTexture = function(e, t, n, r) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    const i = new Eu;
                    i.setCrossOrigin(this.crossOrigin);
                    const a = i.load(e, n, void 0, r);
                    return t && (a.mapping = t),
                    a
                }
                ,
                jn.loadTextureCube = function(e, t, n, r) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    const i = new Su;
                    i.setCrossOrigin(this.crossOrigin);
                    const a = i.load(e, n, void 0, r);
                    return t && (a.mapping = t),
                    a
                }
                ,
                jn.loadCompressedTexture = function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                }
                ,
                jn.loadCompressedTextureCube = function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
                ;
                const cf = {
                    createMultiMaterialObject: function() {
                        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                    },
                    detach: function() {
                        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                    },
                    attach: function() {
                        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                    }
                };
                function uf() {
                    console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
                }
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                    detail: {
                        revision: r
                    }
                })),
                "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r)
            }
            ,
            2886: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    OrbitControls: ()=>i,
                    MapControls: ()=>a
                });
                var r = n(2212)
                  , i = function(e, t) {
                    var n, i, a, o, s, l;
                    void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
                    t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
                    this.object = e,
                    this.domElement = t,
                    this.enabled = !0,
                    this.target = new r.Vector3,
                    this.minDistance = 0,
                    this.maxDistance = 1 / 0,
                    this.minZoom = 0,
                    this.maxZoom = 1 / 0,
                    this.minPolarAngle = 0,
                    this.maxPolarAngle = Math.PI,
                    this.minAzimuthAngle = -1 / 0,
                    this.maxAzimuthAngle = 1 / 0,
                    this.enableDamping = !1,
                    this.dampingFactor = .05,
                    this.enableZoom = !0,
                    this.zoomSpeed = 1,
                    this.enableRotate = !0,
                    this.rotateSpeed = 1,
                    this.enablePan = !0,
                    this.panSpeed = 1,
                    this.screenSpacePanning = !0,
                    this.keyPanSpeed = 7,
                    this.autoRotate = !1,
                    this.autoRotateSpeed = 2,
                    this.keys = {
                        LEFT: 37,
                        UP: 38,
                        RIGHT: 39,
                        BOTTOM: 40
                    },
                    this.mouseButtons = {
                        LEFT: r.MOUSE.ROTATE,
                        MIDDLE: r.MOUSE.DOLLY,
                        RIGHT: r.MOUSE.PAN
                    },
                    this.touches = {
                        ONE: r.TOUCH.ROTATE,
                        TWO: r.TOUCH.DOLLY_PAN
                    },
                    this.target0 = this.target.clone(),
                    this.position0 = this.object.position.clone(),
                    this.zoom0 = this.object.zoom,
                    this._domElementKeyEvents = null,
                    this.getPolarAngle = function() {
                        return g.phi
                    }
                    ,
                    this.getAzimuthalAngle = function() {
                        return g.theta
                    }
                    ,
                    this.listenToKeyEvents = function(e) {
                        e.addEventListener("keydown", K),
                        this._domElementKeyEvents = e
                    }
                    ,
                    this.saveState = function() {
                        c.target0.copy(c.target),
                        c.position0.copy(c.object.position),
                        c.zoom0 = c.object.zoom
                    }
                    ,
                    this.reset = function() {
                        c.target.copy(c.target0),
                        c.object.position.copy(c.position0),
                        c.object.zoom = c.zoom0,
                        c.object.updateProjectionMatrix(),
                        c.dispatchEvent(u),
                        c.update(),
                        f = p.NONE
                    }
                    ,
                    this.update = (n = new r.Vector3,
                    i = (new r.Quaternion).setFromUnitVectors(e.up, new r.Vector3(0,1,0)),
                    a = i.clone().invert(),
                    o = new r.Vector3,
                    s = new r.Quaternion,
                    l = 2 * Math.PI,
                    function() {
                        var e = c.object.position;
                        n.copy(e).sub(c.target),
                        n.applyQuaternion(i),
                        g.setFromVector3(n),
                        c.autoRotate && f === p.NONE && L(2 * Math.PI / 60 / 60 * c.autoRotateSpeed),
                        c.enableDamping ? (g.theta += v.theta * c.dampingFactor,
                        g.phi += v.phi * c.dampingFactor) : (g.theta += v.theta,
                        g.phi += v.phi);
                        var t = c.minAzimuthAngle
                          , r = c.maxAzimuthAngle;
                        return isFinite(t) && isFinite(r) && (t < -Math.PI ? t += l : t > Math.PI && (t -= l),
                        r < -Math.PI ? r += l : r > Math.PI && (r -= l),
                        g.theta = t <= r ? Math.max(t, Math.min(r, g.theta)) : g.theta > (t + r) / 2 ? Math.max(t, g.theta) : Math.min(r, g.theta)),
                        g.phi = Math.max(c.minPolarAngle, Math.min(c.maxPolarAngle, g.phi)),
                        g.makeSafe(),
                        g.radius *= y,
                        g.radius = Math.max(c.minDistance, Math.min(c.maxDistance, g.radius)),
                        !0 === c.enableDamping ? c.target.addScaledVector(_, c.dampingFactor) : c.target.add(_),
                        n.setFromSpherical(g),
                        n.applyQuaternion(a),
                        e.copy(c.target).add(n),
                        c.object.lookAt(c.target),
                        !0 === c.enableDamping ? (v.theta *= 1 - c.dampingFactor,
                        v.phi *= 1 - c.dampingFactor,
                        _.multiplyScalar(1 - c.dampingFactor)) : (v.set(0, 0, 0),
                        _.set(0, 0, 0)),
                        y = 1,
                        !!(x || o.distanceToSquared(c.object.position) > m || 8 * (1 - s.dot(c.object.quaternion)) > m) && (c.dispatchEvent(u),
                        o.copy(c.object.position),
                        s.copy(c.object.quaternion),
                        x = !1,
                        !0)
                    }
                    ),
                    this.dispose = function() {
                        c.domElement.removeEventListener("contextmenu", te),
                        c.domElement.removeEventListener("pointerdown", X),
                        c.domElement.removeEventListener("wheel", J),
                        c.domElement.removeEventListener("touchstart", Q),
                        c.domElement.removeEventListener("touchend", ee),
                        c.domElement.removeEventListener("touchmove", $),
                        c.domElement.ownerDocument.removeEventListener("pointermove", Y),
                        c.domElement.ownerDocument.removeEventListener("pointerup", Z),
                        null !== c._domElementKeyEvents && c._domElementKeyEvents.removeEventListener("keydown", K)
                    }
                    ;
                    var c = this
                      , u = {
                        type: "change"
                    }
                      , h = {
                        type: "start"
                    }
                      , d = {
                        type: "end"
                    }
                      , p = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    }
                      , f = p.NONE
                      , m = 1e-6
                      , g = new r.Spherical
                      , v = new r.Spherical
                      , y = 1
                      , _ = new r.Vector3
                      , x = !1
                      , b = new r.Vector2
                      , w = new r.Vector2
                      , M = new r.Vector2
                      , S = new r.Vector2
                      , T = new r.Vector2
                      , E = new r.Vector2
                      , A = new r.Vector2
                      , C = new r.Vector2
                      , P = new r.Vector2;
                    function R() {
                        return Math.pow(.95, c.zoomSpeed)
                    }
                    function L(e) {
                        v.theta -= e
                    }
                    function D(e) {
                        v.phi -= e
                    }
                    var O, F = (O = new r.Vector3,
                    function(e, t) {
                        O.setFromMatrixColumn(t, 0),
                        O.multiplyScalar(-e),
                        _.add(O)
                    }
                    ), I = function() {
                        var e = new r.Vector3;
                        return function(t, n) {
                            !0 === c.screenSpacePanning ? e.setFromMatrixColumn(n, 1) : (e.setFromMatrixColumn(n, 0),
                            e.crossVectors(c.object.up, e)),
                            e.multiplyScalar(t),
                            _.add(e)
                        }
                    }(), N = function() {
                        var e = new r.Vector3;
                        return function(t, n) {
                            var r = c.domElement;
                            if (c.object.isPerspectiveCamera) {
                                var i = c.object.position;
                                e.copy(i).sub(c.target);
                                var a = e.length();
                                a *= Math.tan(c.object.fov / 2 * Math.PI / 180),
                                F(2 * t * a / r.clientHeight, c.object.matrix),
                                I(2 * n * a / r.clientHeight, c.object.matrix)
                            } else
                                c.object.isOrthographicCamera ? (F(t * (c.object.right - c.object.left) / c.object.zoom / r.clientWidth, c.object.matrix),
                                I(n * (c.object.top - c.object.bottom) / c.object.zoom / r.clientHeight, c.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                                c.enablePan = !1)
                        }
                    }();
                    function B(e) {
                        c.object.isPerspectiveCamera ? y /= e : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom * e)),
                        c.object.updateProjectionMatrix(),
                        x = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                        c.enableZoom = !1)
                    }
                    function k(e) {
                        c.object.isPerspectiveCamera ? y *= e : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom / e)),
                        c.object.updateProjectionMatrix(),
                        x = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                        c.enableZoom = !1)
                    }
                    function z(e) {
                        b.set(e.clientX, e.clientY)
                    }
                    function U(e) {
                        S.set(e.clientX, e.clientY)
                    }
                    function H(e) {
                        if (1 == e.touches.length)
                            b.set(e.touches[0].pageX, e.touches[0].pageY);
                        else {
                            var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                              , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                            b.set(t, n)
                        }
                    }
                    function G(e) {
                        if (1 == e.touches.length)
                            S.set(e.touches[0].pageX, e.touches[0].pageY);
                        else {
                            var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                              , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                            S.set(t, n)
                        }
                    }
                    function j(e) {
                        var t = e.touches[0].pageX - e.touches[1].pageX
                          , n = e.touches[0].pageY - e.touches[1].pageY
                          , r = Math.sqrt(t * t + n * n);
                        A.set(0, r)
                    }
                    function V(e) {
                        if (1 == e.touches.length)
                            w.set(e.touches[0].pageX, e.touches[0].pageY);
                        else {
                            var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                              , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                            w.set(t, n)
                        }
                        M.subVectors(w, b).multiplyScalar(c.rotateSpeed);
                        var r = c.domElement;
                        L(2 * Math.PI * M.x / r.clientHeight),
                        D(2 * Math.PI * M.y / r.clientHeight),
                        b.copy(w)
                    }
                    function W(e) {
                        if (1 == e.touches.length)
                            T.set(e.touches[0].pageX, e.touches[0].pageY);
                        else {
                            var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                              , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                            T.set(t, n)
                        }
                        E.subVectors(T, S).multiplyScalar(c.panSpeed),
                        N(E.x, E.y),
                        S.copy(T)
                    }
                    function q(e) {
                        var t = e.touches[0].pageX - e.touches[1].pageX
                          , n = e.touches[0].pageY - e.touches[1].pageY
                          , r = Math.sqrt(t * t + n * n);
                        C.set(0, r),
                        P.set(0, Math.pow(C.y / A.y, c.zoomSpeed)),
                        B(P.y),
                        A.copy(C)
                    }
                    function X(e) {
                        if (!1 !== c.enabled)
                            switch (e.pointerType) {
                            case "mouse":
                            case "pen":
                                !function(e) {
                                    var t;
                                    switch (e.preventDefault(),
                                    c.domElement.focus ? c.domElement.focus() : window.focus(),
                                    e.button) {
                                    case 0:
                                        t = c.mouseButtons.LEFT;
                                        break;
                                    case 1:
                                        t = c.mouseButtons.MIDDLE;
                                        break;
                                    case 2:
                                        t = c.mouseButtons.RIGHT;
                                        break;
                                    default:
                                        t = -1
                                    }
                                    switch (t) {
                                    case r.MOUSE.DOLLY:
                                        if (!1 === c.enableZoom)
                                            return;
                                        !function(e) {
                                            A.set(e.clientX, e.clientY)
                                        }(e),
                                        f = p.DOLLY;
                                        break;
                                    case r.MOUSE.ROTATE:
                                        if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                            if (!1 === c.enablePan)
                                                return;
                                            U(e),
                                            f = p.PAN
                                        } else {
                                            if (!1 === c.enableRotate)
                                                return;
                                            z(e),
                                            f = p.ROTATE
                                        }
                                        break;
                                    case r.MOUSE.PAN:
                                        if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                            if (!1 === c.enableRotate)
                                                return;
                                            z(e),
                                            f = p.ROTATE
                                        } else {
                                            if (!1 === c.enablePan)
                                                return;
                                            U(e),
                                            f = p.PAN
                                        }
                                        break;
                                    default:
                                        f = p.NONE
                                    }
                                    f !== p.NONE && (c.domElement.ownerDocument.addEventListener("pointermove", Y),
                                    c.domElement.ownerDocument.addEventListener("pointerup", Z),
                                    c.dispatchEvent(h))
                                }(e)
                            }
                    }
                    function Y(e) {
                        if (!1 !== c.enabled)
                            switch (e.pointerType) {
                            case "mouse":
                            case "pen":
                                !function(e) {
                                    if (!1 !== c.enabled)
                                        switch (e.preventDefault(),
                                        f) {
                                        case p.ROTATE:
                                            if (!1 === c.enableRotate)
                                                return;
                                            !function(e) {
                                                w.set(e.clientX, e.clientY),
                                                M.subVectors(w, b).multiplyScalar(c.rotateSpeed);
                                                var t = c.domElement;
                                                L(2 * Math.PI * M.x / t.clientHeight),
                                                D(2 * Math.PI * M.y / t.clientHeight),
                                                b.copy(w),
                                                c.update()
                                            }(e);
                                            break;
                                        case p.DOLLY:
                                            if (!1 === c.enableZoom)
                                                return;
                                            !function(e) {
                                                C.set(e.clientX, e.clientY),
                                                P.subVectors(C, A),
                                                P.y > 0 ? B(R()) : P.y < 0 && k(R()),
                                                A.copy(C),
                                                c.update()
                                            }(e);
                                            break;
                                        case p.PAN:
                                            if (!1 === c.enablePan)
                                                return;
                                            !function(e) {
                                                T.set(e.clientX, e.clientY),
                                                E.subVectors(T, S).multiplyScalar(c.panSpeed),
                                                N(E.x, E.y),
                                                S.copy(T),
                                                c.update()
                                            }(e)
                                        }
                                }(e)
                            }
                    }
                    function Z(e) {
                        switch (e.pointerType) {
                        case "mouse":
                        case "pen":
                            c.domElement.ownerDocument.removeEventListener("pointermove", Y),
                            c.domElement.ownerDocument.removeEventListener("pointerup", Z),
                            !1 !== c.enabled && (c.dispatchEvent(d),
                            f = p.NONE)
                        }
                    }
                    function J(e) {
                        !1 === c.enabled || !1 === c.enableZoom || f !== p.NONE && f !== p.ROTATE || (e.preventDefault(),
                        e.stopPropagation(),
                        c.dispatchEvent(h),
                        function(e) {
                            e.deltaY < 0 ? k(R()) : e.deltaY > 0 && B(R()),
                            c.update()
                        }(e),
                        c.dispatchEvent(d))
                    }
                    function K(e) {
                        !1 !== c.enabled && !1 !== c.enablePan && function(e) {
                            var t = !1;
                            switch (e.keyCode) {
                            case c.keys.UP:
                                N(0, c.keyPanSpeed),
                                t = !0;
                                break;
                            case c.keys.BOTTOM:
                                N(0, -c.keyPanSpeed),
                                t = !0;
                                break;
                            case c.keys.LEFT:
                                N(c.keyPanSpeed, 0),
                                t = !0;
                                break;
                            case c.keys.RIGHT:
                                N(-c.keyPanSpeed, 0),
                                t = !0
                            }
                            t && (e.preventDefault(),
                            c.update())
                        }(e)
                    }
                    function Q(e) {
                        if (!1 !== c.enabled) {
                            switch (e.preventDefault(),
                            e.touches.length) {
                            case 1:
                                switch (c.touches.ONE) {
                                case r.TOUCH.ROTATE:
                                    if (!1 === c.enableRotate)
                                        return;
                                    H(e),
                                    f = p.TOUCH_ROTATE;
                                    break;
                                case r.TOUCH.PAN:
                                    if (!1 === c.enablePan)
                                        return;
                                    G(e),
                                    f = p.TOUCH_PAN;
                                    break;
                                default:
                                    f = p.NONE
                                }
                                break;
                            case 2:
                                switch (c.touches.TWO) {
                                case r.TOUCH.DOLLY_PAN:
                                    if (!1 === c.enableZoom && !1 === c.enablePan)
                                        return;
                                    !function(e) {
                                        c.enableZoom && j(e),
                                        c.enablePan && G(e)
                                    }(e),
                                    f = p.TOUCH_DOLLY_PAN;
                                    break;
                                case r.TOUCH.DOLLY_ROTATE:
                                    if (!1 === c.enableZoom && !1 === c.enableRotate)
                                        return;
                                    !function(e) {
                                        c.enableZoom && j(e),
                                        c.enableRotate && H(e)
                                    }(e),
                                    f = p.TOUCH_DOLLY_ROTATE;
                                    break;
                                default:
                                    f = p.NONE
                                }
                                break;
                            default:
                                f = p.NONE
                            }
                            f !== p.NONE && c.dispatchEvent(h)
                        }
                    }
                    function $(e) {
                        if (!1 !== c.enabled)
                            switch (e.preventDefault(),
                            e.stopPropagation(),
                            f) {
                            case p.TOUCH_ROTATE:
                                if (!1 === c.enableRotate)
                                    return;
                                V(e),
                                c.update();
                                break;
                            case p.TOUCH_PAN:
                                if (!1 === c.enablePan)
                                    return;
                                W(e),
                                c.update();
                                break;
                            case p.TOUCH_DOLLY_PAN:
                                if (!1 === c.enableZoom && !1 === c.enablePan)
                                    return;
                                !function(e) {
                                    c.enableZoom && q(e),
                                    c.enablePan && W(e)
                                }(e),
                                c.update();
                                break;
                            case p.TOUCH_DOLLY_ROTATE:
                                if (!1 === c.enableZoom && !1 === c.enableRotate)
                                    return;
                                !function(e) {
                                    c.enableZoom && q(e),
                                    c.enableRotate && V(e)
                                }(e),
                                c.update();
                                break;
                            default:
                                f = p.NONE
                            }
                    }
                    function ee(e) {
                        !1 !== c.enabled && (c.dispatchEvent(d),
                        f = p.NONE)
                    }
                    function te(e) {
                        !1 !== c.enabled && e.preventDefault()
                    }
                    c.domElement.addEventListener("contextmenu", te),
                    c.domElement.addEventListener("pointerdown", X),
                    c.domElement.addEventListener("wheel", J),
                    c.domElement.addEventListener("touchstart", Q),
                    c.domElement.addEventListener("touchend", ee),
                    c.domElement.addEventListener("touchmove", $),
                    this.update()
                };
                i.prototype = Object.create(r.EventDispatcher.prototype),
                i.prototype.constructor = i;
                var a = function(e, t) {
                    i.call(this, e, t),
                    this.screenSpacePanning = !1,
                    this.mouseButtons.LEFT = r.MOUSE.PAN,
                    this.mouseButtons.RIGHT = r.MOUSE.ROTATE,
                    this.touches.ONE = r.TOUCH.PAN,
                    this.touches.TWO = r.TOUCH.DOLLY_ROTATE
                };
                a.prototype = Object.create(r.EventDispatcher.prototype),
                a.prototype.constructor = a
            }
            ,
            2509: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    GLTFExporter: ()=>c
                });
                var r = n(2212)
                  , i = 5121
                  , a = 5123
                  , o = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                  , s = {};
                s[r.NearestFilter] = 9728,
                s[r.NearestMipmapNearestFilter] = 9984,
                s[r.NearestMipmapLinearFilter] = 9986,
                s[r.LinearFilter] = 9729,
                s[r.LinearMipmapNearestFilter] = 9985,
                s[r.LinearMipmapLinearFilter] = 9987,
                s[r.ClampToEdgeWrapping] = 33071,
                s[r.RepeatWrapping] = 10497,
                s[r.MirroredRepeatWrapping] = 33648;
                var l = {
                    scale: "scale",
                    position: "translation",
                    quaternion: "rotation",
                    morphTargetInfluences: "weights"
                }
                  , c = function() {};
                c.prototype = {
                    constructor: c,
                    parse: function(e, t, n) {
                        (n = Object.assign({}, {
                            binary: !1,
                            trs: !1,
                            onlyVisible: !0,
                            truncateDrawRange: !0,
                            embedImages: !0,
                            maxTextureSize: 1 / 0,
                            animations: [],
                            includeCustomExtensions: !1
                        }, n)).animations.length > 0 && (n.trs = !0);
                        var u, h = {
                            asset: {
                                version: "2.0",
                                generator: "THREE.GLTFExporter"
                            }
                        }, d = 0, p = [], f = [], m = new Map, g = [], v = {}, y = {
                            meshes: new Map,
                            attributes: new Map,
                            attributesNormalized: new Map,
                            materials: new Map,
                            textures: new Map,
                            images: new Map
                        }, _ = new Map, x = 0;
                        function b(e) {
                            return _.has(e) || _.set(e, x++),
                            _.get(e)
                        }
                        function w(e, t) {
                            return e.length === t.length && e.every((function(e, n) {
                                return e === t[n]
                            }
                            ))
                        }
                        function M(e) {
                            return 4 * Math.ceil(e / 4)
                        }
                        function S(e, t) {
                            t = t || 0;
                            var n = M(e.byteLength);
                            if (n !== e.byteLength) {
                                var r = new Uint8Array(n);
                                if (r.set(new Uint8Array(e)),
                                0 !== t)
                                    for (var i = e.byteLength; i < n; i++)
                                        r[i] = t;
                                return r.buffer
                            }
                            return e
                        }
                        function T(e, t) {
                            if (0 !== Object.keys(e.userData).length)
                                try {
                                    var r = JSON.parse(JSON.stringify(e.userData));
                                    if (n.includeCustomExtensions && r.gltfExtensions) {
                                        for (var i in void 0 === t.extensions && (t.extensions = {}),
                                        r.gltfExtensions)
                                            t.extensions[i] = r.gltfExtensions[i],
                                            v[i] = !0;
                                        delete r.gltfExtensions
                                    }
                                    Object.keys(r).length > 0 && (t.extras = r)
                                } catch (t) {
                                    console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message)
                                }
                        }
                        function E(e, t) {
                            var n = !1
                              , r = {};
                            0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(),
                            n = !0),
                            0 !== t.rotation && (r.rotation = t.rotation,
                            n = !0),
                            1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(),
                            n = !0),
                            n && (e.extensions = e.extensions || {},
                            e.extensions.KHR_texture_transform = r,
                            v.KHR_texture_transform = !0)
                        }
                        function A(e) {
                            return h.buffers || (h.buffers = [{
                                byteLength: 0
                            }]),
                            p.push(e),
                            0
                        }
                        function C(e, t, r, o) {
                            var s;
                            if (e.array.constructor === Float32Array)
                                s = 5126;
                            else if (e.array.constructor === Uint32Array)
                                s = 5125;
                            else if (e.array.constructor === Uint16Array)
                                s = a;
                            else {
                                if (e.array.constructor !== Uint8Array)
                                    throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
                                s = i
                            }
                            if (void 0 === r && (r = 0),
                            void 0 === o && (o = e.count),
                            n.truncateDrawRange && void 0 !== t && null === t.index) {
                                var l = r + o
                                  , c = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count;
                                r = Math.max(r, t.drawRange.start),
                                (o = Math.min(l, c) - r) < 0 && (o = 0)
                            }
                            if (0 === o)
                                return null;
                            var u, p = function(e, t, n) {
                                for (var r = {
                                    min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
                                    max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
                                }, i = t; i < t + n; i++)
                                    for (var a = 0; a < e.itemSize; a++) {
                                        var o;
                                        e.itemSize > 4 ? o = e.array[i * e.itemSize + a] : 0 === a ? o = e.getX(i) : 1 === a ? o = e.getY(i) : 2 === a ? o = e.getZ(i) : 3 === a && (o = e.getW(i)),
                                        r.min[a] = Math.min(r.min[a], o),
                                        r.max[a] = Math.max(r.max[a], o)
                                    }
                                return r
                            }(e, r, o);
                            void 0 !== t && (u = e === t.index ? 34963 : 34962);
                            var f = function(e, t, n, r, o) {
                                var s;
                                h.bufferViews || (h.bufferViews = []),
                                s = t === i ? 1 : t === a ? 2 : 4;
                                for (var l = M(r * e.itemSize * s), c = new DataView(new ArrayBuffer(l)), u = 0, p = n; p < n + r; p++)
                                    for (var f = 0; f < e.itemSize; f++) {
                                        var m;
                                        e.itemSize > 4 ? m = e.array[p * e.itemSize + f] : 0 === f ? m = e.getX(p) : 1 === f ? m = e.getY(p) : 2 === f ? m = e.getZ(p) : 3 === f && (m = e.getW(p)),
                                        5126 === t ? c.setFloat32(u, m, !0) : 5125 === t ? c.setUint32(u, m, !0) : t === a ? c.setUint16(u, m, !0) : t === i && c.setUint8(u, m),
                                        u += s
                                    }
                                var g = {
                                    buffer: A(c.buffer),
                                    byteOffset: d,
                                    byteLength: l
                                };
                                return void 0 !== o && (g.target = o),
                                34962 === o && (g.byteStride = e.itemSize * s),
                                d += l,
                                h.bufferViews.push(g),
                                {
                                    id: h.bufferViews.length - 1,
                                    byteLength: 0
                                }
                            }(e, s, r, o, u)
                              , m = {
                                bufferView: f.id,
                                byteOffset: f.byteOffset,
                                componentType: s,
                                count: o,
                                max: p.max,
                                min: p.min,
                                type: {
                                    1: "SCALAR",
                                    2: "VEC2",
                                    3: "VEC3",
                                    4: "VEC4",
                                    16: "MAT4"
                                }[e.itemSize]
                            };
                            return !0 === e.normalized && (m.normalized = !0),
                            h.accessors || (h.accessors = []),
                            h.accessors.push(m),
                            h.accessors.length - 1
                        }
                        function P(e, t, i) {
                            y.images.has(e) || y.images.set(e, {});
                            var a = y.images.get(e)
                              , o = t === r.RGBAFormat ? "image/png" : "image/jpeg"
                              , s = o + ":flipY/" + i.toString();
                            if (void 0 !== a[s])
                                return a[s];
                            h.images || (h.images = []);
                            var l = {
                                mimeType: o
                            };
                            if (n.embedImages) {
                                var c = u = u || document.createElement("canvas");
                                c.width = Math.min(e.width, n.maxTextureSize),
                                c.height = Math.min(e.height, n.maxTextureSize);
                                var p = c.getContext("2d");
                                if (!0 === i && (p.translate(0, c.height),
                                p.scale(1, -1)),
                                "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
                                    p.drawImage(e, 0, 0, c.width, c.height);
                                else {
                                    t !== r.RGBAFormat && t !== r.RGBFormat && console.error("GLTFExporter: Only RGB and RGBA formats are supported."),
                                    (e.width > n.maxTextureSize || e.height > n.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                                    let i = e.data;
                                    if (t === r.RGBFormat) {
                                        i = new Uint8ClampedArray(e.height * e.width * 4);
                                        for (var m = 0, g = 0; m < i.length; m += 4,
                                        g += 3)
                                            i[m + 0] = e.data[g + 0],
                                            i[m + 1] = e.data[g + 1],
                                            i[m + 2] = e.data[g + 2],
                                            i[m + 3] = 255
                                    }
                                    p.putImageData(new ImageData(i,e.width,e.height), 0, 0)
                                }
                                !0 === n.binary ? f.push(new Promise((function(e) {
                                    c.toBlob((function(t) {
                                        (function(e) {
                                            return h.bufferViews || (h.bufferViews = []),
                                            new Promise((function(t) {
                                                var n = new window.FileReader;
                                                n.readAsArrayBuffer(e),
                                                n.onloadend = function() {
                                                    var e = S(n.result)
                                                      , r = {
                                                        buffer: A(e),
                                                        byteOffset: d,
                                                        byteLength: e.byteLength
                                                    };
                                                    d += e.byteLength,
                                                    h.bufferViews.push(r),
                                                    t(h.bufferViews.length - 1)
                                                }
                                            }
                                            ))
                                        }
                                        )(t).then((function(t) {
                                            l.bufferView = t,
                                            e()
                                        }
                                        ))
                                    }
                                    ), o)
                                }
                                ))) : l.uri = c.toDataURL(o)
                            } else
                                l.uri = e.src;
                            h.images.push(l);
                            var v = h.images.length - 1;
                            return a[s] = v,
                            v
                        }
                        function R(e) {
                            h.samplers || (h.samplers = []);
                            var t = {
                                magFilter: s[e.magFilter],
                                minFilter: s[e.minFilter],
                                wrapS: s[e.wrapS],
                                wrapT: s[e.wrapT]
                            };
                            return h.samplers.push(t),
                            h.samplers.length - 1
                        }
                        function L(e) {
                            if (y.textures.has(e))
                                return y.textures.get(e);
                            h.textures || (h.textures = []);
                            var t = {
                                sampler: R(e),
                                source: P(e.image, e.format, e.flipY)
                            };
                            e.name && (t.name = e.name),
                            h.textures.push(t);
                            var n = h.textures.length - 1;
                            return y.textures.set(e, n),
                            n
                        }
                        function D(e) {
                            if (y.materials.has(e))
                                return y.materials.get(e);
                            if (e.isShaderMaterial)
                                return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),
                                null;
                            h.materials || (h.materials = []);
                            var t = {
                                pbrMetallicRoughness: {}
                            };
                            e.isMeshBasicMaterial ? (t.extensions = {
                                KHR_materials_unlit: {}
                            },
                            v.KHR_materials_unlit = !0) : e.isGLTFSpecularGlossinessMaterial ? (t.extensions = {
                                KHR_materials_pbrSpecularGlossiness: {}
                            },
                            v.KHR_materials_pbrSpecularGlossiness = !0) : e.isMeshStandardMaterial || console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
                            var n = e.color.toArray().concat([e.opacity]);
                            if (w(n, [1, 1, 1, 1]) || (t.pbrMetallicRoughness.baseColorFactor = n),
                            e.isMeshStandardMaterial ? (t.pbrMetallicRoughness.metallicFactor = e.metalness,
                            t.pbrMetallicRoughness.roughnessFactor = e.roughness) : e.isMeshBasicMaterial ? (t.pbrMetallicRoughness.metallicFactor = 0,
                            t.pbrMetallicRoughness.roughnessFactor = .9) : (t.pbrMetallicRoughness.metallicFactor = .5,
                            t.pbrMetallicRoughness.roughnessFactor = .5),
                            e.isGLTFSpecularGlossinessMaterial) {
                                t.pbrMetallicRoughness.baseColorFactor && (t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
                                var i = [1, 1, 1];
                                e.specular.toArray(i, 0),
                                t.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = i,
                                t.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = e.glossiness
                            }
                            if (e.metalnessMap || e.roughnessMap)
                                if (e.metalnessMap === e.roughnessMap) {
                                    var a = {
                                        index: L(e.metalnessMap)
                                    };
                                    E(a, e.metalnessMap),
                                    t.pbrMetallicRoughness.metallicRoughnessTexture = a
                                } else
                                    console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
                            if (e.map) {
                                var o = {
                                    index: L(e.map)
                                };
                                E(o, e.map),
                                e.isGLTFSpecularGlossinessMaterial && (t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = o),
                                t.pbrMetallicRoughness.baseColorTexture = o
                            }
                            if (e.isGLTFSpecularGlossinessMaterial && e.specularMap) {
                                var s = {
                                    index: L(e.specularMap)
                                };
                                E(s, e.specularMap),
                                t.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = s
                            }
                            if (e.emissive) {
                                var l = e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray();
                                if (w(l, [0, 0, 0]) || (t.emissiveFactor = l),
                                e.emissiveMap) {
                                    var c = {
                                        index: L(e.emissiveMap)
                                    };
                                    E(c, e.emissiveMap),
                                    t.emissiveTexture = c
                                }
                            }
                            if (e.normalMap) {
                                var u = {
                                    index: L(e.normalMap)
                                };
                                e.normalScale && -1 !== e.normalScale.x && (e.normalScale.x !== e.normalScale.y && console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."),
                                u.scale = e.normalScale.x),
                                E(u, e.normalMap),
                                t.normalTexture = u
                            }
                            if (e.aoMap) {
                                var d = {
                                    index: L(e.aoMap),
                                    texCoord: 1
                                };
                                1 !== e.aoMapIntensity && (d.strength = e.aoMapIntensity),
                                E(d, e.aoMap),
                                t.occlusionTexture = d
                            }
                            e.transparent ? t.alphaMode = "BLEND" : e.alphaTest > 0 && (t.alphaMode = "MASK",
                            t.alphaCutoff = e.alphaTest),
                            e.side === r.DoubleSide && (t.doubleSided = !0),
                            "" !== e.name && (t.name = e.name),
                            T(e, t),
                            h.materials.push(t);
                            var p = h.materials.length - 1;
                            return y.materials.set(e, p),
                            p
                        }
                        function O(e, t) {
                            h.animations || (h.animations = []);
                            for (var n = (e = c.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks, i = [], a = [], o = 0; o < n.length; ++o) {
                                var s = n[o]
                                  , u = r.PropertyBinding.parseTrackName(s.name)
                                  , d = r.PropertyBinding.findNode(t, u.nodeName)
                                  , p = l[u.propertyName];
                                if ("bones" === u.objectName && (d = !0 === d.isSkinnedMesh ? d.skeleton.getBoneByName(u.objectIndex) : void 0),
                                !d || !p)
                                    return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', s.name),
                                    null;
                                var f, g = s.values.length / s.times.length;
                                p === l.morphTargetInfluences && (g /= d.morphTargetInfluences.length),
                                !0 === s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (f = "CUBICSPLINE",
                                g /= 3) : f = s.getInterpolation() === r.InterpolateDiscrete ? "STEP" : "LINEAR",
                                a.push({
                                    input: C(new r.BufferAttribute(s.times,1)),
                                    output: C(new r.BufferAttribute(s.values,g)),
                                    interpolation: f
                                }),
                                i.push({
                                    sampler: a.length - 1,
                                    target: {
                                        node: m.get(d),
                                        path: p
                                    }
                                })
                            }
                            return h.animations.push({
                                name: e.name || "clip_" + h.animations.length,
                                samplers: a,
                                channels: i
                            }),
                            h.animations.length - 1
                        }
                        function F(e) {
                            var t = h.nodes[m.get(e)]
                              , n = e.skeleton;
                            if (void 0 === n)
                                return null;
                            var i = e.skeleton.bones[0];
                            if (void 0 === i)
                                return null;
                            for (var a = [], o = new Float32Array(16 * n.bones.length), s = new r.Matrix4, l = 0; l < n.bones.length; ++l)
                                a.push(m.get(n.bones[l])),
                                s.copy(n.boneInverses[l]),
                                s.multiply(e.bindMatrix).toArray(o, 16 * l);
                            return void 0 === h.skins && (h.skins = []),
                            h.skins.push({
                                inverseBindMatrices: C(new r.BufferAttribute(o,16)),
                                joints: a,
                                skeleton: m.get(i)
                            }),
                            t.skin = h.skins.length - 1
                        }
                        function I(e) {
                            var t = {};
                            e.name && (t.name = e.name),
                            t.color = e.color.toArray(),
                            t.intensity = e.intensity,
                            e.isDirectionalLight ? t.type = "directional" : e.isPointLight ? (t.type = "point",
                            e.distance > 0 && (t.range = e.distance)) : e.isSpotLight && (t.type = "spot",
                            e.distance > 0 && (t.range = e.distance),
                            t.spot = {},
                            t.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1,
                            t.spot.outerConeAngle = e.angle),
                            void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),
                            !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
                            var n = h.extensions.KHR_lights_punctual.lights;
                            return n.push(t),
                            n.length - 1
                        }
                        function N(e) {
                            h.nodes || (h.nodes = []);
                            var t = {};
                            if (n.trs) {
                                var i = e.quaternion.toArray()
                                  , a = e.position.toArray()
                                  , s = e.scale.toArray();
                                w(i, [0, 0, 0, 1]) || (t.rotation = i),
                                w(a, [0, 0, 0]) || (t.translation = a),
                                w(s, [1, 1, 1]) || (t.scale = s)
                            } else
                                e.matrixAutoUpdate && e.updateMatrix(),
                                !1 === w(e.matrix.elements, o) && (t.matrix = e.matrix.elements);
                            if ("" !== e.name && (t.name = String(e.name)),
                            T(e, t),
                            e.isMesh || e.isLine || e.isPoints) {
                                var l = function(e) {
                                    var t = [e.geometry.uuid];
                                    if (Array.isArray(e.material))
                                        for (var n = 0, i = e.material.length; n < i; n++)
                                            t.push(e.material[n].uuid);
                                    else
                                        t.push(e.material.uuid);
                                    var a = t.join(":");
                                    if (y.meshes.has(a))
                                        return y.meshes.get(a);
                                    var o, s = e.geometry;
                                    if (o = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4,
                                    !0 !== s.isBufferGeometry)
                                        throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
                                    var l = {}
                                      , c = {}
                                      , u = []
                                      , d = []
                                      , p = {
                                        uv: "TEXCOORD_0",
                                        uv2: "TEXCOORD_1",
                                        color: "COLOR_0",
                                        skinWeight: "WEIGHTS_0",
                                        skinIndex: "JOINTS_0"
                                    }
                                      , f = s.getAttribute("normal");
                                    void 0 === f || function(e) {
                                        if (y.attributesNormalized.has(e))
                                            return !1;
                                        for (var t = new r.Vector3, n = 0, i = e.count; n < i; n++)
                                            if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4)
                                                return !1;
                                        return !0
                                    }(f) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),
                                    s.setAttribute("normal", function(e) {
                                        if (y.attributesNormalized.has(e))
                                            return y.attributesNormalized.get(e);
                                        for (var t = e.clone(), n = new r.Vector3, i = 0, a = t.count; i < a; i++)
                                            n.fromBufferAttribute(t, i),
                                            0 === n.x && 0 === n.y && 0 === n.z ? n.setX(1) : n.normalize(),
                                            t.setXYZ(i, n.x, n.y, n.z);
                                        return y.attributesNormalized.set(e, t),
                                        t
                                    }(f)));
                                    var m = null;
                                    for (var g in s.attributes)
                                        if ("morph" !== g.substr(0, 5)) {
                                            var v = s.attributes[g];
                                            if (g = p[g] || g.toUpperCase(),
                                            /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(g) || (g = "_" + g),
                                            y.attributes.has(b(v)))
                                                c[g] = y.attributes.get(b(v));
                                            else {
                                                m = null;
                                                var _ = v.array;
                                                "JOINTS_0" !== g || _ instanceof Uint16Array || _ instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),
                                                m = new r.BufferAttribute(new Uint16Array(_),v.itemSize,v.normalized));
                                                var x = C(m || v, s);
                                                null !== x && (c[g] = x,
                                                y.attributes.set(b(v), x))
                                            }
                                        }
                                    if (void 0 !== f && s.setAttribute("normal", f),
                                    0 === Object.keys(c).length)
                                        return null;
                                    if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
                                        var w = []
                                          , M = []
                                          , S = {};
                                        if (void 0 !== e.morphTargetDictionary)
                                            for (var E in e.morphTargetDictionary)
                                                S[e.morphTargetDictionary[E]] = E;
                                        for (n = 0; n < e.morphTargetInfluences.length; ++n) {
                                            var A = {}
                                              , P = !1;
                                            for (var g in s.morphAttributes)
                                                if ("position" === g || "normal" === g) {
                                                    v = s.morphAttributes[g][n];
                                                    var R = g.toUpperCase()
                                                      , L = s.attributes[g];
                                                    if (y.attributes.has(b(v)))
                                                        A[R] = y.attributes.get(b(v));
                                                    else {
                                                        var O = v.clone();
                                                        if (!s.morphTargetsRelative)
                                                            for (var F = 0, I = v.count; F < I; F++)
                                                                O.setXYZ(F, v.getX(F) - L.getX(F), v.getY(F) - L.getY(F), v.getZ(F) - L.getZ(F));
                                                        A[R] = C(O, s),
                                                        y.attributes.set(b(L), A[R])
                                                    }
                                                } else
                                                    P || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),
                                                    P = !0);
                                            d.push(A),
                                            w.push(e.morphTargetInfluences[n]),
                                            void 0 !== e.morphTargetDictionary && M.push(S[n])
                                        }
                                        l.weights = w,
                                        M.length > 0 && (l.extras = {},
                                        l.extras.targetNames = M)
                                    }
                                    var N = Array.isArray(e.material);
                                    if (N && 0 === s.groups.length)
                                        return null;
                                    for (var B = N ? e.material : [e.material], k = N ? s.groups : [{
                                        materialIndex: 0,
                                        start: void 0,
                                        count: void 0
                                    }], z = (n = 0,
                                    k.length); n < z; n++) {
                                        var U = {
                                            mode: o,
                                            attributes: c
                                        };
                                        if (T(s, U),
                                        d.length > 0 && (U.targets = d),
                                        null !== s.index) {
                                            var H = b(s.index);
                                            void 0 === k[n].start && void 0 === k[n].count || (H += ":" + k[n].start + ":" + k[n].count),
                                            y.attributes.has(H) ? U.indices = y.attributes.get(H) : (U.indices = C(s.index, s, k[n].start, k[n].count),
                                            y.attributes.set(H, U.indices)),
                                            null === U.indices && delete U.indices
                                        }
                                        var G = D(B[k[n].materialIndex]);
                                        null !== G && (U.material = G),
                                        u.push(U)
                                    }
                                    l.primitives = u,
                                    h.meshes || (h.meshes = []),
                                    h.meshes.push(l);
                                    var j = h.meshes.length - 1;
                                    return y.meshes.set(a, j),
                                    j
                                }(e);
                                null !== l && (t.mesh = l)
                            } else if (e.isCamera)
                                t.camera = function(e) {
                                    h.cameras || (h.cameras = []);
                                    var t = e.isOrthographicCamera
                                      , n = {
                                        type: t ? "orthographic" : "perspective"
                                    };
                                    return t ? n.orthographic = {
                                        xmag: 2 * e.right,
                                        ymag: 2 * e.top,
                                        zfar: e.far <= 0 ? .001 : e.far,
                                        znear: e.near < 0 ? 0 : e.near
                                    } : n.perspective = {
                                        aspectRatio: e.aspect,
                                        yfov: r.MathUtils.degToRad(e.fov),
                                        zfar: e.far <= 0 ? .001 : e.far,
                                        znear: e.near < 0 ? 0 : e.near
                                    },
                                    "" !== e.name && (n.name = e.type),
                                    h.cameras.push(n),
                                    h.cameras.length - 1
                                }(e);
                            else if (e.isDirectionalLight || e.isPointLight || e.isSpotLight)
                                v.KHR_lights_punctual || (h.extensions = h.extensions || {},
                                h.extensions.KHR_lights_punctual = {
                                    lights: []
                                },
                                v.KHR_lights_punctual = !0),
                                t.extensions = t.extensions || {},
                                t.extensions.KHR_lights_punctual = {
                                    light: I(e)
                                };
                            else if (e.isLight)
                                return console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e),
                                null;
                            if (e.isSkinnedMesh && g.push(e),
                            e.children.length > 0) {
                                for (var c = [], u = 0, d = e.children.length; u < d; u++) {
                                    var p = e.children[u];
                                    if (p.visible || !1 === n.onlyVisible) {
                                        var f = N(p);
                                        null !== f && c.push(f)
                                    }
                                }
                                c.length > 0 && (t.children = c)
                            }
                            h.nodes.push(t);
                            var _ = h.nodes.length - 1;
                            return m.set(e, _),
                            _
                        }
                        function B(e) {
                            h.scenes || (h.scenes = [],
                            h.scene = 0);
                            var t = {};
                            "" !== e.name && (t.name = e.name),
                            h.scenes.push(t);
                            for (var r = [], i = 0, a = e.children.length; i < a; i++) {
                                var o = e.children[i];
                                if (o.visible || !1 === n.onlyVisible) {
                                    var s = N(o);
                                    null !== s && r.push(s)
                                }
                            }
                            r.length > 0 && (t.nodes = r),
                            T(e, t)
                        }
                        !function(e) {
                            e = e instanceof Array ? e : [e];
                            for (var t = [], i = 0; i < e.length; i++)
                                e[i]instanceof r.Scene ? B(e[i]) : t.push(e[i]);
                            for (t.length > 0 && function(e) {
                                var t = new r.Scene;
                                t.name = "AuxScene";
                                for (var n = 0; n < e.length; n++)
                                    t.children.push(e[n]);
                                B(t)
                            }(t),
                            i = 0; i < g.length; ++i)
                                F(g[i]);
                            for (i = 0; i < n.animations.length; ++i)
                                O(n.animations[i], e[0])
                        }(e),
                        Promise.all(f).then((function() {
                            var e, r = new Blob(p,{
                                type: "application/octet-stream"
                            }), i = Object.keys(v);
                            (i.length > 0 && (h.extensionsUsed = i),
                            h.buffers && h.buffers.length > 0 && (h.buffers[0].byteLength = r.size),
                            !0 === n.binary) ? ((e = new window.FileReader).readAsArrayBuffer(r),
                            e.onloadend = function() {
                                var n = S(e.result)
                                  , r = new DataView(new ArrayBuffer(8));
                                r.setUint32(0, n.byteLength, !0),
                                r.setUint32(4, 5130562, !0);
                                var i = S(function(e) {
                                    if (void 0 !== window.TextEncoder)
                                        return (new TextEncoder).encode(e).buffer;
                                    for (var t = new Uint8Array(new ArrayBuffer(e.length)), n = 0, r = e.length; n < r; n++) {
                                        var i = e.charCodeAt(n);
                                        t[n] = i > 255 ? 32 : i
                                    }
                                    return t.buffer
                                }(JSON.stringify(h)), 32)
                                  , a = new DataView(new ArrayBuffer(8));
                                a.setUint32(0, i.byteLength, !0),
                                a.setUint32(4, 1313821514, !0);
                                var o = new ArrayBuffer(12)
                                  , s = new DataView(o);
                                s.setUint32(0, 1179937895, !0),
                                s.setUint32(4, 2, !0);
                                var l = 12 + a.byteLength + i.byteLength + r.byteLength + n.byteLength;
                                s.setUint32(8, l, !0);
                                var c = new Blob([o, a, i, r, n],{
                                    type: "application/octet-stream"
                                })
                                  , u = new window.FileReader;
                                u.readAsArrayBuffer(c),
                                u.onloadend = function() {
                                    t(u.result)
                                }
                            }
                            ) : h.buffers && h.buffers.length > 0 ? ((e = new window.FileReader).readAsDataURL(r),
                            e.onloadend = function() {
                                var n = e.result;
                                h.buffers[0].uri = n,
                                t(h)
                            }
                            ) : t(h)
                        }
                        ))
                    }
                },
                c.Utils = {
                    insertKeyframe: function(e, t) {
                        var n, r = .001, i = e.getValueSize(), a = new e.TimeBufferType(e.times.length + 1), o = new e.ValueBufferType(e.values.length + i), s = e.createInterpolant(new e.ValueBufferType(i));
                        if (0 === e.times.length) {
                            a[0] = t;
                            for (var l = 0; l < i; l++)
                                o[l] = 0;
                            n = 0
                        } else if (t < e.times[0]) {
                            if (Math.abs(e.times[0] - t) < r)
                                return 0;
                            a[0] = t,
                            a.set(e.times, 1),
                            o.set(s.evaluate(t), 0),
                            o.set(e.values, i),
                            n = 0
                        } else if (t > e.times[e.times.length - 1]) {
                            if (Math.abs(e.times[e.times.length - 1] - t) < r)
                                return e.times.length - 1;
                            a[a.length - 1] = t,
                            a.set(e.times, 0),
                            o.set(e.values, 0),
                            o.set(s.evaluate(t), e.values.length),
                            n = a.length - 1
                        } else
                            for (l = 0; l < e.times.length; l++) {
                                if (Math.abs(e.times[l] - t) < r)
                                    return l;
                                if (e.times[l] < t && e.times[l + 1] > t) {
                                    a.set(e.times.slice(0, l + 1), 0),
                                    a[l + 1] = t,
                                    a.set(e.times.slice(l + 1), l + 2),
                                    o.set(e.values.slice(0, (l + 1) * i), 0),
                                    o.set(s.evaluate(t), (l + 1) * i),
                                    o.set(e.values.slice((l + 1) * i), (l + 2) * i),
                                    n = l + 1;
                                    break
                                }
                            }
                        return e.times = a,
                        e.values = o,
                        n
                    },
                    mergeMorphTargetTracks: function(e, t) {
                        for (var n = [], i = {}, a = e.tracks, o = 0; o < a.length; ++o) {
                            var s = a[o]
                              , l = r.PropertyBinding.parseTrackName(s.name)
                              , c = r.PropertyBinding.findNode(t, l.nodeName);
                            if ("morphTargetInfluences" === l.propertyName && void 0 !== l.propertyIndex) {
                                if (s.createInterpolant !== s.InterpolantFactoryMethodDiscrete && s.createInterpolant !== s.InterpolantFactoryMethodLinear) {
                                    if (s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                                        throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                                    console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),
                                    (s = s.clone()).setInterpolation(r.InterpolateLinear)
                                }
                                var u, h = c.morphTargetInfluences.length, d = c.morphTargetDictionary[l.propertyIndex];
                                if (void 0 === d)
                                    throw new Error("THREE.GLTFExporter: Morph target name not found: " + l.propertyIndex);
                                if (void 0 !== i[c.uuid]) {
                                    var p = s.createInterpolant(new s.ValueBufferType(1));
                                    for (u = i[c.uuid],
                                    g = 0; g < u.times.length; g++)
                                        u.values[g * h + d] = p.evaluate(u.times[g]);
                                    for (g = 0; g < s.times.length; g++) {
                                        var f = this.insertKeyframe(u, s.times[g]);
                                        u.values[f * h + d] = s.values[g]
                                    }
                                } else {
                                    for (var m = new ((u = s.clone()).ValueBufferType)(h * u.times.length), g = 0; g < u.times.length; g++)
                                        m[g * h + d] = u.values[g];
                                    u.name = (l.nodeName || "") + ".morphTargetInfluences",
                                    u.values = m,
                                    i[c.uuid] = u,
                                    n.push(u)
                                }
                            } else
                                n.push(s)
                        }
                        return e.tracks = n,
                        e
                    }
                }
            }
            ,
            338: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    DRACOLoader: ()=>i
                });
                var r = n(2212)
                  , i = function(e) {
                    r.Loader.call(this, e),
                    this.decoderPath = "",
                    this.decoderConfig = {},
                    this.decoderBinary = null,
                    this.decoderPending = null,
                    this.workerLimit = 4,
                    this.workerPool = [],
                    this.workerNextTaskID = 1,
                    this.workerSourceURL = "",
                    this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD"
                    },
                    this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array"
                    }
                };
                i.prototype = Object.assign(Object.create(r.Loader.prototype), {
                    constructor: i,
                    setDecoderPath: function(e) {
                        return this.decoderPath = e,
                        this
                    },
                    setDecoderConfig: function(e) {
                        return this.decoderConfig = e,
                        this
                    },
                    setWorkerLimit: function(e) {
                        return this.workerLimit = e,
                        this
                    },
                    setVerbosity: function() {
                        console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.")
                    },
                    setDrawMode: function() {
                        console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.")
                    },
                    setSkipDequantization: function() {
                        console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.")
                    },
                    load: function(e, t, n, i) {
                        var a = new r.FileLoader(this.manager);
                        a.setPath(this.path),
                        a.setResponseType("arraybuffer"),
                        a.setRequestHeader(this.requestHeader),
                        a.setWithCredentials(this.withCredentials),
                        a.load(e, (e=>{
                            var n = {
                                attributeIDs: this.defaultAttributeIDs,
                                attributeTypes: this.defaultAttributeTypes,
                                useUniqueIDs: !1
                            };
                            this.decodeGeometry(e, n).then(t).catch(i)
                        }
                        ), n, i)
                    },
                    decodeDracoFile: function(e, t, n, r) {
                        var i = {
                            attributeIDs: n || this.defaultAttributeIDs,
                            attributeTypes: r || this.defaultAttributeTypes,
                            useUniqueIDs: !!n
                        };
                        this.decodeGeometry(e, i).then(t)
                    },
                    decodeGeometry: function(e, t) {
                        for (var n in t.attributeTypes) {
                            var r = t.attributeTypes[n];
                            void 0 !== r.BYTES_PER_ELEMENT && (t.attributeTypes[n] = r.name)
                        }
                        var a, o = JSON.stringify(t);
                        if (i.taskCache.has(e)) {
                            var s = i.taskCache.get(e);
                            if (s.key === o)
                                return s.promise;
                            if (0 === e.byteLength)
                                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                        }
                        var l = this.workerNextTaskID++
                          , c = e.byteLength
                          , u = this._getWorker(l, c).then((n=>(a = n,
                        new Promise(((n,r)=>{
                            a._callbacks[l] = {
                                resolve: n,
                                reject: r
                            },
                            a.postMessage({
                                type: "decode",
                                id: l,
                                taskConfig: t,
                                buffer: e
                            }, [e])
                        }
                        ))))).then((e=>this._createGeometry(e.geometry)));
                        return u.catch((()=>!0)).then((()=>{
                            a && l && this._releaseTask(a, l)
                        }
                        )),
                        i.taskCache.set(e, {
                            key: o,
                            promise: u
                        }),
                        u
                    },
                    _createGeometry: function(e) {
                        var t = new r.BufferGeometry;
                        e.index && t.setIndex(new r.BufferAttribute(e.index.array,1));
                        for (var n = 0; n < e.attributes.length; n++) {
                            var i = e.attributes[n]
                              , a = i.name
                              , o = i.array
                              , s = i.itemSize;
                            t.setAttribute(a, new r.BufferAttribute(o,s))
                        }
                        return t
                    },
                    _loadLibrary: function(e, t) {
                        var n = new r.FileLoader(this.manager);
                        return n.setPath(this.decoderPath),
                        n.setResponseType(t),
                        n.setWithCredentials(this.withCredentials),
                        new Promise(((t,r)=>{
                            n.load(e, t, void 0, r)
                        }
                        ))
                    },
                    preload: function() {
                        return this._initDecoder(),
                        this
                    },
                    _initDecoder: function() {
                        if (this.decoderPending)
                            return this.decoderPending;
                        var e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                          , t = [];
                        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                        t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                        this.decoderPending = Promise.all(t).then((t=>{
                            var n = t[0];
                            e || (this.decoderConfig.wasmBinary = t[1]);
                            var r = i.DRACOWorker.toString()
                              , a = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                            this.workerSourceURL = URL.createObjectURL(new Blob([a]))
                        }
                        )),
                        this.decoderPending
                    },
                    _getWorker: function(e, t) {
                        return this._initDecoder().then((()=>{
                            var n;
                            return this.workerPool.length < this.workerLimit ? ((n = new Worker(this.workerSourceURL))._callbacks = {},
                            n._taskCosts = {},
                            n._taskLoad = 0,
                            n.postMessage({
                                type: "init",
                                decoderConfig: this.decoderConfig
                            }),
                            n.onmessage = function(e) {
                                var t = e.data;
                                switch (t.type) {
                                case "decode":
                                    n._callbacks[t.id].resolve(t);
                                    break;
                                case "error":
                                    n._callbacks[t.id].reject(t);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"')
                                }
                            }
                            ,
                            this.workerPool.push(n)) : this.workerPool.sort((function(e, t) {
                                return e._taskLoad > t._taskLoad ? -1 : 1
                            }
                            )),
                            (n = this.workerPool[this.workerPool.length - 1])._taskCosts[e] = t,
                            n._taskLoad += t,
                            n
                        }
                        ))
                    },
                    _releaseTask: function(e, t) {
                        e._taskLoad -= e._taskCosts[t],
                        delete e._callbacks[t],
                        delete e._taskCosts[t]
                    },
                    debug: function() {
                        console.log("Task load: ", this.workerPool.map((e=>e._taskLoad)))
                    },
                    dispose: function() {
                        for (var e = 0; e < this.workerPool.length; ++e)
                            this.workerPool[e].terminate();
                        return this.workerPool.length = 0,
                        this
                    }
                }),
                i.DRACOWorker = function() {
                    var e, t;
                    function n(e, t, n, r, i, a) {
                        var o = a.num_components()
                          , s = n.num_points() * o
                          , l = s * i.BYTES_PER_ELEMENT
                          , c = function(e, t) {
                            switch (t) {
                            case Float32Array:
                                return e.DT_FLOAT32;
                            case Int8Array:
                                return e.DT_INT8;
                            case Int16Array:
                                return e.DT_INT16;
                            case Int32Array:
                                return e.DT_INT32;
                            case Uint8Array:
                                return e.DT_UINT8;
                            case Uint16Array:
                                return e.DT_UINT16;
                            case Uint32Array:
                                return e.DT_UINT32
                            }
                        }(e, i)
                          , u = e._malloc(l);
                        t.GetAttributeDataArrayForAllPoints(n, a, c, l, u);
                        var h = new i(e.HEAPF32.buffer,u,s).slice();
                        return e._free(u),
                        {
                            name: r,
                            array: h,
                            itemSize: o
                        }
                    }
                    onmessage = function(r) {
                        var i = r.data;
                        switch (i.type) {
                        case "init":
                            e = i.decoderConfig,
                            t = new Promise((function(t) {
                                e.onModuleLoaded = function(e) {
                                    t({
                                        draco: e
                                    })
                                }
                                ,
                                DracoDecoderModule(e)
                            }
                            ));
                            break;
                        case "decode":
                            var a = i.buffer
                              , o = i.taskConfig;
                            t.then((e=>{
                                var t = e.draco
                                  , r = new t.Decoder
                                  , s = new t.DecoderBuffer;
                                s.Init(new Int8Array(a), a.byteLength);
                                try {
                                    var l = function(e, t, r, i) {
                                        var a, o, s = i.attributeIDs, l = i.attributeTypes, c = t.GetEncodedGeometryType(r);
                                        if (c === e.TRIANGULAR_MESH)
                                            a = new e.Mesh,
                                            o = t.DecodeBufferToMesh(r, a);
                                        else {
                                            if (c !== e.POINT_CLOUD)
                                                throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            a = new e.PointCloud,
                                            o = t.DecodeBufferToPointCloud(r, a)
                                        }
                                        if (!o.ok() || 0 === a.ptr)
                                            throw new Error("THREE.DRACOLoader: Decoding failed: " + o.error_msg());
                                        var u = {
                                            index: null,
                                            attributes: []
                                        };
                                        for (var h in s) {
                                            var d, p, f = self[l[h]];
                                            if (i.useUniqueIDs)
                                                p = s[h],
                                                d = t.GetAttributeByUniqueId(a, p);
                                            else {
                                                if (-1 === (p = t.GetAttributeId(a, e[s[h]])))
                                                    continue;
                                                d = t.GetAttribute(a, p)
                                            }
                                            u.attributes.push(n(e, t, a, h, f, d))
                                        }
                                        return c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                            var r = 3 * n.num_faces()
                                              , i = 4 * r
                                              , a = e._malloc(i);
                                            t.GetTrianglesUInt32Array(n, i, a);
                                            var o = new Uint32Array(e.HEAPF32.buffer,a,r).slice();
                                            return e._free(a),
                                            {
                                                array: o,
                                                itemSize: 1
                                            }
                                        }(e, t, a)),
                                        e.destroy(a),
                                        u
                                    }(t, r, s, o)
                                      , c = l.attributes.map((e=>e.array.buffer));
                                    l.index && c.push(l.index.array.buffer),
                                    self.postMessage({
                                        type: "decode",
                                        id: i.id,
                                        geometry: l
                                    }, c)
                                } catch (e) {
                                    console.error(e),
                                    self.postMessage({
                                        type: "error",
                                        id: i.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(s),
                                    t.destroy(r)
                                }
                            }
                            ))
                        }
                    }
                }
                ,
                i.taskCache = new WeakMap,
                i.setDecoderPath = function() {
                    console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.")
                }
                ,
                i.setDecoderConfig = function() {
                    console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.")
                }
                ,
                i.releaseDecoderModule = function() {
                    console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.")
                }
                ,
                i.getDecoderModule = function() {
                    console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.")
                }
            }
            ,
            1377: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    EXRLoader: ()=>Mt
                });
                var r = {};
                n.r(r),
                n.d(r, {
                    AsyncCompress: ()=>Le,
                    AsyncDecompress: ()=>Xe,
                    AsyncDeflate: ()=>Me,
                    AsyncGunzip: ()=>Ie,
                    AsyncGzip: ()=>Le,
                    AsyncInflate: ()=>Ae,
                    AsyncUnzipInflate: ()=>_t,
                    AsyncUnzlib: ()=>je,
                    AsyncZipDeflate: ()=>pt,
                    AsyncZlib: ()=>ze,
                    Compress: ()=>Re,
                    DecodeUTF8: ()=>tt,
                    Decompress: ()=>qe,
                    Deflate: ()=>we,
                    EncodeUTF8: ()=>nt,
                    Gunzip: ()=>Fe,
                    Gzip: ()=>Re,
                    Inflate: ()=>Ee,
                    Unzip: ()=>xt,
                    UnzipInflate: ()=>yt,
                    UnzipPassThrough: ()=>vt,
                    Unzlib: ()=>Ge,
                    Zip: ()=>ft,
                    ZipDeflate: ()=>dt,
                    ZipPassThrough: ()=>ht,
                    Zlib: ()=>ke,
                    compress: ()=>De,
                    compressSync: ()=>Oe,
                    decompress: ()=>Ye,
                    decompressSync: ()=>Ze,
                    deflate: ()=>Se,
                    deflateSync: ()=>Te,
                    gunzip: ()=>Ne,
                    gunzipSync: ()=>Be,
                    gzip: ()=>De,
                    gzipSync: ()=>Oe,
                    inflate: ()=>Ce,
                    inflateSync: ()=>Pe,
                    strFromU8: ()=>it,
                    strToU8: ()=>rt,
                    unzip: ()=>bt,
                    unzipSync: ()=>wt,
                    unzlib: ()=>Ve,
                    unzlibSync: ()=>We,
                    zip: ()=>mt,
                    zipSync: ()=>gt,
                    zlib: ()=>Ue,
                    zlibSync: ()=>He
                });
                var i = n(2212)
                  , a = {}
                  , o = Uint8Array
                  , s = Uint16Array
                  , l = Uint32Array
                  , c = new o([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
                  , u = new o([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
                  , h = new o([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
                  , d = function(e, t) {
                    for (var n = new s(31), r = 0; r < 31; ++r)
                        n[r] = t += 1 << e[r - 1];
                    var i = new l(n[30]);
                    for (r = 1; r < 30; ++r)
                        for (var a = n[r]; a < n[r + 1]; ++a)
                            i[a] = a - n[r] << 5 | r;
                    return [n, i]
                }
                  , p = d(c, 2)
                  , f = p[0]
                  , m = p[1];
                f[28] = 258,
                m[258] = 28;
                for (var g = d(u, 0), v = g[0], y = g[1], _ = new s(32768), x = 0; x < 32768; ++x) {
                    var b = (43690 & x) >>> 1 | (21845 & x) << 1;
                    b = (61680 & (b = (52428 & b) >>> 2 | (13107 & b) << 2)) >>> 4 | (3855 & b) << 4,
                    _[x] = ((65280 & b) >>> 8 | (255 & b) << 8) >>> 1
                }
                var w = function(e, t, n) {
                    for (var r = e.length, i = 0, a = new s(t); i < r; ++i)
                        ++a[e[i] - 1];
                    var o, l = new s(t);
                    for (i = 0; i < t; ++i)
                        l[i] = l[i - 1] + a[i - 1] << 1;
                    if (n) {
                        o = new s(1 << t);
                        var c = 15 - t;
                        for (i = 0; i < r; ++i)
                            if (e[i])
                                for (var u = i << 4 | e[i], h = t - e[i], d = l[e[i] - 1]++ << h, p = d | (1 << h) - 1; d <= p; ++d)
                                    o[_[d] >>> c] = u
                    } else
                        for (o = new s(r),
                        i = 0; i < r; ++i)
                            o[i] = _[l[e[i] - 1]++] >>> 15 - e[i];
                    return o
                }
                  , M = new o(288);
                for (x = 0; x < 144; ++x)
                    M[x] = 8;
                for (x = 144; x < 256; ++x)
                    M[x] = 9;
                for (x = 256; x < 280; ++x)
                    M[x] = 7;
                for (x = 280; x < 288; ++x)
                    M[x] = 8;
                var S = new o(32);
                for (x = 0; x < 32; ++x)
                    S[x] = 5;
                var T = w(M, 9, 0)
                  , E = w(M, 9, 1)
                  , A = w(S, 5, 0)
                  , C = w(S, 5, 1)
                  , P = function(e) {
                    for (var t = e[0], n = 1; n < e.length; ++n)
                        e[n] > t && (t = e[n]);
                    return t
                }
                  , R = function(e, t, n) {
                    var r = t / 8 >> 0;
                    return (e[r] | e[r + 1] << 8) >>> (7 & t) & n
                }
                  , L = function(e, t) {
                    var n = t / 8 >> 0;
                    return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >>> (7 & t)
                }
                  , D = function(e) {
                    return (e / 8 >> 0) + (7 & e && 1)
                }
                  , O = function(e, t, n) {
                    (null == t || t < 0) && (t = 0),
                    (null == n || n > e.length) && (n = e.length);
                    var r = new (e instanceof s ? s : e instanceof l ? l : o)(n - t);
                    return r.set(e.subarray(t, n)),
                    r
                }
                  , F = function(e, t, n) {
                    var r = e.length
                      , i = !t || n
                      , a = !n || n.i;
                    n || (n = {}),
                    t || (t = new o(3 * r));
                    var s = function(e) {
                        var n = t.length;
                        if (e > n) {
                            var r = new o(Math.max(2 * n, e));
                            r.set(t),
                            t = r
                        }
                    }
                      , l = n.f || 0
                      , d = n.p || 0
                      , p = n.b || 0
                      , m = n.l
                      , g = n.d
                      , y = n.m
                      , _ = n.n
                      , x = 8 * r;
                    do {
                        if (!m) {
                            n.f = l = R(e, d, 1);
                            var b = R(e, d + 1, 3);
                            if (d += 3,
                            !b) {
                                var M = e[(H = D(d) + 4) - 4] | e[H - 3] << 8
                                  , S = H + M;
                                if (S > r) {
                                    if (a)
                                        throw "unexpected EOF";
                                    break
                                }
                                i && s(p + M),
                                t.set(e.subarray(H, S), p),
                                n.b = p += M,
                                n.p = d = 8 * S;
                                continue
                            }
                            if (1 == b)
                                m = E,
                                g = C,
                                y = 9,
                                _ = 5;
                            else {
                                if (2 != b)
                                    throw "invalid block type";
                                var T = R(e, d, 31) + 257
                                  , A = R(e, d + 10, 15) + 4
                                  , F = T + R(e, d + 5, 31) + 1;
                                d += 14;
                                for (var I = new o(F), N = new o(19), B = 0; B < A; ++B)
                                    N[h[B]] = R(e, d + 3 * B, 7);
                                d += 3 * A;
                                var k = P(N)
                                  , z = (1 << k) - 1;
                                if (!a && d + F * (k + 7) > x)
                                    break;
                                var U = w(N, k, 1);
                                for (B = 0; B < F; ) {
                                    var H, G = U[R(e, d, z)];
                                    if (d += 15 & G,
                                    (H = G >>> 4) < 16)
                                        I[B++] = H;
                                    else {
                                        var j = 0
                                          , V = 0;
                                        for (16 == H ? (V = 3 + R(e, d, 3),
                                        d += 2,
                                        j = I[B - 1]) : 17 == H ? (V = 3 + R(e, d, 7),
                                        d += 3) : 18 == H && (V = 11 + R(e, d, 127),
                                        d += 7); V--; )
                                            I[B++] = j
                                    }
                                }
                                var W = I.subarray(0, T)
                                  , q = I.subarray(T);
                                y = P(W),
                                _ = P(q),
                                m = w(W, y, 1),
                                g = w(q, _, 1)
                            }
                            if (d > x)
                                throw "unexpected EOF"
                        }
                        i && s(p + 131072);
                        for (var X = (1 << y) - 1, Y = (1 << _) - 1, Z = y + _ + 18; a || d + Z < x; ) {
                            var J = (j = m[L(e, d) & X]) >>> 4;
                            if ((d += 15 & j) > x)
                                throw "unexpected EOF";
                            if (!j)
                                throw "invalid length/literal";
                            if (J < 256)
                                t[p++] = J;
                            else {
                                if (256 == J) {
                                    m = null;
                                    break
                                }
                                var K = J - 254;
                                if (J > 264) {
                                    var Q = c[B = J - 257];
                                    K = R(e, d, (1 << Q) - 1) + f[B],
                                    d += Q
                                }
                                var $ = g[L(e, d) & Y]
                                  , ee = $ >>> 4;
                                if (!$)
                                    throw "invalid distance";
                                if (d += 15 & $,
                                q = v[ee],
                                ee > 3 && (Q = u[ee],
                                q += L(e, d) & (1 << Q) - 1,
                                d += Q),
                                d > x)
                                    throw "unexpected EOF";
                                i && s(p + 131072);
                                for (var te = p + K; p < te; p += 4)
                                    t[p] = t[p - q],
                                    t[p + 1] = t[p + 1 - q],
                                    t[p + 2] = t[p + 2 - q],
                                    t[p + 3] = t[p + 3 - q];
                                p = te
                            }
                        }
                        n.l = m,
                        n.p = d,
                        n.b = p,
                        m && (l = 1,
                        n.m = y,
                        n.d = g,
                        n.n = _)
                    } while (!l);
                    return p == t.length ? t : O(t, 0, p)
                }
                  , I = function(e, t, n) {
                    n <<= 7 & t;
                    var r = t / 8 >> 0;
                    e[r] |= n,
                    e[r + 1] |= n >>> 8
                }
                  , N = function(e, t, n) {
                    n <<= 7 & t;
                    var r = t / 8 >> 0;
                    e[r] |= n,
                    e[r + 1] |= n >>> 8,
                    e[r + 2] |= n >>> 16
                }
                  , B = function(e, t) {
                    for (var n = [], r = 0; r < e.length; ++r)
                        e[r] && n.push({
                            s: r,
                            f: e[r]
                        });
                    var i = n.length
                      , a = n.slice();
                    if (!i)
                        return [new o(0), 0];
                    if (1 == i) {
                        var l = new o(n[0].s + 1);
                        return l[n[0].s] = 1,
                        [l, 1]
                    }
                    n.sort((function(e, t) {
                        return e.f - t.f
                    }
                    )),
                    n.push({
                        s: -1,
                        f: 25001
                    });
                    var c = n[0]
                      , u = n[1]
                      , h = 0
                      , d = 1
                      , p = 2;
                    for (n[0] = {
                        s: -1,
                        f: c.f + u.f,
                        l: c,
                        r: u
                    }; d != i - 1; )
                        c = n[n[h].f < n[p].f ? h++ : p++],
                        u = n[h != d && n[h].f < n[p].f ? h++ : p++],
                        n[d++] = {
                            s: -1,
                            f: c.f + u.f,
                            l: c,
                            r: u
                        };
                    var f = a[0].s;
                    for (r = 1; r < i; ++r)
                        a[r].s > f && (f = a[r].s);
                    var m = new s(f + 1)
                      , g = k(n[d - 1], m, 0);
                    if (g > t) {
                        r = 0;
                        var v = 0
                          , y = g - t
                          , _ = 1 << y;
                        for (a.sort((function(e, t) {
                            return m[t.s] - m[e.s] || e.f - t.f
                        }
                        )); r < i; ++r) {
                            var x = a[r].s;
                            if (!(m[x] > t))
                                break;
                            v += _ - (1 << g - m[x]),
                            m[x] = t
                        }
                        for (v >>>= y; v > 0; ) {
                            var b = a[r].s;
                            m[b] < t ? v -= 1 << t - m[b]++ - 1 : ++r
                        }
                        for (; r >= 0 && v; --r) {
                            var w = a[r].s;
                            m[w] == t && (--m[w],
                            ++v)
                        }
                        g = t
                    }
                    return [new o(m), g]
                }
                  , k = function(e, t, n) {
                    return -1 == e.s ? Math.max(k(e.l, t, n + 1), k(e.r, t, n + 1)) : t[e.s] = n
                }
                  , z = function(e) {
                    for (var t = e.length; t && !e[--t]; )
                        ;
                    for (var n = new s(++t), r = 0, i = e[0], a = 1, o = function(e) {
                        n[r++] = e
                    }, l = 1; l <= t; ++l)
                        if (e[l] == i && l != t)
                            ++a;
                        else {
                            if (!i && a > 2) {
                                for (; a > 138; a -= 138)
                                    o(32754);
                                a > 2 && (o(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305),
                                a = 0)
                            } else if (a > 3) {
                                for (o(i),
                                --a; a > 6; a -= 6)
                                    o(8304);
                                a > 2 && (o(a - 3 << 5 | 8208),
                                a = 0)
                            }
                            for (; a--; )
                                o(i);
                            a = 1,
                            i = e[l]
                        }
                    return [n.subarray(0, r), t]
                }
                  , U = function(e, t) {
                    for (var n = 0, r = 0; r < t.length; ++r)
                        n += e[r] * t[r];
                    return n
                }
                  , H = function(e, t, n) {
                    var r = n.length
                      , i = D(t + 2);
                    e[i] = 255 & r,
                    e[i + 1] = r >>> 8,
                    e[i + 2] = 255 ^ e[i],
                    e[i + 3] = 255 ^ e[i + 1];
                    for (var a = 0; a < r; ++a)
                        e[i + a + 4] = n[a];
                    return 8 * (i + 4 + r)
                }
                  , G = function(e, t, n, r, i, a, o, l, d, p, f) {
                    I(t, f++, n),
                    ++i[256];
                    for (var m = B(i, 15), g = m[0], v = m[1], y = B(a, 15), _ = y[0], x = y[1], b = z(g), E = b[0], C = b[1], P = z(_), R = P[0], L = P[1], D = new s(19), O = 0; O < E.length; ++O)
                        D[31 & E[O]]++;
                    for (O = 0; O < R.length; ++O)
                        D[31 & R[O]]++;
                    for (var F = B(D, 7), k = F[0], G = F[1], j = 19; j > 4 && !k[h[j - 1]]; --j)
                        ;
                    var V, W, q, X, Y = p + 5 << 3, Z = U(i, M) + U(a, S) + o, J = U(i, g) + U(a, _) + o + 14 + 3 * j + U(D, k) + (2 * D[16] + 3 * D[17] + 7 * D[18]);
                    if (Y <= Z && Y <= J)
                        return H(t, f, e.subarray(d, d + p));
                    if (I(t, f, 1 + (J < Z)),
                    f += 2,
                    J < Z) {
                        V = w(g, v, 0),
                        W = g,
                        q = w(_, x, 0),
                        X = _;
                        var K = w(k, G, 0);
                        for (I(t, f, C - 257),
                        I(t, f + 5, L - 1),
                        I(t, f + 10, j - 4),
                        f += 14,
                        O = 0; O < j; ++O)
                            I(t, f + 3 * O, k[h[O]]);
                        f += 3 * j;
                        for (var Q = [E, R], $ = 0; $ < 2; ++$) {
                            var ee = Q[$];
                            for (O = 0; O < ee.length; ++O) {
                                var te = 31 & ee[O];
                                I(t, f, K[te]),
                                f += k[te],
                                te > 15 && (I(t, f, ee[O] >>> 5 & 127),
                                f += ee[O] >>> 12)
                            }
                        }
                    } else
                        V = T,
                        W = M,
                        q = A,
                        X = S;
                    for (O = 0; O < l; ++O)
                        if (r[O] > 255) {
                            te = r[O] >>> 18 & 31,
                            N(t, f, V[te + 257]),
                            f += W[te + 257],
                            te > 7 && (I(t, f, r[O] >>> 23 & 31),
                            f += c[te]);
                            var ne = 31 & r[O];
                            N(t, f, q[ne]),
                            f += X[ne],
                            ne > 3 && (N(t, f, r[O] >>> 5 & 8191),
                            f += u[ne])
                        } else
                            N(t, f, V[r[O]]),
                            f += W[r[O]];
                    return N(t, f, V[256]),
                    f + W[256]
                }
                  , j = new l([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
                  , V = new o(0)
                  , W = function(e, t, n, r, i, a) {
                    var h = e.length
                      , d = new o(r + h + 5 * (1 + Math.ceil(h / 7e3)) + i)
                      , p = d.subarray(r, d.length - i)
                      , f = 0;
                    if (!t || h < 8)
                        for (var g = 0; g <= h; g += 65535) {
                            var v = g + 65535;
                            v < h ? f = H(p, f, e.subarray(g, v)) : (p[g] = a,
                            f = H(p, f, e.subarray(g, h)))
                        }
                    else {
                        for (var _ = j[t - 1], x = _ >>> 13, b = 8191 & _, w = (1 << n) - 1, M = new s(32768), S = new s(w + 1), T = Math.ceil(n / 3), E = 2 * T, A = function(t) {
                            return (e[t] ^ e[t + 1] << T ^ e[t + 2] << E) & w
                        }, C = new l(25e3), P = new s(288), R = new s(32), L = 0, F = 0, I = (g = 0,
                        0), N = 0, B = 0; g < h; ++g) {
                            var k = A(g)
                              , z = 32767 & g
                              , U = S[k];
                            if (M[z] = U,
                            S[k] = z,
                            N <= g) {
                                var W = h - g;
                                if ((L > 7e3 || I > 24576) && W > 423) {
                                    f = G(e, p, 0, C, P, R, F, I, B, g - B, f),
                                    I = L = F = 0,
                                    B = g;
                                    for (var q = 0; q < 286; ++q)
                                        P[q] = 0;
                                    for (q = 0; q < 30; ++q)
                                        R[q] = 0
                                }
                                var X = 2
                                  , Y = 0
                                  , Z = b
                                  , J = z - U & 32767;
                                if (W > 2 && k == A(g - J))
                                    for (var K = Math.min(x, W) - 1, Q = Math.min(32767, g), $ = Math.min(258, W); J <= Q && --Z && z != U; ) {
                                        if (e[g + X] == e[g + X - J]) {
                                            for (var ee = 0; ee < $ && e[g + ee] == e[g + ee - J]; ++ee)
                                                ;
                                            if (ee > X) {
                                                if (X = ee,
                                                Y = J,
                                                ee > K)
                                                    break;
                                                var te = Math.min(J, ee - 2)
                                                  , ne = 0;
                                                for (q = 0; q < te; ++q) {
                                                    var re = g - J + q + 32768 & 32767
                                                      , ie = re - M[re] + 32768 & 32767;
                                                    ie > ne && (ne = ie,
                                                    U = re)
                                                }
                                            }
                                        }
                                        J += (z = U) - (U = M[z]) + 32768 & 32767
                                    }
                                if (Y) {
                                    C[I++] = 268435456 | m[X] << 18 | y[Y];
                                    var ae = 31 & m[X]
                                      , oe = 31 & y[Y];
                                    F += c[ae] + u[oe],
                                    ++P[257 + ae],
                                    ++R[oe],
                                    N = g + X,
                                    ++L
                                } else
                                    C[I++] = e[g],
                                    ++P[e[g]]
                            }
                        }
                        f = G(e, p, a, C, P, R, F, I, B, g - B, f),
                        !a && 7 & f && (f = H(p, f + 1, V))
                    }
                    return O(d, 0, r + D(f) + i)
                }
                  , q = function() {
                    for (var e = new l(256), t = 0; t < 256; ++t) {
                        for (var n = t, r = 9; --r; )
                            n = (1 & n && 3988292384) ^ n >>> 1;
                        e[t] = n
                    }
                    return e
                }()
                  , X = function() {
                    var e = 4294967295;
                    return {
                        p: function(t) {
                            for (var n = e, r = 0; r < t.length; ++r)
                                n = q[255 & n ^ t[r]] ^ n >>> 8;
                            e = n
                        },
                        d: function() {
                            return 4294967295 ^ e
                        }
                    }
                }
                  , Y = function() {
                    var e = 1
                      , t = 0;
                    return {
                        p: function(n) {
                            for (var r = e, i = t, a = n.length, o = 0; o != a; ) {
                                for (var s = Math.min(o + 5552, a); o < s; ++o)
                                    i += r += n[o];
                                r %= 65521,
                                i %= 65521
                            }
                            e = r,
                            t = i
                        },
                        d: function() {
                            return (e >>> 8 << 16 | (255 & t) << 8 | t >>> 8) + 2 * ((255 & e) << 23)
                        }
                    }
                }
                  , Z = function(e, t, n, r, i) {
                    return W(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i)
                }
                  , J = function(e, t) {
                    var n = {};
                    for (var r in e)
                        n[r] = e[r];
                    for (var r in t)
                        n[r] = t[r];
                    return n
                }
                  , K = function(e, t, n) {
                    for (var r = e(), i = e.toString(), a = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
                        var s = r[o]
                          , l = a[o];
                        if ("function" == typeof s) {
                            t += ";" + l + "=";
                            var c = s.toString();
                            if (s.prototype)
                                if (-1 != c.indexOf("[native code]")) {
                                    var u = c.indexOf(" ", 8) + 1;
                                    t += c.slice(u, c.indexOf("(", u))
                                } else
                                    for (var h in t += c,
                                    s.prototype)
                                        t += ";" + l + ".prototype." + h + "=" + s.prototype[h].toString();
                            else
                                t += c
                        } else
                            n[l] = s
                    }
                    return [t, n]
                }
                  , Q = []
                  , $ = function(e, t, n, r) {
                    var i;
                    if (!Q[n]) {
                        for (var c = "", u = {}, h = e.length - 1, d = 0; d < h; ++d)
                            c = (i = K(e[d], c, u))[0],
                            u = i[1];
                        Q[n] = K(e[h], c, u)
                    }
                    var p = J({}, Q[n][1]);
                    return function(e, t, n, r, i) {
                        var o = a[t] || (a[t] = URL.createObjectURL(new Blob([e],{
                            type: "text/javascript"
                        })))
                          , s = new Worker(o);
                        return s.onerror = function(e) {
                            i(e.error, null)
                        }
                        ,
                        s.onmessage = function(e) {
                            i(null, e.data)
                        }
                        ,
                        s.postMessage(n, r),
                        s
                    }(Q[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, p, function(e) {
                        var t = [];
                        for (var n in e)
                            (e[n]instanceof o || e[n]instanceof s || e[n]instanceof l) && t.push((e[n] = new e[n].constructor(e[n])).buffer);
                        return t
                    }(p), r)
                }
                  , ee = function() {
                    return [o, s, l, c, u, h, f, v, E, C, _, w, P, R, L, D, O, F, Pe, oe, se]
                }
                  , te = function() {
                    return [o, s, l, c, u, h, m, y, T, M, A, S, _, j, V, w, I, N, B, k, z, U, H, G, D, O, W, Z, Te, oe]
                }
                  , ne = function() {
                    return [me, ye, fe, X, q]
                }
                  , re = function() {
                    return [ge, ve]
                }
                  , ie = function() {
                    return [_e, fe, Y]
                }
                  , ae = function() {
                    return [xe]
                }
                  , oe = function(e) {
                    return postMessage(e, [e.buffer])
                }
                  , se = function(e) {
                    return e && e.size && new o(e.size)
                }
                  , le = function(e, t, n, r, i, a) {
                    var s = $(n, r, i, (function(e, t) {
                        s.terminate(),
                        a(e, t)
                    }
                    ));
                    return t.consume || (e = new o(e)),
                    s.postMessage([e, t], [e.buffer]),
                    function() {
                        s.terminate()
                    }
                }
                  , ce = function(e) {
                    return e.ondata = function(e, t) {
                        return postMessage([e, t], [e.buffer])
                    }
                    ,
                    function(t) {
                        return e.push(t.data[0], t.data[1])
                    }
                }
                  , ue = function(e, t, n, r, i) {
                    var a, o = $(e, r, i, (function(e, n) {
                        e ? (o.terminate(),
                        t.ondata.call(t, e)) : (n[1] && o.terminate(),
                        t.ondata.call(t, e, n[0], n[1]))
                    }
                    ));
                    o.postMessage(n),
                    t.push = function(e, n) {
                        if (a)
                            throw "stream finished";
                        if (!t.ondata)
                            throw "no stream handler";
                        o.postMessage([e, a = n], [e.buffer])
                    }
                    ,
                    t.terminate = function() {
                        o.terminate()
                    }
                }
                  , he = function(e, t) {
                    return e[t] | e[t + 1] << 8
                }
                  , de = function(e, t) {
                    return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 2 * (e[t + 3] << 23)
                }
                  , pe = function(e, t) {
                    return de(e, t) | 4294967296 * de(e, t)
                }
                  , fe = function(e, t, n) {
                    for (; n; ++t)
                        e[t] = n,
                        n >>>= 8
                }
                  , me = function(e, t) {
                    var n = t.filename;
                    if (e[0] = 31,
                    e[1] = 139,
                    e[2] = 8,
                    e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0,
                    e[9] = 3,
                    0 != t.mtime && fe(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)),
                    n) {
                        e[3] = 8;
                        for (var r = 0; r <= n.length; ++r)
                            e[r + 10] = n.charCodeAt(r)
                    }
                }
                  , ge = function(e) {
                    if (31 != e[0] || 139 != e[1] || 8 != e[2])
                        throw "invalid gzip data";
                    var t = e[3]
                      , n = 10;
                    4 & t && (n += e[10] | 2 + (e[11] << 8));
                    for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++])
                        ;
                    return n + (2 & t)
                }
                  , ve = function(e) {
                    var t = e.length;
                    return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16) + 2 * (e[t - 1] << 23)
                }
                  , ye = function(e) {
                    return 10 + (e.filename && e.filename.length + 1 || 0)
                }
                  , _e = function(e, t) {
                    var n = t.level
                      , r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
                    e[0] = 120,
                    e[1] = r << 6 | (r ? 32 - 2 * r : 1)
                }
                  , xe = function(e) {
                    if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31)
                        throw "invalid zlib data";
                    if (32 & e[1])
                        throw "invalid zlib data: preset dictionaries not supported"
                };
                function be(e, t) {
                    return t || "function" != typeof e || (t = e,
                    e = {}),
                    this.ondata = t,
                    e
                }
                var we = function() {
                    function e(e, t) {
                        t || "function" != typeof e || (t = e,
                        e = {}),
                        this.ondata = t,
                        this.o = e || {}
                    }
                    return e.prototype.p = function(e, t) {
                        this.ondata(Z(e, this.o, 0, 0, !t), t)
                    }
                    ,
                    e.prototype.push = function(e, t) {
                        if (this.d)
                            throw "stream finished";
                        if (!this.ondata)
                            throw "no stream handler";
                        this.d = t,
                        this.p(e, t || !1)
                    }
                    ,
                    e
                }()
                  , Me = function(e, t) {
                    ue([te, function() {
                        return [ce, we]
                    }
                    ], this, be.call(this, e, t), (function(e) {
                        var t = new we(e.data);
                        onmessage = ce(t)
                    }
                    ), 6)
                };
                function Se(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return le(e, t, [te], (function(e) {
                        return oe(Te(e.data[0], e.data[1]))
                    }
                    ), 0, n)
                }
                function Te(e, t) {
                    return void 0 === t && (t = {}),
                    Z(e, t, 0, 0)
                }
                var Ee = function() {
                    function e(e) {
                        this.s = {},
                        this.p = new o(0),
                        this.ondata = e
                    }
                    return e.prototype.e = function(e) {
                        if (this.d)
                            throw "stream finished";
                        if (!this.ondata)
                            throw "no stream handler";
                        var t = this.p.length
                          , n = new o(t + e.length);
                        n.set(this.p),
                        n.set(e, t),
                        this.p = n
                    }
                    ,
                    e.prototype.c = function(e) {
                        this.d = this.s.i = e || !1;
                        var t = this.s.b
                          , n = F(this.p, this.o, this.s);
                        this.ondata(O(n, t, this.s.b), this.d),
                        this.o = O(n, this.s.b - 32768),
                        this.s.b = this.o.length,
                        this.p = O(this.p, this.s.p / 8 >> 0),
                        this.s.p &= 7
                    }
                    ,
                    e.prototype.push = function(e, t) {
                        this.e(e),
                        this.c(t)
                    }
                    ,
                    e
                }()
                  , Ae = function(e) {
                    this.ondata = e,
                    ue([ee, function() {
                        return [ce, Ee]
                    }
                    ], this, 0, (function() {
                        var e = new Ee;
                        onmessage = ce(e)
                    }
                    ), 7)
                };
                function Ce(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return le(e, t, [ee], (function(e) {
                        return oe(Pe(e.data[0], se(e.data[1])))
                    }
                    ), 1, n)
                }
                function Pe(e, t) {
                    return F(e, t)
                }
                var Re = function() {
                    function e(e, t) {
                        this.c = X(),
                        this.l = 0,
                        this.v = 1,
                        we.call(this, e, t)
                    }
                    return e.prototype.push = function(e, t) {
                        we.prototype.push.call(this, e, t)
                    }
                    ,
                    e.prototype.p = function(e, t) {
                        this.c.p(e),
                        this.l += e.length;
                        var n = Z(e, this.o, this.v && ye(this.o), t && 8, !t);
                        this.v && (me(n, this.o),
                        this.v = 0),
                        t && (fe(n, n.length - 8, this.c.d()),
                        fe(n, n.length - 4, this.l)),
                        this.ondata(n, t)
                    }
                    ,
                    e
                }()
                  , Le = function(e, t) {
                    ue([te, ne, function() {
                        return [ce, we, Re]
                    }
                    ], this, be.call(this, e, t), (function(e) {
                        var t = new Re(e.data);
                        onmessage = ce(t)
                    }
                    ), 8)
                };
                function De(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return le(e, t, [te, ne, function() {
                        return [Oe]
                    }
                    ], (function(e) {
                        return oe(Oe(e.data[0], e.data[1]))
                    }
                    ), 2, n)
                }
                function Oe(e, t) {
                    void 0 === t && (t = {});
                    var n = X()
                      , r = e.length;
                    n.p(e);
                    var i = Z(e, t, ye(t), 8)
                      , a = i.length;
                    return me(i, t),
                    fe(i, a - 8, n.d()),
                    fe(i, a - 4, r),
                    i
                }
                var Fe = function() {
                    function e(e) {
                        this.v = 1,
                        Ee.call(this, e)
                    }
                    return e.prototype.push = function(e, t) {
                        if (Ee.prototype.e.call(this, e),
                        this.v) {
                            var n = ge(this.p);
                            if (n >= this.p.length && !t)
                                return;
                            this.p = this.p.subarray(n),
                            this.v = 0
                        }
                        if (t) {
                            if (this.p.length < 8)
                                throw "invalid gzip stream";
                            this.p = this.p.subarray(0, -8)
                        }
                        Ee.prototype.c.call(this, t)
                    }
                    ,
                    e
                }()
                  , Ie = function(e) {
                    this.ondata = e,
                    ue([ee, re, function() {
                        return [ce, Ee, Fe]
                    }
                    ], this, 0, (function() {
                        var e = new Fe;
                        onmessage = ce(e)
                    }
                    ), 9)
                };
                function Ne(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return le(e, t, [ee, re, function() {
                        return [Be]
                    }
                    ], (function(e) {
                        return oe(Be(e.data[0]))
                    }
                    ), 3, n)
                }
                function Be(e, t) {
                    return F(e.subarray(ge(e), -8), t || new o(ve(e)))
                }
                var ke = function() {
                    function e(e, t) {
                        this.c = Y(),
                        this.v = 1,
                        we.call(this, e, t)
                    }
                    return e.prototype.push = function(e, t) {
                        we.prototype.push.call(this, e, t)
                    }
                    ,
                    e.prototype.p = function(e, t) {
                        this.c.p(e);
                        var n = Z(e, this.o, this.v && 2, t && 4, !t);
                        this.v && (_e(n, this.o),
                        this.v = 0),
                        t && fe(n, n.length - 4, this.c.d()),
                        this.ondata(n, t)
                    }
                    ,
                    e
                }()
                  , ze = function(e, t) {
                    ue([te, ie, function() {
                        return [ce, we, ke]
                    }
                    ], this, be.call(this, e, t), (function(e) {
                        var t = new ke(e.data);
                        onmessage = ce(t)
                    }
                    ), 10)
                };
                function Ue(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return le(e, t, [te, ie, function() {
                        return [He]
                    }
                    ], (function(e) {
                        return oe(He(e.data[0], e.data[1]))
                    }
                    ), 4, n)
                }
                function He(e, t) {
                    void 0 === t && (t = {});
                    var n = Y();
                    n.p(e);
                    var r = Z(e, t, 2, 4);
                    return _e(r, t),
                    fe(r, r.length - 4, n.d()),
                    r
                }
                var Ge = function() {
                    function e(e) {
                        this.v = 1,
                        Ee.call(this, e)
                    }
                    return e.prototype.push = function(e, t) {
                        if (Ee.prototype.e.call(this, e),
                        this.v) {
                            if (this.p.length < 2 && !t)
                                return;
                            this.p = this.p.subarray(2),
                            this.v = 0
                        }
                        if (t) {
                            if (this.p.length < 4)
                                throw "invalid zlib stream";
                            this.p = this.p.subarray(0, -4)
                        }
                        Ee.prototype.c.call(this, t)
                    }
                    ,
                    e
                }()
                  , je = function(e) {
                    this.ondata = e,
                    ue([ee, ae, function() {
                        return [ce, Ee, Ge]
                    }
                    ], this, 0, (function() {
                        var e = new Ge;
                        onmessage = ce(e)
                    }
                    ), 11)
                };
                function Ve(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return le(e, t, [ee, ae, function() {
                        return [We]
                    }
                    ], (function(e) {
                        return oe(We(e.data[0], se(e.data[1])))
                    }
                    ), 5, n)
                }
                function We(e, t) {
                    return F((xe(e),
                    e.subarray(2, -4)), t)
                }
                var qe = function() {
                    function e(e) {
                        this.G = Fe,
                        this.I = Ee,
                        this.Z = Ge,
                        this.ondata = e
                    }
                    return e.prototype.push = function(e, t) {
                        if (!this.ondata)
                            throw "no stream handler";
                        if (this.s)
                            this.s.push(e, t);
                        else {
                            if (this.p && this.p.length) {
                                var n = new o(this.p.length + e.length);
                                n.set(this.p),
                                n.set(e, this.p.length)
                            } else
                                this.p = e;
                            if (this.p.length > 2) {
                                var r = this
                                  , i = function() {
                                    r.ondata.apply(r, arguments)
                                };
                                this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i),
                                this.s.push(this.p, t),
                                this.p = null
                            }
                        }
                    }
                    ,
                    e
                }()
                  , Xe = function() {
                    function e(e) {
                        this.G = Ie,
                        this.I = Ae,
                        this.Z = je,
                        this.ondata = e
                    }
                    return e.prototype.push = function(e, t) {
                        qe.prototype.push.call(this, e, t)
                    }
                    ,
                    e
                }();
                function Ye(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Ne(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ce(e, t, n) : Ve(e, t, n)
                }
                function Ze(e, t) {
                    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Be(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Pe(e, t) : We(e, t)
                }
                var Je = function(e, t, n, r) {
                    for (var i in e) {
                        var a = e[i]
                          , s = t + i;
                        a instanceof o ? n[s] = [a, r] : Array.isArray(a) ? n[s] = [a[0], J(r, a[1])] : Je(a, s + "/", n, r)
                    }
                }
                  , Ke = "undefined" != typeof TextEncoder && new TextEncoder
                  , Qe = "undefined" != typeof TextDecoder && new TextDecoder
                  , $e = 0;
                try {
                    Qe.decode(V, {
                        stream: !0
                    }),
                    $e = 1
                } catch (a) {}
                var et = function(e) {
                    for (var t = "", n = 0; ; ) {
                        var r = e[n++]
                          , i = (r > 127) + (r > 223) + (r > 239);
                        if (n + i > e.length)
                            return [t, e.slice(n - 1)];
                        i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536,
                        t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r)
                    }
                }
                  , tt = function() {
                    function e(e) {
                        this.ondata = e,
                        $e ? this.t = new TextDecoder : this.p = V
                    }
                    return e.prototype.push = function(e, t) {
                        if (!this.ondata)
                            throw "no callback";
                        if (t || (t = !1),
                        this.t)
                            return this.ondata(this.t.decode(e, {
                                stream: !t
                            }), t);
                        var n = new o(this.p.length + e.length);
                        n.set(this.p),
                        n.set(e, this.p.length);
                        var r = et(n)
                          , i = r[0]
                          , a = r[1];
                        if (t && a.length)
                            throw "invalid utf-8 data";
                        this.p = a,
                        this.ondata(i, t)
                    }
                    ,
                    e
                }()
                  , nt = function() {
                    function e(e) {
                        this.ondata = e
                    }
                    return e.prototype.push = function(e, t) {
                        if (!this.ondata)
                            throw "no callback";
                        this.ondata(rt(e), t || !1)
                    }
                    ,
                    e
                }();
                function rt(e, t) {
                    if (t) {
                        for (var n = new o(e.length), r = 0; r < e.length; ++r)
                            n[r] = e.charCodeAt(r);
                        return n
                    }
                    if (Ke)
                        return Ke.encode(e);
                    var i = e.length
                      , a = new o(e.length + (e.length >> 1))
                      , s = 0
                      , l = function(e) {
                        a[s++] = e
                    };
                    for (r = 0; r < i; ++r) {
                        if (s + 5 > a.length) {
                            var c = new o(s + 8 + (i - r << 1));
                            c.set(a),
                            a = c
                        }
                        var u = e.charCodeAt(r);
                        u < 128 || t ? l(u) : u < 2048 ? (l(192 | u >>> 6),
                        l(128 | 63 & u)) : u > 55295 && u < 57344 ? (l(240 | (u = 65536 + (1047552 & u) | 1023 & e.charCodeAt(++r)) >>> 18),
                        l(128 | u >>> 12 & 63),
                        l(128 | u >>> 6 & 63),
                        l(128 | 63 & u)) : (l(224 | u >>> 12),
                        l(128 | u >>> 6 & 63),
                        l(128 | 63 & u))
                    }
                    return O(a, 0, s)
                }
                function it(e, t) {
                    if (t) {
                        for (var n = "", r = 0; r < e.length; r += 16384)
                            n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));
                        return n
                    }
                    if (Qe)
                        return Qe.decode(e);
                    var i = et(e)
                      , a = i[0];
                    if (i[1].length)
                        throw "invalid utf-8 data";
                    return a
                }
                var at = function(e) {
                    return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0
                }
                  , ot = function(e, t) {
                    return t + 30 + he(e, t + 26) + he(e, t + 28)
                }
                  , st = function(e, t, n) {
                    var r = he(e, t + 28)
                      , i = it(e.subarray(t + 46, t + 46 + r), !(2048 & he(e, t + 8)))
                      , a = t + 46 + r
                      , o = de(e, t + 20)
                      , s = n && 4294967295 == o ? lt(e, a) : [o, de(e, t + 24), de(e, t + 42)]
                      , l = s[0]
                      , c = s[1]
                      , u = s[2];
                    return [he(e, t + 10), l, c, i, a + he(e, t + 30) + he(e, t + 32), u]
                }
                  , lt = function(e, t) {
                    for (; 1 != he(e, t); t += 4 + he(e, t + 2))
                        ;
                    return [pe(e, t + 12), pe(e, t + 4), pe(e, t + 20)]
                }
                  , ct = function(e, t, n, r, i, a, o) {
                    var s = r.length;
                    fe(e, t, null != o ? 33639248 : 67324752),
                    t += 4,
                    null != o && (e[t++] = 20,
                    e[t++] = n.os),
                    e[t] = 20,
                    t += 2,
                    e[t++] = n.flag << 1 | (null == a && 8),
                    e[t++] = i && 8,
                    e[t++] = 255 & n.compression,
                    e[t++] = n.compression >> 8;
                    var l = new Date(null == n.mtime ? Date.now() : n.mtime)
                      , c = l.getFullYear() - 1980;
                    if (c < 0 || c > 119)
                        throw "date not in range 1980-2099";
                    return fe(e, t, 2 * (c << 24) | l.getMonth() + 1 << 21 | l.getDate() << 16 | l.getHours() << 11 | l.getMinutes() << 5 | l.getSeconds() >>> 1),
                    t += 4,
                    null != a && (fe(e, t, n.crc),
                    fe(e, t + 4, a),
                    fe(e, t + 8, n.size)),
                    fe(e, t + 12, s),
                    t += 16,
                    null != o && (fe(e, t + 6, n.attrs),
                    fe(e, t + 10, o),
                    t += 14),
                    e.set(r, t),
                    t + s
                }
                  , ut = function(e, t, n, r, i) {
                    fe(e, t, 101010256),
                    fe(e, t + 8, n),
                    fe(e, t + 10, n),
                    fe(e, t + 12, r),
                    fe(e, t + 16, i)
                }
                  , ht = function() {
                    function e(e) {
                        this.filename = e,
                        this.c = X(),
                        this.size = 0,
                        this.compression = 0
                    }
                    return e.prototype.process = function(e, t) {
                        this.ondata(null, e, t)
                    }
                    ,
                    e.prototype.push = function(e, t) {
                        if (!this.ondata)
                            throw "no callback - add to ZIP archive before pushing";
                        this.c.p(e),
                        this.size += e.length,
                        t && (this.crc = this.c.d()),
                        this.process(e, t || !1)
                    }
                    ,
                    e
                }()
                  , dt = function() {
                    function e(e, t) {
                        var n = this;
                        void 0 === t && (t = {}),
                        ht.call(this, e),
                        this.d = new we(t,(function(e, t) {
                            n.ondata(null, e, t)
                        }
                        )),
                        this.compression = 8,
                        this.flag = at(t.level)
                    }
                    return e.prototype.process = function(e, t) {
                        try {
                            this.d.push(e, t)
                        } catch (e) {
                            this.ondata(e, null, t)
                        }
                    }
                    ,
                    e.prototype.push = function(e, t) {
                        ht.prototype.push.call(this, e, t)
                    }
                    ,
                    e
                }()
                  , pt = function() {
                    function e(e, t) {
                        var n = this;
                        void 0 === t && (t = {}),
                        ht.call(this, e),
                        this.d = new Me(t,(function(e, t, r) {
                            n.ondata(e, t, r)
                        }
                        )),
                        this.compression = 8,
                        this.flag = at(t.level),
                        this.terminate = this.d.terminate
                    }
                    return e.prototype.process = function(e, t) {
                        this.d.push(e, t)
                    }
                    ,
                    e.prototype.push = function(e, t) {
                        ht.prototype.push.call(this, e, t)
                    }
                    ,
                    e
                }()
                  , ft = function() {
                    function e(e) {
                        this.ondata = e,
                        this.u = [],
                        this.d = 1
                    }
                    return e.prototype.add = function(e) {
                        var t = this;
                        if (2 & this.d)
                            throw "stream finished";
                        var n = rt(e.filename)
                          , r = n.length
                          , i = r != e.filename.length
                          , a = r + 30;
                        if (r > 65535)
                            throw "filename too long";
                        var s = new o(a);
                        ct(s, 0, e, n, i);
                        var l = [s]
                          , c = function() {
                            for (var e = 0, n = l; e < n.length; e++) {
                                var r = n[e];
                                t.ondata(null, r, !1)
                            }
                            l = []
                        }
                          , u = this.d;
                        this.d = 0;
                        var h = this.u.length
                          , d = J(e, {
                            f: n,
                            u: i,
                            t: function() {
                                e.terminate && e.terminate()
                            },
                            r: function() {
                                if (c(),
                                u) {
                                    var e = t.u[h + 1];
                                    e ? e.r() : t.d = 1
                                }
                                u = 1
                            }
                        })
                          , p = 0;
                        e.ondata = function(n, r, i) {
                            n ? (t.ondata(n, r, i),
                            t.terminate()) : (p += r.length,
                            l.push(r),
                            i ? (l.push(function(e, t) {
                                var n = new o(16);
                                return fe(n, 0, 134695760),
                                fe(n, 4, e.crc),
                                fe(n, 8, t),
                                fe(n, 12, e.size),
                                n
                            }(e, p)),
                            d.c = p,
                            d.b = a + p + 16,
                            d.crc = e.crc,
                            d.size = e.size,
                            u && d.r(),
                            u = 1) : u && c())
                        }
                        ,
                        this.u.push(d)
                    }
                    ,
                    e.prototype.end = function() {
                        var e = this;
                        if (2 & this.d) {
                            if (1 & this.d)
                                throw "stream finishing";
                            throw "stream finished"
                        }
                        this.d ? this.e() : this.u.push({
                            r: function() {
                                1 & e.d && (e.u.splice(-1, 1),
                                e.e())
                            },
                            t: function() {}
                        }),
                        this.d = 3
                    }
                    ,
                    e.prototype.e = function() {
                        for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++)
                            n += 46 + (c = i[r]).f.length;
                        for (var a = new o(n + 22), s = 0, l = this.u; s < l.length; s++) {
                            var c = l[s];
                            ct(a, e, c, c.f, c.u, c.c, t),
                            e += 46 + c.f.length,
                            t += c.b
                        }
                        ut(a, e, this.u.length, n, t),
                        this.ondata(null, a, !0),
                        this.d = 2
                    }
                    ,
                    e.prototype.terminate = function() {
                        for (var e = 0, t = this.u; e < t.length; e++)
                            t[e].t();
                        this.d = 2
                    }
                    ,
                    e
                }();
                function mt(e, t, n) {
                    if (n || (n = t,
                    t = {}),
                    "function" != typeof n)
                        throw "no callback";
                    var r = {};
                    Je(e, "", r, t);
                    var i = Object.keys(r)
                      , a = i.length
                      , s = 0
                      , l = 0
                      , c = a
                      , u = new Array(a)
                      , h = []
                      , d = function() {
                        for (var e = 0; e < h.length; ++e)
                            h[e]()
                    }
                      , p = function() {
                        var e = new o(l + 22)
                          , t = s
                          , r = l - s;
                        l = 0;
                        for (var i = 0; i < c; ++i) {
                            var a = u[i];
                            try {
                                var h = a.c.length;
                                ct(e, l, a, a.f, a.u, h);
                                var d = l + 30 + a.f.length;
                                e.set(a.c, d),
                                ct(e, s, a, a.f, a.u, h, l),
                                s += 46 + a.f.length,
                                l = d + h
                            } catch (e) {
                                return n(e, null)
                            }
                        }
                        ut(e, s, u.length, r, t),
                        n(null, e)
                    };
                    a || p();
                    for (var f = function(e) {
                        var t = i[e]
                          , o = r[t]
                          , c = o[0]
                          , f = o[1]
                          , m = X()
                          , g = c.length;
                        m.p(c);
                        var v = rt(t)
                          , y = v.length
                          , _ = 0 == f.level ? 0 : 8
                          , x = function(r, i) {
                            if (r)
                                d(),
                                n(r, null);
                            else {
                                var o = i.length;
                                u[e] = J(f, {
                                    size: g,
                                    crc: m.d(),
                                    c: i,
                                    f: v,
                                    u: y != t.length,
                                    compression: _
                                }),
                                s += 30 + y + o,
                                l += 76 + 2 * y + o,
                                --a || p()
                            }
                        };
                        if (y > 65535 && x("filename too long", null),
                        _)
                            if (g < 16e4)
                                try {
                                    x(null, Te(c, f))
                                } catch (e) {
                                    x(e, null)
                                }
                            else
                                h.push(Se(c, f, x));
                        else
                            x(null, c)
                    }, m = 0; m < c; ++m)
                        f(m);
                    return d
                }
                function gt(e, t) {
                    void 0 === t && (t = {});
                    var n = {}
                      , r = [];
                    Je(e, "", n, t);
                    var i = 0
                      , a = 0;
                    for (var s in n) {
                        var l = n[s]
                          , c = l[0]
                          , u = l[1]
                          , h = 0 == u.level ? 0 : 8
                          , d = (x = rt(s)).length;
                        if (d > 65535)
                            throw "filename too long";
                        var p = h ? Te(c, u) : c
                          , f = p.length
                          , m = X();
                        m.p(c),
                        r.push(J(u, {
                            size: c.length,
                            crc: m.d(),
                            c: p,
                            f: x,
                            u: d != s.length,
                            o: i,
                            compression: h
                        })),
                        i += 30 + d + f,
                        a += 76 + 2 * d + f
                    }
                    for (var g = new o(a + 22), v = i, y = a - i, _ = 0; _ < r.length; ++_) {
                        var x = r[_];
                        ct(g, x.o, x, x.f, x.u, x.c.length),
                        g.set(x.c, x.o + 30 + x.f.length),
                        ct(g, i, x, x.f, x.u, x.c.length, x.o),
                        i += 46 + x.f.length
                    }
                    return ut(g, i, r.length, y, v),
                    g
                }
                var vt = function() {
                    function e() {}
                    return e.prototype.push = function(e, t) {
                        this.ondata(null, e, t)
                    }
                    ,
                    e.compression = 0,
                    e
                }()
                  , yt = function() {
                    function e() {
                        var e = this;
                        this.i = new Ee((function(t, n) {
                            e.ondata(null, t, n)
                        }
                        ))
                    }
                    return e.prototype.push = function(e, t) {
                        try {
                            this.i.push(e, t)
                        } catch (n) {
                            this.ondata(n, e, t)
                        }
                    }
                    ,
                    e.compression = 8,
                    e
                }()
                  , _t = function() {
                    function e() {
                        var e = this;
                        this.i = new Ae((function(t, n, r) {
                            e.ondata(t, n, r)
                        }
                        )),
                        this.terminate = this.i.terminate
                    }
                    return e.prototype.push = function(e, t) {
                        this.i.push(O(e, 0), t)
                    }
                    ,
                    e.compression = 8,
                    e
                }()
                  , xt = function() {
                    function e(e) {
                        this.onfile = e,
                        this.k = [],
                        this.o = {
                            0: vt
                        },
                        this.p = V
                    }
                    return e.prototype.push = function(e, t) {
                        var n = this
                          , r = -1 == this.c && this.d;
                        if (this.c && !r) {
                            var i = Math.min(this.c, e.length)
                              , a = e.subarray(0, i);
                            this.c -= i,
                            this.d ? this.d.push(a, !this.c) : this.k[0].push([a, !this.c]),
                            e = e.subarray(i)
                        }
                        if (r || !this.c) {
                            var s = 0
                              , l = 0
                              , c = void 0
                              , u = void 0
                              , h = e.length
                              , d = this.p.length
                              , p = h + d;
                            if (h)
                                d ? ((u = new Uint8Array(p)).set(this.p),
                                u.set(e, this.p.length)) : u = e;
                            else {
                                if (!d)
                                    return;
                                u = this.p
                            }
                            this.p = V;
                            for (var f = function() {
                                if (67324752 == de(u, l)) {
                                    s = 1,
                                    r && r.push(V, !0),
                                    m.d = null,
                                    m.c = 0;
                                    var e = he(u, l + 6)
                                      , t = he(u, l + 8)
                                      , i = 2048 & e
                                      , a = 8 & e
                                      , h = he(u, l + 26)
                                      , d = he(u, l + 28);
                                    if (p > l + 30 + h + d) {
                                        var f = [];
                                        m.k.unshift(f),
                                        s = 2,
                                        c = l;
                                        var g = de(u, l + 18)
                                          , v = it(u.subarray(l + 30, l += 30 + h), !i);
                                        if (a && (g = -1),
                                        4294967295 == g && (g = lt(u, l)[0]),
                                        !m.o[t])
                                            return m.onfile("unknown compression type " + t, v, null),
                                            "break";
                                        m.c = g;
                                        var y = {
                                            start: function() {
                                                if (!y.ondata)
                                                    throw "no callback";
                                                if (g) {
                                                    var e = new n.o[t];
                                                    e.ondata = function(e, t, n) {
                                                        y.ondata(e, t, n)
                                                    }
                                                    ;
                                                    for (var r = 0, i = f; r < i.length; r++) {
                                                        var a = i[r]
                                                          , s = a[0]
                                                          , l = a[1];
                                                        e.push(s, l)
                                                    }
                                                    n.k[0] == f && (n.d = e)
                                                } else
                                                    y.ondata(null, new o(0), !0)
                                            },
                                            terminate: function() {
                                                n.k[0] == f && n.d.terminate && n.d.terminate()
                                            }
                                        };
                                        m.onfile(null, v, y),
                                        l += d
                                    }
                                    return "break"
                                }
                            }, m = this; l < p && "break" !== f(); ++l)
                                ;
                            if (r && r.push(2 == s ? u.subarray(0, c - 12 - (134695760 == de(u, c - 12) && 4)) : u.subarray(0, l), !!s),
                            2 & s)
                                return this.push(u.subarray(l), t);
                            if (1 & s && (this.p = u),
                            t && (s || this.c))
                                throw "invalid zip file"
                        }
                    }
                    ,
                    e.prototype.register = function(e) {
                        this.o[e.compression] = e
                    }
                    ,
                    e
                }();
                function bt(e, t) {
                    if ("function" != typeof t)
                        throw "no callback";
                    for (var n = [], r = function() {
                        for (var e = 0; e < n.length; ++e)
                            n[e]()
                    }, i = {}, a = e.length - 22; 101010256 != de(e, a); --a)
                        if (!a || e.length - a > 65558)
                            return void t("invalid zip file", null);
                    var s = he(e, a + 8);
                    s || t(null, {});
                    var l = s
                      , c = de(e, a + 16)
                      , u = 4294967295 == c;
                    if (u) {
                        if (a = de(e, a - 12),
                        101075792 != de(e, a))
                            return void t("invalid zip file", null);
                        l = s = de(e, a + 32),
                        c = de(e, a + 48)
                    }
                    for (var h = function(a) {
                        var l = st(e, c, u)
                          , h = l[0]
                          , d = l[1]
                          , p = l[2]
                          , f = l[3]
                          , m = l[4]
                          , g = l[5]
                          , v = ot(e, g);
                        c = m;
                        var y = function(e, n) {
                            e ? (r(),
                            t(e, null)) : (i[f] = n,
                            --s || t(null, i))
                        };
                        if (h)
                            if (8 == h) {
                                var _ = e.subarray(v, v + d);
                                if (d < 32e4)
                                    try {
                                        y(null, Pe(_, new o(p)))
                                    } catch (e) {
                                        y(e, null)
                                    }
                                else
                                    n.push(Ce(_, {
                                        size: p
                                    }, y))
                            } else
                                y("unknown compression type " + h, null);
                        else
                            y(null, O(e, v, v + d))
                    }, d = 0; d < l; ++d)
                        h();
                    return r
                }
                function wt(e) {
                    for (var t = {}, n = e.length - 22; 101010256 != de(e, n); --n)
                        if (!n || e.length - n > 65558)
                            throw "invalid zip file";
                    var r = he(e, n + 8);
                    if (!r)
                        return {};
                    var i = de(e, n + 16)
                      , a = 4294967295 == i;
                    if (a) {
                        if (n = de(e, n - 12),
                        101075792 != de(e, n))
                            throw "invalid zip file";
                        r = de(e, n + 32),
                        i = de(e, n + 48)
                    }
                    for (var s = 0; s < r; ++s) {
                        var l = st(e, i, a)
                          , c = l[0]
                          , u = l[1]
                          , h = l[2]
                          , d = l[3]
                          , p = l[4]
                          , f = l[5]
                          , m = ot(e, f);
                        if (i = p,
                        c) {
                            if (8 != c)
                                throw "unknown compression type " + c;
                            t[d] = Pe(e.subarray(m, m + u), new o(h))
                        } else
                            t[d] = O(e, m, m + u)
                    }
                    return t
                }
                var Mt = function(e) {
                    i.DataTextureLoader.call(this, e),
                    this.type = i.FloatType
                };
                Mt.prototype = Object.assign(Object.create(i.DataTextureLoader.prototype), {
                    constructor: Mt,
                    parse: function(e) {
                        const t = 65536
                          , n = 14
                          , a = 65537
                          , o = Math.pow(2.7182818, 2.2);
                        var s = new DataView(new ArrayBuffer(8));
                        function l(e) {
                            if (0 === e)
                                return [e, 0];
                            s.setFloat64(0, e);
                            var t = s.getUint32(0) >>> 20 & 2047;
                            0 === t && (s.setFloat64(0, e * Math.pow(2, 64)),
                            t = (s.getUint32(0) >>> 20 & 2047) - 64);
                            var n = t - 1022
                              , r = function(e, t) {
                                for (var n = Math.min(3, Math.ceil(Math.abs(t) / 1023)), r = e, i = 0; i < n; i++)
                                    r *= Math.pow(2, Math.floor((t + i) / n));
                                return r
                            }(e, -n);
                            return [r, n]
                        }
                        const c = {
                            l: 0,
                            c: 0,
                            lc: 0
                        };
                        function u(e, t, n, r, i) {
                            for (; n < e; )
                                t = t << 8 | k(r, i),
                                n += 8;
                            n -= e,
                            c.l = t >> n & (1 << e) - 1,
                            c.c = t,
                            c.lc = n
                        }
                        const h = new Array(59);
                        function d(e) {
                            return 63 & e
                        }
                        function p(e) {
                            return e >> 6
                        }
                        const f = {
                            c: 0,
                            lc: 0
                        };
                        function m(e, t, n, r) {
                            e = e << 8 | k(n, r),
                            t += 8,
                            f.c = e,
                            f.lc = t
                        }
                        const g = {
                            c: 0,
                            lc: 0
                        };
                        function v(e, t, n, r, i, a, o, s, l, c) {
                            if (e == t) {
                                r < 8 && (m(n, r, i, o),
                                n = f.c,
                                r = f.lc);
                                var u = n >> (r -= 8);
                                if (u = new Uint8Array([u])[0],
                                l.value + u > c)
                                    return !1;
                                for (var h = s[l.value - 1]; u-- > 0; )
                                    s[l.value++] = h
                            } else {
                                if (!(l.value < c))
                                    return !1;
                                s[l.value++] = e
                            }
                            g.c = n,
                            g.lc = r
                        }
                        function y(e) {
                            return 65535 & e
                        }
                        function _(e) {
                            var t = y(e);
                            return t > 32767 ? t - 65536 : t
                        }
                        const x = {
                            a: 0,
                            b: 0
                        };
                        function b(e, t) {
                            var n = _(e)
                              , r = _(t)
                              , i = n + (1 & r) + (r >> 1)
                              , a = i
                              , o = i - r;
                            x.a = a,
                            x.b = o
                        }
                        function w(e, t) {
                            var n = y(e)
                              , r = y(t)
                              , i = n - (r >> 1) & 65535
                              , a = r + i - 32768 & 65535;
                            x.a = a,
                            x.b = i
                        }
                        function M(e, t, n, r, i, a, o) {
                            for (var s, l = o < 16384, c = n > i ? i : n, u = 1; u <= c; )
                                u <<= 1;
                            for (s = u >>= 1,
                            u >>= 1; u >= 1; ) {
                                for (var h, d, p, f, m = 0, g = m + a * (i - s), v = a * u, y = a * s, _ = r * u, M = r * s; m <= g; m += y) {
                                    for (var S = m, T = m + r * (n - s); S <= T; S += M) {
                                        var E = S + _
                                          , A = (C = S + v) + _;
                                        l ? (b(e[S + t], e[C + t]),
                                        h = x.a,
                                        p = x.b,
                                        b(e[E + t], e[A + t]),
                                        d = x.a,
                                        f = x.b,
                                        b(h, d),
                                        e[S + t] = x.a,
                                        e[E + t] = x.b,
                                        b(p, f),
                                        e[C + t] = x.a,
                                        e[A + t] = x.b) : (w(e[S + t], e[C + t]),
                                        h = x.a,
                                        p = x.b,
                                        w(e[E + t], e[A + t]),
                                        d = x.a,
                                        f = x.b,
                                        w(h, d),
                                        e[S + t] = x.a,
                                        e[E + t] = x.b,
                                        w(p, f),
                                        e[C + t] = x.a,
                                        e[A + t] = x.b)
                                    }
                                    if (n & u) {
                                        var C = S + v;
                                        l ? b(e[S + t], e[C + t]) : w(e[S + t], e[C + t]),
                                        h = x.a,
                                        e[C + t] = x.b,
                                        e[S + t] = h
                                    }
                                }
                                if (i & u)
                                    for (S = m,
                                    T = m + r * (n - s); S <= T; S += M)
                                        E = S + _,
                                        l ? b(e[S + t], e[E + t]) : w(e[S + t], e[E + t]),
                                        h = x.a,
                                        e[E + t] = x.b,
                                        e[S + t] = h;
                                s = u,
                                u >>= 1
                            }
                            return m
                        }
                        function S(e, t, r, i, o, s) {
                            var l = r.value
                              , y = B(t, r)
                              , _ = B(t, r);
                            r.value += 4;
                            var x = B(t, r);
                            if (r.value += 4,
                            y < 0 || y >= a || _ < 0 || _ >= a)
                                throw "Something wrong with HUF_ENCSIZE";
                            var b = new Array(a)
                              , w = new Array(16384);
                            if (function(e) {
                                for (var t = 0; t < 16384; t++)
                                    e[t] = {},
                                    e[t].len = 0,
                                    e[t].lit = 0,
                                    e[t].p = null
                            }(w),
                            function(e, t, n, r, i, o, s) {
                                for (var l = n, d = 0, p = 0; i <= o; i++) {
                                    if (l.value - n.value > r)
                                        return !1;
                                    u(6, d, p, e, l);
                                    var f = c.l;
                                    if (d = c.c,
                                    p = c.lc,
                                    s[i] = f,
                                    63 == f) {
                                        if (l.value - n.value > r)
                                            throw "Something wrong with hufUnpackEncTable";
                                        u(8, d, p, e, l);
                                        var m = c.l + 6;
                                        if (d = c.c,
                                        p = c.lc,
                                        i + m > o + 1)
                                            throw "Something wrong with hufUnpackEncTable";
                                        for (; m--; )
                                            s[i++] = 0;
                                        i--
                                    } else if (f >= 59) {
                                        if (i + (m = f - 59 + 2) > o + 1)
                                            throw "Something wrong with hufUnpackEncTable";
                                        for (; m--; )
                                            s[i++] = 0;
                                        i--
                                    }
                                }
                                !function(e) {
                                    for (var t = 0; t <= 58; ++t)
                                        h[t] = 0;
                                    for (t = 0; t < a; ++t)
                                        h[e[t]] += 1;
                                    var n = 0;
                                    for (t = 58; t > 0; --t) {
                                        var r = n + h[t] >> 1;
                                        h[t] = n,
                                        n = r
                                    }
                                    for (t = 0; t < a; ++t) {
                                        var i = e[t];
                                        i > 0 && (e[t] = i | h[i]++ << 6)
                                    }
                                }(s)
                            }(e, 0, r, i - (r.value - l), y, _, b),
                            x > 8 * (i - (r.value - l)))
                                throw "Something wrong with hufUncompress";
                            !function(e, t, r, i) {
                                for (; t <= r; t++) {
                                    var a = p(e[t])
                                      , o = d(e[t]);
                                    if (a >> o)
                                        throw "Invalid table entry";
                                    if (o > n) {
                                        if ((u = i[a >> o - n]).len)
                                            throw "Invalid table entry";
                                        if (u.lit++,
                                        u.p) {
                                            var s = u.p;
                                            u.p = new Array(u.lit);
                                            for (var l = 0; l < u.lit - 1; ++l)
                                                u.p[l] = s[l]
                                        } else
                                            u.p = new Array(1);
                                        u.p[u.lit - 1] = t
                                    } else if (o) {
                                        var c = 0;
                                        for (l = 1 << n - o; l > 0; l--) {
                                            var u;
                                            if ((u = i[(a << n - o) + c]).len || u.p)
                                                throw "Invalid table entry";
                                            u.len = o,
                                            u.lit = t,
                                            c++
                                        }
                                    }
                                }
                            }(b, y, _, w),
                            function(e, t, r, i, a, o, s, l, c, u) {
                                for (var h = 0, y = 0, _ = l, x = Math.trunc(a.value + (o + 7) / 8); a.value < x; )
                                    for (m(h, y, r, a),
                                    h = f.c,
                                    y = f.lc; y >= n; )
                                        if ((S = t[h >> y - n & 16383]).len)
                                            y -= S.len,
                                            v(S.lit, s, h, y, r, 0, a, c, u, _),
                                            h = g.c,
                                            y = g.lc;
                                        else {
                                            if (!S.p)
                                                throw "hufDecode issues";
                                            var b;
                                            for (b = 0; b < S.lit; b++) {
                                                for (var w = d(e[S.p[b]]); y < w && a.value < x; )
                                                    m(h, y, r, a),
                                                    h = f.c,
                                                    y = f.lc;
                                                if (y >= w && p(e[S.p[b]]) == (h >> y - w & (1 << w) - 1)) {
                                                    y -= w,
                                                    v(S.p[b], s, h, y, r, 0, a, c, u, _),
                                                    h = g.c,
                                                    y = g.lc;
                                                    break
                                                }
                                            }
                                            if (b == S.lit)
                                                throw "hufDecode issues"
                                        }
                                var M = 8 - o & 7;
                                for (h >>= M,
                                y -= M; y > 0; ) {
                                    var S;
                                    if (!(S = t[h << n - y & 16383]).len)
                                        throw "hufDecode issues";
                                    y -= S.len,
                                    v(S.lit, s, h, y, r, 0, a, c, u, _),
                                    h = g.c,
                                    y = g.lc
                                }
                            }(b, w, e, 0, r, x, _, s, o, {
                                value: 0
                            })
                        }
                        function T(e) {
                            for (var t = 1; t < e.length; t++) {
                                var n = e[t - 1] + e[t] - 128;
                                e[t] = n
                            }
                        }
                        function E(e, t) {
                            for (var n = 0, r = Math.floor((e.length + 1) / 2), i = 0, a = e.length - 1; !(i > a || (t[i++] = e[n++],
                            i > a)); )
                                t[i++] = e[r++]
                        }
                        function A(e) {
                            for (var t = e.byteLength, n = new Array, r = 0, i = new DataView(e); t > 0; ) {
                                var a = i.getInt8(r++);
                                if (a < 0) {
                                    t -= 1 + (s = -a);
                                    for (var o = 0; o < s; o++)
                                        n.push(i.getUint8(r++))
                                } else {
                                    var s = a;
                                    t -= 2;
                                    var l = i.getUint8(r++);
                                    for (o = 0; o < s + 1; o++)
                                        n.push(l)
                                }
                            }
                            return n
                        }
                        function C(e, t, n) {
                            for (var r, i = 1; i < 64; )
                                65280 == (r = t[e.value]) ? i = 64 : r >> 8 == 255 ? i += 255 & r : (n[i] = r,
                                i++),
                                e.value++
                        }
                        function P(e) {
                            const t = .5 * Math.cos(.7853975)
                              , n = .5 * Math.cos(3.14159 / 16)
                              , r = .5 * Math.cos(3.14159 / 8)
                              , i = .5 * Math.cos(3 * 3.14159 / 16)
                              , a = .5 * Math.cos(.981746875)
                              , o = .5 * Math.cos(3 * 3.14159 / 8)
                              , s = .5 * Math.cos(1.374445625);
                            for (var l = new Array(4), c = new Array(4), u = new Array(4), h = new Array(4), d = 0; d < 8; ++d) {
                                var p = 8 * d;
                                l[0] = r * e[p + 2],
                                l[1] = o * e[p + 2],
                                l[2] = r * e[p + 6],
                                l[3] = o * e[p + 6],
                                c[0] = n * e[p + 1] + i * e[p + 3] + a * e[p + 5] + s * e[p + 7],
                                c[1] = i * e[p + 1] - s * e[p + 3] - n * e[p + 5] - a * e[p + 7],
                                c[2] = a * e[p + 1] - n * e[p + 3] + s * e[p + 5] + i * e[p + 7],
                                c[3] = s * e[p + 1] - a * e[p + 3] + i * e[p + 5] - n * e[p + 7],
                                u[0] = t * (e[p + 0] + e[p + 4]),
                                u[3] = t * (e[p + 0] - e[p + 4]),
                                u[1] = l[0] + l[3],
                                u[2] = l[1] - l[2],
                                h[0] = u[0] + u[1],
                                h[1] = u[3] + u[2],
                                h[2] = u[3] - u[2],
                                h[3] = u[0] - u[1],
                                e[p + 0] = h[0] + c[0],
                                e[p + 1] = h[1] + c[1],
                                e[p + 2] = h[2] + c[2],
                                e[p + 3] = h[3] + c[3],
                                e[p + 4] = h[3] - c[3],
                                e[p + 5] = h[2] - c[2],
                                e[p + 6] = h[1] - c[1],
                                e[p + 7] = h[0] - c[0]
                            }
                            for (var f = 0; f < 8; ++f)
                                l[0] = r * e[16 + f],
                                l[1] = o * e[16 + f],
                                l[2] = r * e[48 + f],
                                l[3] = o * e[48 + f],
                                c[0] = n * e[8 + f] + i * e[24 + f] + a * e[40 + f] + s * e[56 + f],
                                c[1] = i * e[8 + f] - s * e[24 + f] - n * e[40 + f] - a * e[56 + f],
                                c[2] = a * e[8 + f] - n * e[24 + f] + s * e[40 + f] + i * e[56 + f],
                                c[3] = s * e[8 + f] - a * e[24 + f] + i * e[40 + f] - n * e[56 + f],
                                u[0] = t * (e[f] + e[32 + f]),
                                u[3] = t * (e[f] - e[32 + f]),
                                u[1] = l[0] + l[3],
                                u[2] = l[1] - l[2],
                                h[0] = u[0] + u[1],
                                h[1] = u[3] + u[2],
                                h[2] = u[3] - u[2],
                                h[3] = u[0] - u[1],
                                e[0 + f] = h[0] + c[0],
                                e[8 + f] = h[1] + c[1],
                                e[16 + f] = h[2] + c[2],
                                e[24 + f] = h[3] + c[3],
                                e[32 + f] = h[3] - c[3],
                                e[40 + f] = h[2] - c[2],
                                e[48 + f] = h[1] - c[1],
                                e[56 + f] = h[0] - c[0]
                        }
                        function R(e) {
                            for (var t = 0; t < 64; ++t) {
                                var n = e[0][t]
                                  , r = e[1][t]
                                  , i = e[2][t];
                                e[0][t] = n + 1.5747 * i,
                                e[1][t] = n - .1873 * r - .4682 * i,
                                e[2][t] = n + 1.8556 * r
                            }
                        }
                        function L(e, t, n) {
                            for (var r = 0; r < 64; ++r)
                                t[n + r] = i.DataUtils.toHalfFloat((a = e[r]) <= 1 ? Math.sign(a) * Math.pow(Math.abs(a), 2.2) : Math.sign(a) * Math.pow(o, Math.abs(a) - 1));
                            var a
                        }
                        function D(e) {
                            var t = e.array.slice(e.offset.value, e.offset.value + e.size);
                            void 0 === r && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                            var n = We(t)
                              , i = new Uint8Array(n.length);
                            return T(n),
                            E(n, i),
                            new DataView(i.buffer)
                        }
                        function O(e) {
                            var t = e.viewer
                              , n = {
                                value: e.offset.value
                            }
                              , r = new Uint8Array(e.width * e.lines * (X.channels.length * e.type * 2))
                              , i = {
                                version: U(t, n),
                                unknownUncompressedSize: U(t, n),
                                unknownCompressedSize: U(t, n),
                                acCompressedSize: U(t, n),
                                dcCompressedSize: U(t, n),
                                rleCompressedSize: U(t, n),
                                rleUncompressedSize: U(t, n),
                                rleRawSize: U(t, n),
                                totalAcUncompressedCount: U(t, n),
                                totalDcUncompressedCount: U(t, n),
                                acCompression: U(t, n)
                            };
                            if (i.version < 2)
                                throw "EXRLoader.parse: " + X.compression + " version " + i.version + " is unsupported";
                            for (var a = new Array, o = j(t, n) - 2; o > 0; ) {
                                var s = F(t.buffer, n)
                                  , l = z(t, n)
                                  , c = l >> 2 & 3
                                  , u = new Int8Array([(l >> 4) - 1])[0]
                                  , h = z(t, n);
                                a.push({
                                    name: s,
                                    index: u,
                                    type: h,
                                    compression: c
                                }),
                                o -= s.length + 3
                            }
                            for (var d = X.channels, p = new Array(e.channels), f = 0; f < e.channels; ++f) {
                                var m = p[f] = {}
                                  , g = d[f];
                                m.name = g.name,
                                m.compression = 0,
                                m.decoded = !1,
                                m.type = g.pixelType,
                                m.pLinear = g.pLinear,
                                m.width = e.width,
                                m.height = e.lines
                            }
                            for (var v = {
                                idx: new Array(3)
                            }, y = 0; y < e.channels; ++y)
                                for (m = p[y],
                                f = 0; f < a.length; ++f) {
                                    var _ = a[f];
                                    m.name == _.name && (m.compression = _.compression,
                                    _.index >= 0 && (v.idx[_.index] = y),
                                    m.offset = y)
                                }
                            if (i.acCompressedSize > 0)
                                switch (i.acCompression) {
                                case 0:
                                    var x = new Uint16Array(i.totalAcUncompressedCount);
                                    S(e.array, t, n, i.acCompressedSize, x, i.totalAcUncompressedCount);
                                    break;
                                case 1:
                                    var b = We(e.array.slice(n.value, n.value + i.totalAcUncompressedCount));
                                    x = new Uint16Array(b.buffer),
                                    n.value += i.totalAcUncompressedCount
                                }
                            if (i.dcCompressedSize > 0) {
                                var w = {
                                    array: e.array,
                                    offset: n,
                                    size: i.dcCompressedSize
                                }
                                  , M = new Uint16Array(D(w).buffer);
                                n.value += i.dcCompressedSize
                            }
                            if (i.rleRawSize > 0) {
                                var T = A((b = We(e.array.slice(n.value, n.value + i.rleCompressedSize))).buffer);
                                n.value += i.rleCompressedSize
                            }
                            var E = 0
                              , O = new Array(p.length);
                            for (f = 0; f < O.length; ++f)
                                O[f] = new Array;
                            for (var I = 0; I < e.lines; ++I)
                                for (var N = 0; N < p.length; ++N)
                                    O[N].push(E),
                                    E += p[N].width * e.type * 2;
                            for (function(e, t, n, r, i, a) {
                                var o, s, l = new DataView(a.buffer), c = n[e.idx[0]].width, u = n[e.idx[0]].height, h = Math.floor(c / 8), d = Math.ceil(c / 8), p = Math.ceil(u / 8), f = c - 8 * (d - 1), m = u - 8 * (p - 1), g = {
                                    value: 0
                                }, v = new Array(3), y = new Array(3), _ = new Array(3), x = new Array(3), b = new Array(3);
                                for (let n = 0; n < 3; ++n)
                                    b[n] = t[e.idx[n]],
                                    v[n] = n < 1 ? 0 : v[n - 1] + d * p,
                                    y[n] = new Float32Array(64),
                                    _[n] = new Uint16Array(64),
                                    x[n] = new Uint16Array(64 * d);
                                for (let t = 0; t < p; ++t) {
                                    var w = 8;
                                    t == p - 1 && (w = m);
                                    var M = 8;
                                    for (let e = 0; e < d; ++e) {
                                        e == d - 1 && (M = f);
                                        for (let e = 0; e < 3; ++e)
                                            _[e].fill(0),
                                            _[e][0] = i[v[e]++],
                                            C(g, r, _[e]),
                                            o = _[e],
                                            (s = y[e])[0] = G(o[0]),
                                            s[1] = G(o[1]),
                                            s[2] = G(o[5]),
                                            s[3] = G(o[6]),
                                            s[4] = G(o[14]),
                                            s[5] = G(o[15]),
                                            s[6] = G(o[27]),
                                            s[7] = G(o[28]),
                                            s[8] = G(o[2]),
                                            s[9] = G(o[4]),
                                            s[10] = G(o[7]),
                                            s[11] = G(o[13]),
                                            s[12] = G(o[16]),
                                            s[13] = G(o[26]),
                                            s[14] = G(o[29]),
                                            s[15] = G(o[42]),
                                            s[16] = G(o[3]),
                                            s[17] = G(o[8]),
                                            s[18] = G(o[12]),
                                            s[19] = G(o[17]),
                                            s[20] = G(o[25]),
                                            s[21] = G(o[30]),
                                            s[22] = G(o[41]),
                                            s[23] = G(o[43]),
                                            s[24] = G(o[9]),
                                            s[25] = G(o[11]),
                                            s[26] = G(o[18]),
                                            s[27] = G(o[24]),
                                            s[28] = G(o[31]),
                                            s[29] = G(o[40]),
                                            s[30] = G(o[44]),
                                            s[31] = G(o[53]),
                                            s[32] = G(o[10]),
                                            s[33] = G(o[19]),
                                            s[34] = G(o[23]),
                                            s[35] = G(o[32]),
                                            s[36] = G(o[39]),
                                            s[37] = G(o[45]),
                                            s[38] = G(o[52]),
                                            s[39] = G(o[54]),
                                            s[40] = G(o[20]),
                                            s[41] = G(o[22]),
                                            s[42] = G(o[33]),
                                            s[43] = G(o[38]),
                                            s[44] = G(o[46]),
                                            s[45] = G(o[51]),
                                            s[46] = G(o[55]),
                                            s[47] = G(o[60]),
                                            s[48] = G(o[21]),
                                            s[49] = G(o[34]),
                                            s[50] = G(o[37]),
                                            s[51] = G(o[47]),
                                            s[52] = G(o[50]),
                                            s[53] = G(o[56]),
                                            s[54] = G(o[59]),
                                            s[55] = G(o[61]),
                                            s[56] = G(o[35]),
                                            s[57] = G(o[36]),
                                            s[58] = G(o[48]),
                                            s[59] = G(o[49]),
                                            s[60] = G(o[57]),
                                            s[61] = G(o[58]),
                                            s[62] = G(o[62]),
                                            s[63] = G(o[63]),
                                            P(y[e]);
                                        R(y);
                                        for (let t = 0; t < 3; ++t)
                                            L(y[t], x[t], 64 * e)
                                    }
                                    let a = 0;
                                    for (let r = 0; r < 3; ++r) {
                                        const i = n[e.idx[r]].type;
                                        for (let e = 8 * t; e < 8 * t + w; ++e) {
                                            a = b[r][e];
                                            for (let t = 0; t < h; ++t) {
                                                const n = 64 * t + 8 * (7 & e);
                                                l.setUint16(a + 0 * i, x[r][n + 0], !0),
                                                l.setUint16(a + 2 * i, x[r][n + 1], !0),
                                                l.setUint16(a + 4 * i, x[r][n + 2], !0),
                                                l.setUint16(a + 6 * i, x[r][n + 3], !0),
                                                l.setUint16(a + 8 * i, x[r][n + 4], !0),
                                                l.setUint16(a + 10 * i, x[r][n + 5], !0),
                                                l.setUint16(a + 12 * i, x[r][n + 6], !0),
                                                l.setUint16(a + 14 * i, x[r][n + 7], !0),
                                                a += 16 * i
                                            }
                                        }
                                        if (h != d)
                                            for (let e = 8 * t; e < 8 * t + w; ++e) {
                                                const t = b[r][e] + 8 * h * 2 * i
                                                  , n = 64 * h + 8 * (7 & e);
                                                for (let e = 0; e < M; ++e)
                                                    l.setUint16(t + 2 * e * i, x[r][n + e], !0)
                                            }
                                    }
                                }
                                for (var S = new Uint16Array(c), T = (l = new DataView(a.buffer),
                                0); T < 3; ++T) {
                                    n[e.idx[T]].decoded = !0;
                                    var E = n[e.idx[T]].type;
                                    if (2 == n[T].type)
                                        for (var A = 0; A < u; ++A) {
                                            const e = b[T][A];
                                            for (var D = 0; D < c; ++D)
                                                S[D] = l.getUint16(e + 2 * D * E, !0);
                                            for (D = 0; D < c; ++D)
                                                l.setFloat32(e + 2 * D * E, G(S[D]), !0)
                                        }
                                }
                            }(v, O, p, x, M, r),
                            f = 0; f < p.length; ++f)
                                if (!(m = p[f]).decoded) {
                                    if (2 !== m.compression)
                                        throw "EXRLoader.parse: unsupported channel compression";
                                    var B = 0
                                      , k = 0;
                                    for (I = 0; I < e.lines; ++I) {
                                        for (var H = O[f][B], V = 0; V < m.width; ++V) {
                                            for (var W = 0; W < 2 * m.type; ++W)
                                                r[H++] = T[k + W * m.width * m.height];
                                            k++
                                        }
                                        B++
                                    }
                                }
                            return new DataView(r.buffer)
                        }
                        function F(e, t) {
                            for (var n = new Uint8Array(e), r = 0; 0 != n[t.value + r]; )
                                r += 1;
                            var i = (new TextDecoder).decode(n.slice(t.value, t.value + r));
                            return t.value = t.value + r + 1,
                            i
                        }
                        function I(e, t) {
                            var n = e.getUint32(0, !0);
                            return t.value = t.value + 8,
                            n
                        }
                        function N(e, t) {
                            var n = e.getInt32(t.value, !0);
                            return t.value = t.value + 4,
                            n
                        }
                        function B(e, t) {
                            var n = e.getUint32(t.value, !0);
                            return t.value = t.value + 4,
                            n
                        }
                        function k(e, t) {
                            var n = e[t.value];
                            return t.value = t.value + 1,
                            n
                        }
                        function z(e, t) {
                            var n = e.getUint8(t.value);
                            return t.value = t.value + 1,
                            n
                        }
                        function U(e, t) {
                            var n = Number(e.getBigInt64(t.value, !0));
                            return t.value += 8,
                            n
                        }
                        function H(e, t) {
                            var n = e.getFloat32(t.value, !0);
                            return t.value += 4,
                            n
                        }
                        function G(e) {
                            var t = (31744 & e) >> 10
                              , n = 1023 & e;
                            return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
                        }
                        function j(e, t) {
                            var n = e.getUint16(t.value, !0);
                            return t.value += 2,
                            n
                        }
                        function V(e, t, n, r, i) {
                            return "string" === r || "stringvector" === r || "iccProfile" === r ? function(e, t, n) {
                                var r = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + n));
                                return t.value = t.value + n,
                                r
                            }(t, n, i) : "chlist" === r ? function(e, t, n, r) {
                                for (var i = n.value, a = []; n.value < i + r - 1; ) {
                                    var o = F(t, n)
                                      , s = N(e, n)
                                      , l = z(e, n);
                                    n.value += 3;
                                    var c = N(e, n)
                                      , u = N(e, n);
                                    a.push({
                                        name: o,
                                        pixelType: s,
                                        pLinear: l,
                                        xSampling: c,
                                        ySampling: u
                                    })
                                }
                                return n.value += 1,
                                a
                            }(e, t, n, i) : "chromaticities" === r ? function(e, t) {
                                return {
                                    redX: H(e, t),
                                    redY: H(e, t),
                                    greenX: H(e, t),
                                    greenY: H(e, t),
                                    blueX: H(e, t),
                                    blueY: H(e, t),
                                    whiteX: H(e, t),
                                    whiteY: H(e, t)
                                }
                            }(e, n) : "compression" === r ? function(e, t) {
                                return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][z(e, t)]
                            }(e, n) : "box2i" === r ? function(e, t) {
                                return {
                                    xMin: B(e, t),
                                    yMin: B(e, t),
                                    xMax: B(e, t),
                                    yMax: B(e, t)
                                }
                            }(e, n) : "lineOrder" === r ? function(e, t) {
                                return ["INCREASING_Y"][z(e, t)]
                            }(e, n) : "float" === r ? H(e, n) : "v2f" === r ? function(e, t) {
                                return [H(e, t), H(e, t)]
                            }(e, n) : "v3f" === r ? function(e, t) {
                                return [H(e, t), H(e, t), H(e, t)]
                            }(e, n) : "int" === r ? N(e, n) : "rational" === r ? function(e, t) {
                                return [N(e, t), B(e, t)]
                            }(e, n) : "timecode" === r ? function(e, t) {
                                return [B(e, t), B(e, t)]
                            }(e, n) : "preview" === r ? (n.value += i,
                            "skipped") : void (n.value += i)
                        }
                        var W = new DataView(e)
                          , q = new Uint8Array(e)
                          , X = {};
                        W.getUint32(0, !0),
                        W.getUint8(4, !0),
                        W.getUint8(5, !0);
                        for (var Y = {
                            value: 8
                        }, Z = !0; Z; ) {
                            var J = F(e, Y);
                            if (0 == J)
                                Z = !1;
                            else {
                                var K = F(e, Y)
                                  , Q = V(W, e, Y, K, B(W, Y));
                                void 0 === Q ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${K}'.`) : X[J] = Q
                            }
                        }
                        var $, ee, te, ne, re = X.dataWindow.yMax + 1;
                        switch (X.compression) {
                        case "NO_COMPRESSION":
                            ee = 1,
                            $ = function(e) {
                                return new DataView(e.array.buffer,e.offset.value,e.size)
                            }
                            ;
                            break;
                        case "RLE_COMPRESSION":
                            ee = 1,
                            $ = function(e) {
                                var t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size)
                                  , n = new Uint8Array(A(t))
                                  , r = new Uint8Array(n.length);
                                return T(n),
                                E(n, r),
                                new DataView(r.buffer)
                            }
                            ;
                            break;
                        case "ZIPS_COMPRESSION":
                            ee = 1,
                            $ = D;
                            break;
                        case "ZIP_COMPRESSION":
                            ee = 16,
                            $ = D;
                            break;
                        case "PIZ_COMPRESSION":
                            ee = 32,
                            $ = function(e) {
                                for (var n = e.viewer, r = {
                                    value: e.offset.value
                                }, i = e.width * ee * (X.channels.length * e.type), a = new Uint16Array(i), o = new Uint8Array(8192), s = 0, l = new Array(e.channels), c = 0; c < e.channels; c++)
                                    l[c] = {},
                                    l[c].start = s,
                                    l[c].end = l[c].start,
                                    l[c].nx = e.width,
                                    l[c].ny = e.lines,
                                    l[c].size = e.type,
                                    s += l[c].nx * l[c].ny * l[c].size;
                                var u = j(n, r)
                                  , h = j(n, r);
                                if (h >= 8192)
                                    throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
                                if (u <= h)
                                    for (c = 0; c < h - u + 1; c++)
                                        o[c + u] = z(n, r);
                                var d = new Uint16Array(t)
                                  , p = function(e, n) {
                                    for (var r = 0, i = 0; i < t; ++i)
                                        (0 == i || e[i >> 3] & 1 << (7 & i)) && (n[r++] = i);
                                    for (var a = r - 1; r < t; )
                                        n[r++] = 0;
                                    return a
                                }(o, d)
                                  , f = B(n, r);
                                for (S(e.array, n, r, f, a, s),
                                c = 0; c < e.channels; ++c)
                                    for (var m = l[c], g = 0; g < l[c].size; ++g)
                                        M(a, m.start + g, m.nx, m.size, m.ny, m.nx * m.size, p);
                                !function(e, t, n) {
                                    for (var r = 0; r < n; ++r)
                                        t[r] = e[t[r]]
                                }(d, a, s);
                                for (var v = 0, y = new Uint8Array(a.buffer.byteLength), _ = 0; _ < e.lines; _++)
                                    for (var x = 0; x < e.channels; x++) {
                                        var b = (m = l[x]).nx * m.size
                                          , w = new Uint8Array(a.buffer,2 * m.end,2 * b);
                                        y.set(w, v),
                                        v += 2 * b,
                                        m.end += b
                                    }
                                return new DataView(y.buffer)
                            }
                            ;
                            break;
                        case "PXR24_COMPRESSION":
                            ee = 16,
                            $ = function(e) {
                                var t = e.array.slice(e.offset.value, e.offset.value + e.size);
                                void 0 === r && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                                var n = We(t);
                                const i = e.lines * e.channels * e.width
                                  , a = 1 == e.type ? new Uint16Array(i) : new Uint32Array(i);
                                let o = 0
                                  , s = 0;
                                const l = new Array(4);
                                for (let t = 0; t < e.lines; t++)
                                    for (let t = 0; t < e.channels; t++) {
                                        let t = 0;
                                        switch (e.type) {
                                        case 1:
                                            l[0] = o,
                                            l[1] = l[0] + e.width,
                                            o = l[1] + e.width;
                                            for (let r = 0; r < e.width; ++r)
                                                t += n[l[0]++] << 8 | n[l[1]++],
                                                a[s] = t,
                                                s++;
                                            break;
                                        case 2:
                                            l[0] = o,
                                            l[1] = l[0] + e.width,
                                            l[2] = l[1] + e.width,
                                            o = l[2] + e.width;
                                            for (let r = 0; r < e.width; ++r)
                                                t += n[l[0]++] << 24 | n[l[1]++] << 16 | n[l[2]++] << 8,
                                                a[s] = t,
                                                s++
                                        }
                                    }
                                return new DataView(a.buffer)
                            }
                            ;
                            break;
                        case "DWAA_COMPRESSION":
                            ee = 32,
                            $ = O;
                            break;
                        case "DWAB_COMPRESSION":
                            ee = 256,
                            $ = O;
                            break;
                        default:
                            throw "EXRLoader.parse: " + X.compression + " is unsupported"
                        }
                        var ie = X.channels[0].pixelType;
                        if (1 === ie)
                            switch (this.type) {
                            case i.UnsignedByteType:
                            case i.FloatType:
                                ne = function(e, t) {
                                    return G(j(e, t))
                                }
                                ,
                                te = 2;
                                break;
                            case i.HalfFloatType:
                                ne = j,
                                te = 2
                            }
                        else {
                            if (2 !== ie)
                                throw "EXRLoader.parse: unsupported pixelType " + ie + " for " + X.compression + ".";
                            switch (this.type) {
                            case i.UnsignedByteType:
                            case i.FloatType:
                                ne = H,
                                te = 4;
                                break;
                            case i.HalfFloatType:
                                ne = function(e, t) {
                                    return i.DataUtils.toHalfFloat(H(e, t))
                                }
                                ,
                                te = 4
                            }
                        }
                        for (var ae = re / ee, oe = 0; oe < ae; oe++)
                            I(W, Y);
                        var se = X.dataWindow.xMax - X.dataWindow.xMin + 1
                          , le = X.dataWindow.yMax - X.dataWindow.yMin + 1
                          , ce = se * le * 4;
                        switch (this.type) {
                        case i.UnsignedByteType:
                        case i.FloatType:
                            var ue = new Float32Array(ce);
                            X.channels.length < 4 && ue.fill(1, 0, ce);
                            break;
                        case i.HalfFloatType:
                            ue = new Uint16Array(ce),
                            X.channels.length < 4 && ue.fill(15360, 0, ce);
                            break;
                        default:
                            console.error("THREE.EXRLoader: unsupported type: ", this.type)
                        }
                        for (var he, de, pe = {
                            R: 0,
                            G: 1,
                            B: 2,
                            A: 3
                        }, fe = {
                            size: 0,
                            width: se,
                            lines: ee,
                            offset: Y,
                            array: q,
                            viewer: W,
                            type: ie,
                            channels: X.channels.length
                        }, me = {
                            value: 0
                        }, ge = 0; ge < le / ee; ge++) {
                            he = B(W, Y),
                            ce = B(W, Y),
                            fe.lines = he + ee > le ? le - he : ee,
                            fe.offset = Y,
                            fe.size = ce,
                            de = $(fe),
                            Y.value += ce;
                            for (var ve = 0; ve < ee; ve++) {
                                var ye = ve + ge * ee;
                                if (ye >= le)
                                    break;
                                for (var _e = 0; _e < X.channels.length; _e++)
                                    for (var xe = pe[X.channels[_e].name], be = 0; be < se; be++) {
                                        var we = ve * (X.channels.length * se) + _e * se + be;
                                        me.value = we * te;
                                        var Me = ne(de, me);
                                        ue[4 * se * (le - 1 - ye) + 4 * be + xe] = Me
                                    }
                            }
                        }
                        if (this.type === i.UnsignedByteType) {
                            let e, t;
                            const n = ue.length
                              , r = new Uint8Array(n);
                            for (let n = 0; n < le; ++n)
                                for (let i = 0; i < se; ++i) {
                                    t = n * se * 4 + 4 * i;
                                    const a = ue[t]
                                      , o = ue[t + 1]
                                      , s = ue[t + 2];
                                    if (e = a > o ? a : o,
                                    e = s > e ? s : e,
                                    e < 1e-32)
                                        r[t] = r[t + 1] = r[t + 2] = r[t + 3] = 0;
                                    else {
                                        const n = l(e);
                                        e = 256 * n[0] / e,
                                        r[t] = a * e,
                                        r[t + 1] = o * e,
                                        r[t + 2] = s * e,
                                        r[t + 3] = n[1] + 128
                                    }
                                }
                            ue = r
                        }
                        const Se = this.type === i.UnsignedByteType ? i.RGBEFormat : i.RGBAFormat;
                        return {
                            header: X,
                            width: se,
                            height: le,
                            data: ue,
                            format: Se,
                            type: this.type
                        }
                    },
                    setDataType: function(e) {
                        return this.type = e,
                        this
                    },
                    load: function(e, t, n, r) {
                        return i.DataTextureLoader.prototype.load.call(this, e, (function(e, n) {
                            switch (e.type) {
                            case i.UnsignedByteType:
                                e.encoding = i.RGBEEncoding,
                                e.minFilter = i.NearestFilter,
                                e.magFilter = i.NearestFilter,
                                e.generateMipmaps = !1,
                                e.flipY = !1;
                                break;
                            case i.FloatType:
                            case i.HalfFloatType:
                                e.encoding = i.LinearEncoding,
                                e.minFilter = i.LinearFilter,
                                e.magFilter = i.LinearFilter,
                                e.generateMipmaps = !1,
                                e.flipY = !1
                            }
                            t && t(e, n)
                        }
                        ), n, r)
                    }
                })
            }
            ,
            7047: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    GLTFLoader: ()=>i
                });
                var r = n(2212)
                  , i = function() {
                    function e(e) {
                        r.Loader.call(this, e),
                        this.dracoLoader = null,
                        this.ddsLoader = null,
                        this.ktx2Loader = null,
                        this.meshoptDecoder = null,
                        this.pluginCallbacks = [],
                        this.register((function(e) {
                            return new s(e)
                        }
                        )),
                        this.register((function(e) {
                            return new c(e)
                        }
                        )),
                        this.register((function(e) {
                            return new u(e)
                        }
                        )),
                        this.register((function(e) {
                            return new l(e)
                        }
                        )),
                        this.register((function(e) {
                            return new a(e)
                        }
                        )),
                        this.register((function(e) {
                            return new h(e)
                        }
                        ))
                    }
                    function t() {
                        var e = {};
                        return {
                            get: function(t) {
                                return e[t]
                            },
                            add: function(t, n) {
                                e[t] = n
                            },
                            remove: function(t) {
                                delete e[t]
                            },
                            removeAll: function() {
                                e = {}
                            }
                        }
                    }
                    e.prototype = Object.assign(Object.create(r.Loader.prototype), {
                        constructor: e,
                        load: function(e, t, n, i) {
                            var a, o = this;
                            a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : r.LoaderUtils.extractUrlBase(e),
                            this.manager.itemStart(e);
                            var s = function(t) {
                                i ? i(t) : console.error(t),
                                o.manager.itemError(e),
                                o.manager.itemEnd(e)
                            }
                              , l = new r.FileLoader(this.manager);
                            l.setPath(this.path),
                            l.setResponseType("arraybuffer"),
                            l.setRequestHeader(this.requestHeader),
                            l.setWithCredentials(this.withCredentials),
                            l.load(e, (function(n) {
                                try {
                                    o.parse(n, a, (function(n) {
                                        t(n),
                                        o.manager.itemEnd(e)
                                    }
                                    ), s)
                                } catch (e) {
                                    s(e)
                                }
                            }
                            ), n, s)
                        },
                        setDRACOLoader: function(e) {
                            return this.dracoLoader = e,
                            this
                        },
                        setDDSLoader: function(e) {
                            return this.ddsLoader = e,
                            this
                        },
                        setKTX2Loader: function(e) {
                            return this.ktx2Loader = e,
                            this
                        },
                        setMeshoptDecoder: function(e) {
                            return this.meshoptDecoder = e,
                            this
                        },
                        register: function(e) {
                            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                            this
                        },
                        unregister: function(e) {
                            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                            this
                        },
                        parse: function(e, t, a, s) {
                            var l, c = {}, u = {};
                            if ("string" == typeof e)
                                l = e;
                            else if (r.LoaderUtils.decodeText(new Uint8Array(e,0,4)) === d) {
                                try {
                                    c[n.KHR_BINARY_GLTF] = new p(e)
                                } catch (e) {
                                    return void (s && s(e))
                                }
                                l = c[n.KHR_BINARY_GLTF].content
                            } else
                                l = r.LoaderUtils.decodeText(new Uint8Array(e));
                            var h = JSON.parse(l);
                            if (void 0 === h.asset || h.asset.version[0] < 2)
                                s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                            else {
                                var g = new D(h,{
                                    path: t || this.resourcePath || "",
                                    crossOrigin: this.crossOrigin,
                                    manager: this.manager,
                                    ktx2Loader: this.ktx2Loader,
                                    meshoptDecoder: this.meshoptDecoder
                                });
                                g.fileLoader.setRequestHeader(this.requestHeader);
                                for (var _ = 0; _ < this.pluginCallbacks.length; _++) {
                                    var x = this.pluginCallbacks[_](g);
                                    u[x.name] = x,
                                    c[x.name] = !0
                                }
                                if (h.extensionsUsed)
                                    for (_ = 0; _ < h.extensionsUsed.length; ++_) {
                                        var b = h.extensionsUsed[_]
                                          , w = h.extensionsRequired || [];
                                        switch (b) {
                                        case n.KHR_MATERIALS_UNLIT:
                                            c[b] = new o;
                                            break;
                                        case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                            c[b] = new v;
                                            break;
                                        case n.KHR_DRACO_MESH_COMPRESSION:
                                            c[b] = new f(h,this.dracoLoader);
                                            break;
                                        case n.MSFT_TEXTURE_DDS:
                                            c[b] = new i(this.ddsLoader);
                                            break;
                                        case n.KHR_TEXTURE_TRANSFORM:
                                            c[b] = new m;
                                            break;
                                        case n.KHR_MESH_QUANTIZATION:
                                            c[b] = new y;
                                            break;
                                        default:
                                            w.indexOf(b) >= 0 && void 0 === u[b] && console.warn('THREE.GLTFLoader: Unknown extension "' + b + '".')
                                        }
                                    }
                                g.setExtensions(c),
                                g.setPlugins(u),
                                g.parse(a, s)
                            }
                        }
                    });
                    var n = {
                        KHR_BINARY_GLTF: "KHR_binary_glTF",
                        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                        EXT_TEXTURE_WEBP: "EXT_texture_webp",
                        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                        MSFT_TEXTURE_DDS: "MSFT_texture_dds"
                    };
                    function i(e) {
                        if (!e)
                            throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
                        this.name = n.MSFT_TEXTURE_DDS,
                        this.ddsLoader = e
                    }
                    function a(e) {
                        this.parser = e,
                        this.name = n.KHR_LIGHTS_PUNCTUAL,
                        this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }
                    function o() {
                        this.name = n.KHR_MATERIALS_UNLIT
                    }
                    function s(e) {
                        this.parser = e,
                        this.name = n.KHR_MATERIALS_CLEARCOAT
                    }
                    function l(e) {
                        this.parser = e,
                        this.name = n.KHR_MATERIALS_TRANSMISSION
                    }
                    function c(e) {
                        this.parser = e,
                        this.name = n.KHR_TEXTURE_BASISU
                    }
                    function u(e) {
                        this.parser = e,
                        this.name = n.EXT_TEXTURE_WEBP,
                        this.isSupported = null
                    }
                    function h(e) {
                        this.name = n.EXT_MESHOPT_COMPRESSION,
                        this.parser = e
                    }
                    a.prototype._markDefs = function() {
                        for (var e = this.parser, t = this.parser.json.nodes || [], n = 0, r = t.length; n < r; n++) {
                            var i = t[n];
                            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                        }
                    }
                    ,
                    a.prototype._loadLight = function(e) {
                        var t = this.parser
                          , n = "light:" + e
                          , i = t.cache.get(n);
                        if (i)
                            return i;
                        var a, o = t.json, s = ((o.extensions && o.extensions[this.name] || {}).lights || [])[e], l = new r.Color(16777215);
                        void 0 !== s.color && l.fromArray(s.color);
                        var c = void 0 !== s.range ? s.range : 0;
                        switch (s.type) {
                        case "directional":
                            (a = new r.DirectionalLight(l)).target.position.set(0, 0, -1),
                            a.add(a.target);
                            break;
                        case "point":
                            (a = new r.PointLight(l)).distance = c;
                            break;
                        case "spot":
                            (a = new r.SpotLight(l)).distance = c,
                            s.spot = s.spot || {},
                            s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                            s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                            a.angle = s.spot.outerConeAngle,
                            a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                            a.target.position.set(0, 0, -1),
                            a.add(a.target);
                            break;
                        default:
                            throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                        }
                        return a.position.set(0, 0, 0),
                        a.decay = 2,
                        void 0 !== s.intensity && (a.intensity = s.intensity),
                        a.name = t.createUniqueName(s.name || "light_" + e),
                        i = Promise.resolve(a),
                        t.cache.add(n, i),
                        i
                    }
                    ,
                    a.prototype.createNodeAttachment = function(e) {
                        var t = this
                          , n = this.parser
                          , r = n.json.nodes[e]
                          , i = (r.extensions && r.extensions[this.name] || {}).light;
                        return void 0 === i ? null : this._loadLight(i).then((function(e) {
                            return n._getNodeRef(t.cache, i, e)
                        }
                        ))
                    }
                    ,
                    o.prototype.getMaterialType = function() {
                        return r.MeshBasicMaterial
                    }
                    ,
                    o.prototype.extendParams = function(e, t, n) {
                        var i = [];
                        e.color = new r.Color(1,1,1),
                        e.opacity = 1;
                        var a = t.pbrMetallicRoughness;
                        if (a) {
                            if (Array.isArray(a.baseColorFactor)) {
                                var o = a.baseColorFactor;
                                e.color.fromArray(o),
                                e.opacity = o[3]
                            }
                            void 0 !== a.baseColorTexture && i.push(n.assignTexture(e, "map", a.baseColorTexture))
                        }
                        return Promise.all(i)
                    }
                    ,
                    s.prototype.getMaterialType = function(e) {
                        var t = this.parser.json.materials[e];
                        return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
                    }
                    ,
                    s.prototype.extendMaterialParams = function(e, t) {
                        var n = this.parser
                          , i = n.json.materials[e];
                        if (!i.extensions || !i.extensions[this.name])
                            return Promise.resolve();
                        var a = []
                          , o = i.extensions[this.name];
                        if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor),
                        void 0 !== o.clearcoatTexture && a.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
                        void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
                        void 0 !== o.clearcoatRoughnessTexture && a.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
                        void 0 !== o.clearcoatNormalTexture && (a.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
                        void 0 !== o.clearcoatNormalTexture.scale)) {
                            var s = o.clearcoatNormalTexture.scale;
                            t.clearcoatNormalScale = new r.Vector2(s,-s)
                        }
                        return Promise.all(a)
                    }
                    ,
                    l.prototype.getMaterialType = function(e) {
                        var t = this.parser.json.materials[e];
                        return t.extensions && t.extensions[this.name] ? r.MeshPhysicalMaterial : null
                    }
                    ,
                    l.prototype.extendMaterialParams = function(e, t) {
                        var n = this.parser
                          , r = n.json.materials[e];
                        if (!r.extensions || !r.extensions[this.name])
                            return Promise.resolve();
                        var i = []
                          , a = r.extensions[this.name];
                        return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor),
                        void 0 !== a.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
                        Promise.all(i)
                    }
                    ,
                    c.prototype.loadTexture = function(e) {
                        var t = this.parser
                          , n = t.json
                          , r = n.textures[e];
                        if (!r.extensions || !r.extensions[this.name])
                            return null;
                        var i = r.extensions[this.name]
                          , a = n.images[i.source]
                          , o = t.options.ktx2Loader;
                        if (!o) {
                            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                            return null
                        }
                        return t.loadTextureImage(e, a, o)
                    }
                    ,
                    u.prototype.loadTexture = function(e) {
                        var t = this.name
                          , n = this.parser
                          , r = n.json
                          , i = r.textures[e];
                        if (!i.extensions || !i.extensions[t])
                            return null;
                        var a = i.extensions[t]
                          , o = r.images[a.source]
                          , s = o.uri ? n.options.manager.getHandler(o.uri) : n.textureLoader;
                        return this.detectSupport().then((function(i) {
                            if (i)
                                return n.loadTextureImage(e, o, s);
                            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                            return n.loadTexture(e)
                        }
                        ))
                    }
                    ,
                    u.prototype.detectSupport = function() {
                        return this.isSupported || (this.isSupported = new Promise((function(e) {
                            var t = new Image;
                            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                            t.onload = t.onerror = function() {
                                e(1 === t.height)
                            }
                        }
                        ))),
                        this.isSupported
                    }
                    ,
                    h.prototype.loadBufferView = function(e) {
                        var t = this.parser.json
                          , n = t.bufferViews[e];
                        if (n.extensions && n.extensions[this.name]) {
                            var r = n.extensions[this.name]
                              , i = this.parser.getDependency("buffer", r.buffer)
                              , a = this.parser.options.meshoptDecoder;
                            if (!a || !a.supported) {
                                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                return null
                            }
                            return Promise.all([i, a.ready]).then((function(e) {
                                var t = r.byteOffset || 0
                                  , n = r.byteLength || 0
                                  , i = r.count
                                  , o = r.byteStride
                                  , s = new ArrayBuffer(i * o)
                                  , l = new Uint8Array(e[0],t,n);
                                return a.decodeGltfBuffer(new Uint8Array(s), i, o, l, r.mode, r.filter),
                                s
                            }
                            ))
                        }
                        return null
                    }
                    ;
                    var d = "glTF";
                    function p(e) {
                        this.name = n.KHR_BINARY_GLTF,
                        this.content = null,
                        this.body = null;
                        var t = new DataView(e,0,12);
                        if (this.header = {
                            magic: r.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
                            version: t.getUint32(4, !0),
                            length: t.getUint32(8, !0)
                        },
                        this.header.magic !== d)
                            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                        if (this.header.version < 2)
                            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                        for (var i = this.header.length - 12, a = new DataView(e,12), o = 0; o < i; ) {
                            var s = a.getUint32(o, !0);
                            o += 4;
                            var l = a.getUint32(o, !0);
                            if (o += 4,
                            1313821514 === l) {
                                var c = new Uint8Array(e,12 + o,s);
                                this.content = r.LoaderUtils.decodeText(c)
                            } else if (5130562 === l) {
                                var u = 12 + o;
                                this.body = e.slice(u, u + s)
                            }
                            o += s
                        }
                        if (null === this.content)
                            throw new Error("THREE.GLTFLoader: JSON content not found.")
                    }
                    function f(e, t) {
                        if (!t)
                            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = n.KHR_DRACO_MESH_COMPRESSION,
                        this.json = e,
                        this.dracoLoader = t,
                        this.dracoLoader.preload()
                    }
                    function m() {
                        this.name = n.KHR_TEXTURE_TRANSFORM
                    }
                    function g(e) {
                        r.MeshStandardMaterial.call(this),
                        this.isGLTFSpecularGlossinessMaterial = !0;
                        var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
                          , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
                          , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
                          , a = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
                          , o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
                          , s = {
                            specular: {
                                value: (new r.Color).setHex(16777215)
                            },
                            glossiness: {
                                value: 1
                            },
                            specularMap: {
                                value: null
                            },
                            glossinessMap: {
                                value: null
                            }
                        };
                        this._extraUniforms = s,
                        this.onBeforeCompile = function(e) {
                            for (var r in s)
                                e.uniforms[r] = s[r];
                            e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", a).replace("#include <lights_physical_fragment>", o)
                        }
                        ,
                        Object.defineProperties(this, {
                            specular: {
                                get: function() {
                                    return s.specular.value
                                },
                                set: function(e) {
                                    s.specular.value = e
                                }
                            },
                            specularMap: {
                                get: function() {
                                    return s.specularMap.value
                                },
                                set: function(e) {
                                    s.specularMap.value = e,
                                    e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                                }
                            },
                            glossiness: {
                                get: function() {
                                    return s.glossiness.value
                                },
                                set: function(e) {
                                    s.glossiness.value = e
                                }
                            },
                            glossinessMap: {
                                get: function() {
                                    return s.glossinessMap.value
                                },
                                set: function(e) {
                                    s.glossinessMap.value = e,
                                    e ? (this.defines.USE_GLOSSINESSMAP = "",
                                    this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                                    delete this.defines.USE_UV)
                                }
                            }
                        }),
                        delete this.metalness,
                        delete this.roughness,
                        delete this.metalnessMap,
                        delete this.roughnessMap,
                        this.setValues(e)
                    }
                    function v() {
                        return {
                            name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                            specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                            getMaterialType: function() {
                                return g
                            },
                            extendParams: function(e, t, n) {
                                var i = t.extensions[this.name];
                                e.color = new r.Color(1,1,1),
                                e.opacity = 1;
                                var a = [];
                                if (Array.isArray(i.diffuseFactor)) {
                                    var o = i.diffuseFactor;
                                    e.color.fromArray(o),
                                    e.opacity = o[3]
                                }
                                if (void 0 !== i.diffuseTexture && a.push(n.assignTexture(e, "map", i.diffuseTexture)),
                                e.emissive = new r.Color(0,0,0),
                                e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1,
                                e.specular = new r.Color(1,1,1),
                                Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
                                void 0 !== i.specularGlossinessTexture) {
                                    var s = i.specularGlossinessTexture;
                                    a.push(n.assignTexture(e, "glossinessMap", s)),
                                    a.push(n.assignTexture(e, "specularMap", s))
                                }
                                return Promise.all(a)
                            },
                            createMaterial: function(e) {
                                var t = new g(e);
                                return t.fog = !0,
                                t.color = e.color,
                                t.map = void 0 === e.map ? null : e.map,
                                t.lightMap = null,
                                t.lightMapIntensity = 1,
                                t.aoMap = void 0 === e.aoMap ? null : e.aoMap,
                                t.aoMapIntensity = 1,
                                t.emissive = e.emissive,
                                t.emissiveIntensity = 1,
                                t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap,
                                t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap,
                                t.bumpScale = 1,
                                t.normalMap = void 0 === e.normalMap ? null : e.normalMap,
                                t.normalMapType = r.TangentSpaceNormalMap,
                                e.normalScale && (t.normalScale = e.normalScale),
                                t.displacementMap = null,
                                t.displacementScale = 1,
                                t.displacementBias = 0,
                                t.specularMap = void 0 === e.specularMap ? null : e.specularMap,
                                t.specular = e.specular,
                                t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap,
                                t.glossiness = e.glossiness,
                                t.alphaMap = null,
                                t.envMap = void 0 === e.envMap ? null : e.envMap,
                                t.envMapIntensity = 1,
                                t.refractionRatio = .98,
                                t
                            }
                        }
                    }
                    function y() {
                        this.name = n.KHR_MESH_QUANTIZATION
                    }
                    function _(e, t, n, i) {
                        r.Interpolant.call(this, e, t, n, i)
                    }
                    f.prototype.decodePrimitive = function(e, t) {
                        var n = this.json
                          , r = this.dracoLoader
                          , i = e.extensions[this.name].bufferView
                          , a = e.extensions[this.name].attributes
                          , o = {}
                          , s = {}
                          , l = {};
                        for (var c in a) {
                            var u = S[c] || c.toLowerCase();
                            o[u] = a[c]
                        }
                        for (c in e.attributes)
                            if (u = S[c] || c.toLowerCase(),
                            void 0 !== a[c]) {
                                var h = n.accessors[e.attributes[c]]
                                  , d = x[h.componentType];
                                l[u] = d,
                                s[u] = !0 === h.normalized
                            }
                        return t.getDependency("bufferView", i).then((function(e) {
                            return new Promise((function(t) {
                                r.decodeDracoFile(e, (function(e) {
                                    for (var n in e.attributes) {
                                        var r = e.attributes[n]
                                          , i = s[n];
                                        void 0 !== i && (r.normalized = i)
                                    }
                                    t(e)
                                }
                                ), o, l)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    m.prototype.extendTexture = function(e, t) {
                        return e = e.clone(),
                        void 0 !== t.offset && e.offset.fromArray(t.offset),
                        void 0 !== t.rotation && (e.rotation = t.rotation),
                        void 0 !== t.scale && e.repeat.fromArray(t.scale),
                        void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
                        e.needsUpdate = !0,
                        e
                    }
                    ,
                    g.prototype = Object.create(r.MeshStandardMaterial.prototype),
                    g.prototype.constructor = g,
                    g.prototype.copy = function(e) {
                        return r.MeshStandardMaterial.prototype.copy.call(this, e),
                        this.specularMap = e.specularMap,
                        this.specular.copy(e.specular),
                        this.glossinessMap = e.glossinessMap,
                        this.glossiness = e.glossiness,
                        delete this.metalness,
                        delete this.roughness,
                        delete this.metalnessMap,
                        delete this.roughnessMap,
                        this
                    }
                    ,
                    _.prototype = Object.create(r.Interpolant.prototype),
                    _.prototype.constructor = _,
                    _.prototype.copySampleValue_ = function(e) {
                        for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r, a = 0; a !== r; a++)
                            t[a] = n[i + a];
                        return t
                    }
                    ,
                    _.prototype.beforeStart_ = _.prototype.copySampleValue_,
                    _.prototype.afterEnd_ = _.prototype.copySampleValue_,
                    _.prototype.interpolate_ = function(e, t, n, r) {
                        for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, u = (n - t) / c, h = u * u, d = h * u, p = e * l, f = p - l, m = -2 * d + 3 * h, g = d - h, v = 1 - m, y = g - h + u, _ = 0; _ !== o; _++) {
                            var x = a[f + _ + o]
                              , b = a[f + _ + s] * c
                              , w = a[p + _ + o]
                              , M = a[p + _] * c;
                            i[_] = v * x + y * b + m * w + g * M
                        }
                        return i
                    }
                    ;
                    var x = {
                        5120: Int8Array,
                        5121: Uint8Array,
                        5122: Int16Array,
                        5123: Uint16Array,
                        5125: Uint32Array,
                        5126: Float32Array
                    }
                      , b = {
                        9728: r.NearestFilter,
                        9729: r.LinearFilter,
                        9984: r.NearestMipmapNearestFilter,
                        9985: r.LinearMipmapNearestFilter,
                        9986: r.NearestMipmapLinearFilter,
                        9987: r.LinearMipmapLinearFilter
                    }
                      , w = {
                        33071: r.ClampToEdgeWrapping,
                        33648: r.MirroredRepeatWrapping,
                        10497: r.RepeatWrapping
                    }
                      , M = {
                        SCALAR: 1,
                        VEC2: 2,
                        VEC3: 3,
                        VEC4: 4,
                        MAT2: 4,
                        MAT3: 9,
                        MAT4: 16
                    }
                      , S = {
                        POSITION: "position",
                        NORMAL: "normal",
                        TANGENT: "tangent",
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv2",
                        COLOR_0: "color",
                        WEIGHTS_0: "skinWeight",
                        JOINTS_0: "skinIndex"
                    }
                      , T = {
                        scale: "scale",
                        translation: "position",
                        rotation: "quaternion",
                        weights: "morphTargetInfluences"
                    }
                      , E = {
                        CUBICSPLINE: void 0,
                        LINEAR: r.InterpolateLinear,
                        STEP: r.InterpolateDiscrete
                    };
                    function A(e, t) {
                        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                    }
                    function C(e, t, n) {
                        for (var r in n.extensions)
                            void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                            t.userData.gltfExtensions[r] = n.extensions[r])
                    }
                    function P(e, t) {
                        void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
                    }
                    function R(e, t) {
                        if (e.updateMorphTargets(),
                        void 0 !== t.weights)
                            for (var n = 0, r = t.weights.length; n < r; n++)
                                e.morphTargetInfluences[n] = t.weights[n];
                        if (t.extras && Array.isArray(t.extras.targetNames)) {
                            var i = t.extras.targetNames;
                            if (e.morphTargetInfluences.length === i.length)
                                for (e.morphTargetDictionary = {},
                                n = 0,
                                r = i.length; n < r; n++)
                                    e.morphTargetDictionary[i[n]] = n;
                            else
                                console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                        }
                    }
                    function L(e) {
                        for (var t = "", n = Object.keys(e).sort(), r = 0, i = n.length; r < i; r++)
                            t += n[r] + ":" + e[n[r]] + ";";
                        return t
                    }
                    function D(e, n) {
                        this.json = e || {},
                        this.extensions = {},
                        this.plugins = {},
                        this.options = n || {},
                        this.cache = new t,
                        this.associations = new Map,
                        this.primitiveCache = {},
                        this.meshCache = {
                            refs: {},
                            uses: {}
                        },
                        this.cameraCache = {
                            refs: {},
                            uses: {}
                        },
                        this.lightCache = {
                            refs: {},
                            uses: {}
                        },
                        this.nodeNamesUsed = {},
                        "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new r.ImageBitmapLoader(this.options.manager) : this.textureLoader = new r.TextureLoader(this.options.manager),
                        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                        this.fileLoader = new r.FileLoader(this.options.manager),
                        this.fileLoader.setResponseType("arraybuffer"),
                        "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                    }
                    function O(e, t, n) {
                        var i = t.attributes
                          , a = [];
                        function o(t, r) {
                            return n.getDependency("accessor", t).then((function(t) {
                                e.setAttribute(r, t)
                            }
                            ))
                        }
                        for (var s in i) {
                            var l = S[s] || s.toLowerCase();
                            l in e.attributes || a.push(o(i[s], l))
                        }
                        if (void 0 !== t.indices && !e.index) {
                            var c = n.getDependency("accessor", t.indices).then((function(t) {
                                e.setIndex(t)
                            }
                            ));
                            a.push(c)
                        }
                        return P(e, t),
                        function(e, t, n) {
                            var i = t.attributes
                              , a = new r.Box3;
                            if (void 0 !== i.POSITION) {
                                var o = (p = n.json.accessors[i.POSITION]).min
                                  , s = p.max;
                                if (void 0 !== o && void 0 !== s) {
                                    a.set(new r.Vector3(o[0],o[1],o[2]), new r.Vector3(s[0],s[1],s[2]));
                                    var l = t.targets;
                                    if (void 0 !== l) {
                                        for (var c = new r.Vector3, u = new r.Vector3, h = 0, d = l.length; h < d; h++) {
                                            var p, f = l[h];
                                            void 0 !== f.POSITION && (o = (p = n.json.accessors[f.POSITION]).min,
                                            s = p.max,
                                            void 0 !== o && void 0 !== s ? (u.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
                                            u.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
                                            u.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
                                            c.max(u)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."))
                                        }
                                        a.expandByVector(c)
                                    }
                                    e.boundingBox = a;
                                    var m = new r.Sphere;
                                    a.getCenter(m.center),
                                    m.radius = a.min.distanceTo(a.max) / 2,
                                    e.boundingSphere = m
                                } else
                                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }(e, t, n),
                        Promise.all(a).then((function() {
                            return void 0 !== t.targets ? function(e, t, n) {
                                for (var r = !1, i = !1, a = 0, o = t.length; a < o && (void 0 !== (c = t[a]).POSITION && (r = !0),
                                void 0 !== c.NORMAL && (i = !0),
                                !r || !i); a++)
                                    ;
                                if (!r && !i)
                                    return Promise.resolve(e);
                                var s = []
                                  , l = [];
                                for (a = 0,
                                o = t.length; a < o; a++) {
                                    var c = t[a];
                                    if (r) {
                                        var u = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : e.attributes.position;
                                        s.push(u)
                                    }
                                    i && (u = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : e.attributes.normal,
                                    l.push(u))
                                }
                                return Promise.all([Promise.all(s), Promise.all(l)]).then((function(t) {
                                    var n = t[0]
                                      , a = t[1];
                                    return r && (e.morphAttributes.position = n),
                                    i && (e.morphAttributes.normal = a),
                                    e.morphTargetsRelative = !0,
                                    e
                                }
                                ))
                            }(e, t.targets, n) : e
                        }
                        ))
                    }
                    function F(e, t) {
                        var n = e.getIndex();
                        if (null === n) {
                            var i = []
                              , a = e.getAttribute("position");
                            if (void 0 === a)
                                return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                                e;
                            for (var o = 0; o < a.count; o++)
                                i.push(o);
                            e.setIndex(i),
                            n = e.getIndex()
                        }
                        var s = n.count - 2
                          , l = [];
                        if (t === r.TriangleFanDrawMode)
                            for (o = 1; o <= s; o++)
                                l.push(n.getX(0)),
                                l.push(n.getX(o)),
                                l.push(n.getX(o + 1));
                        else
                            for (o = 0; o < s; o++)
                                o % 2 == 0 ? (l.push(n.getX(o)),
                                l.push(n.getX(o + 1)),
                                l.push(n.getX(o + 2))) : (l.push(n.getX(o + 2)),
                                l.push(n.getX(o + 1)),
                                l.push(n.getX(o)));
                        l.length / 3 !== s && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                        var c = e.clone();
                        return c.setIndex(l),
                        c
                    }
                    return D.prototype.setExtensions = function(e) {
                        this.extensions = e
                    }
                    ,
                    D.prototype.setPlugins = function(e) {
                        this.plugins = e
                    }
                    ,
                    D.prototype.parse = function(e, t) {
                        var n = this
                          , r = this.json
                          , i = this.extensions;
                        this.cache.removeAll(),
                        this._invokeAll((function(e) {
                            return e._markDefs && e._markDefs()
                        }
                        )),
                        Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function(t) {
                            var a = {
                                scene: t[0][r.scene || 0],
                                scenes: t[0],
                                animations: t[1],
                                cameras: t[2],
                                asset: r.asset,
                                parser: n,
                                userData: {}
                            };
                            C(i, a, r),
                            P(a, r),
                            e(a)
                        }
                        )).catch(t)
                    }
                    ,
                    D.prototype._markDefs = function() {
                        for (var e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [], r = 0, i = t.length; r < i; r++)
                            for (var a = t[r].joints, o = 0, s = a.length; o < s; o++)
                                e[a[o]].isBone = !0;
                        for (var l = 0, c = e.length; l < c; l++) {
                            var u = e[l];
                            void 0 !== u.mesh && (this._addNodeRef(this.meshCache, u.mesh),
                            void 0 !== u.skin && (n[u.mesh].isSkinnedMesh = !0)),
                            void 0 !== u.camera && this._addNodeRef(this.cameraCache, u.camera)
                        }
                    }
                    ,
                    D.prototype._addNodeRef = function(e, t) {
                        void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                        e.refs[t]++)
                    }
                    ,
                    D.prototype._getNodeRef = function(e, t, n) {
                        if (e.refs[t] <= 1)
                            return n;
                        var r = n.clone();
                        return r.name += "_instance_" + e.uses[t]++,
                        r
                    }
                    ,
                    D.prototype._invokeOne = function(e) {
                        var t = Object.values(this.plugins);
                        t.push(this);
                        for (var n = 0; n < t.length; n++) {
                            var r = e(t[n]);
                            if (r)
                                return r
                        }
                    }
                    ,
                    D.prototype._invokeAll = function(e) {
                        var t = Object.values(this.plugins);
                        t.unshift(this);
                        for (var n = [], r = 0; r < t.length; r++) {
                            var i = e(t[r]);
                            i && n.push(i)
                        }
                        return n
                    }
                    ,
                    D.prototype.getDependency = function(e, t) {
                        var n = e + ":" + t
                          , r = this.cache.get(n);
                        if (!r) {
                            switch (e) {
                            case "scene":
                                r = this.loadScene(t);
                                break;
                            case "node":
                                r = this.loadNode(t);
                                break;
                            case "mesh":
                                r = this._invokeOne((function(e) {
                                    return e.loadMesh && e.loadMesh(t)
                                }
                                ));
                                break;
                            case "accessor":
                                r = this.loadAccessor(t);
                                break;
                            case "bufferView":
                                r = this._invokeOne((function(e) {
                                    return e.loadBufferView && e.loadBufferView(t)
                                }
                                ));
                                break;
                            case "buffer":
                                r = this.loadBuffer(t);
                                break;
                            case "material":
                                r = this._invokeOne((function(e) {
                                    return e.loadMaterial && e.loadMaterial(t)
                                }
                                ));
                                break;
                            case "texture":
                                r = this._invokeOne((function(e) {
                                    return e.loadTexture && e.loadTexture(t)
                                }
                                ));
                                break;
                            case "skin":
                                r = this.loadSkin(t);
                                break;
                            case "animation":
                                r = this.loadAnimation(t);
                                break;
                            case "camera":
                                r = this.loadCamera(t);
                                break;
                            default:
                                throw new Error("Unknown type: " + e)
                            }
                            this.cache.add(n, r)
                        }
                        return r
                    }
                    ,
                    D.prototype.getDependencies = function(e) {
                        var t = this.cache.get(e);
                        if (!t) {
                            var n = this
                              , r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                            t = Promise.all(r.map((function(t, r) {
                                return n.getDependency(e, r)
                            }
                            ))),
                            this.cache.add(e, t)
                        }
                        return t
                    }
                    ,
                    D.prototype.loadBuffer = function(e) {
                        var t = this.json.buffers[e]
                          , r = this.fileLoader;
                        if (t.type && "arraybuffer" !== t.type)
                            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                        if (void 0 === t.uri && 0 === e)
                            return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
                        var i = this.options;
                        return new Promise((function(e, n) {
                            r.load(A(t.uri, i.path), e, void 0, (function() {
                                n(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    D.prototype.loadBufferView = function(e) {
                        var t = this.json.bufferViews[e];
                        return this.getDependency("buffer", t.buffer).then((function(e) {
                            var n = t.byteLength || 0
                              , r = t.byteOffset || 0;
                            return e.slice(r, r + n)
                        }
                        ))
                    }
                    ,
                    D.prototype.loadAccessor = function(e) {
                        var t = this
                          , n = this.json
                          , i = this.json.accessors[e];
                        if (void 0 === i.bufferView && void 0 === i.sparse)
                            return Promise.resolve(null);
                        var a = [];
                        return void 0 !== i.bufferView ? a.push(this.getDependency("bufferView", i.bufferView)) : a.push(null),
                        void 0 !== i.sparse && (a.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
                        a.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
                        Promise.all(a).then((function(e) {
                            var a, o, s = e[0], l = M[i.type], c = x[i.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, d = i.byteOffset || 0, p = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, f = !0 === i.normalized;
                            if (p && p !== h) {
                                var m = Math.floor(d / p)
                                  , g = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + m + ":" + i.count
                                  , v = t.cache.get(g);
                                v || (a = new c(s,m * p,i.count * p / u),
                                v = new r.InterleavedBuffer(a,p / u),
                                t.cache.add(g, v)),
                                o = new r.InterleavedBufferAttribute(v,l,d % p / u,f)
                            } else
                                a = null === s ? new c(i.count * l) : new c(s,d,i.count * l),
                                o = new r.BufferAttribute(a,l,f);
                            if (void 0 !== i.sparse) {
                                var y = M.SCALAR
                                  , _ = x[i.sparse.indices.componentType]
                                  , b = i.sparse.indices.byteOffset || 0
                                  , w = i.sparse.values.byteOffset || 0
                                  , S = new _(e[1],b,i.sparse.count * y)
                                  , T = new c(e[2],w,i.sparse.count * l);
                                null !== s && (o = new r.BufferAttribute(o.array.slice(),o.itemSize,o.normalized));
                                for (var E = 0, A = S.length; E < A; E++) {
                                    var C = S[E];
                                    if (o.setX(C, T[E * l]),
                                    l >= 2 && o.setY(C, T[E * l + 1]),
                                    l >= 3 && o.setZ(C, T[E * l + 2]),
                                    l >= 4 && o.setW(C, T[E * l + 3]),
                                    l >= 5)
                                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                }
                            }
                            return o
                        }
                        ))
                    }
                    ,
                    D.prototype.loadTexture = function(e) {
                        var t, r, i = this.json, a = this.options, o = i.textures[e], s = o.extensions || {};
                        return (t = s[n.MSFT_TEXTURE_DDS] ? i.images[s[n.MSFT_TEXTURE_DDS].source] : i.images[o.source]).uri && (r = a.manager.getHandler(t.uri)),
                        r || (r = s[n.MSFT_TEXTURE_DDS] ? this.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader),
                        this.loadTextureImage(e, t, r)
                    }
                    ,
                    D.prototype.loadTextureImage = function(e, t, n) {
                        var i = this
                          , a = this.json
                          , o = this.options
                          , s = a.textures[e]
                          , l = self.URL || self.webkitURL
                          , c = t.uri
                          , u = !1
                          , h = !0;
                        return "image/jpeg" === t.mimeType && (h = !1),
                        void 0 !== t.bufferView && (c = i.getDependency("bufferView", t.bufferView).then((function(e) {
                            if ("image/png" === t.mimeType) {
                                var n = new DataView(e,25,1).getUint8(0, !1);
                                h = 6 === n || 4 === n || 3 === n
                            }
                            u = !0;
                            var r = new Blob([e],{
                                type: t.mimeType
                            });
                            return c = l.createObjectURL(r)
                        }
                        ))),
                        Promise.resolve(c).then((function(e) {
                            return new Promise((function(t, i) {
                                var a = t;
                                !0 === n.isImageBitmapLoader && (a = function(e) {
                                    t(new r.CanvasTexture(e))
                                }
                                ),
                                n.load(A(e, o.path), a, void 0, i)
                            }
                            ))
                        }
                        )).then((function(t) {
                            !0 === u && l.revokeObjectURL(c),
                            t.flipY = !1,
                            s.name && (t.name = s.name),
                            h || (t.format = r.RGBFormat);
                            var n = (a.samplers || {})[s.sampler] || {};
                            return t.magFilter = b[n.magFilter] || r.LinearFilter,
                            t.minFilter = b[n.minFilter] || r.LinearMipmapLinearFilter,
                            t.wrapS = w[n.wrapS] || r.RepeatWrapping,
                            t.wrapT = w[n.wrapT] || r.RepeatWrapping,
                            i.associations.set(t, {
                                type: "textures",
                                index: e
                            }),
                            t
                        }
                        ))
                    }
                    ,
                    D.prototype.assignTexture = function(e, t, r) {
                        var i = this;
                        return this.getDependency("texture", r.index).then((function(a) {
                            if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === t && 1 == r.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."),
                            i.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                                var o = void 0 !== r.extensions ? r.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (o) {
                                    var s = i.associations.get(a);
                                    a = i.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(a, o),
                                    i.associations.set(a, s)
                                }
                            }
                            e[t] = a
                        }
                        ))
                    }
                    ,
                    D.prototype.assignFinalMaterial = function(e) {
                        var t = e.geometry
                          , n = e.material
                          , i = void 0 !== t.attributes.tangent
                          , a = void 0 !== t.attributes.color
                          , o = void 0 === t.attributes.normal
                          , s = !0 === e.isSkinnedMesh
                          , l = Object.keys(t.morphAttributes).length > 0
                          , c = l && void 0 !== t.morphAttributes.normal;
                        if (e.isPoints) {
                            var u = "PointsMaterial:" + n.uuid
                              , h = this.cache.get(u);
                            h || (h = new r.PointsMaterial,
                            r.Material.prototype.copy.call(h, n),
                            h.color.copy(n.color),
                            h.map = n.map,
                            h.sizeAttenuation = !1,
                            this.cache.add(u, h)),
                            n = h
                        } else if (e.isLine) {
                            u = "LineBasicMaterial:" + n.uuid;
                            var d = this.cache.get(u);
                            d || (d = new r.LineBasicMaterial,
                            r.Material.prototype.copy.call(d, n),
                            d.color.copy(n.color),
                            this.cache.add(u, d)),
                            n = d
                        }
                        if (i || a || o || s || l) {
                            u = "ClonedMaterial:" + n.uuid + ":",
                            n.isGLTFSpecularGlossinessMaterial && (u += "specular-glossiness:"),
                            s && (u += "skinning:"),
                            i && (u += "vertex-tangents:"),
                            a && (u += "vertex-colors:"),
                            o && (u += "flat-shading:"),
                            l && (u += "morph-targets:"),
                            c && (u += "morph-normals:");
                            var p = this.cache.get(u);
                            p || (p = n.clone(),
                            s && (p.skinning = !0),
                            a && (p.vertexColors = !0),
                            o && (p.flatShading = !0),
                            l && (p.morphTargets = !0),
                            c && (p.morphNormals = !0),
                            i && (p.vertexTangents = !0,
                            p.normalScale && (p.normalScale.y *= -1),
                            p.clearcoatNormalScale && (p.clearcoatNormalScale.y *= -1)),
                            this.cache.add(u, p),
                            this.associations.set(p, this.associations.get(n))),
                            n = p
                        }
                        n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv),
                        e.material = n
                    }
                    ,
                    D.prototype.getMaterialType = function() {
                        return r.MeshStandardMaterial
                    }
                    ,
                    D.prototype.loadMaterial = function(e) {
                        var t, i = this, a = this.json, o = this.extensions, s = a.materials[e], l = {}, c = s.extensions || {}, u = [];
                        if (c[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            var h = o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            t = h.getMaterialType(),
                            u.push(h.extendParams(l, s, i))
                        } else if (c[n.KHR_MATERIALS_UNLIT]) {
                            var d = o[n.KHR_MATERIALS_UNLIT];
                            t = d.getMaterialType(),
                            u.push(d.extendParams(l, s, i))
                        } else {
                            var p = s.pbrMetallicRoughness || {};
                            if (l.color = new r.Color(1,1,1),
                            l.opacity = 1,
                            Array.isArray(p.baseColorFactor)) {
                                var f = p.baseColorFactor;
                                l.color.fromArray(f),
                                l.opacity = f[3]
                            }
                            void 0 !== p.baseColorTexture && u.push(i.assignTexture(l, "map", p.baseColorTexture)),
                            l.metalness = void 0 !== p.metallicFactor ? p.metallicFactor : 1,
                            l.roughness = void 0 !== p.roughnessFactor ? p.roughnessFactor : 1,
                            void 0 !== p.metallicRoughnessTexture && (u.push(i.assignTexture(l, "metalnessMap", p.metallicRoughnessTexture)),
                            u.push(i.assignTexture(l, "roughnessMap", p.metallicRoughnessTexture))),
                            t = this._invokeOne((function(t) {
                                return t.getMaterialType && t.getMaterialType(e)
                            }
                            )),
                            u.push(Promise.all(this._invokeAll((function(t) {
                                return t.extendMaterialParams && t.extendMaterialParams(e, l)
                            }
                            ))))
                        }
                        !0 === s.doubleSided && (l.side = r.DoubleSide);
                        var m = s.alphaMode || "OPAQUE";
                        return "BLEND" === m ? (l.transparent = !0,
                        l.depthWrite = !1) : (l.transparent = !1,
                        "MASK" === m && (l.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)),
                        void 0 !== s.normalTexture && t !== r.MeshBasicMaterial && (u.push(i.assignTexture(l, "normalMap", s.normalTexture)),
                        l.normalScale = new r.Vector2(1,-1),
                        void 0 !== s.normalTexture.scale && l.normalScale.set(s.normalTexture.scale, -s.normalTexture.scale)),
                        void 0 !== s.occlusionTexture && t !== r.MeshBasicMaterial && (u.push(i.assignTexture(l, "aoMap", s.occlusionTexture)),
                        void 0 !== s.occlusionTexture.strength && (l.aoMapIntensity = s.occlusionTexture.strength)),
                        void 0 !== s.emissiveFactor && t !== r.MeshBasicMaterial && (l.emissive = (new r.Color).fromArray(s.emissiveFactor)),
                        void 0 !== s.emissiveTexture && t !== r.MeshBasicMaterial && u.push(i.assignTexture(l, "emissiveMap", s.emissiveTexture)),
                        Promise.all(u).then((function() {
                            var a;
                            return a = t === g ? o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l) : new t(l),
                            s.name && (a.name = s.name),
                            a.map && (a.map.encoding = r.sRGBEncoding),
                            a.emissiveMap && (a.emissiveMap.encoding = r.sRGBEncoding),
                            P(a, s),
                            i.associations.set(a, {
                                type: "materials",
                                index: e
                            }),
                            s.extensions && C(o, a, s),
                            a
                        }
                        ))
                    }
                    ,
                    D.prototype.createUniqueName = function(e) {
                        for (var t = r.PropertyBinding.sanitizeNodeName(e || ""), n = t, i = 1; this.nodeNamesUsed[n]; ++i)
                            n = t + "_" + i;
                        return this.nodeNamesUsed[n] = !0,
                        n
                    }
                    ,
                    D.prototype.loadGeometries = function(e) {
                        var t = this
                          , i = this.extensions
                          , a = this.primitiveCache;
                        function o(e) {
                            return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                                return O(n, e, t)
                            }
                            ))
                        }
                        for (var s, l, c = [], u = 0, h = e.length; u < h; u++) {
                            var d, p = e[u], f = (void 0,
                            (l = (s = p).extensions && s.extensions[n.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + l.bufferView + ":" + l.indices + ":" + L(l.attributes) : s.indices + ":" + L(s.attributes) + ":" + s.mode), m = a[f];
                            m ? c.push(m.promise) : (d = p.extensions && p.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? o(p) : O(new r.BufferGeometry, p, t),
                            a[f] = {
                                primitive: p,
                                promise: d
                            },
                            c.push(d))
                        }
                        return Promise.all(c)
                    }
                    ,
                    D.prototype.loadMesh = function(e) {
                        for (var t, n = this, i = this.json, a = this.extensions, o = i.meshes[e], s = o.primitives, l = [], c = 0, u = s.length; c < u; c++) {
                            var h = void 0 === s[c].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new r.MeshStandardMaterial({
                                color: 16777215,
                                emissive: 0,
                                metalness: 1,
                                roughness: 1,
                                transparent: !1,
                                depthTest: !0,
                                side: r.FrontSide
                            })),
                            t.DefaultMaterial) : this.getDependency("material", s[c].material);
                            l.push(h)
                        }
                        return l.push(n.loadGeometries(s)),
                        Promise.all(l).then((function(t) {
                            for (var i = t.slice(0, t.length - 1), l = t[t.length - 1], c = [], u = 0, h = l.length; u < h; u++) {
                                var d, p = l[u], f = s[u], m = i[u];
                                if (4 === f.mode || 5 === f.mode || 6 === f.mode || void 0 === f.mode)
                                    d = !0 === o.isSkinnedMesh ? new r.SkinnedMesh(p,m) : new r.Mesh(p,m),
                                    !0 === m.isMeshStandardMaterial && m.side === r.DoubleSide && null !== p.getIndex() && !0 === p.hasAttribute("position") && !0 === p.hasAttribute("normal") && !0 === p.hasAttribute("uv") && !1 === p.hasAttribute("tangent") && (p.computeTangents(),
                                    m.vertexTangents = !0),
                                    !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(),
                                    5 === f.mode ? d.geometry = F(d.geometry, r.TriangleStripDrawMode) : 6 === f.mode && (d.geometry = F(d.geometry, r.TriangleFanDrawMode));
                                else if (1 === f.mode)
                                    d = new r.LineSegments(p,m);
                                else if (3 === f.mode)
                                    d = new r.Line(p,m);
                                else if (2 === f.mode)
                                    d = new r.LineLoop(p,m);
                                else {
                                    if (0 !== f.mode)
                                        throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + f.mode);
                                    d = new r.Points(p,m)
                                }
                                Object.keys(d.geometry.morphAttributes).length > 0 && R(d, o),
                                d.name = n.createUniqueName(o.name || "mesh_" + e),
                                P(d, o),
                                f.extensions && C(a, d, f),
                                n.assignFinalMaterial(d),
                                c.push(d)
                            }
                            if (1 === c.length)
                                return c[0];
                            var g = new r.Group;
                            for (u = 0,
                            h = c.length; u < h; u++)
                                g.add(c[u]);
                            return g
                        }
                        ))
                    }
                    ,
                    D.prototype.loadCamera = function(e) {
                        var t, n = this.json.cameras[e], i = n[n.type];
                        if (i)
                            return "perspective" === n.type ? t = new r.PerspectiveCamera(r.MathUtils.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (t = new r.OrthographicCamera(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                            n.name && (t.name = this.createUniqueName(n.name)),
                            P(t, n),
                            Promise.resolve(t);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }
                    ,
                    D.prototype.loadSkin = function(e) {
                        var t = this.json.skins[e]
                          , n = {
                            joints: t.joints
                        };
                        return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                            return n.inverseBindMatrices = e,
                            n
                        }
                        ))
                    }
                    ,
                    D.prototype.loadAnimation = function(e) {
                        for (var t = this.json.animations[e], n = [], i = [], a = [], o = [], s = [], l = 0, c = t.channels.length; l < c; l++) {
                            var u = t.channels[l]
                              , h = t.samplers[u.sampler]
                              , d = u.target
                              , p = void 0 !== d.node ? d.node : d.id
                              , f = void 0 !== t.parameters ? t.parameters[h.input] : h.input
                              , m = void 0 !== t.parameters ? t.parameters[h.output] : h.output;
                            n.push(this.getDependency("node", p)),
                            i.push(this.getDependency("accessor", f)),
                            a.push(this.getDependency("accessor", m)),
                            o.push(h),
                            s.push(d)
                        }
                        return Promise.all([Promise.all(n), Promise.all(i), Promise.all(a), Promise.all(o), Promise.all(s)]).then((function(n) {
                            for (var i = n[0], a = n[1], o = n[2], s = n[3], l = n[4], c = [], u = 0, h = i.length; u < h; u++) {
                                var d = i[u]
                                  , p = a[u]
                                  , f = o[u]
                                  , m = s[u]
                                  , g = l[u];
                                if (void 0 !== d) {
                                    var v;
                                    switch (d.updateMatrix(),
                                    d.matrixAutoUpdate = !0,
                                    T[g.path]) {
                                    case T.weights:
                                        v = r.NumberKeyframeTrack;
                                        break;
                                    case T.rotation:
                                        v = r.QuaternionKeyframeTrack;
                                        break;
                                    default:
                                        v = r.VectorKeyframeTrack
                                    }
                                    var y = d.name ? d.name : d.uuid
                                      , x = void 0 !== m.interpolation ? E[m.interpolation] : r.InterpolateLinear
                                      , b = [];
                                    T[g.path] === T.weights ? d.traverse((function(e) {
                                        !0 === e.isMesh && e.morphTargetInfluences && b.push(e.name ? e.name : e.uuid)
                                    }
                                    )) : b.push(y);
                                    var w = f.array;
                                    if (f.normalized) {
                                        var M;
                                        if (w.constructor === Int8Array)
                                            M = 1 / 127;
                                        else if (w.constructor === Uint8Array)
                                            M = 1 / 255;
                                        else if (w.constructor == Int16Array)
                                            M = 1 / 32767;
                                        else {
                                            if (w.constructor !== Uint16Array)
                                                throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                            M = 1 / 65535
                                        }
                                        for (var S = new Float32Array(w.length), A = 0, C = w.length; A < C; A++)
                                            S[A] = w[A] * M;
                                        w = S
                                    }
                                    for (A = 0,
                                    C = b.length; A < C; A++) {
                                        var P = new v(b[A] + "." + T[g.path],p.array,w,x);
                                        "CUBICSPLINE" === m.interpolation && (P.createInterpolant = function(e) {
                                            return new _(this.times,this.values,this.getValueSize() / 3,e)
                                        }
                                        ,
                                        P.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                                        c.push(P)
                                    }
                                }
                            }
                            var R = t.name ? t.name : "animation_" + e;
                            return new r.AnimationClip(R,void 0,c)
                        }
                        ))
                    }
                    ,
                    D.prototype.loadNode = function(e) {
                        var t, n = this.json, i = this.extensions, a = this, o = n.nodes[e], s = o.name ? a.createUniqueName(o.name) : "";
                        return (t = [],
                        void 0 !== o.mesh && t.push(a.getDependency("mesh", o.mesh).then((function(e) {
                            var t = a._getNodeRef(a.meshCache, o.mesh, e);
                            return void 0 !== o.weights && t.traverse((function(e) {
                                if (e.isMesh)
                                    for (var t = 0, n = o.weights.length; t < n; t++)
                                        e.morphTargetInfluences[t] = o.weights[t]
                            }
                            )),
                            t
                        }
                        ))),
                        void 0 !== o.camera && t.push(a.getDependency("camera", o.camera).then((function(e) {
                            return a._getNodeRef(a.cameraCache, o.camera, e)
                        }
                        ))),
                        a._invokeAll((function(t) {
                            return t.createNodeAttachment && t.createNodeAttachment(e)
                        }
                        )).forEach((function(e) {
                            t.push(e)
                        }
                        )),
                        Promise.all(t)).then((function(t) {
                            var n;
                            if ((n = !0 === o.isBone ? new r.Bone : t.length > 1 ? new r.Group : 1 === t.length ? t[0] : new r.Object3D) !== t[0])
                                for (var l = 0, c = t.length; l < c; l++)
                                    n.add(t[l]);
                            if (o.name && (n.userData.name = o.name,
                            n.name = s),
                            P(n, o),
                            o.extensions && C(i, n, o),
                            void 0 !== o.matrix) {
                                var u = new r.Matrix4;
                                u.fromArray(o.matrix),
                                n.applyMatrix4(u)
                            } else
                                void 0 !== o.translation && n.position.fromArray(o.translation),
                                void 0 !== o.rotation && n.quaternion.fromArray(o.rotation),
                                void 0 !== o.scale && n.scale.fromArray(o.scale);
                            return a.associations.set(n, {
                                type: "nodes",
                                index: e
                            }),
                            n
                        }
                        ))
                    }
                    ,
                    D.prototype.loadScene = function() {
                        function e(t, n, i, a) {
                            var o = i.nodes[t];
                            return a.getDependency("node", t).then((function(e) {
                                return void 0 === o.skin ? e : a.getDependency("skin", o.skin).then((function(e) {
                                    for (var n = [], r = 0, i = (t = e).joints.length; r < i; r++)
                                        n.push(a.getDependency("node", t.joints[r]));
                                    return Promise.all(n)
                                }
                                )).then((function(n) {
                                    return e.traverse((function(e) {
                                        if (e.isMesh) {
                                            for (var i = [], a = [], o = 0, s = n.length; o < s; o++) {
                                                var l = n[o];
                                                if (l) {
                                                    i.push(l);
                                                    var c = new r.Matrix4;
                                                    void 0 !== t.inverseBindMatrices && c.fromArray(t.inverseBindMatrices.array, 16 * o),
                                                    a.push(c)
                                                } else
                                                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[o])
                                            }
                                            e.bind(new r.Skeleton(i,a), e.matrixWorld)
                                        }
                                    }
                                    )),
                                    e
                                }
                                ));
                                var t
                            }
                            )).then((function(t) {
                                n.add(t);
                                var r = [];
                                if (o.children)
                                    for (var s = o.children, l = 0, c = s.length; l < c; l++) {
                                        var u = s[l];
                                        r.push(e(u, t, i, a))
                                    }
                                return Promise.all(r)
                            }
                            ))
                        }
                        return function(t) {
                            var n = this.json
                              , i = this.extensions
                              , a = this.json.scenes[t]
                              , o = new r.Group;
                            a.name && (o.name = this.createUniqueName(a.name)),
                            P(o, a),
                            a.extensions && C(i, o, a);
                            for (var s = a.nodes || [], l = [], c = 0, u = s.length; c < u; c++)
                                l.push(e(s[c], o, n, this));
                            return Promise.all(l).then((function() {
                                return o
                            }
                            ))
                        }
                    }(),
                    e
                }()
            }
            ,
            1356: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    HDRCubeTextureLoader: ()=>a
                });
                var r = n(2212)
                  , i = n(5174)
                  , a = function(e) {
                    r.Loader.call(this, e),
                    this.hdrLoader = new i.RGBELoader,
                    this.type = r.UnsignedByteType
                };
                a.prototype = Object.assign(Object.create(r.Loader.prototype), {
                    constructor: a,
                    load: function(e, t, n, i) {
                        Array.isArray(e) || (console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead."),
                        this.setDataType(e),
                        e = t,
                        t = n,
                        n = i,
                        i = arguments[4]);
                        var a = new r.CubeTexture;
                        switch (a.type = this.type,
                        a.type) {
                        case r.UnsignedByteType:
                            a.encoding = r.RGBEEncoding,
                            a.format = r.RGBAFormat,
                            a.minFilter = r.NearestFilter,
                            a.magFilter = r.NearestFilter,
                            a.generateMipmaps = !1;
                            break;
                        case r.FloatType:
                        case r.HalfFloatType:
                            a.encoding = r.LinearEncoding,
                            a.format = r.RGBFormat,
                            a.minFilter = r.LinearFilter,
                            a.magFilter = r.LinearFilter,
                            a.generateMipmaps = !1
                        }
                        var o = this
                          , s = 0;
                        function l(t, n, i, l) {
                            new r.FileLoader(o.manager).setPath(o.path).setResponseType("arraybuffer").setWithCredentials(o.withCredentials).load(e[t], (function(e) {
                                s++;
                                var i = o.hdrLoader.parse(e);
                                if (i) {
                                    if (void 0 !== i.data) {
                                        var l = new r.DataTexture(i.data,i.width,i.height);
                                        l.type = a.type,
                                        l.encoding = a.encoding,
                                        l.format = a.format,
                                        l.minFilter = a.minFilter,
                                        l.magFilter = a.magFilter,
                                        l.generateMipmaps = a.generateMipmaps,
                                        a.images[t] = l
                                    }
                                    6 === s && (a.needsUpdate = !0,
                                    n && n(a))
                                }
                            }
                            ), i, l)
                        }
                        for (var c = 0; c < e.length; c++)
                            l(c, t, n, i);
                        return a
                    },
                    setDataType: function(e) {
                        return this.type = e,
                        this.hdrLoader.setDataType(e),
                        this
                    }
                })
            }
            ,
            8840: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    OBJLoader: ()=>i
                });
                var r = n(2212)
                  , i = function() {
                    var e = /^[og]\s*(.+)?/
                      , t = /^mtllib /
                      , n = /^usemtl /
                      , i = /^usemap /
                      , a = new r.Vector3
                      , o = new r.Vector3
                      , s = new r.Vector3
                      , l = new r.Vector3
                      , c = new r.Vector3;
                    function u() {
                        var e = {
                            objects: [],
                            object: {},
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            materials: {},
                            materialLibraries: [],
                            startObject: function(e, t) {
                                if (this.object && !1 === this.object.fromDeclaration)
                                    return this.object.name = e,
                                    void (this.object.fromDeclaration = !1 !== t);
                                var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                                if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0),
                                this.object = {
                                    name: e || "",
                                    fromDeclaration: !1 !== t,
                                    geometry: {
                                        vertices: [],
                                        normals: [],
                                        colors: [],
                                        uvs: [],
                                        hasUVIndices: !1
                                    },
                                    materials: [],
                                    smooth: !0,
                                    startMaterial: function(e, t) {
                                        var n = this._finalize(!1);
                                        n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                        var r = {
                                            index: this.materials.length,
                                            name: e || "",
                                            mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                            smooth: void 0 !== n ? n.smooth : this.smooth,
                                            groupStart: void 0 !== n ? n.groupEnd : 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1,
                                            clone: function(e) {
                                                var t = {
                                                    index: "number" == typeof e ? e : this.index,
                                                    name: this.name,
                                                    mtllib: this.mtllib,
                                                    smooth: this.smooth,
                                                    groupStart: 0,
                                                    groupEnd: -1,
                                                    groupCount: -1,
                                                    inherited: !1
                                                };
                                                return t.clone = this.clone.bind(t),
                                                t
                                            }
                                        };
                                        return this.materials.push(r),
                                        r
                                    },
                                    currentMaterial: function() {
                                        if (this.materials.length > 0)
                                            return this.materials[this.materials.length - 1]
                                    },
                                    _finalize: function(e) {
                                        var t = this.currentMaterial();
                                        if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3,
                                        t.groupCount = t.groupEnd - t.groupStart,
                                        t.inherited = !1),
                                        e && this.materials.length > 1)
                                            for (var n = this.materials.length - 1; n >= 0; n--)
                                                this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                                        return e && 0 === this.materials.length && this.materials.push({
                                            name: "",
                                            smooth: this.smooth
                                        }),
                                        t
                                    }
                                },
                                n && n.name && "function" == typeof n.clone) {
                                    var r = n.clone(0);
                                    r.inherited = !0,
                                    this.object.materials.push(r)
                                }
                                this.objects.push(this.object)
                            },
                            finalize: function() {
                                this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                            },
                            parseVertexIndex: function(e, t) {
                                var n = parseInt(e, 10);
                                return 3 * (n >= 0 ? n - 1 : n + t / 3)
                            },
                            parseNormalIndex: function(e, t) {
                                var n = parseInt(e, 10);
                                return 3 * (n >= 0 ? n - 1 : n + t / 3)
                            },
                            parseUVIndex: function(e, t) {
                                var n = parseInt(e, 10);
                                return 2 * (n >= 0 ? n - 1 : n + t / 2)
                            },
                            addVertex: function(e, t, n) {
                                var r = this.vertices
                                  , i = this.object.geometry.vertices;
                                i.push(r[e + 0], r[e + 1], r[e + 2]),
                                i.push(r[t + 0], r[t + 1], r[t + 2]),
                                i.push(r[n + 0], r[n + 1], r[n + 2])
                            },
                            addVertexPoint: function(e) {
                                var t = this.vertices;
                                this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                            },
                            addVertexLine: function(e) {
                                var t = this.vertices;
                                this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                            },
                            addNormal: function(e, t, n) {
                                var r = this.normals
                                  , i = this.object.geometry.normals;
                                i.push(r[e + 0], r[e + 1], r[e + 2]),
                                i.push(r[t + 0], r[t + 1], r[t + 2]),
                                i.push(r[n + 0], r[n + 1], r[n + 2])
                            },
                            addFaceNormal: function(e, t, n) {
                                var r = this.vertices
                                  , i = this.object.geometry.normals;
                                a.fromArray(r, e),
                                o.fromArray(r, t),
                                s.fromArray(r, n),
                                c.subVectors(s, o),
                                l.subVectors(a, o),
                                c.cross(l),
                                c.normalize(),
                                i.push(c.x, c.y, c.z),
                                i.push(c.x, c.y, c.z),
                                i.push(c.x, c.y, c.z)
                            },
                            addColor: function(e, t, n) {
                                var r = this.colors
                                  , i = this.object.geometry.colors;
                                void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]),
                                void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]),
                                void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2])
                            },
                            addUV: function(e, t, n) {
                                var r = this.uvs
                                  , i = this.object.geometry.uvs;
                                i.push(r[e + 0], r[e + 1]),
                                i.push(r[t + 0], r[t + 1]),
                                i.push(r[n + 0], r[n + 1])
                            },
                            addDefaultUV: function() {
                                var e = this.object.geometry.uvs;
                                e.push(0, 0),
                                e.push(0, 0),
                                e.push(0, 0)
                            },
                            addUVLine: function(e) {
                                var t = this.uvs;
                                this.object.geometry.uvs.push(t[e + 0], t[e + 1])
                            },
                            addFace: function(e, t, n, r, i, a, o, s, l) {
                                var c = this.vertices.length
                                  , u = this.parseVertexIndex(e, c)
                                  , h = this.parseVertexIndex(t, c)
                                  , d = this.parseVertexIndex(n, c);
                                if (this.addVertex(u, h, d),
                                this.addColor(u, h, d),
                                void 0 !== o && "" !== o) {
                                    var p = this.normals.length;
                                    u = this.parseNormalIndex(o, p),
                                    h = this.parseNormalIndex(s, p),
                                    d = this.parseNormalIndex(l, p),
                                    this.addNormal(u, h, d)
                                } else
                                    this.addFaceNormal(u, h, d);
                                if (void 0 !== r && "" !== r) {
                                    var f = this.uvs.length;
                                    u = this.parseUVIndex(r, f),
                                    h = this.parseUVIndex(i, f),
                                    d = this.parseUVIndex(a, f),
                                    this.addUV(u, h, d),
                                    this.object.geometry.hasUVIndices = !0
                                } else
                                    this.addDefaultUV()
                            },
                            addPointGeometry: function(e) {
                                this.object.geometry.type = "Points";
                                for (var t = this.vertices.length, n = 0, r = e.length; n < r; n++) {
                                    var i = this.parseVertexIndex(e[n], t);
                                    this.addVertexPoint(i),
                                    this.addColor(i)
                                }
                            },
                            addLineGeometry: function(e, t) {
                                this.object.geometry.type = "Line";
                                for (var n = this.vertices.length, r = this.uvs.length, i = 0, a = e.length; i < a; i++)
                                    this.addVertexLine(this.parseVertexIndex(e[i], n));
                                var o = 0;
                                for (a = t.length; o < a; o++)
                                    this.addUVLine(this.parseUVIndex(t[o], r))
                            }
                        };
                        return e.startObject("", !1),
                        e
                    }
                    function h(e) {
                        r.Loader.call(this, e),
                        this.materials = null
                    }
                    return h.prototype = Object.assign(Object.create(r.Loader.prototype), {
                        constructor: h,
                        load: function(e, t, n, i) {
                            var a = this
                              , o = new r.FileLoader(this.manager);
                            o.setPath(this.path),
                            o.setRequestHeader(this.requestHeader),
                            o.setWithCredentials(this.withCredentials),
                            o.load(e, (function(n) {
                                try {
                                    t(a.parse(n))
                                } catch (t) {
                                    i ? i(t) : console.error(t),
                                    a.manager.itemError(e)
                                }
                            }
                            ), n, i)
                        },
                        setMaterials: function(e) {
                            return this.materials = e,
                            this
                        },
                        parse: function(a) {
                            var o = new u;
                            -1 !== a.indexOf("\r\n") && (a = a.replace(/\r\n/g, "\n")),
                            -1 !== a.indexOf("\\\n") && (a = a.replace(/\\\n/g, ""));
                            for (var s = a.split("\n"), l = "", c = "", h = [], d = "function" == typeof "".trimLeft, p = 0, f = s.length; p < f; p++)
                                if (l = s[p],
                                0 !== (l = d ? l.trimLeft() : l.trim()).length && "#" !== (c = l.charAt(0)))
                                    if ("v" === c) {
                                        var m = l.split(/\s+/);
                                        switch (m[0]) {
                                        case "v":
                                            o.vertices.push(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])),
                                            m.length >= 7 ? o.colors.push(parseFloat(m[4]), parseFloat(m[5]), parseFloat(m[6])) : o.colors.push(void 0, void 0, void 0);
                                            break;
                                        case "vn":
                                            o.normals.push(parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]));
                                            break;
                                        case "vt":
                                            o.uvs.push(parseFloat(m[1]), parseFloat(m[2]))
                                        }
                                    } else if ("f" === c) {
                                        for (var g = l.substr(1).trim().split(/\s+/), v = [], y = 0, _ = g.length; y < _; y++) {
                                            var x = g[y];
                                            if (x.length > 0) {
                                                var b = x.split("/");
                                                v.push(b)
                                            }
                                        }
                                        var w = v[0];
                                        for (y = 1,
                                        _ = v.length - 1; y < _; y++) {
                                            var M = v[y]
                                              , S = v[y + 1];
                                            o.addFace(w[0], M[0], S[0], w[1], M[1], S[1], w[2], M[2], S[2])
                                        }
                                    } else if ("l" === c) {
                                        var T = l.substring(1).trim().split(" ")
                                          , E = []
                                          , A = [];
                                        if (-1 === l.indexOf("/"))
                                            E = T;
                                        else
                                            for (var C = 0, P = T.length; C < P; C++) {
                                                var R = T[C].split("/");
                                                "" !== R[0] && E.push(R[0]),
                                                "" !== R[1] && A.push(R[1])
                                            }
                                        o.addLineGeometry(E, A)
                                    } else if ("p" === c) {
                                        var L = l.substr(1).trim().split(" ");
                                        o.addPointGeometry(L)
                                    } else if (null !== (h = e.exec(l))) {
                                        var D = (" " + h[0].substr(1).trim()).substr(1);
                                        o.startObject(D)
                                    } else if (n.test(l))
                                        o.object.startMaterial(l.substring(7).trim(), o.materialLibraries);
                                    else if (t.test(l))
                                        o.materialLibraries.push(l.substring(7).trim());
                                    else if (i.test(l))
                                        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                                    else if ("s" === c) {
                                        if ((h = l.split(" ")).length > 1) {
                                            var O = h[1].trim().toLowerCase();
                                            o.object.smooth = "0" !== O && "off" !== O
                                        } else
                                            o.object.smooth = !0;
                                        (q = o.object.currentMaterial()) && (q.smooth = o.object.smooth)
                                    } else {
                                        if ("\0" === l)
                                            continue;
                                        console.warn('THREE.OBJLoader: Unexpected line: "' + l + '"')
                                    }
                            o.finalize();
                            var F = new r.Group;
                            if (F.materialLibraries = [].concat(o.materialLibraries),
                            !0 == !(1 === o.objects.length && 0 === o.objects[0].geometry.vertices.length))
                                for (p = 0,
                                f = o.objects.length; p < f; p++) {
                                    var I = o.objects[p]
                                      , N = I.geometry
                                      , B = I.materials
                                      , k = "Line" === N.type
                                      , z = "Points" === N.type
                                      , U = !1;
                                    if (0 !== N.vertices.length) {
                                        (J = new r.BufferGeometry).setAttribute("position", new r.Float32BufferAttribute(N.vertices,3)),
                                        N.normals.length > 0 && J.setAttribute("normal", new r.Float32BufferAttribute(N.normals,3)),
                                        N.colors.length > 0 && (U = !0,
                                        J.setAttribute("color", new r.Float32BufferAttribute(N.colors,3))),
                                        !0 === N.hasUVIndices && J.setAttribute("uv", new r.Float32BufferAttribute(N.uvs,2));
                                        for (var H, G = [], j = 0, V = B.length; j < V; j++) {
                                            var W = (Z = B[j]).name + "_" + Z.smooth + "_" + U
                                              , q = o.materials[W];
                                            if (null !== this.materials)
                                                if (q = this.materials.create(Z.name),
                                                !k || !q || q instanceof r.LineBasicMaterial) {
                                                    if (z && q && !(q instanceof r.PointsMaterial)) {
                                                        var X = new r.PointsMaterial({
                                                            size: 10,
                                                            sizeAttenuation: !1
                                                        });
                                                        r.Material.prototype.copy.call(X, q),
                                                        X.color.copy(q.color),
                                                        X.map = q.map,
                                                        q = X
                                                    }
                                                } else {
                                                    var Y = new r.LineBasicMaterial;
                                                    r.Material.prototype.copy.call(Y, q),
                                                    Y.color.copy(q.color),
                                                    q = Y
                                                }
                                            void 0 === q && ((q = k ? new r.LineBasicMaterial : z ? new r.PointsMaterial({
                                                size: 1,
                                                sizeAttenuation: !1
                                            }) : new r.MeshPhongMaterial).name = Z.name,
                                            q.flatShading = !Z.smooth,
                                            q.vertexColors = U,
                                            o.materials[W] = q),
                                            G.push(q)
                                        }
                                        if (G.length > 1) {
                                            for (j = 0,
                                            V = B.length; j < V; j++) {
                                                var Z = B[j];
                                                J.addGroup(Z.groupStart, Z.groupCount, j)
                                            }
                                            H = k ? new r.LineSegments(J,G) : z ? new r.Points(J,G) : new r.Mesh(J,G)
                                        } else
                                            H = k ? new r.LineSegments(J,G[0]) : z ? new r.Points(J,G[0]) : new r.Mesh(J,G[0]);
                                        H.name = I.name,
                                        F.add(H)
                                    }
                                }
                            else if (o.vertices.length > 0) {
                                var J;
                                q = new r.PointsMaterial({
                                    size: 1,
                                    sizeAttenuation: !1
                                }),
                                (J = new r.BufferGeometry).setAttribute("position", new r.Float32BufferAttribute(o.vertices,3)),
                                o.colors.length > 0 && void 0 !== o.colors[0] && (J.setAttribute("color", new r.Float32BufferAttribute(o.colors,3)),
                                q.vertexColors = !0);
                                var K = new r.Points(J,q);
                                F.add(K)
                            }
                            return F
                        }
                    }),
                    h
                }()
            }
            ,
            5174: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    RGBELoader: ()=>i
                });
                var r = n(2212)
                  , i = function(e) {
                    r.DataTextureLoader.call(this, e),
                    this.type = r.UnsignedByteType
                };
                i.prototype = Object.assign(Object.create(r.DataTextureLoader.prototype), {
                    constructor: i,
                    parse: function(e) {
                        var t = function(e, t) {
                            switch (e) {
                            case 1:
                                console.error("THREE.RGBELoader Read Error: " + (t || ""));
                                break;
                            case 2:
                                console.error("THREE.RGBELoader Write Error: " + (t || ""));
                                break;
                            case 3:
                                console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
                                break;
                            default:
                                console.error("THREE.RGBELoader: Error: " + (t || ""))
                            }
                            return -1
                        }
                          , n = function(e, t, n) {
                            t = t || 1024;
                            for (var r = e.pos, i = -1, a = 0, o = "", s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128))); 0 > (i = s.indexOf("\n")) && a < t && r < e.byteLength; )
                                o += s,
                                a += s.length,
                                r += 128,
                                s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                            return -1 < i && (!1 !== n && (e.pos += a + i + 1),
                            o + s.slice(0, i))
                        }
                          , i = function(e, t, n, i) {
                            var a = e[t + 3]
                              , o = Math.pow(2, a - 128) / 255;
                            n[i + 0] = r.DataUtils.toHalfFloat(e[t + 0] * o),
                            n[i + 1] = r.DataUtils.toHalfFloat(e[t + 1] * o),
                            n[i + 2] = r.DataUtils.toHalfFloat(e[t + 2] * o)
                        }
                          , a = new Uint8Array(e);
                        a.pos = 0;
                        var o, s, l, c, u, h, d = function(e) {
                            var r, i, a = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, o = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s = /^\s*FORMAT=(\S+)\s*$/, l = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, c = {
                                valid: 0,
                                string: "",
                                comments: "",
                                programtype: "RGBE",
                                format: "",
                                gamma: 1,
                                exposure: 1,
                                width: 0,
                                height: 0
                            };
                            if (e.pos >= e.byteLength || !(r = n(e)))
                                return t(1, "no header found");
                            if (!(i = r.match(/^#\?(\S+)/)))
                                return t(3, "bad initial token");
                            for (c.valid |= 1,
                            c.programtype = i[1],
                            c.string += r + "\n"; !1 !== (r = n(e)); )
                                if (c.string += r + "\n",
                                "#" !== r.charAt(0)) {
                                    if ((i = r.match(a)) && (c.gamma = parseFloat(i[1], 10)),
                                    (i = r.match(o)) && (c.exposure = parseFloat(i[1], 10)),
                                    (i = r.match(s)) && (c.valid |= 2,
                                    c.format = i[1]),
                                    (i = r.match(l)) && (c.valid |= 4,
                                    c.height = parseInt(i[1], 10),
                                    c.width = parseInt(i[2], 10)),
                                    2 & c.valid && 4 & c.valid)
                                        break
                                } else
                                    c.comments += r + "\n";
                            return 2 & c.valid ? 4 & c.valid ? c : t(3, "missing image size specifier") : t(3, "missing format specifier")
                        }(a);
                        if (-1 !== d) {
                            var p = d.width
                              , f = d.height
                              , m = function(e, n, r) {
                                var i, a, o, s, l, c, u, h, d, p, f, m, g, v = n, y = r;
                                if (v < 8 || v > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2])
                                    return new Uint8Array(e);
                                if (v !== (e[2] << 8 | e[3]))
                                    return t(3, "wrong scanline width");
                                if (!(i = new Uint8Array(4 * n * r)).length)
                                    return t(4, "unable to allocate buffer space");
                                for (a = 0,
                                o = 0,
                                h = 4 * v,
                                g = new Uint8Array(4),
                                c = new Uint8Array(h); y > 0 && o < e.byteLength; ) {
                                    if (o + 4 > e.byteLength)
                                        return t(1);
                                    if (g[0] = e[o++],
                                    g[1] = e[o++],
                                    g[2] = e[o++],
                                    g[3] = e[o++],
                                    2 != g[0] || 2 != g[1] || (g[2] << 8 | g[3]) != v)
                                        return t(3, "bad rgbe scanline format");
                                    for (u = 0; u < h && o < e.byteLength; ) {
                                        if ((m = (s = e[o++]) > 128) && (s -= 128),
                                        0 === s || u + s > h)
                                            return t(3, "bad scanline data");
                                        if (m)
                                            for (l = e[o++],
                                            d = 0; d < s; d++)
                                                c[u++] = l;
                                        else
                                            c.set(e.subarray(o, o + s), u),
                                            u += s,
                                            o += s
                                    }
                                    for (p = v,
                                    d = 0; d < p; d++)
                                        f = 0,
                                        i[a] = c[d + f],
                                        f += v,
                                        i[a + 1] = c[d + f],
                                        f += v,
                                        i[a + 2] = c[d + f],
                                        f += v,
                                        i[a + 3] = c[d + f],
                                        a += 4;
                                    y--
                                }
                                return i
                            }(a.subarray(a.pos), p, f);
                            if (-1 !== m) {
                                switch (this.type) {
                                case r.UnsignedByteType:
                                    var g = m
                                      , v = r.RGBEFormat
                                      , y = r.UnsignedByteType;
                                    break;
                                case r.FloatType:
                                    for (var _ = m.length / 4 * 3, x = new Float32Array(_), b = 0; b < _; b++)
                                        l = x,
                                        c = 3 * b,
                                        void 0,
                                        void 0,
                                        u = (o = m)[3 + (s = 4 * b)],
                                        h = Math.pow(2, u - 128) / 255,
                                        l[c + 0] = o[s + 0] * h,
                                        l[c + 1] = o[s + 1] * h,
                                        l[c + 2] = o[s + 2] * h;
                                    g = x,
                                    v = r.RGBFormat,
                                    y = r.FloatType;
                                    break;
                                case r.HalfFloatType:
                                    _ = m.length / 4 * 3;
                                    var w = new Uint16Array(_);
                                    for (b = 0; b < _; b++)
                                        i(m, 4 * b, w, 3 * b);
                                    g = w,
                                    v = r.RGBFormat,
                                    y = r.HalfFloatType;
                                    break;
                                default:
                                    console.error("THREE.RGBELoader: unsupported type: ", this.type)
                                }
                                return {
                                    width: p,
                                    height: f,
                                    data: g,
                                    header: d.string,
                                    gamma: d.gamma,
                                    exposure: d.exposure,
                                    format: v,
                                    type: y
                                }
                            }
                        }
                        return null
                    },
                    setDataType: function(e) {
                        return this.type = e,
                        this
                    },
                    load: function(e, t, n, i) {
                        return r.DataTextureLoader.prototype.load.call(this, e, (function(e, n) {
                            switch (e.type) {
                            case r.UnsignedByteType:
                                e.encoding = r.RGBEEncoding,
                                e.minFilter = r.NearestFilter,
                                e.magFilter = r.NearestFilter,
                                e.generateMipmaps = !1,
                                e.flipY = !0;
                                break;
                            case r.FloatType:
                            case r.HalfFloatType:
                                e.encoding = r.LinearEncoding,
                                e.minFilter = r.LinearFilter,
                                e.magFilter = r.LinearFilter,
                                e.generateMipmaps = !1,
                                e.flipY = !0
                            }
                            t && t(e, n)
                        }
                        ), n, i)
                    }
                })
            }
            ,
            1334: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    ClearPass: ()=>a
                });
                var r = n(2212)
                  , i = n(740)
                  , a = function(e, t) {
                    i.Pass.call(this),
                    this.needsSwap = !1,
                    this.clearColor = void 0 !== e ? e : 0,
                    this.clearAlpha = void 0 !== t ? t : 0,
                    this._oldClearColor = new r.Color
                };
                a.prototype = Object.assign(Object.create(i.Pass.prototype), {
                    constructor: a,
                    render: function(e, t, n) {
                        var r;
                        this.clearColor && (e.getClearColor(this._oldClearColor),
                        r = e.getClearAlpha(),
                        e.setClearColor(this.clearColor, this.clearAlpha)),
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        e.clear(),
                        this.clearColor && e.setClearColor(this._oldClearColor, r)
                    }
                })
            }
            ,
            2050: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    EffectComposer: ()=>c,
                    Pass: ()=>p
                });
                var r = n(2212)
                  , i = n(8546)
                  , a = n(5980)
                  , o = n(740)
                  , s = function(e, t) {
                    o.Pass.call(this),
                    this.scene = e,
                    this.camera = t,
                    this.clear = !0,
                    this.needsSwap = !1,
                    this.inverse = !1
                };
                s.prototype = Object.assign(Object.create(o.Pass.prototype), {
                    constructor: s,
                    render: function(e, t, n) {
                        var r, i, a = e.getContext(), o = e.state;
                        o.buffers.color.setMask(!1),
                        o.buffers.depth.setMask(!1),
                        o.buffers.color.setLocked(!0),
                        o.buffers.depth.setLocked(!0),
                        this.inverse ? (r = 0,
                        i = 1) : (r = 1,
                        i = 0),
                        o.buffers.stencil.setTest(!0),
                        o.buffers.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE),
                        o.buffers.stencil.setFunc(a.ALWAYS, r, 4294967295),
                        o.buffers.stencil.setClear(i),
                        o.buffers.stencil.setLocked(!0),
                        e.setRenderTarget(n),
                        this.clear && e.clear(),
                        e.render(this.scene, this.camera),
                        e.setRenderTarget(t),
                        this.clear && e.clear(),
                        e.render(this.scene, this.camera),
                        o.buffers.color.setLocked(!1),
                        o.buffers.depth.setLocked(!1),
                        o.buffers.stencil.setLocked(!1),
                        o.buffers.stencil.setFunc(a.EQUAL, 1, 4294967295),
                        o.buffers.stencil.setOp(a.KEEP, a.KEEP, a.KEEP),
                        o.buffers.stencil.setLocked(!0)
                    }
                });
                var l = function() {
                    o.Pass.call(this),
                    this.needsSwap = !1
                };
                l.prototype = Object.create(o.Pass.prototype),
                Object.assign(l.prototype, {
                    render: function(e) {
                        e.state.buffers.stencil.setLocked(!1),
                        e.state.buffers.stencil.setTest(!1)
                    }
                });
                var c = function(e, t) {
                    if (this.renderer = e,
                    void 0 === t) {
                        var n = {
                            minFilter: r.LinearFilter,
                            magFilter: r.LinearFilter,
                            format: r.RGBAFormat
                        }
                          , o = e.getSize(new r.Vector2);
                        this._pixelRatio = e.getPixelRatio(),
                        this._width = o.width,
                        this._height = o.height,
                        (t = new r.WebGLRenderTarget(this._width * this._pixelRatio,this._height * this._pixelRatio,n)).texture.name = "EffectComposer.rt1"
                    } else
                        this._pixelRatio = 1,
                        this._width = t.width,
                        this._height = t.height;
                    this.renderTarget1 = t,
                    this.renderTarget2 = t.clone(),
                    this.renderTarget2.texture.name = "EffectComposer.rt2",
                    this.writeBuffer = this.renderTarget1,
                    this.readBuffer = this.renderTarget2,
                    this.renderToScreen = !0,
                    this.passes = [],
                    void 0 === i.CopyShader && console.error("THREE.EffectComposer relies on CopyShader"),
                    void 0 === a.ShaderPass && console.error("THREE.EffectComposer relies on ShaderPass"),
                    this.copyPass = new a.ShaderPass(i.CopyShader),
                    this.clock = new r.Clock
                };
                Object.assign(c.prototype, {
                    swapBuffers: function() {
                        var e = this.readBuffer;
                        this.readBuffer = this.writeBuffer,
                        this.writeBuffer = e
                    },
                    addPass: function(e) {
                        this.passes.push(e),
                        e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    },
                    insertPass: function(e, t) {
                        this.passes.splice(t, 0, e),
                        e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    },
                    removePass: function(e) {
                        const t = this.passes.indexOf(e);
                        -1 !== t && this.passes.splice(t, 1)
                    },
                    isLastEnabledPass: function(e) {
                        for (var t = e + 1; t < this.passes.length; t++)
                            if (this.passes[t].enabled)
                                return !1;
                        return !0
                    },
                    render: function(e) {
                        void 0 === e && (e = this.clock.getDelta());
                        var t, n, r = this.renderer.getRenderTarget(), i = !1, a = this.passes.length;
                        for (n = 0; n < a; n++)
                            if (!1 !== (t = this.passes[n]).enabled) {
                                if (t.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n),
                                t.render(this.renderer, this.writeBuffer, this.readBuffer, e, i),
                                t.needsSwap) {
                                    if (i) {
                                        var o = this.renderer.getContext()
                                          , c = this.renderer.state.buffers.stencil;
                                        c.setFunc(o.NOTEQUAL, 1, 4294967295),
                                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e),
                                        c.setFunc(o.EQUAL, 1, 4294967295)
                                    }
                                    this.swapBuffers()
                                }
                                void 0 !== s && (t instanceof s ? i = !0 : t instanceof l && (i = !1))
                            }
                        this.renderer.setRenderTarget(r)
                    },
                    reset: function(e) {
                        if (void 0 === e) {
                            var t = this.renderer.getSize(new r.Vector2);
                            this._pixelRatio = this.renderer.getPixelRatio(),
                            this._width = t.width,
                            this._height = t.height,
                            (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                        }
                        this.renderTarget1.dispose(),
                        this.renderTarget2.dispose(),
                        this.renderTarget1 = e,
                        this.renderTarget2 = e.clone(),
                        this.writeBuffer = this.renderTarget1,
                        this.readBuffer = this.renderTarget2
                    },
                    setSize: function(e, t) {
                        this._width = e,
                        this._height = t;
                        var n = this._width * this._pixelRatio
                          , r = this._height * this._pixelRatio;
                        this.renderTarget1.setSize(n, r),
                        this.renderTarget2.setSize(n, r);
                        for (var i = 0; i < this.passes.length; i++)
                            this.passes[i].setSize(n, r)
                    },
                    setPixelRatio: function(e) {
                        this._pixelRatio = e,
                        this.setSize(this._width, this._height)
                    }
                });
                var u, h, d, p = function() {
                    this.enabled = !0,
                    this.needsSwap = !0,
                    this.clear = !1,
                    this.renderToScreen = !1
                };
                Object.assign(p.prototype, {
                    setSize: function() {},
                    render: function() {
                        console.error("THREE.Pass: .render() must be implemented in derived pass.")
                    }
                }),
                p.FullScreenQuad = (u = new r.OrthographicCamera(-1,1,1,-1,0,1),
                h = new r.PlaneGeometry(2,2),
                d = function(e) {
                    this._mesh = new r.Mesh(h,e)
                }
                ,
                Object.defineProperty(d.prototype, "material", {
                    get: function() {
                        return this._mesh.material
                    },
                    set: function(e) {
                        this._mesh.material = e
                    }
                }),
                Object.assign(d.prototype, {
                    dispose: function() {
                        this._mesh.geometry.dispose()
                    },
                    render: function(e) {
                        e.render(this._mesh, u)
                    }
                }),
                d)
            }
            ,
            2088: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    OutlinePass: ()=>o
                });
                var r = n(2212)
                  , i = n(740)
                  , a = n(8546)
                  , o = function(e, t, n, o) {
                    this.renderScene = t,
                    this.renderCamera = n,
                    this.selectedObjects = void 0 !== o ? o : [],
                    this.visibleEdgeColor = new r.Color(1,1,1),
                    this.hiddenEdgeColor = new r.Color(.1,.04,.02),
                    this.edgeGlow = 0,
                    this.usePatternTexture = !1,
                    this.edgeThickness = 1,
                    this.edgeStrength = 3,
                    this.downSampleRatio = 2,
                    this.pulsePeriod = 0,
                    this._visibilityCache = new Map,
                    i.Pass.call(this),
                    this.resolution = void 0 !== e ? new r.Vector2(e.x,e.y) : new r.Vector2(256,256);
                    var s = {
                        minFilter: r.LinearFilter,
                        magFilter: r.LinearFilter,
                        format: r.RGBAFormat
                    }
                      , l = Math.round(this.resolution.x / this.downSampleRatio)
                      , c = Math.round(this.resolution.y / this.downSampleRatio);
                    this.maskBufferMaterial = new r.MeshBasicMaterial({
                        color: 16777215
                    }),
                    this.maskBufferMaterial.side = r.DoubleSide,
                    this.renderTargetMaskBuffer = new r.WebGLRenderTarget(this.resolution.x,this.resolution.y,s),
                    this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask",
                    this.renderTargetMaskBuffer.texture.generateMipmaps = !1,
                    this.depthMaterial = new r.MeshDepthMaterial,
                    this.depthMaterial.side = r.DoubleSide,
                    this.depthMaterial.depthPacking = r.RGBADepthPacking,
                    this.depthMaterial.blending = r.NoBlending,
                    this.prepareMaskMaterial = this.getPrepareMaskMaterial(),
                    this.prepareMaskMaterial.side = r.DoubleSide,
                    this.prepareMaskMaterial.fragmentShader = function(e, t) {
                        var n = t.isPerspectiveCamera ? "perspective" : "orthographic";
                        return e.replace(/DEPTH_TO_VIEW_Z/g, n + "DepthToViewZ")
                    }(this.prepareMaskMaterial.fragmentShader, this.renderCamera),
                    this.renderTargetDepthBuffer = new r.WebGLRenderTarget(this.resolution.x,this.resolution.y,s),
                    this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth",
                    this.renderTargetDepthBuffer.texture.generateMipmaps = !1,
                    this.renderTargetMaskDownSampleBuffer = new r.WebGLRenderTarget(l,c,s),
                    this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample",
                    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1,
                    this.renderTargetBlurBuffer1 = new r.WebGLRenderTarget(l,c,s),
                    this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1",
                    this.renderTargetBlurBuffer1.texture.generateMipmaps = !1,
                    this.renderTargetBlurBuffer2 = new r.WebGLRenderTarget(Math.round(l / 2),Math.round(c / 2),s),
                    this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2",
                    this.renderTargetBlurBuffer2.texture.generateMipmaps = !1,
                    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(),
                    this.renderTargetEdgeBuffer1 = new r.WebGLRenderTarget(l,c,s),
                    this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1",
                    this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1,
                    this.renderTargetEdgeBuffer2 = new r.WebGLRenderTarget(Math.round(l / 2),Math.round(c / 2),s),
                    this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2",
                    this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1,
                    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4),
                    this.separableBlurMaterial1.uniforms.texSize.value.set(l, c),
                    this.separableBlurMaterial1.uniforms.kernelRadius.value = 1,
                    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4),
                    this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(l / 2), Math.round(c / 2)),
                    this.separableBlurMaterial2.uniforms.kernelRadius.value = 4,
                    this.overlayMaterial = this.getOverlayMaterial(),
                    void 0 === a.CopyShader && console.error("THREE.OutlinePass relies on CopyShader");
                    var u = a.CopyShader;
                    this.copyUniforms = r.UniformsUtils.clone(u.uniforms),
                    this.copyUniforms.opacity.value = 1,
                    this.materialCopy = new r.ShaderMaterial({
                        uniforms: this.copyUniforms,
                        vertexShader: u.vertexShader,
                        fragmentShader: u.fragmentShader,
                        blending: r.NoBlending,
                        depthTest: !1,
                        depthWrite: !1,
                        transparent: !0
                    }),
                    this.enabled = !0,
                    this.needsSwap = !1,
                    this._oldClearColor = new r.Color,
                    this.oldClearAlpha = 1,
                    this.fsQuad = new i.Pass.FullScreenQuad(null),
                    this.tempPulseColor1 = new r.Color,
                    this.tempPulseColor2 = new r.Color,
                    this.textureMatrix = new r.Matrix4
                };
                o.prototype = Object.assign(Object.create(i.Pass.prototype), {
                    constructor: o,
                    dispose: function() {
                        this.renderTargetMaskBuffer.dispose(),
                        this.renderTargetDepthBuffer.dispose(),
                        this.renderTargetMaskDownSampleBuffer.dispose(),
                        this.renderTargetBlurBuffer1.dispose(),
                        this.renderTargetBlurBuffer2.dispose(),
                        this.renderTargetEdgeBuffer1.dispose(),
                        this.renderTargetEdgeBuffer2.dispose()
                    },
                    setSize: function(e, t) {
                        this.renderTargetMaskBuffer.setSize(e, t);
                        var n = Math.round(e / this.downSampleRatio)
                          , r = Math.round(t / this.downSampleRatio);
                        this.renderTargetMaskDownSampleBuffer.setSize(n, r),
                        this.renderTargetBlurBuffer1.setSize(n, r),
                        this.renderTargetEdgeBuffer1.setSize(n, r),
                        this.separableBlurMaterial1.uniforms.texSize.value.set(n, r),
                        n = Math.round(n / 2),
                        r = Math.round(r / 2),
                        this.renderTargetBlurBuffer2.setSize(n, r),
                        this.renderTargetEdgeBuffer2.setSize(n, r),
                        this.separableBlurMaterial2.uniforms.texSize.value.set(n, r)
                    },
                    changeVisibilityOfSelectedObjects: function(e) {
                        var t = this._visibilityCache;
                        function n(n) {
                            n.isMesh && (!0 === e ? n.visible = t.get(n) : (t.set(n, n.visible),
                            n.visible = e))
                        }
                        for (var r = 0; r < this.selectedObjects.length; r++)
                            this.selectedObjects[r].traverse(n)
                    },
                    changeVisibilityOfNonSelectedObjects: function(e) {
                        var t = this._visibilityCache
                          , n = [];
                        function r(e) {
                            e.isMesh && n.push(e)
                        }
                        for (var i = 0; i < this.selectedObjects.length; i++)
                            this.selectedObjects[i].traverse(r);
                        this.renderScene.traverse((function(r) {
                            if (r.isMesh || r.isSprite) {
                                for (var i = !1, a = 0; a < n.length; a++)
                                    if (n[a].id === r.id) {
                                        i = !0;
                                        break
                                    }
                                if (!1 === i) {
                                    var o = r.visible;
                                    !1 !== e && !0 !== t.get(r) || (r.visible = e),
                                    t.set(r, o)
                                }
                            } else
                                (r.isPoints || r.isLine) && (!0 === e ? r.visible = t.get(r) : (t.set(r, r.visible),
                                r.visible = e))
                        }
                        ))
                    },
                    updateTextureMatrix: function() {
                        this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        this.textureMatrix.multiply(this.renderCamera.projectionMatrix),
                        this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)
                    },
                    render: function(e, t, n, r, i) {
                        if (this.selectedObjects.length > 0) {
                            e.getClearColor(this._oldClearColor),
                            this.oldClearAlpha = e.getClearAlpha();
                            var a = e.autoClear;
                            e.autoClear = !1,
                            i && e.state.buffers.stencil.setTest(!1),
                            e.setClearColor(16777215, 1),
                            this.changeVisibilityOfSelectedObjects(!1);
                            var s = this.renderScene.background;
                            if (this.renderScene.background = null,
                            this.renderScene.overrideMaterial = this.depthMaterial,
                            e.setRenderTarget(this.renderTargetDepthBuffer),
                            e.clear(),
                            e.render(this.renderScene, this.renderCamera),
                            this.changeVisibilityOfSelectedObjects(!0),
                            this._visibilityCache.clear(),
                            this.updateTextureMatrix(),
                            this.changeVisibilityOfNonSelectedObjects(!1),
                            this.renderScene.overrideMaterial = this.prepareMaskMaterial,
                            this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near, this.renderCamera.far),
                            this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture,
                            this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix,
                            e.setRenderTarget(this.renderTargetMaskBuffer),
                            e.clear(),
                            e.render(this.renderScene, this.renderCamera),
                            this.renderScene.overrideMaterial = null,
                            this.changeVisibilityOfNonSelectedObjects(!0),
                            this._visibilityCache.clear(),
                            this.renderScene.background = s,
                            this.fsQuad.material = this.materialCopy,
                            this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture,
                            e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),
                            e.clear(),
                            this.fsQuad.render(e),
                            this.tempPulseColor1.copy(this.visibleEdgeColor),
                            this.tempPulseColor2.copy(this.hiddenEdgeColor),
                            this.pulsePeriod > 0) {
                                var l = .625 + .75 * Math.cos(.01 * performance.now() / this.pulsePeriod) / 2;
                                this.tempPulseColor1.multiplyScalar(l),
                                this.tempPulseColor2.multiplyScalar(l)
                            }
                            this.fsQuad.material = this.edgeDetectionMaterial,
                            this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture,
                            this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height),
                            this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1,
                            this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2,
                            e.setRenderTarget(this.renderTargetEdgeBuffer1),
                            e.clear(),
                            this.fsQuad.render(e),
                            this.fsQuad.material = this.separableBlurMaterial1,
                            this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture,
                            this.separableBlurMaterial1.uniforms.direction.value = o.BlurDirectionX,
                            this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness,
                            e.setRenderTarget(this.renderTargetBlurBuffer1),
                            e.clear(),
                            this.fsQuad.render(e),
                            this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture,
                            this.separableBlurMaterial1.uniforms.direction.value = o.BlurDirectionY,
                            e.setRenderTarget(this.renderTargetEdgeBuffer1),
                            e.clear(),
                            this.fsQuad.render(e),
                            this.fsQuad.material = this.separableBlurMaterial2,
                            this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture,
                            this.separableBlurMaterial2.uniforms.direction.value = o.BlurDirectionX,
                            e.setRenderTarget(this.renderTargetBlurBuffer2),
                            e.clear(),
                            this.fsQuad.render(e),
                            this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture,
                            this.separableBlurMaterial2.uniforms.direction.value = o.BlurDirectionY,
                            e.setRenderTarget(this.renderTargetEdgeBuffer2),
                            e.clear(),
                            this.fsQuad.render(e),
                            this.fsQuad.material = this.overlayMaterial,
                            this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture,
                            this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture,
                            this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture,
                            this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture,
                            this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength,
                            this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow,
                            this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture,
                            i && e.state.buffers.stencil.setTest(!0),
                            e.setRenderTarget(n),
                            this.fsQuad.render(e),
                            e.setClearColor(this._oldClearColor, this.oldClearAlpha),
                            e.autoClear = a
                        }
                        this.renderToScreen && (this.fsQuad.material = this.materialCopy,
                        this.copyUniforms.tDiffuse.value = n.texture,
                        e.setRenderTarget(null),
                        this.fsQuad.render(e))
                    },
                    getPrepareMaskMaterial: function() {
                        return new r.ShaderMaterial({
                            uniforms: {
                                depthTexture: {
                                    value: null
                                },
                                cameraNearFar: {
                                    value: new r.Vector2(.5,.5)
                                },
                                textureMatrix: {
                                    value: null
                                }
                            },
                            vertexShader: ["#include <morphtarget_pars_vertex>", "#include <skinning_pars_vertex>", "varying vec4 projTexCoord;", "varying vec4 vPosition;", "uniform mat4 textureMatrix;", "void main() {", "\t#include <skinbase_vertex>", "\t#include <begin_vertex>", "\t#include <morphtarget_vertex>", "\t#include <skinning_vertex>", "\t#include <project_vertex>", "\tvPosition = mvPosition;", "\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "\tprojTexCoord = textureMatrix * worldPosition;", "}"].join("\n"),
                            fragmentShader: ["#include <packing>", "varying vec4 vPosition;", "varying vec4 projTexCoord;", "uniform sampler2D depthTexture;", "uniform vec2 cameraNearFar;", "void main() {", "\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));", "\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );", "\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;", "\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);", "}"].join("\n")
                        })
                    },
                    getEdgeDetectionMaterial: function() {
                        return new r.ShaderMaterial({
                            uniforms: {
                                maskTexture: {
                                    value: null
                                },
                                texSize: {
                                    value: new r.Vector2(.5,.5)
                                },
                                visibleEdgeColor: {
                                    value: new r.Vector3(1,1,1)
                                },
                                hiddenEdgeColor: {
                                    value: new r.Vector3(1,1,1)
                                }
                            },
                            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                            fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec3 visibleEdgeColor;\t\t\t\tuniform vec3 hiddenEdgeColor;\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\t\t\t\t}"
                        })
                    },
                    getSeperableBlurMaterial: function(e) {
                        return new r.ShaderMaterial({
                            defines: {
                                MAX_RADIUS: e
                            },
                            uniforms: {
                                colorTexture: {
                                    value: null
                                },
                                texSize: {
                                    value: new r.Vector2(.5,.5)
                                },
                                direction: {
                                    value: new r.Vector2(.5,.5)
                                },
                                kernelRadius: {
                                    value: 1
                                }
                            },
                            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                            fragmentShader: "#include <common>\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform sampler2D colorTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\tuniform float kernelRadius;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\t\t\t\t\tvec2 uvOffset = delta;\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\t\t\t\t\t\tweightSum += (2.0 * w);\t\t\t\t\t\tuvOffset += delta;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\t\t\t\t}"
                        })
                    },
                    getOverlayMaterial: function() {
                        return new r.ShaderMaterial({
                            uniforms: {
                                maskTexture: {
                                    value: null
                                },
                                edgeTexture1: {
                                    value: null
                                },
                                edgeTexture2: {
                                    value: null
                                },
                                patternTexture: {
                                    value: null
                                },
                                edgeStrength: {
                                    value: 1
                                },
                                edgeGlow: {
                                    value: 1
                                },
                                usePatternTexture: {
                                    value: 0
                                }
                            },
                            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                            fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform sampler2D edgeTexture1;\t\t\t\tuniform sampler2D edgeTexture2;\t\t\t\tuniform sampler2D patternTexture;\t\t\t\tuniform float edgeStrength;\t\t\t\tuniform float edgeGlow;\t\t\t\tuniform bool usePatternTexture;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\t\t\t\t\tif(usePatternTexture)\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\t\t\t\t\tgl_FragColor = finalColor;\t\t\t\t}",
                            blending: r.AdditiveBlending,
                            depthTest: !1,
                            depthWrite: !1,
                            transparent: !0
                        })
                    }
                }),
                o.BlurDirectionX = new r.Vector2(1,0),
                o.BlurDirectionY = new r.Vector2(0,1)
            }
            ,
            740: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    Pass: ()=>s
                });
                var r, i, a, o = n(2212);
                function s() {
                    this.enabled = !0,
                    this.needsSwap = !0,
                    this.clear = !1,
                    this.renderToScreen = !1
                }
                Object.assign(s.prototype, {
                    setSize: function() {},
                    render: function() {
                        console.error("THREE.Pass: .render() must be implemented in derived pass.")
                    }
                }),
                s.FullScreenQuad = (r = new o.OrthographicCamera(-1,1,1,-1,0,1),
                i = new o.PlaneGeometry(2,2),
                a = function(e) {
                    this._mesh = new o.Mesh(i,e)
                }
                ,
                Object.defineProperty(a.prototype, "material", {
                    get: function() {
                        return this._mesh.material
                    },
                    set: function(e) {
                        this._mesh.material = e
                    }
                }),
                Object.assign(a.prototype, {
                    dispose: function() {
                        this._mesh.geometry.dispose()
                    },
                    render: function(e) {
                        e.render(this._mesh, r)
                    }
                }),
                a)
            }
            ,
            6426: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    RenderPass: ()=>a
                });
                var r = n(2212)
                  , i = n(740)
                  , a = function(e, t, n, a, o) {
                    i.Pass.call(this),
                    this.scene = e,
                    this.camera = t,
                    this.overrideMaterial = n,
                    this.clearColor = a,
                    this.clearAlpha = void 0 !== o ? o : 0,
                    this.clear = !0,
                    this.clearDepth = !1,
                    this.needsSwap = !1,
                    this._oldClearColor = new r.Color
                };
                a.prototype = Object.assign(Object.create(i.Pass.prototype), {
                    constructor: a,
                    render: function(e, t, n) {
                        var r, i, a = e.autoClear;
                        e.autoClear = !1,
                        void 0 !== this.overrideMaterial && (i = this.scene.overrideMaterial,
                        this.scene.overrideMaterial = this.overrideMaterial),
                        this.clearColor && (e.getClearColor(this._oldClearColor),
                        r = e.getClearAlpha(),
                        e.setClearColor(this.clearColor, this.clearAlpha)),
                        this.clearDepth && e.clearDepth(),
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                        e.render(this.scene, this.camera),
                        this.clearColor && e.setClearColor(this._oldClearColor, r),
                        void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = i),
                        e.autoClear = a
                    }
                })
            }
            ,
            5980: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    ShaderPass: ()=>a
                });
                var r = n(2212)
                  , i = n(740)
                  , a = function(e, t) {
                    i.Pass.call(this),
                    this.textureID = void 0 !== t ? t : "tDiffuse",
                    e instanceof r.ShaderMaterial ? (this.uniforms = e.uniforms,
                    this.material = e) : e && (this.uniforms = r.UniformsUtils.clone(e.uniforms),
                    this.material = new r.ShaderMaterial({
                        defines: Object.assign({}, e.defines),
                        uniforms: this.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    })),
                    this.fsQuad = new i.Pass.FullScreenQuad(this.material)
                };
                a.prototype = Object.assign(Object.create(i.Pass.prototype), {
                    constructor: a,
                    render: function(e, t, n) {
                        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture),
                        this.fsQuad.material = this.material,
                        this.renderToScreen ? (e.setRenderTarget(null),
                        this.fsQuad.render(e)) : (e.setRenderTarget(t),
                        this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                        this.fsQuad.render(e))
                    }
                })
            }
            ,
            1808: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    TexturePass: ()=>o
                });
                var r = n(2212)
                  , i = n(740)
                  , a = n(8546)
                  , o = function(e, t) {
                    i.Pass.call(this),
                    void 0 === a.CopyShader && console.error("THREE.TexturePass relies on CopyShader");
                    var n = a.CopyShader;
                    this.map = e,
                    this.opacity = void 0 !== t ? t : 1,
                    this.uniforms = r.UniformsUtils.clone(n.uniforms),
                    this.material = new r.ShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        depthTest: !1,
                        depthWrite: !1
                    }),
                    this.needsSwap = !1,
                    this.fsQuad = new i.Pass.FullScreenQuad(null)
                };
                o.prototype = Object.assign(Object.create(i.Pass.prototype), {
                    constructor: o,
                    render: function(e, t, n) {
                        var r = e.autoClear;
                        e.autoClear = !1,
                        this.fsQuad.material = this.material,
                        this.uniforms.opacity.value = this.opacity,
                        this.uniforms.tDiffuse.value = this.map,
                        this.material.transparent = this.opacity < 1,
                        e.setRenderTarget(this.renderToScreen ? null : n),
                        this.clear && e.clear(),
                        this.fsQuad.render(e),
                        e.autoClear = r
                    }
                })
            }
            ,
            8546: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    CopyShader: ()=>r
                });
                var r = {
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
                }
            }
            ,
            4717: (e,t,n)=>{
                "use strict";
                n.r(t),
                n.d(t, {
                    GammaCorrectionShader: ()=>r
                });
                var r = {
                    uniforms: {
                        tDiffuse: {
                            value: null
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 tex = texture2D( tDiffuse, vUv );", "\tgl_FragColor = LinearTosRGB( tex );", "}"].join("\n")
                }
            }
            ,
            1384: function(e, t, n) {
                "use strict";
                var r = this && this.__assign || function() {
                    return r = Object.assign || function(e) {
                        for (var t, n = 1, r = arguments.length; n < r; n++)
                            for (var i in t = arguments[n])
                                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                        return e
                    }
                    ,
                    r.apply(this, arguments)
                }
                  , i = this && this.__awaiter || function(e, t, n, r) {
                    return new (n || (n = Promise))((function(i, a) {
                        function o(e) {
                            try {
                                l(r.next(e))
                            } catch (e) {
                                a(e)
                            }
                        }
                        function s(e) {
                            try {
                                l(r.throw(e))
                            } catch (e) {
                                a(e)
                            }
                        }
                        function l(e) {
                            var t;
                            e.done ? i(e.value) : (t = e.value,
                            t instanceof n ? t : new n((function(e) {
                                e(t)
                            }
                            ))).then(o, s)
                        }
                        l((r = r.apply(e, t || [])).next())
                    }
                    ))
                }
                  , a = this && this.__generator || function(e, t) {
                    var n, r, i, a, o = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0])
                                throw i[1];
                            return i[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return a = {
                        next: s(0),
                        throw: s(1),
                        return: s(2)
                    },
                    "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                        return this
                    }
                    ),
                    a;
                    function s(a) {
                        return function(s) {
                            return function(a) {
                                if (n)
                                    throw new TypeError("Generator is already executing.");
                                for (; o; )
                                    try {
                                        if (n = 1,
                                        r && (i = 2 & a[0] ? r.return : a[0] ? r.throw || ((i = r.return) && i.call(r),
                                        0) : r.next) && !(i = i.call(r, a[1])).done)
                                            return i;
                                        switch (r = 0,
                                        i && (a = [2 & a[0], i.value]),
                                        a[0]) {
                                        case 0:
                                        case 1:
                                            i = a;
                                            break;
                                        case 4:
                                            return o.label++,
                                            {
                                                value: a[1],
                                                done: !1
                                            };
                                        case 5:
                                            o.label++,
                                            r = a[1],
                                            a = [0];
                                            continue;
                                        case 7:
                                            a = o.ops.pop(),
                                            o.trys.pop();
                                            continue;
                                        default:
                                            if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                                o = 0;
                                                continue
                                            }
                                            if (3 === a[0] && (!i || a[1] > i[0] && a[1] < i[3])) {
                                                o.label = a[1];
                                                break
                                            }
                                            if (6 === a[0] && o.label < i[1]) {
                                                o.label = i[1],
                                                i = a;
                                                break
                                            }
                                            if (i && o.label < i[2]) {
                                                o.label = i[2],
                                                o.ops.push(a);
                                                break
                                            }
                                            i[2] && o.ops.pop(),
                                            o.trys.pop();
                                            continue
                                        }
                                        a = t.call(e, o)
                                    } catch (e) {
                                        a = [6, e],
                                        r = 0
                                    } finally {
                                        n = i = 0
                                    }
                                if (5 & a[0])
                                    throw a[1];
                                return {
                                    value: a[0] ? a[1] : void 0,
                                    done: !0
                                }
                            }([a, s])
                        }
                    }
                }
                  , o = this && this.__spreadArrays || function() {
                    for (var e = 0, t = 0, n = arguments.length; t < n; t++)
                        e += arguments[t].length;
                    var r = Array(e)
                      , i = 0;
                    for (t = 0; t < n; t++)
                        for (var a = arguments[t], o = 0, s = a.length; o < s; o++,
                        i++)
                            r[i] = a[o];
                    return r
                }
                ;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.Editor = void 0;
                var s = n(1278)
                  , l = n(4376)
                  , c = n(2212)
                  , u = n(7473)
                  , h = n(1903).X
                  , d = (n(1354),
                function() {
                    function e(e) {
                        var t, n, r = this;
                        this.mouseDownTime = 0,
                        this.mousePosition = new c.Vector2(0,0),
                        this.diamondArrays = [],
                        this.materialsArrays = [],
                        this.shankMaterialArrays = [],
                        this.headMaterialArrays = [],
                        this.currentSHANK = "",
                        this.currentHEAD = "",
                        this.currentGEM = "",
                        this.currentColor = "",
                        this.currentHeadColor = "",
                        this.currentShankColor = "",
                        this.loadedModels = {},
                        this._metalColorTexture = {},
                        this.lutMap = null,
                        this.currentPosition = new c.Vector3(0,0,0),
                        this.selectedObject = null,
                        this.handModel = null,
                        this.selectedMaterial = null,
                        this.groupHolder = new c.Group,
                        this.isHandON = !1,
                        this.updateLUTMap = function(e) {
                            e ? r.diamondArrays && r.diamondArrays.forEach((function(t, n) {
                                t.getMesh().material.lut = e.texture
                            }
                            )) : r.diamondArrays && r.diamondArrays.forEach((function(e, t) {
                                e.getMesh().material.lut = null
                            }
                            ));
                            var t = r.api.sceneManager.cameraParams;
                            r.api.sceneManager.cameraParams = t
                        }
                        ,
                        this.getAllowedURLS = function() {}
                        ,
                        this.encryptURLS = function(e) {
                            return "string" != typeof e ? [] : e.split("").reverse().join(",")
                        }
                        ,
                        this.decryptURLS = function(e) {
                            return "string" != typeof e ? "" : e.split(",").reverse().join("")
                        }
                        ,
                        this.fitCameraToCenteredObject = function(e, t, n, r) {
                            var i = new c.Box3;
                            i.setFromObject(t),
                            new c.Vector3;
                            var a = new c.Vector3;
                            i.getSize(a);
                            var o = e.fov * (Math.PI / 180)
                              , s = 2 * Math.atan(Math.tan(o / 2) * e.aspect)
                              , l = a.z / 2 + Math.abs(a.x / 2 / Math.tan(s / 2))
                              , u = a.z / 2 + Math.abs(a.y / 2 / Math.tan(o / 2))
                              , h = Math.max(l, u);
                            void 0 !== n && 0 !== n && (h *= n);
                            var d = i.min.z
                              , p = d < 0 ? -d + h : h - d;
                            e.fov = 3 * p,
                            console.log(p),
                            e.updateProjectionMatrix(),
                            void 0 !== r && (r.maxDistance = 2 * p)
                        }
                        ,
                        this.onPointerMove = function(e) {
                            var t, n = 0, i = 0;
                            e instanceof TouchEvent && (null === (t = e.changedTouches) || void 0 === t ? void 0 : t.length) > 0 ? (n = e.changedTouches[0].pageX,
                            i = e.changedTouches[0].pageY) : e instanceof MouseEvent && (n = e.clientX,
                            i = e.clientY),
                            r.mousePosition.x = n / window.innerWidth * 2 - 1,
                            r.mousePosition.y = -i / window.innerHeight * 2 + 1
                        }
                        ,
                        this.onPointerUp = function() {
                            var e = Date.now() - r.mouseDownTime;
                            if (r.mouseDownTime = 0,
                            !(e > 200)) {
                                var t = r.api.pickObject(r.mousePosition);
                                r.api.pickObjectByNameOrId("Diamond"),
                                r.selectObject(t)
                            }
                        }
                        ,
                        this.onPointerDown = function() {
                            r.mouseDownTime = Date.now(),
                            console.log("SS")
                        }
                        ;
                        var i = {
                            quality: "high",
                            diamondClass: JSON.parse('[{"name":"diamond","geometryFactor":0.29,"color":16777215,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"round","geometryFactor":0.29,"color":16777215,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":0.8,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"cushion","geometryFactor":0.26,"color":16777215,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"emerald","color":16777215,"geometryFactor":0.19,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"pear","color":16777215,"geometryFactor":0.2,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"oval","color":16777215,"geometryFactor":0.29,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"princess","color":16777215,"geometryFactor":0.22,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1.3,"absFactor":1,"gammaFactor":1},{"name":"marquise","color":16777215,"geometryFactor":0.22,"boostFactorX":2.3,"boostFactorY":2.3,"boostFactorZ":2.5,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"heart","color":16777215,"geometryFactor":0.2,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"asscher","color":16777215,"geometryFactor":0.22,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1.3,"absFactor":1,"gammaFactor":1},{"name":"radiant","color":16777215,"geometryFactor":0.19,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},{"name":"baguette","color":16777215,"geometryFactor":0.17,"boostFactorX":2.2,"boostFactorY":2.2,"boostFactorZ":2.4,"envMapIntensity":2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1}]')
                        };
                        e.gemConfig = i;
                        var a = document.getElementById("loading-overlay");
                        a && (a.style.display = "block"),
                        this._metalColorTexture = {
                            roseGold: {
                                color: 16748148,
                                envMapIntensity: 5
                            },
                            whiteGold: {
                                color: 13816530,
                                envMapIntensity: 4.4
                            },
                            yellowGold: {
                                color: 15908190,
                                envMapIntensity: 5
                            }
                        },
                        this.currentColor = "whiteGold",
                        this.currentHeadColor = "whiteGold",
                        this.currentShankColor = "whiteGold",
                        this.api = new s.API(e),
                        this.api.play(),
                        this.api.setDisplayPixelRatio(1.5);
                        var o = document.getElementsByTagName("body")[0];
                        o.addEventListener("click", (function() {
                            var e = document.getElementById("helper-popup");
                            e && (e.style.display = "none")
                        }
                        )),
                        o.addEventListener("drag", (function() {
                            var e = document.getElementById("helper-popup");
                            e && (e.style.display = "none")
                        }
                        )),
                        o.addEventListener("dblclick", (function() {
                            var e = document.getElementById("helper-popup");
                            e && (e.style.display = "none")
                        }
                        ));
                        var l, u, h = [(l = "https://gb-production-canvas-env.s3.amazonaws.com/") + "py" + (u = ".hdr"), l + "ny" + u, l + "pz" + u, l + "pz" + u, l + "pz" + u, l + "nz" + u], d = window.location.search, f = new URLSearchParams(d), m = f.get("headType"), g = f.get("shankType"), v = f.get("bandType"), y = f.get("bandParentType"), _ = f.get("GUICode"), x = f.get("headColor"), b = f.get("shankColor"), w = (f.get("placeHandImg"),
                        f.get("screenCapture")), M = f.get("responseURL");
                        this.handModel = f.get("handModel");
                        var S = d.split("&");
                        this.gui = null;
                        var T = ""
                          , E = ""
                          , A = [];
                        if (null === (t = S[2]) || void 0 === t || t.split("=")[1],
                        m && (T = m),
                        g && (E = g),
                        w) {
                            var C = null === (n = document.getElementById("icadCanvas")) || void 0 === n ? void 0 : n.getBoundingClientRect()
                              , P = {
                                height: null == C ? void 0 : C.height,
                                width: null == C ? void 0 : C.width
                            }
                              , R = document.getElementById("loading-overlay");
                            R && (R.style.display = "block",
                            R.style.zIndex = "6"),
                            this.createDummyCanvas(P, !0)
                        }
                        v && (A = [{
                            url: v,
                            colorParent: y || "SHANK"
                        }]),
                        x && (this.currentHeadColor = x),
                        b && (this.currentShankColor = b),
                        this.api.loadTexture(h, (function(e) {}
                        ), {}).then((function(t) {
                            r.api.sceneManager.setSceneEnvironment(t, {
                                imageBasedLighting: !0,
                                setBackground: !1
                            }),
                            r.listenForMessages(),
                            r.api.sceneManager.background = new c.Color(1,1,1),
                            r.api.sceneManager._mainContainer.add(r.api.sceneManager.meshHolder),
                            "VALID_CREATOR" === _ && (r.gui = new p(r.api,r));
                            var n = T || "https://all3dmodels2021-nv.s3.amazonaws.com/R-150-SO.glb"
                              , i = E || "https://all3dmodels2021-nv.s3.amazonaws.com/LGR2598X2.glb";
                            r.getTempLoad(n, i, A, !0, w, M, "ADD", null),
                            e.canvas.addEventListener("mousemove", r.onPointerMove),
                            e.canvas.addEventListener("touchmove", r.onPointerMove),
                            e.canvas.addEventListener("mousedown", r.onPointerDown),
                            e.canvas.addEventListener("touchstart", r.onPointerDown),
                            e.canvas.addEventListener("mouseup", r.onPointerUp),
                            e.canvas.addEventListener("touchend", r.onPointerUp),
                            window.addEventListener("resize", (function(e) {
                                r.api.setViewerSize(window.innerWidth, window.innerHeight)
                            }
                            ), !1)
                        }
                        )).catch((function(e) {
                            alert("Unable to load cube texture, check console"),
                            console.log(e)
                        }
                        ))
                    }
                    return e.prototype.listenForMessages = function() {
                        var e = this;
                        window.addEventListener("message", (function(t) {
                            var n;
                            if (["m,o,c,.,e,c,n,a,i,l,l,i,r,b,n,w,o,r,g,/,/,:,s,p,t,t,h", "m,o,c,.,s,n,o,i,t,u,l,o,s,-,e,l,o,.,b,g,r,o,t,a,e,r,c,/,/,:,s,p,t,t,h", "3,8,3,2,:,m,o,c,.,e,v,i,l,e,u,l,b,e,l,d,o,o,d,/,/,:,p,t,t,h", "0,0,0,3,:,t,s,o,h,l,a,c,o,l,/,/,:,p,t,t,h", "m,o,c,.,s,n,o,i,t,u,l,o,s,-,e,l,o,/,/,:,p,t,t,h", "7,7,2,2,:,0,4,.,7,9,.,1,.,5,6,/,/,:,p,t,t,h", "1,0,0,2,:,9,1,1,.,8,7,1,.,8,0,1,.,3,/,/,:,p,t,t,h"].some((function(n) {
                                return t.origin.startsWith(e.decryptURLS(n))
                            }
                            ))) {
                                var i = t.data
                                  , a = i.head
                                  , s = i.shank
                                  , l = i.band
                                  , c = i.hand
                                  , u = i.isColor
                                  , h = i.shankColor
                                  , d = i.headColor
                                  , p = i.isScreenshot
                                  , f = i.parentURL
                                  , m = i.additionalModels
                                  , g = void 0 === m ? [] : m
                                  , v = i.imgFormat
                                  , y = void 0 === v ? "jpeg" : v
                                  , _ = i.secondResolutionSize
                                  , x = void 0 === _ ? null : _
                                  , b = i.changeType
                                  , w = i.isRevert
                                  , M = void 0 !== w && w
                                  , S = i.isHandModel
                                  , T = void 0 !== S && S;
                                if (console.log(t.data),
                                Array.isArray(g),
                                e.handModel = T,
                                !1 === e.api.sceneManager.isHandOn && T && (e.isHandON = !0,
                                e.api.sceneManager.isHandOn = !0),
                                p)
                                    e.captureScreenshot(f, !0, y, x);
                                else {
                                    if (M)
                                        return e.currentShankColor = d,
                                        e.currentHeadColor = h,
                                        e.api.sceneManager.changeModelColor(e.headMaterialArrays, e._metalColorTexture[d]),
                                        e.api.sceneManager.changeModelColor(e.shankMaterialArrays, e._metalColorTexture[h]),
                                        e.getTempLoad(a, s, g, !0, !1, "", "REMOVE", ["HEAD", "SHANK", "BAND", "HAND"], !0);
                                    if (h && (e.currentShankColor = h),
                                    d && (e.currentHeadColor = d),
                                    u)
                                        e.currentShankColor = h,
                                        e.currentHeadColor = d,
                                        e.api.sceneManager.changeModelColor(e.headMaterialArrays, e._metalColorTexture[d]),
                                        e.api.sceneManager.changeModelColor(e.shankMaterialArrays, e._metalColorTexture[h]);
                                    else {
                                        var E = r({}, e.api.sceneManager.loadedModelsDetails)
                                          , A = null
                                          , C = null
                                          , P = null
                                          , R = [];
                                        a !== E.head && (A = a),
                                        s !== E.shank && (C = s);
                                        var L = null === (n = g[0]) || void 0 === n ? void 0 : n.url;
                                        if (console.log(l, L, "bandDetail"),
                                        "ON" === l || L !== E.band && E.band && "BAND" === b && "OFF" !== l)
                                            L !== E.band && (P = o(g)),
                                            console.log("ON Triggered", e.api.sceneManager.loadedModelsDetails, L, E.band);
                                        else if ("OFF" === l && "BAND" === b) {
                                            var D = document.getElementById("loading-overlay");
                                            return D && (D.style.display = "block"),
                                            e.api.sceneManager.updateLoadedModelDetails(null, null, "OFF"),
                                            console.log("OFF trigged", e.api.sceneManager.currentLoadedData, "this.currentLoadedData"),
                                            e.api.sceneManager.removeSpecificObject("BAND", "OFF")
                                        }
                                        if (A && R.push("HEAD"),
                                        C && R.push("SHANK"),
                                        (L !== E.band && E.band && "BAND" === b || "BAND" === b && "ON" === l) && R.push("BAND"),
                                        "HAND" === b && "ON" === c && (P = o(g),
                                        R.push("HAND")),
                                        "HAND" === b && "OFF" === c)
                                            return console.log("HAND", e.api.sceneManager.currentLoadedData),
                                            e.api.sceneManager.removeSpecificObject("HAND", "OFF");
                                        console.log("called...", A, C, P, R),
                                        (A || C || P && (null == P ? void 0 : P.length) > 0) && e.getTempLoad(A || null, C || null, P || null, !0, !1, "", "REMOVE", R)
                                    }
                                }
                            }
                        }
                        ))
                    }
                    ,
                    e.prototype.createDummyCanvas = function(e, t) {
                        var n = this;
                        return new Promise((function(e, r) {
                            setTimeout((function() {
                                var r = n.api.getSnapshotData("image/jpeg")
                                  , i = document.createElement("canvas");
                                i.id = "tempCanvas",
                                i.width = window.innerWidth,
                                i.height = window.innerHeight,
                                i.style.position = "absolute",
                                i.style.top = "0%",
                                i.style.left = "0%",
                                i.style.zIndex = "5",
                                i.style.background = "white";
                                var a = i.getContext("2d");
                                t && (a.fillStyle = "#ffffff",
                                a.fillRect(0, 0, window.innerWidth, window.innerHeight),
                                r = i.toDataURL("image/jpeg", 1));
                                var o = new Image;
                                o.src = r,
                                o.onload = function() {
                                    var t = o.width / o.height
                                      , n = i.width
                                      , r = n / t;
                                    r > i.height && (n = (r = i.height) * t);
                                    var s = n < i.width ? (i.width - n) / 2 : 0
                                      , l = r < i.height ? (i.height - r) / 2 : 0;
                                    a.drawImage(o, s, l, n, r),
                                    e(!0)
                                }
                                ,
                                document.getElementsByTagName("body")[0].appendChild(i)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.getMousePos = function(e, t) {
                        var n = e.getBoundingClientRect();
                        return {
                            x: t.clientX - n.left,
                            y: t.clientY - n.top
                        }
                    }
                    ,
                    e.prototype.draw = function(e) {
                        var t = document.createElement("canvas")
                          , n = this.getMousePos(t, e)
                          , r = t.getContext("2d");
                        r.fillStyle = "#000000",
                        r.fillRect(n.x, n.y, 4, 4)
                    }
                    ,
                    e.prototype.getCursorPosition = function(e, t) {
                        var n = e.getBoundingClientRect()
                          , r = t.clientX - n.left
                          , i = t.clientY - n.top;
                        console.log("x: " + r + " y: " + i)
                    }
                    ,
                    e.prototype.placeHandImgPosition = function(e, t, n, o, s, l) {
                        if (this.api.viewer.renderer.setSize(700, 700),
                        e) {
                            var c = document.createElement("canvas");
                            c.id = "tempCanvas",
                            c.width = 700,
                            c.height = 700,
                            c.style.position = "absolute",
                            c.style.top = "0%",
                            c.style.left = "0%",
                            c.style.zIndex = "-1",
                            c.style.opacity = "0";
                            var u = c.getContext("2d")
                              , h = new Image;
                            h.crossOrigin = "anonymous";
                            var d = this;
                            h.onload = function() {
                                var e = this;
                                u.save();
                                u.translate(190, 178),
                                u.save(),
                                u.translate(85, 85),
                                u.rotate(345 * Math.PI / 180),
                                u.drawImage(h, -42.5, -42.5, 85, 85),
                                u.restore();
                                var p = c.toDataURL("image/png");
                                console.log(p, "hand 1"),
                                fetch(p).then((function(e) {
                                    return e.blob()
                                }
                                )).then((function(u) {
                                    new File([u],"ring position.png");
                                    var h = new Image;
                                    h.src = URL.createObjectURL(u),
                                    h.crossOrigin = "anonymous",
                                    h.onload = function() {
                                        return i(e, void 0, void 0, (function() {
                                            var e, i, u, p, f, m, g;
                                            return a(this, (function(a) {
                                                switch (a.label) {
                                                case 0:
                                                    return (e = document.createElement("canvas")).height = 1200,
                                                    e.width = 1200,
                                                    i = e.getContext("2d"),
                                                    e.width = 1200,
                                                    e.height = 1200,
                                                    i.drawImage(h, 0, 0, 700, 700, 0, 0, 1200, 1200),
                                                    u = e.toDataURL("image/png", 1),
                                                    [4, d.convertDataURLToFiles(u, "ring - 1200X1200.png", "1200X1200")];
                                                case 1:
                                                    return p = a.sent(),
                                                    (g = {})["1200X1200"] = r({}, p["1200X1200"]),
                                                    f = {
                                                        ringImgData: o,
                                                        handImgData: g
                                                    },
                                                    s && window.parent.postMessage(f, s),
                                                    document.getElementsByTagName("body")[0].removeChild(c),
                                                    d.resetModelPositions(t, n),
                                                    !1 === l && (m = document.getElementById("helper-popup")) && (m.style.display = "flex"),
                                                    [2]
                                                }
                                            }
                                            ))
                                        }
                                        ))
                                    }
                                }
                                ))
                            }
                            ,
                            h.src = e,
                            document.getElementsByTagName("body")[0].appendChild(c)
                        }
                    }
                    ,
                    e.prototype.convertDataURLToFiles = function(e, t, n) {
                        return new Promise((function(r, i) {
                            fetch(e).then((function(e) {
                                return e.blob()
                            }
                            )).then((function(i) {
                                var a, o = new File([i],"" + t), s = ((a = {})["" + n] = {
                                    fileData: o,
                                    fileDataURI: e,
                                    fileDataBlob: i
                                },
                                a);
                                r(s),
                                console.log(URL.createObjectURL(i), t, "blob links")
                            }
                            )).catch((function(e) {
                                return i(e)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.removeDummyCanvas = function() {
                        var e = document.getElementById("tempCanvas")
                          , t = document.getElementsByTagName("body")[0]
                          , n = document.getElementById("loading-overlay");
                        n && (n.style.display = "none"),
                        t.removeChild(e)
                    }
                    ,
                    e.prototype.captureScreenshot = function(e, t, n, o) {
                        var s;
                        return i(this, void 0, void 0, (function() {
                            var o, l, u, h, d, p = this;
                            return a(this, (function(f) {
                                switch (f.label) {
                                case 0:
                                    return console.log("screenShot called"),
                                    o = null === (s = document.getElementById("icadCanvas")) || void 0 === s ? void 0 : s.getBoundingClientRect(),
                                    l = {
                                        height: null == o ? void 0 : o.height,
                                        width: null == o ? void 0 : o.width
                                    },
                                    (u = document.getElementById("loading-overlay")) && (u.style.display = "block",
                                    u.style.zIndex = "6"),
                                    t ? [4, this.createDummyCanvas(l, !1)] : [3, 2];
                                case 1:
                                    f.sent(),
                                    f.label = 2;
                                case 2:
                                    return h = new c.Vector3(this.api.sceneManager.camera.position.x,this.api.sceneManager.camera.position.y,this.api.sceneManager.camera.position.z),
                                    this.api.sceneManager.camera.position.copy(new c.Vector3(.0691875708244352,1.8585023275855987,4.592443457156328)),
                                    this.api.sceneManager.mesh.position.y = 10,
                                    this.api.viewer.renderer.setSize(500, 500),
                                    this.api.sceneManager.scene.translateX(-.06),
                                    (d = this.api.sceneManager.cameraParams).fov = 25,
                                    this.api.sceneManager.cameraParams = d,
                                    this.api.sceneManager.background = null,
                                    setTimeout((function() {
                                        var o = p.api.getSnapshotData("image/png")
                                          , s = document.createElement("a");
                                        s.download = "ring.png",
                                        s.href = o,
                                        console.log(o);
                                        var c = p;
                                        fetch(o).then((function(e) {
                                            return e.blob()
                                        }
                                        )).then((function(s) {
                                            new File([s],"ring.png");
                                            var u = 1100
                                              , d = new Image;
                                            d.src = URL.createObjectURL(s),
                                            d.crossOrigin = "anonymous",
                                            d.onload = function() {
                                                return i(p, void 0, void 0, (function() {
                                                    var s, p, f, m, g, v, y, _, x, b, w = this;
                                                    return a(this, (function(M) {
                                                        switch (M.label) {
                                                        case 0:
                                                            return (p = document.createElement("canvas")).style.background = "white",
                                                            p.height = 700,
                                                            p.width = 700,
                                                            f = p.getContext("2d"),
                                                            (s = document.createElement("canvas")).style.background = "white",
                                                            s.width = u,
                                                            s.height = u,
                                                            m = s.getContext("2d"),
                                                            p.width = 700,
                                                            p.height = 700,
                                                            f.fillStyle = "#ffffff",
                                                            f.fillRect(0, 0, 700, 700),
                                                            f.drawImage(d, 0, 0, 700, 700, 0, 0, 700, 700),
                                                            g = "image/jpeg",
                                                            v = p.toDataURL(g, 1),
                                                            [4, c.convertDataURLToFiles(v, "ring - 700X700." + n, "700X700")];
                                                        case 1:
                                                            return y = M.sent(),
                                                            (b = {})["700X700"] = r({}, y["700X700"]),
                                                            _ = b,
                                                            (x = new Image).onload = function() {
                                                                return i(w, void 0, void 0, (function() {
                                                                    var i, d, p;
                                                                    return a(this, (function(a) {
                                                                        switch (a.label) {
                                                                        case 0:
                                                                            return m.fillStyle = "#ffffff",
                                                                            m.fillRect(0, 0, u, u),
                                                                            m.drawImage(x, 0, 0, 700, 700, 0, 0, u, u),
                                                                            i = s.toDataURL(g, 1),
                                                                            [4, c.convertDataURLToFiles(i, "ring - 1100X1100." + n, "1100X1100")];
                                                                        case 1:
                                                                            return d = a.sent(),
                                                                            _ = r(r({}, _), ((p = {})["1100X1100"] = r({}, d["1100X1100"]),
                                                                            p)),
                                                                            this.placeHandImgPosition(o, h, l, _, e, t),
                                                                            [2]
                                                                        }
                                                                    }
                                                                    ))
                                                                }
                                                                ))
                                                            }
                                                            ,
                                                            x.src = v,
                                                            [2]
                                                        }
                                                    }
                                                    ))
                                                }
                                                ))
                                            }
                                        }
                                        ))
                                    }
                                    ), 1e3),
                                    [2]
                                }
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.resetModelPositions = function(e, t) {
                        var n = this;
                        this.api.sceneManager.camera.position.copy(e),
                        this.api.sceneManager.scene.add.apply(this.api.sceneManager.scene, [this.api.sceneManager.lightHolder]),
                        this.api.sceneManager.scene.add.apply(this.api.sceneManager.scene, [this.api.sceneManager.meshHolder]),
                        this.api.sceneManager.mesh.position.y = -.017,
                        this.api.viewer.renderer.setSize(t.width, t.height);
                        var r = this.api.sceneManager.cameraParams;
                        r.fov = 30,
                        this.api.sceneManager.cameraParams = r,
                        this.api.sceneManager.background = new c.Color(1,1,1),
                        setTimeout((function() {
                            n.removeDummyCanvas()
                        }
                        ), 500)
                    }
                    ,
                    e.prototype.getDynamicModels = function(e) {
                        var t = this;
                        return new Promise((function(n, r) {
                            return i(t, void 0, void 0, (function() {
                                var t;
                                return a(this, (function(r) {
                                    switch (r.label) {
                                    case 0:
                                        return [4, this.api.loadModel(e, (function(e) {
                                            document.getElementById("loading-overlay")
                                        }
                                        )).catch((function(e) {
                                            alert("Unable to load model, check console"),
                                            console.log(e)
                                        }
                                        ))];
                                    case 1:
                                        return t = r.sent(),
                                        n(t),
                                        [2]
                                    }
                                }
                                ))
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.loadAddonModels = function(e, t, n) {
                        return i(this, void 0, void 0, (function() {
                            var r = this;
                            return a(this, (function(s) {
                                return [2, new Promise((function(s, l) {
                                    e.forEach((function(c, u) {
                                        var h = c.url
                                          , d = c.colorParent;
                                        return i(r, void 0, void 0, (function() {
                                            var r, i, c, p;
                                            return a(this, (function(a) {
                                                switch (a.label) {
                                                case 0:
                                                    return [4, this.getDynamicModels(h)];
                                                case 1:
                                                    if (r = a.sent(),
                                                    document.getElementById("loading-overlay"),
                                                    r) {
                                                        if (i = this.api.addObject(r, this._metalColorTexture[this.currentShankColor], t, n),
                                                        c = i.diamonds,
                                                        p = i.materials,
                                                        this.diamondArrays = o(this.diamondArrays, c),
                                                        this.api.sceneManager.mesh.position.y = Number(-.13),
                                                        "SHANK" === d)
                                                            this.shankMaterialArrays = o(this.shankMaterialArrays, p);
                                                        else {
                                                            if ("HEAD" !== d)
                                                                return alert("INVALID PARENT"),
                                                                [2, l("INVALID PARENT")];
                                                            this.headMaterialArrays = o(this.headMaterialArrays, p)
                                                        }
                                                        u === e.length - 1 && console.log("OLE FINISH", u),
                                                        s(!0)
                                                    }
                                                    return [2]
                                                }
                                            }
                                            ))
                                        }
                                        ))
                                    }
                                    ))
                                }
                                ))]
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.getTempLoad = function(e, t, n, s, l, c, u, h, d) {
                        return void 0 === l && (l = !1),
                        void 0 === c && (c = ""),
                        void 0 === u && (u = "ADD"),
                        void 0 === d && (d = !1),
                        i(this, void 0, void 0, (function() {
                            var i, p, f, m, g, v, y, _, x, b, w = this;
                            return a(this, (function(a) {
                                switch (a.label) {
                                case 0:
                                    return i = r({}, this.api.sceneManager.currentLoadedData),
                                    console.log(this.handModel, "this.handModel"),
                                    this.handModel ? (this.api.sceneManager.mesh.material.opacity = 0,
                                    this.api.sceneManager.dirLight.intensity = .6) : (this.api.sceneManager.mesh.material.opacity = .2,
                                    this.api.sceneManager.dirLight.intensity = 1),
                                    p = null,
                                    f = null,
                                    (m = document.getElementById("loading-overlay")) && (m.style.display = "block"),
                                    e ? [4, this.api.loadModel(e, (function() {}
                                    )).catch((function(e) {
                                        alert("Unable to load model, check console"),
                                        console.log(e)
                                    }
                                    ))] : [3, 2];
                                case 1:
                                    p = a.sent(),
                                    a.label = 2;
                                case 2:
                                    return t ? [4, this.api.loadModel(t, (function() {}
                                    )).catch((function(e) {
                                        alert("Unable to load model, check console"),
                                        console.log(e)
                                    }
                                    ))] : [3, 4];
                                case 3:
                                    f = a.sent(),
                                    a.label = 4;
                                case 4:
                                    return s || this.api.clearAll(!0),
                                    p && (g = this.api.addObject(p, this._metalColorTexture[this.currentHeadColor], ["HEAD"], u),
                                    y = g.diamonds,
                                    _ = g.materials,
                                    this.diamondArrays = o(this.diamondArrays, y),
                                    this.headMaterialArrays = o(this.headMaterialArrays, _),
                                    this.materialsArrays = o(this.materialsArrays, _)),
                                    f && (v = this.api.addObject(f, this._metalColorTexture[this.currentShankColor], ["SHANK"], u),
                                    y = v.diamonds,
                                    _ = v.materials,
                                    this.diamondArrays = o(this.diamondArrays, y),
                                    this.shankMaterialArrays = o(this.shankMaterialArrays, _),
                                    this.materialsArrays = o(this.materialsArrays, _)),
                                    n && n.length > 0 ? [4, this.loadAddonModels(n, h, u)] : [3, 6];
                                case 5:
                                    a.sent(),
                                    a.label = 6;
                                case 6:
                                    return "REMOVE" === u && h && "BAND" !== h[0] && h.forEach((function(e) {
                                        console.log(e, "type--", n),
                                        "BAND" === e ? (i.BAND && 0 === (null == n ? void 0 : n.length) && w.api.sceneManager.removeSpecificObject(e, "OFF"),
                                        i.BAND && n && (null == n ? void 0 : n.length) > 0 && w.api.sceneManager.removeSpecificObject(e)) : "HAND" === e ? (i.HAND && 0 === (null == n ? void 0 : n.length) && w.api.sceneManager.removeSpecificObject(e, "OFF"),
                                        i.HAND && n && (null == n ? void 0 : n.length) > 0 && w.api.sceneManager.removeSpecificObject(e)) : w.api.sceneManager.removeSpecificObject(e)
                                    }
                                    )),
                                    l ? [2, this.captureScreenshot(c, !1, "jpeg", null)] : ((x = document.getElementById("loading-overlay")) && (x.style.display = "none",
                                    console.log("Fully loaded")),
                                    this.api.sceneManager.updateLoadedModelDetails(e, t, n && (null == n ? void 0 : n.length) > 0 ? n[0].url : null),
                                    d && 0 === (null == n ? void 0 : n.length) && (this.api.sceneManager.loadedModelsDetails.band = null),
                                    s && "ADD" === u && (b = document.getElementById("helper-popup")) && (b.style.display = "flex"),
                                    [2])
                                }
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.getLoadedModel = function(e, t, n, r, s, l, c, u) {
                        var h, d, p, f, m, g, v, y, _, x, b, w, M, S, T, E, A, C;
                        return void 0 === l && (l = !1),
                        void 0 === c && (c = ""),
                        void 0 === u && (u = "ADD"),
                        i(this, void 0, void 0, (function() {
                            var n, i, P, R, L, D, O, F, I, N, B, k;
                            return a(this, (function(a) {
                                switch (a.label) {
                                case 0:
                                    return console.log("changing", this.currentShankColor, l),
                                    n = null === (h = this.api.getCameraParams().position) || void 0 === h ? void 0 : h.y,
                                    i = null === (d = this.api.getCameraParams().position) || void 0 === d ? void 0 : d.x,
                                    P = null === (p = this.api.getCameraParams().position) || void 0 === p ? void 0 : p.z,
                                    R = 0,
                                    [4, this.api.loadModel(e, (function(e) {
                                        var t = e.loaded / e.total * 100;
                                        R = Math.floor((t - R + R) / 2);
                                        var n = document.getElementById("loading-overlay");
                                        n && (n.style.display = "block")
                                    }
                                    )).catch((function(e) {
                                        alert("Unable to load model, check console"),
                                        console.log(e)
                                    }
                                    ))];
                                case 1:
                                    return L = a.sent(),
                                    [4, this.api.loadModel(t, (function(e) {
                                        var t = e.loaded / e.total * 100;
                                        R = Math.floor((t - R + R) / 2) + 50,
                                        document.getElementById("loading-overlay")
                                    }
                                    )).catch((function(e) {
                                        alert("Unable to load model, check console"),
                                        console.log(e)
                                    }
                                    ))];
                                case 2:
                                    return D = a.sent(),
                                    this.api.clearAll(!0),
                                    L && (O = this.api.addObject(L, this._metalColorTexture[this.currentHeadColor], ["HEAD"], u),
                                    I = O.diamonds,
                                    N = O.materials,
                                    (null === (f = this.api.sceneManager.cameraParams.position) || void 0 === f ? void 0 : f.y) && (this.api.sceneManager.cameraParams.position.y = n),
                                    (null === (m = this.api.sceneManager.cameraParams.position) || void 0 === m ? void 0 : m.x) && (this.api.sceneManager.cameraParams.position.x = i),
                                    (null === (g = this.api.sceneManager.cameraParams.position) || void 0 === g ? void 0 : g.z) && (this.api.sceneManager.cameraParams.position.z = P),
                                    e.includes("CUSHION_HALO") && (L.position.z = 7),
                                    this.currentGEM = e.split("_")[0],
                                    this.currentHEAD = e.split("_")[1],
                                    this.diamondArrays = o(this.diamondArrays, I),
                                    this.headMaterialArrays = o(this.headMaterialArrays, N),
                                    this.materialsArrays = o(this.materialsArrays, N)),
                                    D && (F = this.api.addObject(D, this._metalColorTexture[this.currentShankColor], ["SHANK"], u),
                                    I = F.diamonds,
                                    N = F.materials,
                                    (null === (v = this.api.sceneManager.cameraParams.position) || void 0 === v ? void 0 : v.y) && (this.api.sceneManager.cameraParams.position.y = n),
                                    (null === (y = this.api.sceneManager.cameraParams.position) || void 0 === y ? void 0 : y.x) && (this.api.sceneManager.cameraParams.position.x = i),
                                    (null === (_ = this.api.sceneManager.cameraParams.position) || void 0 === _ ? void 0 : _.z) && (this.api.sceneManager.cameraParams.position.z = P),
                                    this.diamondArrays = o(this.diamondArrays, I),
                                    this.currentSHANK = t,
                                    this.shankMaterialArrays = o(this.shankMaterialArrays, N),
                                    this.materialsArrays = o(this.materialsArrays, N)),
                                    (null === (x = this.api.sceneManager.cameraParams.position) || void 0 === x ? void 0 : x.y) && (this.api.sceneManager.cameraParams.position.y = n),
                                    (null === (b = this.api.sceneManager.cameraParams.position) || void 0 === b ? void 0 : b.x) && (this.api.sceneManager.cameraParams.position.x = i),
                                    (null === (w = this.api.sceneManager.cameraParams.position) || void 0 === w ? void 0 : w.z) && (this.api.sceneManager.cameraParams.position.z = P),
                                    s.length > 0 ? [4, this.loadAddonModels(s, [], u)] : [3, 4];
                                case 3:
                                    a.sent(),
                                    (null === (M = this.api.sceneManager.cameraParams.position) || void 0 === M ? void 0 : M.y) && (this.api.sceneManager.cameraParams.position.y = n),
                                    (null === (S = this.api.sceneManager.cameraParams.position) || void 0 === S ? void 0 : S.x) && (this.api.sceneManager.cameraParams.position.x = i),
                                    (null === (T = this.api.sceneManager.cameraParams.position) || void 0 === T ? void 0 : T.z) && (this.api.sceneManager.cameraParams.position.z = P),
                                    a.label = 4;
                                case 4:
                                    return (null === (E = this.api.sceneManager.cameraParams.position) || void 0 === E ? void 0 : E.y) && (this.api.sceneManager.cameraParams.position.y = n),
                                    (null === (A = this.api.sceneManager.cameraParams.position) || void 0 === A ? void 0 : A.x) && (this.api.sceneManager.cameraParams.position.x = i),
                                    (null === (C = this.api.sceneManager.cameraParams.position) || void 0 === C ? void 0 : C.z) && (this.api.sceneManager.cameraParams.position.z = P),
                                    console.log("CHANGE"),
                                    l ? [2, this.captureScreenshot(c, !1, "jpeg", null)] : ((B = document.getElementById("loading-overlay")) && (B.style.display = "none",
                                    console.log("Fully loaded")),
                                    r && (k = document.getElementById("helper-popup")) && (k.style.display = "flex"),
                                    [2])
                                }
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.selectObject = function(e) {
                        var t, n;
                        e ? (this.api.highlightObjects(e),
                        this.selectedMaterial = this.api.getMaterialParams(e),
                        null === (t = this.gui) || void 0 === t || t.showMaterialUi(),
                        this.selectedObject = e) : (this.api.highlightObjects(),
                        null === (n = this.gui) || void 0 === n || n.removeMaterialUi(),
                        this.selectedMaterial = null)
                    }
                    ,
                    e.prototype.updateSelectedMaterial = function() {
                        this.selectedObject && this.selectedMaterial && this.api.setMaterialParams(this.selectedObject, this.selectedMaterial)
                    }
                    ,
                    e
                }());
                t.Editor = d;
                var p = function() {
                    function e(e, t) {
                        var n, r, s, d, p = this;
                        this.lutFolder = null,
                        this.diamondFolder = null,
                        this.ocTexture = function(e, t, n) {
                            p.promptForFile((function(e) {
                                var r = Array.isArray(e) ? e[0] : e;
                                if (t) {
                                    var i = URL.createObjectURL(r);
                                    (new h).load(i, (function(e) {
                                        console.log("LUT loaded"),
                                        console.log(e),
                                        p.editor.updateLUTMap(e)
                                    }
                                    ))
                                } else if (1 === e.length)
                                    p.api.importTexture(r, (function(e) {
                                        p.api.sceneManager.refreshAllDiamonds(e, p.editor.diamondArrays)
                                    }
                                    ));
                                else {
                                    var a = e.map((function(e) {
                                        return URL.createObjectURL(e)
                                    }
                                    ));
                                    p.api.loadTexture(a, (function(e) {}
                                    ), {
                                        extension: "hdr"
                                    }).then((function(e) {
                                        n ? p.editor.materialsArrays.forEach((function(t) {
                                            t.material.envMap = e;
                                            var n = p.api.sceneManager.cameraParams;
                                            p.api.sceneManager.cameraParams = n
                                        }
                                        )) : p.api.sceneManager.setSceneEnvironment(e, {
                                            imageBasedLighting: !0,
                                            setBackground: !1
                                        })
                                    }
                                    )).catch((function(e) {
                                        alert("Unable to load cube texture, check console"),
                                        console.log(e)
                                    }
                                    ))
                                }
                            }
                            ))
                        }
                        ,
                        this.addTextureFolder = function(e, t, n, r) {
                            e.addFolder(t).add({
                                f: function() {
                                    return p.ocTexture(t, n, r)
                                }
                            }, "f").name("set file")
                        }
                        ,
                        this.materialFolder = null,
                        this.gui = new l.GUI,
                        this.api = e,
                        this.editor = t,
                        this.dropzone = new u.SimpleDropzone(document.querySelector("body"),document.querySelector("#inputDropzone")),
                        this.dropzone.on("drop", (function(n) {
                            var r = n.files;
                            return i(p, void 0, void 0, (function() {
                                return a(this, (function(n) {
                                    switch (n.label) {
                                    case 0:
                                        return e.clearAll(),
                                        [4, e.importModelFiles(r, this.editor._metalColorTexture[this.editor.currentHeadColor])];
                                    case 1:
                                        return n.sent().forEach((function(e) {
                                            var n = e.diamonds
                                              , r = e.materials;
                                            t.diamondArrays = o(t.diamondArrays, n),
                                            t.materialsArrays = o(t.materialsArrays, r)
                                        }
                                        )),
                                        e.sceneManager.cameraParams.position = new c.Vector3(0,1,1),
                                        [2]
                                    }
                                }
                                ))
                            }
                            ))
                        }
                        )),
                        this.gui.addFolder("TAA").add(e, "enableTAA");
                        var f = this.gui.addFolder("Actions");
                        f.add({
                            a: function() {
                                e.sceneManager.exportGltf().then((function(e) {
                                    var t = document.createElement("a")
                                      , n = new Blob([e],{
                                        type: "application/json"
                                    });
                                    t.href = URL.createObjectURL(n),
                                    t.download = "scene.gltf";
                                    var r = document.getElementsByTagName("body")[0];
                                    r.appendChild(t),
                                    t.click(),
                                    r.removeChild(t)
                                }
                                ))
                            }
                        }, "a").name("gltf download"),
                        f.add({
                            a: function() {
                                return e.clearAll()
                            }
                        }, "a").name("clear all"),
                        f.add({
                            a: function() {
                                var n = e.getSnapshotData("image/jpeg")
                                  , r = document.createElement("a");
                                r.download = "screenshot.jpeg",
                                r.href = n,
                                t.captureScreenshot("", !0, "png", null)
                            }
                        }, "a").name("dl screenshot"),
                        f.add({
                            a: function() {
                                var t = document.createElement("canvas");
                                t.id = "Temp",
                                t.width = window.innerWidth / 3,
                                t.height = window.innerHeight / 3,
                                t.style.zIndex = "",
                                t.style.position = "absolute",
                                t.style.border = "1px solid",
                                t.style.borderColor = "#ff0000",
                                t.style.top = "0px",
                                t.style.left = "0px";
                                var n = document.getElementsByTagName("body")[0];
                                n.appendChild(t),
                                e.getSnapshot({
                                    canvas: t
                                }).then((function(e) {
                                    setTimeout((function() {
                                        n.removeChild(t)
                                    }
                                    ), 5e3)
                                }
                                ))
                            }
                        }, "a").name("snap canvas");
                        var m = this.gui.addFolder("Background");
                        e.sceneManager.background = new c.Color(1,1,1),
                        m.add(e, "exposure", 0, 2),
                        m.addColor({
                            color: [205, 205, 205]
                        }, "color").name("set color").onChange((function(t) {
                            e.sceneManager.background = new c.Color(t[0] / 255,t[1] / 255,t[2] / 255)
                        }
                        ));
                        var g = this;
                        m.add({
                            f: function() {
                                return g.promptForFile((function(t) {
                                    return e.setBackgroundTexture(t)
                                }
                                ))
                            }
                        }, "f").name("select bg image"),
                        m.add({
                            f: function() {
                                return g.promptForFile((function(t) {
                                    return e.setBackgroundTexture(t, !0)
                                }
                                ))
                            }
                        }, "f").name("select equirec env file"),
                        m.add({
                            f: function() {
                                return e.setBackgroundTexture(null)
                            }
                        }, "f").name("remove bg");
                        var v = this.gui.addFolder("Camera")
                          , y = e.sceneManager.cameraParams
                          , _ = function(t) {
                            e.sceneManager.cameraParams = y
                        };
                        v.add(y, "mode", ["orbit", "fixed"]).onChange(_),
                        v.add(y, "zoom", 0, 10).onChange(_),
                        v.add(y, "fov", 1, 100).onChange(_),
                        v.add(y.position, "x", -10, 10).onChange(_),
                        v.add(y.position, "y", -10, 10).onChange(_),
                        v.add(y.position, "z", -10, 10).onChange(_);
                        var x = v.addFolder("Orbit");
                        x.add(y.orbitParams, "minDistance").onChange(_),
                        x.add(y.orbitParams, "maxDistance").onChange(_),
                        x.add(y.orbitParams, "minZoom").onChange(_),
                        x.add(y.orbitParams, "maxZoom").onChange(_),
                        x.add(y.orbitParams, "minPolarAngle").onChange(_),
                        x.add(y.orbitParams, "maxPolarAngle").onChange(_),
                        x.add(y.orbitParams, "minAzimuthAngle").onChange(_),
                        x.add(y.orbitParams, "maxAzimuthAngle").onChange(_),
                        x.add(y.orbitParams, "dampingFactor", 0, 1).onChange(_),
                        x.add(y.orbitParams, "autoRotate").onChange(_),
                        x.add(y.orbitParams, "autoRotateSpeed", .1, 10).onChange(_);
                        var b = this.gui.addFolder("Scene settings")
                          , w = b.addFolder("Orientation")
                          , M = e.sceneManager.orientation;
                        _ = function(t) {
                            e.sceneManager.orientation = M
                        }
                        ,
                        w.add(M, "y", -3.5, 3.5).onChange(_);
                        var S = function(t, n) {
                            e.sceneManager.rotateAround(new c.Vector3(+("x" == t),+("y" == t),+("z" == t)), ("+" == n ? 1 : -1) * Math.PI / 2, .4)
                        }
                          , T = {
                            reset: function() {
                                return e.resetRotation()
                            },
                            "x+": function() {
                                return S("x", "+")
                            },
                            "x-": function() {
                                return S("x", "-")
                            },
                            "y+": function() {
                                return S("y", "+")
                            },
                            "y-": function() {
                                return S("y", "-")
                            },
                            "z+": function() {
                                return S("z", "+")
                            },
                            "z-": function() {
                                return S("z", "-")
                            }
                        }
                          , E = b.addFolder("Straighten Model");
                        E.add(T, "reset").name("Reset"),
                        E.add(T, "x+").name("Rotate X +"),
                        E.add(T, "x-").name("Rotate X -"),
                        E.add(T, "y+").name("Rotate Y +"),
                        E.add(T, "y-").name("Rotate Y -"),
                        E.add(T, "z+").name("Rotate Z +"),
                        E.add(T, "z-").name("Rotate Z -");
                        var A = this.gui.addFolder("light")
                          , C = this.gui.addFolder("plane")
                          , P = {
                            x: 0,
                            y: 0,
                            z: 0,
                            color: 14211288,
                            opacity: .15,
                            enable: !0
                        };
                        C.add(P, "x", -1e3).onChange((function(t) {
                            p.api.sceneManager.mesh.position.x = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        C.add(P, "enable").onChange((function(e) {
                            p.api.sceneManager.getHeadPosition()
                        }
                        )),
                        b.add({
                            x: 0,
                            y: 0,
                            z: 0,
                            color: 14211288,
                            opacity: .15
                        }, "x", -1e3).onChange((function(e) {
                            p.api.sceneManager.scene.translateX(Number(e))
                        }
                        )),
                        C.add(P, "y", -1e3).onChange((function(t) {
                            p.api.sceneManager.mesh.position.y = Number(t),
                            e.sceneManager.cameraParams = y,
                            console.log("HURRAY")
                        }
                        )),
                        b.add(P, "y", -1e3).onChange((function(t) {
                            p.api.sceneManager.scene.translateX(Number(-.1)),
                            p.api.sceneManager.scene.translateY(Number(-.3)),
                            e.sceneManager.cameraParams = y,
                            console.log("HURRAY")
                        }
                        )),
                        b.add(P, "z", -1e3).onChange((function(t) {
                            p.api.sceneManager.scene.position.y = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        C.add(P, "z", -1e3).onChange((function(t) {
                            p.api.sceneManager.mesh.position.z = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        C.add(P, "z", -1e3).onChange((function(t) {
                            p.api.sceneManager.mesh.position.z = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        C.add(P, "opacity", 0, 1, .1).onChange((function(t) {
                            p.api.sceneManager.mesh.material.opacity = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        C.addColor({
                            color: [205, 205, 205]
                        }, "color").name("set color").onChange((function(t) {
                            console.log(p.api.sceneManager.mesh.material, t),
                            p.api.sceneManager.mesh.material = new c.Color(t[0] / 255,t[1] / 255,t[2] / 255),
                            e.sceneManager.cameraParams = y
                        }
                        ));
                        var R = {
                            positionX: -3,
                            positionY: 10,
                            positionZ: -10,
                            near: .1,
                            far: 40,
                            right: 2,
                            left: -2,
                            top: 2,
                            bottom: -2,
                            enable: !0,
                            intensity: 1
                        };
                        A.add(R, "positionX", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.position.x = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "intensity", 0, 1, .1).onChange((function(t) {
                            p.api.sceneManager.dirLight.intensity = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "enable").onChange((function(t) {
                            t ? (p.api.sceneManager.scene.add(p.api.sceneManager.meshHolder),
                            p.api.sceneManager.scene.add(p.api.sceneManager.lightHolder),
                            e.sceneManager.cameraParams = y) : (p.api.sceneManager.scene.remove.apply(p.api.sceneManager.scene, [p.api.sceneManager.lightHolder]),
                            p.api.sceneManager.scene.remove.apply(p.api.sceneManager.scene, [p.api.sceneManager.meshHolder]),
                            e.sceneManager.cameraParams = y)
                        }
                        )),
                        A.add(R, "positionY", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.position.y = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "positionZ", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.position.z = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "near", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.shadow.camera.near = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "far", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.shadow.camera.far = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "right", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.shadow.camera.right = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "left", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.shadow.camera.left = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "top", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.shadow.camera.top = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        A.add(R, "bottom", -100).onChange((function(t) {
                            p.api.sceneManager.dirLight.shadow.camera.bottom = Number(t),
                            e.sceneManager.cameraParams = y
                        }
                        ));
                        var L = this.gui.addFolder("Default Material")
                          , D = this.gui.addFolder("Change Model")
                          , O = this.gui.addFolder("Remove Model")
                          , F = {
                            head: "HEAD",
                            shank: "STRAIGHT_SHANK",
                            gem: "ROUND"
                        }
                          , I = this;
                        O.add({
                            remove: ""
                        }, "remove", (n = {},
                        n.Head = "HEAD",
                        n.SHANK = "SHANK",
                        n.Band = "BAND",
                        n)).onChange((function(e) {
                            console.log(e),
                            I.api.sceneManager.removeSpecificObject(e)
                        }
                        )),
                        D.add(F, "gem", (r = {},
                        r.Round = "ROUND",
                        r.Oval = "OVAL",
                        r)).onChange((function(e) {
                            var t;
                            I.editor.currentGEM = e,
                            t = "HALO" === I.editor.currentHEAD ? "ROUND" === e ? "https://all3dmodels.s3.ap-south-1.amazonaws.com/R-150-H1.glb" : "https://all3dmodels.s3.ap-south-1.amazonaws.com/O-150-H1.glb" : "ROUND" === e ? "https://all3dmodels2021-nv.s3.amazonaws.com/R-150-SO.glb" : "https://all3dmodels.s3.ap-south-1.amazonaws.com/O-150-SO.glb",
                            I.editor.getTempLoad(t || null, null, null, !0, !1, "", "REMOVE", ["HEAD"])
                        }
                        )),
                        D.add(F, "head", (s = {},
                        s["Classic Prong"] = "HEAD",
                        s["Single Halo"] = "HALO",
                        s)).onChange((function(e) {
                            var t;
                            I.editor.currentHEAD = e,
                            t = "HALO" === e ? "ROUND" === I.editor.currentGEM ? "https://all3dmodels.s3.ap-south-1.amazonaws.com/R-150-H1.glb" : "https://all3dmodels.s3.ap-south-1.amazonaws.com/O-150-H1.glb" : "ROUND" === I.editor.currentGEM ? "https://all3dmodels2021-nv.s3.amazonaws.com/R-150-SO.glb" : "https://all3dmodels.s3.ap-south-1.amazonaws.com/O-150-SO.glb",
                            I.editor.getTempLoad(t || null, null, null, !0, !1, "", "REMOVE", ["HEAD"])
                        }
                        )),
                        D.add(F, "shank", (d = {},
                        d["Straight Shank"] = "STRAIGHT_SHANK",
                        d["Cross Shank"] = "CROSS_SHANK",
                        d)).onChange((function(e) {
                            var t = "https://all3dmodels2021-nv.s3.amazonaws.com/LGR2598X2.glb";
                            "CROSS_SHANK" === e && (t = "https://all3dmodels.s3.ap-south-1.amazonaws.com/LGR0631X4.glb"),
                            I.editor.getTempLoad(null, t, null, !0, !1, "", "REMOVE", ["SHANK"])
                        }
                        ));
                        var N = {
                            headColor: "#b8b8cd",
                            shankColor: "#b8b8cd",
                            roughness: .12,
                            metalness: 1,
                            envMapIntensity: 4,
                            emissiveIntensity: 1,
                            emissiveMap: 1,
                            emissive: "#000000"
                        };
                        L.addColor(N, "headColor").onChange((function(t) {
                            for (var n = 0; n < I.editor.headMaterialArrays.length; n++)
                                I.editor.headMaterialArrays[n].material.color = new c.Color(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        L.addColor(N, "shankColor").onChange((function(t) {
                            for (var n = 0; n < I.editor.shankMaterialArrays.length; n++)
                                I.editor.shankMaterialArrays[n].material.color = new c.Color(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        L.add(N, "roughness", 0, 1).onChange((function(t) {
                            for (var n = 0; n < I.editor.materialsArrays.length; n++)
                                I.editor.materialsArrays[n].material.roughness = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        L.add(N, "metalness", 0, 1).onChange((function(t) {
                            for (var n = 0; n < I.editor.materialsArrays.length; n++)
                                I.editor.materialsArrays[n].material.metalness = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        L.addColor(N, "emissive").onChange((function(t) {
                            for (var n = 0; n < I.editor.materialsArrays.length; n++)
                                I.editor.materialsArrays[n].material.emissive = new c.Color(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        L.add(N, "emissiveIntensity", 1, 10).onChange((function(t) {
                            for (var n = 0; n < I.editor.materialsArrays.length; n++)
                                I.editor.materialsArrays[n].material.emissiveIntensity = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        L.add(N, "envMapIntensity", 0, 10).onChange((function(t) {
                            for (var n = 0; n < I.editor.materialsArrays.length; n++)
                                I.editor.materialsArrays[n].material.envMapIntensity = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.addTextureFolder(L, "envmap", !1, !0),
                        this.lutFolder = this.gui.addFolder("LUT"),
                        this.lutFolder.add({
                            enable: !0
                        }, "enable").onChange((function(t) {
                            var n = t ? p.editor.lutMap : null;
                            p.editor.updateLUTMap(n),
                            e.sceneManager.cameraParams = y
                        }
                        )),
                        this.addTextureFolder(this.lutFolder, "lutmap", !0),
                        this.diamondFolder = this.gui.addFolder("Diamond");
                        var B = {
                            geometryFactor: .19,
                            distanceOffset: 0,
                            squashFactor: 1,
                            refractiveIndex: 2.4,
                            color: "#ffffff",
                            boostFactorsX: 2,
                            boostFactorsY: 2,
                            boostFactorsZ: 2.2,
                            envMapIntensity: 2,
                            rIndexDelta: 0,
                            gammaFactor: 1,
                            absorbptionFactor: 1,
                            LUT: !1
                        };
                        I = this,
                        this.diamondFolder.add(B, "geometryFactor", .1, .5, .01).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.geometryFactor.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.addColor(B, "color").onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.colorCorrection.value = new c.Color(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "boostFactorsX", 1, 5, .01).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.boostFactors.value.x = t,
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "boostFactorsY", 1, 5, .01).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.boostFactors.value.y = t,
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "boostFactorsZ", 1, 5, .01).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.boostFactors.value.z = t,
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.addTextureFolder(this.diamondFolder, "envMap"),
                        this.diamondFolder.add(B, "envMapIntensity", 0, 5).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.envMapIntensity.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "refractiveIndex", 0, 5).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.refractiveIndex.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "rIndexDelta", 0, 1).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.rIndexDelta.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "squashFactor", 0, 5).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.squashFactor.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "absorbptionFactor", 1, 5).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.absorbptionFactor.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        )),
                        this.diamondFolder.add(B, "gammaFactor", 1, 2).onChange((function(t) {
                            for (var n = 0; n < I.editor.diamondArrays.length; n++)
                                I.editor.diamondArrays[n].getMesh().material.uniforms.gammaFactor.value = Number(t),
                                e.sceneManager.cameraParams = y
                        }
                        ));
                        var k = this.gui.addFolder("Outline")
                          , z = e.sceneManager.outlineParams;
                        _ = function(t) {
                            e.sceneManager.outlineParams = z
                        }
                        ,
                        k.add(z, "edgeGlow", 0, 1).onChange(_),
                        k.add(z, "edgeThickness", 1, 4).onChange(_),
                        k.add(z, "edgeStrength", .01, 10).onChange(_),
                        k.add(z, "downSampleRatio").onChange(_),
                        k.add(z, "pulsePeriod", 0, 5).onChange(_);
                        var U = this.gui.addFolder("SSAO")
                          , H = e.viewer.ssaoParams;
                        _ = function(t) {
                            e.viewer.ssaoParams = H
                        }
                        ,
                        U.add(H, "enabled").onChange(_),
                        U.add(H, "enableDebug").onChange(_),
                        U.add(H, "intensity", 0, 1).onChange(_),
                        U.add(H, "radius", 0, 10).onChange(_),
                        U.add(H, "downscaleLevel", [1, 2]).onChange(_);
                        var G = this.gui.addFolder("SSR")
                          , j = e.sceneManager.ssrParams;
                        _ = function(t) {
                            e.sceneManager.ssrParams = j
                        }
                        ,
                        G.add(j, "enabled").onChange(_),
                        G.add(j, "intensity", 0, 1).onChange(_);
                        var V = this.gui.addFolder("Ground shadows")
                          , W = e.getGroundShadowParams();
                        _ = function(t) {
                            e.setGroundShadowParams(W)
                        }
                        ,
                        V.add(W, "numSamples", 1, 1e3).onChange(_),
                        V.add(W, "numSamplesPerFrame", 1, 10).onChange(_),
                        V.add(W, "brightness", 0, 1).onChange(_),
                        V.add(W, "blurRadius", 0, 10).onChange(_),
                        V.add(W, "sharpness", 0, 90).onChange(_),
                        V.add(W, "falloff", 1, 5).onChange(_),
                        V.add(W, "smoothTransition").onChange(_),
                        V.add(W, "enableSmooth").onChange(_),
                        V.add(W, "side", {
                            UP: 1,
                            DOWN: 2,
                            LEFT: 3,
                            RIGHT: 4,
                            FRONT: 5,
                            BACK: 6
                        }).onChange(_)
                    }
                    return e.prototype.convertFileToDataURI = function(e) {
                        return i(this, void 0, void 0, (function() {
                            return a(this, (function(t) {
                                return [2, new Promise((function(t, n) {
                                    if (6 !== e.length)
                                        return n("Cube texture needs 6 files");
                                    var r = [];
                                    e.forEach((function(e) {
                                        var n = new FileReader;
                                        n.onload = function() {
                                            var e = n.result || "";
                                            r.push(e),
                                            6 === r.length && t(r)
                                        }
                                        ,
                                        n.readAsDataURL(e)
                                    }
                                    ))
                                }
                                ))]
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.promptForFile = function(e, t) {
                        void 0 === t && (t = !1);
                        var n = document.getElementById("fileInput");
                        n.onchange = function(t) {
                            if (n.files.length > 0) {
                                var r = n.files;
                                e(Array.from(r || [])),
                                n.value = ""
                            }
                            n.onchange = null
                        }
                        ,
                        n.click()
                    }
                    ,
                    e.prototype.showMaterialUi = function() {
                        var e, t, n = this, r = this.editor.selectedMaterial;
                        if (r && r !== {}) {
                            this.materialFolder && this.removeMaterialUi();
                            var i = function(e) {
                                n.editor.updateSelectedMaterial()
                            }
                              , a = function(e, t) {
                                var i = e.addFolder(t);
                                i.add({
                                    f: function() {
                                        return function(e) {
                                            n.promptForFile((function(t) {
                                                var i = Array.isArray(t) ? t[0] : t;
                                                i && i instanceof File && n.api.importTexture(i, (function(t) {
                                                    var i = r[e];
                                                    r[e] = t,
                                                    i instanceof c.Texture && i.dispose(),
                                                    n.editor.updateSelectedMaterial(),
                                                    n.showMaterialUi()
                                                }
                                                ))
                                            }
                                            ))
                                        }(t)
                                    }
                                }, "f").name((r[t] ? "replace" : "set") + " file");
                                var a = r[t];
                                if (a) {
                                    i.add({
                                        f: function() {
                                            return function(e) {
                                                var t = new s.TextureExporter
                                                  , n = t.exportTexture(e, {
                                                    embedImages: !0,
                                                    maxTextureSize: 1024
                                                });
                                                t.dispose();
                                                var r = window.open("about:blank")
                                                  , i = new Image;
                                                i.src = n.image.data,
                                                null == r || r.document.write(i.outerHTML)
                                            }(r[t])
                                        }
                                    }, "f").name("open file"),
                                    i.add({
                                        f: function() {
                                            return function(e, t) {
                                                var n = new s.TextureExporter
                                                  , r = n.exportTexture(e, {
                                                    embedImages: !0,
                                                    maxTextureSize: 2048
                                                });
                                                n.dispose();
                                                var i = r.image.data
                                                  , a = document.createElement("a");
                                                a.download = t + "." + r.image.mimeType.split("/")[1],
                                                a.href = i;
                                                var o = document.getElementsByTagName("body")[0];
                                                o.appendChild(a),
                                                a.click(),
                                                o.removeChild(a)
                                            }(r[t], t)
                                        }
                                    }, "f").name("download file"),
                                    i.add({
                                        f: function() {
                                            r[t] = null,
                                            n.editor.updateSelectedMaterial(),
                                            n.showMaterialUi()
                                        }
                                    }, "f").name("remove file");
                                    var o = s.TextureExporter.getSampler(a)
                                      , l = function() {
                                        s.TextureExporter.setSampler(o, a),
                                        console.log(a),
                                        a.needsUpdate = !0,
                                        n.api.setDirty()
                                    }
                                      , u = {
                                        CLAMP_TO_EDGE: s.TextureExporter.WEBGL_CONSTANTS.CLAMP_TO_EDGE,
                                        MIRRORED_REPEAT: s.TextureExporter.WEBGL_CONSTANTS.MIRRORED_REPEAT,
                                        REPEAT: s.TextureExporter.WEBGL_CONSTANTS.REPEAT
                                    };
                                    i.add(o, "wrapU", u).onChange(l),
                                    i.add(o, "wrapV", u).onChange(l),
                                    i.add(o, "repeatU", 0, 10).onChange(l),
                                    i.add(o, "repeatV", 0, 10).onChange(l)
                                }
                            }
                              , o = this
                              , l = {
                                download: function() {
                                    o.api.exportMaterialParams(r).then((function(e) {
                                        var t = document.createElement("a")
                                          , n = new Blob([e],{
                                            type: "application/json"
                                        });
                                        t.href = URL.createObjectURL(n),
                                        t.download = "material.json";
                                        var r = document.getElementsByTagName("body")[0];
                                        r.appendChild(t),
                                        t.click(),
                                        r.removeChild(t)
                                    }
                                    ))
                                },
                                upload: function() {
                                    o.promptForFile((function(e) {
                                        var t = Array.isArray(e) ? e[0] : e;
                                        if (t && t instanceof File) {
                                            var n = new FileReader;
                                            n.readAsText(t),
                                            n.onload = function() {
                                                o.api.importMaterialParams(n.result).then((function(e) {
                                                    o.editor.selectedMaterial = e,
                                                    o.editor.updateSelectedMaterial(),
                                                    o.showMaterialUi()
                                                }
                                                ))
                                            }
                                        }
                                    }
                                    ))
                                }
                            };
                            if (this.materialFolder = this.gui.addFolder("Material"),
                            this.materialFolder.add(l, "download"),
                            this.materialFolder.add(l, "upload").name("load from file"),
                            this.materialFolder.addColor(r, "color").onChange(i),
                            r.isDiamond)
                                this.materialFolder.add(r.boostFactors, "x", 0, 5).name("boostFac.x").onChange(i),
                                this.materialFolder.add(r.boostFactors, "y", 0, 5).name("boostFac.y").onChange(i),
                                this.materialFolder.add(r.boostFactors, "z", 0, 5).name("boostFac.z").onChange(i),
                                this.materialFolder.add(r, "envMapIntensity", 0, 5).onChange(i),
                                this.materialFolder.add(r, "refractiveIndex", 0, 5).onChange(i),
                                this.materialFolder.add(r, "geometryFactor", 0, 5).onChange(i),
                                this.materialFolder.add(r, "rIndexDelta", 0, 1).onChange(i),
                                a(this.materialFolder, "map"),
                                this.materialFolder.add(r, "absorbptionFactor", 1, 5).onChange(i),
                                this.materialFolder.add(r, "gammaFactor", 1, 2).onChange(i),
                                this.materialFolder.add(r, "squashFactor", 0, 5).onChange(i);
                            else {
                                this.materialFolder.add(r, "roughness", 0, 1).onChange(i),
                                this.materialFolder.add(r, "metalness", 0, 1).onChange(i),
                                a(this.materialFolder, "map"),
                                a(this.materialFolder, "lightMap"),
                                this.materialFolder.add(r, "lightMapIntensity").onChange(i),
                                a(this.materialFolder, "aoMap"),
                                this.materialFolder.add(r, "aoMapIntensity").onChange(i),
                                this.materialFolder.addColor(r, "emissive").onChange(i),
                                this.materialFolder.add(r, "emissiveIntensity").onChange(i),
                                a(this.materialFolder, "emissiveMap"),
                                a(this.materialFolder, "bumpMap"),
                                this.materialFolder.add(r, "bumpScale").onChange(i),
                                a(this.materialFolder, "normalMap"),
                                r.normalScale && (r.normalScaleX = null !== (e = r.normalScale[0]) && void 0 !== e ? e : 1,
                                r.normalScaleY = null !== (t = r.normalScale[1]) && void 0 !== t ? t : 1);
                                var u = function(e) {
                                    var t;
                                    void 0 !== (t = r.normalScaleX) && r.normalScale && (r.normalScale[0] = t),
                                    void 0 !== (t = r.normalScaleY) && r.normalScale && (r.normalScale[1] = t),
                                    i()
                                };
                                this.materialFolder.add(r, "normalScaleX").onChange(u),
                                this.materialFolder.add(r, "normalScaleY").onChange(u),
                                a(this.materialFolder, "roughnessMap"),
                                a(this.materialFolder, "metalnessMap"),
                                a(this.materialFolder, "alphaMap"),
                                this.materialFolder.add(r, "envMapIntensity").onChange(i),
                                this.materialFolder.add(r, "wireframe").onChange(i),
                                this.materialFolder.add(r, "wireframeLinewidth").onChange(i)
                            }
                            this.materialFolder.open()
                        }
                    }
                    ,
                    e.prototype.removeMaterialUi = function() {
                        this.materialFolder && this.gui.removeFolder(this.materialFolder),
                        this.materialFolder = null
                    }
                    ,
                    e
                }()
            },
            1278: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.TextureExporter = t.API = void 0;
                var r = n(9953);
                Object.defineProperty(t, "API", {
                    enumerable: !0,
                    get: function() {
                        return r.API
                    }
                }),
                Object.defineProperty(t, "TextureExporter", {
                    enumerable: !0,
                    get: function() {
                        return r.TextureExporter
                    }
                })
            }
            ,
            9953: function(e, t, n) {
                "use strict";
                var r = this && this.__awaiter || function(e, t, n, r) {
                    return new (n || (n = Promise))((function(i, a) {
                        function o(e) {
                            try {
                                l(r.next(e))
                            } catch (e) {
                                a(e)
                            }
                        }
                        function s(e) {
                            try {
                                l(r.throw(e))
                            } catch (e) {
                                a(e)
                            }
                        }
                        function l(e) {
                            var t;
                            e.done ? i(e.value) : (t = e.value,
                            t instanceof n ? t : new n((function(e) {
                                e(t)
                            }
                            ))).then(o, s)
                        }
                        l((r = r.apply(e, t || [])).next())
                    }
                    ))
                }
                  , i = this && this.__generator || function(e, t) {
                    var n, r, i, a, o = {
                        label: 0,
                        sent: function() {
                            if (1 & i[0])
                                throw i[1];
                            return i[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return a = {
                        next: s(0),
                        throw: s(1),
                        return: s(2)
                    },
                    "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                        return this
                    }
                    ),
                    a;
                    function s(a) {
                        return function(s) {
                            return function(a) {
                                if (n)
                                    throw new TypeError("Generator is already executing.");
                                for (; o; )
                                    try {
                                        if (n = 1,
                                        r && (i = 2 & a[0] ? r.return : a[0] ? r.throw || ((i = r.return) && i.call(r),
                                        0) : r.next) && !(i = i.call(r, a[1])).done)
                                            return i;
                                        switch (r = 0,
                                        i && (a = [2 & a[0], i.value]),
                                        a[0]) {
                                        case 0:
                                        case 1:
                                            i = a;
                                            break;
                                        case 4:
                                            return o.label++,
                                            {
                                                value: a[1],
                                                done: !1
                                            };
                                        case 5:
                                            o.label++,
                                            r = a[1],
                                            a = [0];
                                            continue;
                                        case 7:
                                            a = o.ops.pop(),
                                            o.trys.pop();
                                            continue;
                                        default:
                                            if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                                o = 0;
                                                continue
                                            }
                                            if (3 === a[0] && (!i || a[1] > i[0] && a[1] < i[3])) {
                                                o.label = a[1];
                                                break
                                            }
                                            if (6 === a[0] && o.label < i[1]) {
                                                o.label = i[1],
                                                i = a;
                                                break
                                            }
                                            if (i && o.label < i[2]) {
                                                o.label = i[2],
                                                o.ops.push(a);
                                                break
                                            }
                                            i[2] && o.ops.pop(),
                                            o.trys.pop();
                                            continue
                                        }
                                        a = t.call(e, o)
                                    } catch (e) {
                                        a = [6, e],
                                        r = 0
                                    } finally {
                                        n = i = 0
                                    }
                                if (5 & a[0])
                                    throw a[1];
                                return {
                                    value: a[0] ? a[1] : void 0,
                                    done: !0
                                }
                            }([a, s])
                        }
                    }
                }
                ;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.API = t.TextureExporter = void 0;
                var a = n(1559)
                  , o = n(7717)
                  , s = n(2104)
                  , l = n(3992)
                  , c = n(2592)
                  , u = n(8975)
                  , h = n(7137);
                Object.defineProperty(t, "TextureExporter", {
                    enumerable: !0,
                    get: function() {
                        return h.TextureExporter
                    }
                });
                var d = function() {
                    function e(e) {
                        var t = this;
                        this._animationId = 0,
                        this._viewer = new a.Viewer({
                            canvas: e.canvas
                        }),
                        this._sceneManager = new o.SceneManager(this._viewer,e.gemConfig),
                        this.sceneManager.onDirty((function() {
                            return t._viewer.setDirty()
                        }
                        )),
                        this._modelImporter = new s.ModelImporter,
                        this._textureImporter = new l.TextureImporter(this._viewer),
                        this._animationLoop = this._animationLoop.bind(this)
                    }
                    return e.prototype.play = function() {
                        this._animationId = requestAnimationFrame(this._animationLoop)
                    }
                    ,
                    e.prototype.pause = function() {
                        cancelAnimationFrame(this._animationId)
                    }
                    ,
                    e.prototype.loadModel = function(e, t, n) {
                        void 0 === n && (n = {});
                        var r = t || function() {}
                        ;
                        return this._modelImporter.import(e, r, n)
                    }
                    ,
                    e.prototype.loadTexture = function(e, t, n) {
                        void 0 === n && (n = {});
                        var r = t || function() {}
                        ;
                        return this._textureImporter.import(e, r, n)
                    }
                    ,
                    e.prototype.addObject = function(e, t, n, r) {
                        var i = this._sceneManager.add(e, t, n, r);
                        return {
                            diamonds: i.diamonds,
                            materials: i.materials
                        }
                    }
                    ,
                    e.prototype.removeObject = function(e) {
                        this._sceneManager.remove(e)
                    }
                    ,
                    e.prototype.clearAll = function(e) {
                        this._sceneManager.clearAll(e)
                    }
                    ,
                    e.prototype._animationLoop = function() {
                        this._viewer.render(this._sceneManager),
                        this._animationId = requestAnimationFrame(this._animationLoop)
                    }
                    ,
                    Object.defineProperty(e.prototype, "sceneManager", {
                        get: function() {
                            return this._sceneManager
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "viewer", {
                        get: function() {
                            return this._viewer
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.getSnapshot = function(e) {
                        return c.SnapshotHelper.getSnapshot(this._viewer.renderer, e)
                    }
                    ,
                    e.prototype.getSnapshotData = function(e) {
                        return c.SnapshotHelper.getSnapshotData(this._viewer.renderer, e)
                    }
                    ,
                    e.prototype.pickObject = function(e) {
                        return this._sceneManager.pickObject(e)
                    }
                    ,
                    e.prototype.pickObjectByNameOrId = function(e) {
                        return this._sceneManager.pickObjectByNameOrId(e)
                    }
                    ,
                    e.prototype.getMaterialParams = function(e) {
                        return u.MaterialUtils.getMaterialParams(e)
                    }
                    ,
                    e.prototype.setMaterialParams = function(e, t) {
                        u.MaterialUtils.setMaterialParams(e, t),
                        this._sceneManager.setDirty()
                    }
                    ,
                    e.prototype.highlightObjects = function() {
                        for (var e = [], t = 0; t < arguments.length; t++)
                            e[t] = arguments[t];
                        this.sceneManager.highlightObjects.apply(this.sceneManager, e)
                    }
                    ,
                    e.prototype.setBackgroundTexture = function(e, t, n) {
                        var r = this;
                        if (void 0 === t && (t = !1),
                        void 0 === n && (n = !1),
                        !e || e === [])
                            return this.sceneManager.background = null,
                            void (this.sceneManager.environment = null);
                        var i = {}
                          , a = Array.isArray(e) ? e[0] : e;
                        n && Array.isArray(e) && (i.cubeMapFiles = new Map,
                        e.forEach((function(e) {
                            return i.cubeMapFiles.set(e.name, e)
                        }
                        ))),
                        i.filename = a.name;
                        var o = URL.createObjectURL(a);
                        this.loadTexture(o, (function(e) {
                            return console.log(e)
                        }
                        ), i).then((function(e) {
                            t || n ? r.sceneManager.setSceneEnvironment(e, {
                                imageBasedLighting: !0,
                                setBackground: !0
                            }) : r.sceneManager.background = e
                        }
                        )).catch((function(e) {
                            alert("Unable to load texture, check console"),
                            console.log(e)
                        }
                        )).finally((function() {
                            URL.revokeObjectURL(o)
                        }
                        ))
                    }
                    ,
                    e.prototype.importModelFiles = function(e, t) {
                        return r(this, void 0, void 0, (function() {
                            var n, a = this;
                            return i(this, (function(o) {
                                return 0 == e.size ? [2] : (e.forEach((function(e, t) {
                                    e.name.match(/\.(gltf|glb|obj)$/) && t.replace(e.name, "")
                                }
                                )),
                                n = [],
                                [2, new Promise((function(o) {
                                    e.forEach((function(s) {
                                        return r(a, void 0, void 0, (function() {
                                            var r, a, l;
                                            return i(this, (function(i) {
                                                switch (i.label) {
                                                case 0:
                                                    return [4, this.importModel(s, {}, t)];
                                                case 1:
                                                    return r = i.sent(),
                                                    a = r.diamonds,
                                                    l = r.materials,
                                                    n.push({
                                                        diamonds: a,
                                                        materials: l
                                                    }),
                                                    e.size === n.length && o(n),
                                                    [2]
                                                }
                                            }
                                            ))
                                        }
                                        ))
                                    }
                                    ))
                                }
                                ))])
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.importModel = function(e, t, n) {
                        var r = this;
                        return void 0 === t && (t = {}),
                        new Promise((function(i, a) {
                            var o = URL.createObjectURL(e);
                            t.filename = e.name,
                            r.loadModel(o, (function(e) {
                                return console.log(e)
                            }
                            ), t).then((function(e) {
                                var t = r.addObject(e, n, null, "")
                                  , a = t.diamonds
                                  , o = t.materials;
                                i({
                                    diamonds: a,
                                    materials: o
                                })
                            }
                            )).catch((function(e) {
                                alert("Unable to load model, check console"),
                                console.log(e),
                                a(e)
                            }
                            )).finally((function() {
                                URL.revokeObjectURL(o)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e.prototype.importTexture = function(e, t) {
                        if (e) {
                            var n = URL.createObjectURL(e);
                            this.loadTexture(n, (function(e) {
                                return console.log(e)
                            }
                            ), {
                                filename: e.name
                            }).then((function(e) {
                                t(e)
                            }
                            )).catch((function(e) {
                                alert("Unable to load texture, check console"),
                                console.log(e)
                            }
                            )).finally((function() {
                                URL.revokeObjectURL(n)
                            }
                            ))
                        }
                    }
                    ,
                    e.prototype.exportMaterialParams = function(e) {
                        return u.MaterialUtils.exportMaterialParams(e)
                    }
                    ,
                    e.prototype.importMaterialParams = function(e) {
                        return u.MaterialUtils.importMaterialParams(e, this._textureImporter)
                    }
                    ,
                    Object.defineProperty(e.prototype, "exposure", {
                        get: function() {
                            return this._viewer.exposure
                        },
                        set: function(e) {
                            this._viewer.exposure = e,
                            this._sceneManager.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.setViewerSize = function(e, t) {
                        this._viewer.setSize(e, t),
                        this._sceneManager.setSize(e, t)
                    }
                    ,
                    e.prototype.setDisplayPixelRatio = function(e) {
                        this._sceneManager.pixelRatio = e,
                        this.viewer.pixelratio = e
                    }
                    ,
                    e.prototype.setSceneEnvironment = function(e, t) {
                        this._sceneManager.setSceneEnvironment(e, t)
                    }
                    ,
                    e.prototype.getCameraParams = function() {
                        return this._sceneManager.cameraParams
                    }
                    ,
                    e.prototype.setCameraParams = function(e) {
                        this._sceneManager.cameraParams = e
                    }
                    ,
                    e.prototype.getBackground = function() {
                        return this._sceneManager.background
                    }
                    ,
                    e.prototype.setBackground = function(e) {
                        this._sceneManager.background = e
                    }
                    ,
                    e.prototype.setOrientation = function(e) {
                        this._sceneManager.orientation = e
                    }
                    ,
                    e.prototype.getOrientation = function() {
                        return this._sceneManager.orientation
                    }
                    ,
                    e.prototype.setOutlineParams = function(e) {
                        this._sceneManager.outlineParams = e
                    }
                    ,
                    e.prototype.getOutlineParams = function() {
                        return this._sceneManager.outlineParams
                    }
                    ,
                    e.prototype.setSSAOParams = function(e) {
                        this._viewer.ssaoParams = e
                    }
                    ,
                    e.prototype.getSSAOParams = function() {
                        return this._viewer.ssaoParams
                    }
                    ,
                    e.prototype.setGroundShadowParams = function(e) {
                        this._sceneManager.groundShadows.config = e
                    }
                    ,
                    e.prototype.getGroundShadowParams = function() {
                        return this._sceneManager.groundShadows.config
                    }
                    ,
                    e.prototype.rotateAround = function(e, t, n) {}
                    ,
                    e.prototype.resetRotation = function(e) {
                        void 0 === e && (e = .5)
                    }
                    ,
                    e.prototype.resetCameraView = function(e, t) {
                        void 0 === e && (e = "z"),
                        void 0 === t && (t = !0),
                        this._sceneManager.resetCameraView(e, t)
                    }
                    ,
                    e.prototype.setDirty = function() {
                        this._sceneManager.setDirty()
                    }
                    ,
                    Object.defineProperty(e.prototype, "enableTAA", {
                        get: function() {
                            return this.sceneManager.enableTAA
                        },
                        set: function(e) {
                            this.sceneManager.enableTAA = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e
                }();
                t.API = d
            },
            57: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.GroundShadowsPlane = void 0;
                var r = n(2908)
                  , i = n(2212)
                  , a = function() {
                    function e(e, t, n) {
                        this._onUpdate = function() {}
                        ,
                        this.renderer = e,
                        this.scene_ = t,
                        this.camera = n,
                        this._shadowRenderTarget = new i.WebGLRenderTarget(512,512,{
                            format: i.RGBAFormat,
                            minFilter: i.LinearFilter,
                            magFilter: i.LinearFilter
                        }),
                        this._shadowBaker = new r.ShadowBaker({
                            numSamples: 100,
                            numSamplesPerFrame: 50,
                            size: 1.3,
                            brightness: .1,
                            enableBlur: !0,
                            blurRadius: .5,
                            falloff: 1.5,
                            smoothTransition: !1,
                            useMovingAverage: !0,
                            side: r.ShadowBaker.ShadowSide.DOWN
                        });
                        var a = new i.MeshBasicMaterial({
                            color: 16777215,
                            transparent: !0,
                            map: this._shadowRenderTarget.texture,
                            opacity: .5
                        });
                        this._planeMesh = new i.Mesh(new i.PlaneBufferGeometry(1,1),a),
                        this.initialize()
                    }
                    return Object.defineProperty(e.prototype, "scene", {
                        set: function(e) {
                            this.scene_ = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "planeMesh", {
                        get: function() {
                            return this._planeMesh
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "setSide", {
                        set: function(e) {
                            this._shadowBaker.setSide(Number(e))
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.updateShadows = function() {
                        this._shadowBaker.startBake(this.renderer, this.scene_, this.camera, this._shadowRenderTarget)
                    }
                    ,
                    e.prototype.initialize = function() {
                        var e = this;
                        this._planeMesh.castShadow = !1,
                        this._shadowBaker.onBeforeStart((function() {
                            var t = new i.Vector3
                              , n = new i.Quaternion
                              , r = new i.Vector3;
                            e._shadowBaker.getShadowPlaneTransform(t, n, r),
                            e._planeMesh.position.copy(t),
                            e._planeMesh.quaternion.copy(n),
                            e._planeMesh.scale.copy(r),
                            e._planeMesh.material.needsUpdate = !0,
                            e._planeMesh.updateMatrixWorld()
                        }
                        )),
                        this._shadowBaker.onComplete,
                        this._shadowBaker.onProgress((function(t) {
                            e._onUpdate()
                        }
                        ))
                    }
                    ,
                    Object.defineProperty(e.prototype, "config", {
                        get: function() {
                            return {
                                numSamples: this._shadowBaker.getNumSamples(),
                                numSamplesPerFrame: this._shadowBaker.getNumSamplesPerFrame(),
                                brightness: this._shadowBaker.getBrightness(),
                                enableSmooth: this._shadowBaker.getEnableSmooth(),
                                blurRadius: this._shadowBaker.getBlurRadius(),
                                falloff: this._shadowBaker.getFalloff(),
                                smoothTransition: this._shadowBaker.getSmoothTransition(),
                                side: this._shadowBaker.getSide(),
                                sharpness: this._shadowBaker.getLightSolidAngle()
                            }
                        },
                        set: function(e) {
                            this._shadowBaker.setNumSamples(e.numSamples),
                            this._shadowBaker.setNumSamplesPerFrame(e.numSamplesPerFrame),
                            void 0 !== e.size && this._shadowBaker.setSize(e.size),
                            this._shadowBaker.setBrightness(e.brightness),
                            this._shadowBaker.setBlurRadius(e.blurRadius),
                            this._shadowBaker.setFalloff(e.falloff),
                            this._shadowBaker.setSide(e.side),
                            this._shadowBaker.setSmoothTransition(e.smoothTransition),
                            this._shadowBaker.setEnableSmooth(e.enableSmooth),
                            void 0 !== e.sharpness && this._shadowBaker.setLightSolidAngle(e.sharpness),
                            this.updateShadows()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "onUpdate", {
                        set: function(e) {
                            this._onUpdate = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e
                }();
                t.GroundShadowsPlane = a
            }
            ,
            2104: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.ModelImporter = void 0;
                var r = n(2212)
                  , i = n(7047)
                  , a = n(8840)
                  , o = n(338)
                  , s = n(4506)
                  , l = function() {
                    function e(e) {
                        this._blobURLs = [],
                        this._loadingManager = null != e ? e : new r.LoadingManager
                    }
                    return e.isSupportedExtension = function(t) {
                        return e.Loaders.hasOwnProperty(t.toLowerCase())
                    }
                    ,
                    e.prototype.getLoaderInstance = function(t) {
                        return new (e.Loaders[t.toLowerCase()])(this._loadingManager)
                    }
                    ,
                    e.prototype.isDracoSupported = function(e) {
                        return "glb" === e.toLowerCase()
                    }
                    ,
                    e.prototype.import = function(t, n, r) {
                        var a, l = this;
                        void 0 === r && (r = {});
                        var c = this;
                        return r.assetMap && this.initializeAssetMapUrlModifier(t, r.assetMap, null !== (a = r.rootPath) && void 0 !== a ? a : ""),
                        new Promise((function(a, u) {
                            var h = r.extension || r.filename && s.parseFileExtension(r.filename) || s.parseFileExtension(t);
                            if (h && "" !== h.trim() || u(new Error("Unable to identify model extension, for blobs pass extension in options")),
                            e.isSupportedExtension(h)) {
                                var d = l.getLoaderInstance(h);
                                if (l.isDracoSupported(h)) {
                                    var p = new o.DRACOLoader;
                                    p.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.4.1/"),
                                    d.setDRACOLoader(p)
                                }
                                var f = function(e) {
                                    console.log(e),
                                    d instanceof i.GLTFLoader && (e = e.scene || e.scenes[0]),
                                    c.removeAssetMapUrlModifier(),
                                    e ? a(e) : u("No scene found in file")
                                };
                                console.log(t),
                                "function" == typeof d.load ? d.load(t, f, n, (function(e) {
                                    console.error(e)
                                }
                                )) : "function" == typeof d.loadAsync && d.loadAsync(t, n).then(f).catch(u)
                            } else
                                u("Not supported file extension: " + h)
                        }
                        ))
                    }
                    ,
                    Object.defineProperty(e.prototype, "loadingManager", {
                        get: function() {
                            return this._loadingManager
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.initializeAssetMapUrlModifier = function(e, t, n) {
                        var i = this;
                        void 0 === n && (n = "");
                        var a = r.LoaderUtils.extractUrlBase(e);
                        this._loadingManager.setURLModifier((function(e) {
                            var r = n + decodeURI(e).replace(a, "").replace(/^(\.?\/)/, "");
                            if (t.has(r)) {
                                var o = t.get(r)
                                  , s = URL.createObjectURL(o);
                                return i._blobURLs.push(s),
                                s
                            }
                            return e
                        }
                        ))
                    }
                    ,
                    e.prototype.removeAssetMapUrlModifier = function() {
                        this._loadingManager.setURLModifier((function(e) {
                            return e
                        }
                        )),
                        this._blobURLs.forEach(URL.revokeObjectURL),
                        this._blobURLs = []
                    }
                    ,
                    e.Loaders = {
                        gltf: i.GLTFLoader,
                        glb: i.GLTFLoader,
                        obj: a.OBJLoader,
                        drc: o.DRACOLoader
                    },
                    e
                }();
                t.ModelImporter = l
            }
            ,
            5318: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.SceneExporter = void 0;
                var r = n(2212)
                  , i = n(2509)
                  , a = function() {
                    function e() {}
                    return e.exportGltf = function(e, t, n) {
                        var a = new i.GLTFExporter
                          , o = {
                            includeCustomExtensions: !0,
                            embedImages: !1
                        };
                        return new Promise((function(n, i) {
                            var s = {};
                            t.forEach((function(e) {
                                var t = e.getMesh();
                                t.material && (s[t.id] = t.material,
                                t.material = new r.MeshStandardMaterial,
                                t.material.userData = s[t.id].userData,
                                t.material.name = s[t.id].name)
                            }
                            )),
                            a.parse(e, (function(e) {
                                if (t.forEach((function(e) {
                                    var t = e.getMesh();
                                    if (t.material) {
                                        var n = t.material;
                                        t.material = s[t.id],
                                        n.dispose()
                                    }
                                }
                                )),
                                e instanceof ArrayBuffer)
                                    ;
                                else {
                                    console.log("result"),
                                    console.log(e);
                                    var r = JSON.stringify(e, null, 4);
                                    n(r)
                                }
                            }
                            ), o)
                        }
                        ))
                    }
                    ,
                    e
                }();
                t.SceneExporter = a
            }
            ,
            7137: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.TextureExporter = void 0;
                var r = n(2212)
                  , i = r.MathUtils.isPowerOfTwo
                  , a = n(3992)
                  , o = function() {
                    function e() {
                        this.cachedData = new Map,
                        this.cachedCanvas = null
                    }
                    return e.prototype.exportTextures = function(e, t) {
                        for (var n = [], r = [], i = 0, a = e; i < a.length; i++) {
                            var o = a[i];
                            r.push(this.processTexture(o, n, t))
                        }
                        return {
                            textures: r,
                            images: n
                        }
                    }
                    ,
                    e.prototype.exportTexture = function(e, t) {
                        var n = this.exportTextures([e], t);
                        return {
                            texture: n.textures[0],
                            image: n.images[0]
                        }
                    }
                    ,
                    e.exportTexture = function(t, n) {
                        var r = new e
                          , i = r.exportTexture(t, n);
                        return r.dispose(),
                        i
                    }
                    ,
                    e.prototype.processTexture = function(t, n, r) {
                        var i = {
                            sampler: e.processSampler(t),
                            source: this.processImage(t.image, t.format, t.flipY, n, r),
                            name: "",
                            isTexture: !0
                        };
                        return t.name && (i.name = t.name),
                        i
                    }
                    ,
                    e.getSampler = function(t) {
                        return e.processSampler(t)
                    }
                    ,
                    e.setSampler = function(t, n) {
                        return e.applySampler(t, n)
                    }
                    ,
                    e.processSampler = function(t) {
                        return {
                            magFilter: e.THREE_TO_WEBGL.get(t.magFilter),
                            minFilter: e.THREE_TO_WEBGL.get(t.minFilter),
                            wrapU: e.THREE_TO_WEBGL.get(t.wrapS),
                            wrapV: e.THREE_TO_WEBGL.get(t.wrapT),
                            flipY: t.flipY,
                            encoding: t.encoding,
                            repeatU: t.repeat.x,
                            repeatV: t.repeat.y
                        }
                    }
                    ,
                    e.applySampler = function(t, n) {
                        var r = n;
                        t.wrapU && (r.wrapS = e.WEBGL_TO_THREE.get(+t.wrapU)),
                        t.wrapV && (r.wrapT = e.WEBGL_TO_THREE.get(+t.wrapV)),
                        t.minFilter && (r.minFilter = e.WEBGL_TO_THREE.get(+t.minFilter)),
                        t.magFilter && (r.magFilter = e.WEBGL_TO_THREE.get(+t.magFilter)),
                        void 0 !== t.flipY && (r.flipY = t.flipY),
                        t.encoding && (r.encoding = t.encoding),
                        void 0 !== t.repeatU && (r.repeat.x = +t.repeatU),
                        void 0 !== t.repeatV && (r.repeat.y = +t.repeatV),
                        r.needsUpdate = !0
                    }
                    ,
                    e.prototype.processImage = function(e, t, n, a, o) {
                        var s;
                        this.cachedData.has(e) || this.cachedData.set(e, {});
                        var l = this.cachedData.get(e)
                          , c = null !== (s = o.mimeType) && void 0 !== s ? s : t === r.RGBAFormat ? "image/png" : "image/jpeg"
                          , u = c + ":flipY/" + n.toString();
                        if (void 0 !== l[u])
                            return l[u];
                        var h, d = {
                            mimeType: c,
                            data: ""
                        };
                        if (o.embedImages) {
                            if (e instanceof HTMLCanvasElement)
                                h = e;
                            else {
                                var p = this.cachedCanvas = this.cachedCanvas || document.createElement("canvas");
                                o.maxTextureSize || (o.maxTextureSize = 1024),
                                p.width = Math.min(e.width, o.maxTextureSize),
                                p.height = Math.min(e.height, o.maxTextureSize),
                                !o.forcePowerOfTwoTextures || i(p.height) && i(p.width) || (console.warn("TextureExporter: Resized non-power-of-two image.", e),
                                p.width = r.MathUtils.floorPowerOfTwo(p.width),
                                p.height = r.MathUtils.floorPowerOfTwo(p.height)),
                                p.getContext("2d").drawImage(e, 0, 0, p.width, p.height),
                                h = p
                            }
                            d.data = h.toDataURL(c)
                        } else
                            e instanceof HTMLCanvasElement || (d.data = e.src);
                        a.push(d);
                        var f = a.length - 1;
                        return l[u] = f,
                        f
                    }
                    ,
                    e.importExported = function(t) {
                        return new Promise((function(n, r) {
                            (new a.TextureImporter).import(t.image.data, (function(e) {}
                            ), {
                                extension: t.image.mimeType
                            }).then((function(i) {
                                i && i.isTexture ? (e.applySampler(t.texture.sampler, i),
                                t.texture.name && (i.name = t.texture.name),
                                n(i)) : r("Unable to load")
                            }
                            )).catch(r)
                        }
                        ))
                    }
                    ,
                    e.prototype.dispose = function() {
                        var e;
                        this.cachedData.clear(),
                        null === (e = this.cachedCanvas) || void 0 === e || e.remove()
                    }
                    ,
                    e._constructor = function() {
                        e.THREE_TO_WEBGL.set(r.NearestFilter, e.WEBGL_CONSTANTS.NEAREST),
                        e.THREE_TO_WEBGL.set(r.NearestMipmapNearestFilter, e.WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST),
                        e.THREE_TO_WEBGL.set(r.NearestMipmapLinearFilter, e.WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR),
                        e.THREE_TO_WEBGL.set(r.LinearFilter, e.WEBGL_CONSTANTS.LINEAR),
                        e.THREE_TO_WEBGL.set(r.LinearMipmapNearestFilter, e.WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST),
                        e.THREE_TO_WEBGL.set(r.LinearMipmapLinearFilter, e.WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR),
                        e.THREE_TO_WEBGL.set(r.ClampToEdgeWrapping, e.WEBGL_CONSTANTS.CLAMP_TO_EDGE),
                        e.THREE_TO_WEBGL.set(r.RepeatWrapping, e.WEBGL_CONSTANTS.REPEAT),
                        e.THREE_TO_WEBGL.set(r.MirroredRepeatWrapping, e.WEBGL_CONSTANTS.MIRRORED_REPEAT),
                        e.THREE_TO_WEBGL.forEach((function(t, n) {
                            e.WEBGL_TO_THREE.set(t, n)
                        }
                        ))
                    }
                    ,
                    e.WEBGL_CONSTANTS = {
                        POINTS: 0,
                        LINES: 1,
                        LINE_LOOP: 2,
                        LINE_STRIP: 3,
                        TRIANGLES: 4,
                        TRIANGLE_STRIP: 5,
                        TRIANGLE_FAN: 6,
                        UNSIGNED_BYTE: 5121,
                        UNSIGNED_SHORT: 5123,
                        FLOAT: 5126,
                        UNSIGNED_INT: 5125,
                        ARRAY_BUFFER: 34962,
                        ELEMENT_ARRAY_BUFFER: 34963,
                        NEAREST: 9728,
                        LINEAR: 9729,
                        NEAREST_MIPMAP_NEAREST: 9984,
                        LINEAR_MIPMAP_NEAREST: 9985,
                        NEAREST_MIPMAP_LINEAR: 9986,
                        LINEAR_MIPMAP_LINEAR: 9987,
                        CLAMP_TO_EDGE: 33071,
                        MIRRORED_REPEAT: 33648,
                        REPEAT: 10497
                    },
                    e.THREE_TO_WEBGL = new Map,
                    e.WEBGL_TO_THREE = new Map,
                    e
                }();
                t.TextureExporter = o,
                o._constructor()
            }
            ,
            3992: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.TextureImporter = void 0;
                var r = n(2212)
                  , i = n(4506)
                  , a = n(5174)
                  , o = n(1377)
                  , s = n(1356)
                  , l = function() {
                    function e(e, t) {
                        this._loadingManager = null != t ? t : new r.LoadingManager
                    }
                    return e.isSupportedExtension = function(t) {
                        return e.Loaders.hasOwnProperty(t.toLowerCase())
                    }
                    ,
                    e.prototype.getLoaderInstance = function(t) {
                        return new (e.Loaders[t.toLowerCase()])(this._loadingManager)
                    }
                    ,
                    e.fileMapToCubeFileUrls = function(e, t) {
                        for (var n = [], r = function(r) {
                            if (e.forEach((function(e, i) {
                                (i.endsWith(r[0] + "." + t) || i.endsWith(r[1] + "." + t)) && n.push(e ? URL.createObjectURL(e) : i)
                            }
                            )),
                            6 === n.length)
                                return "break"
                        }, i = 0, a = [["px", "posx"], ["nx", "negx"], ["py", "posy"], ["ny", "negy"], ["pz", "posz"], ["nz", "negz"]]; i < a.length && "break" !== r(a[i]); i++)
                            ;
                        return n
                    }
                    ,
                    e.disposeFileUrls = function(e) {
                        return e.forEach((function(e) {
                            return URL.revokeObjectURL(e)
                        }
                        )),
                        e
                    }
                    ,
                    e.prototype.import = function(t, n, r) {
                        var a = this;
                        return void 0 === r && (r = {}),
                        new Promise((function(o, s) {
                            var l, c = r.extension || r.filename && i.parseFileExtension(r.filename) || i.parseFileExtension(Array.isArray(t) ? t.length > 0 ? t[0] : "" : t);
                            if (r.cubeMapFiles && r.cubeMapFiles.size >= 6 && ((t = e.fileMapToCubeFileUrls(r.cubeMapFiles, c)) || (t = [])),
                            Array.isArray(t)) {
                                if (6 !== t.length)
                                    return t && e.disposeFileUrls(t),
                                    void s("6 files required for cubemap");
                                c = "cube." + c
                            }
                            if (c && "" !== c.trim() || s(new Error("Unable to identify texture extension, for blobs pass extension in options")),
                            e.isSupportedExtension(c)) {
                                var u = a.getLoaderInstance(c);
                                u.setCrossOrigin(""),
                                u.setPath(null !== (l = r.loaderPath) && void 0 !== l ? l : "");
                                var h = function(n) {
                                    Array.isArray(t) && e.disposeFileUrls(t),
                                    o(n)
                                }
                                  , d = function(n) {
                                    Array.isArray(t) && e.disposeFileUrls(t),
                                    s(n)
                                };
                                "function" == typeof u.load ? u.load(t, h, n, d) : "function" == typeof u.loadAsync && u.loadAsync(t, n).then(h).catch(d)
                            } else
                                s("Not supported file extension: " + c)
                        }
                        ))
                    }
                    ,
                    Object.defineProperty(e.prototype, "loadingManager", {
                        get: function() {
                            return this._loadingManager
                        },
                        set: function(e) {
                            this._loadingManager = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.Loaders = {
                        "image/png": r.TextureLoader,
                        png: r.TextureLoader,
                        jpg: r.TextureLoader,
                        jpeg: r.TextureLoader,
                        "image/jpg": r.TextureLoader,
                        "image/jpeg": r.TextureLoader,
                        hdr: a.RGBELoader,
                        exr: o.EXRLoader,
                        "cube.png": r.CubeTextureLoader,
                        "cube.jpg": r.CubeTextureLoader,
                        "cube.jpeg": r.CubeTextureLoader,
                        "cube.hdr": s.HDRCubeTextureLoader
                    },
                    e
                }();
                t.TextureImporter = l
            }
            ,
            2732: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.BackgroundManager = void 0;
                var r = n(2212)
                  , i = n(1808)
                  , a = n(7137)
                  , o = function() {
                    function e(e, t, n) {
                        this._background = null,
                        this._backgroundOptions = {
                            color: !1,
                            preserveAspect: !1
                        },
                        this._viewer = e,
                        this._scene = t,
                        this._texturePass = new i.TexturePass(new r.Texture),
                        this._texturePass.clear = !1,
                        this._viewer.addPass(this._texturePass, 1),
                        this._texturePass.enabled = !1;
                        var a = this._texturePass.fsQuad;
                        this._imageMesh = a._mesh,
                        this.setupFsq(a),
                        this.setBackground(null != n ? n : this._background)
                    }
                    return e.prototype.setBackground = function(e, t) {
                        var n;
                        void 0 === t && (t = {}),
                        this._background = e,
                        this._backgroundOptions.preserveAspect = null !== (n = t.preserveAspect) && void 0 !== n && n,
                        this._backgroundOptions.color = e instanceof r.Color,
                        this._texturePass.enabled = this.isUsingPlaneBackground(),
                        this._texturePass.enabled && (e = null,
                        this._texturePass.map = this._background,
                        this.refreshSize()),
                        this._scene.background = e
                    }
                    ,
                    e.prototype.isUsingPlaneBackground = function() {
                        return !(this._backgroundOptions.color || !this._backgroundOptions.preserveAspect || !this._background)
                    }
                    ,
                    e.prototype.setupFsq = function(e) {
                        var t = new r.OrthographicCamera(-1,1,1,-1,0,1)
                          , n = new r.Scene;
                        n.add(this._imageMesh),
                        e.render = function(e) {
                            e.render(n, t)
                        }
                    }
                    ,
                    e.prototype.refreshSize = function() {
                        if (this.isUsingPlaneBackground()) {
                            var e = new r.Vector2;
                            this._viewer.renderer.getDrawingBufferSize(e);
                            var t = this._background
                              , n = e.x / e.y
                              , i = t.image.width / t.image.height;
                            this._imageMesh.scale.set(1, 1, 1);
                            var a = n / i;
                            a < 1 ? this._imageMesh.scale.x = 1 / a : this._imageMesh.scale.y = a
                        }
                    }
                    ,
                    Object.defineProperty(e.prototype, "background", {
                        get: function() {
                            return this._background
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "backgroundOptions", {
                        get: function() {
                            return this._backgroundOptions
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.toJson = function() {
                        return null == this.background ? {} : {
                            value: this._backgroundOptions.color ? "#" + this.background.getHexString() : a.TextureExporter.exportTexture(this.background, {
                                embedImages: !0,
                                maxTextureSize: 2048
                            }),
                            options: this._backgroundOptions
                        }
                    }
                    ,
                    e.prototype.copyFromJson = function(e) {
                        var t, n = this;
                        if (null == e ? void 0 : e.value) {
                            var i = function(t) {
                                return n.setBackground(t, e.options)
                            };
                            (null === (t = e.options) || void 0 === t ? void 0 : t.color) ? i(new r.Color(e.value)) : a.TextureExporter.importExported(e.value).then(i)
                        }
                    }
                    ,
                    e
                }();
                t.BackgroundManager = o
            }
            ,
            7717: function(e, t, n) {
                "use strict";
                var r = this && this.__spreadArrays || function() {
                    for (var e = 0, t = 0, n = arguments.length; t < n; t++)
                        e += arguments[t].length;
                    var r = Array(e)
                      , i = 0;
                    for (t = 0; t < n; t++)
                        for (var a = arguments[t], o = 0, s = a.length; o < s; o++,
                        i++)
                            r[i] = a[o];
                    return r
                }
                ;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.SceneManager = void 0;
                var i = n(2212)
                  , a = n(2886)
                  , o = n(2732)
                  , s = n(6426)
                  , l = n(8442)
                  , c = n(57)
                  , u = n(3372)
                  , h = n(5318)
                  , d = n(7137)
                  , p = n(2088)
                  , f = n(5377)
                  , m = n(5157)
                  , g = n(9230)
                  , v = n(4796)
                  , y = function() {
                    function e(e, t) {
                        var n = this;
                        this.needsUpdate = !1,
                        this._controls = null,
                        this._imageBasedLighting = !1,
                        this._originalEnvMap = null,
                        this._diamonds = {},
                        this._materials = [],
                        this._diamondTextureEnvMap = null,
                        this._pixelRatio = 1,
                        this._taaEnabled = !0,
                        this.currentShadowPos = 2,
                        this._dofTransitionDelta = .04,
                        this._focusPoint = new i.Vector3,
                        this.spotLightShadowMapViewer = null,
                        this.dirLight = null,
                        this.dirLight2 = null,
                        this.maxModelWidth = 0,
                        this.maxModelHeight = 0,
                        this.maxModelZ = 0,
                        this.mesh = null,
                        this.lightHolder = null,
                        this.lightHolder2 = null,
                        this.meshHolder = null,
                        this._diamondMetrics = {},
                        this.currentLoadedData = {},
                        this.loadedBandObj = [],
                        this.loadedModelsDetails = {
                            shank: "",
                            head: "",
                            band: ""
                        },
                        this.isHandOn = !1,
                        this._cameraState = {
                            fixed: !0,
                            lastPosition: new i.Vector3,
                            time: 0,
                            onStart: function() {
                                n._viewer.enableSupersample = !1,
                                n._controls && (n._controls.enableDamping = !0),
                                n.enableTAA_(!0),
                                n.setDirty();
                                var e = n._camera.position.y;
                                if (n._controls) {
                                    if (i.MathUtils.radToDeg(n._controls.getAzimuthalAngle()) > 50 && i.MathUtils.radToDeg(n._controls.getPolarAngle()) > 102)
                                        return n._groundShadows.setSide = 3,
                                        n._groundShadows.updateShadows();
                                    if (i.MathUtils.radToDeg(n._controls.getAzimuthalAngle()) < -50 && i.MathUtils.radToDeg(n._controls.getPolarAngle()) > 102)
                                        return n._groundShadows.setSide = 4,
                                        n._groundShadows.updateShadows();
                                    e < 0 ? (n._groundShadows.setSide = 6,
                                    n._groundShadows.updateShadows()) : (n._groundShadows.setSide = 2,
                                    n._groundShadows.updateShadows())
                                }
                            },
                            onStop: function() {
                                n._viewer.enableSupersample = !0,
                                n._controls && (n._controls.enableDamping = !1),
                                n.enableTAA_(!1),
                                n.setDirty();
                                var e = n._camera.position.y;
                                if (n._controls) {
                                    if (i.MathUtils.radToDeg(n._controls.getAzimuthalAngle()) > 50 && i.MathUtils.radToDeg(n._controls.getPolarAngle()) > 102)
                                        return n._groundShadows.setSide = 3,
                                        n._groundShadows.updateShadows();
                                    if (i.MathUtils.radToDeg(n._controls.getAzimuthalAngle()) < -50 && i.MathUtils.radToDeg(n._controls.getPolarAngle()) > 102)
                                        return n._groundShadows.setSide = 4,
                                        n._groundShadows.updateShadows();
                                    e < 0 ? (n._groundShadows.setSide = 6,
                                    n._groundShadows.updateShadows()) : (n._groundShadows.setSide = 2,
                                    n._groundShadows.updateShadows())
                                }
                            }
                        },
                        this._scene = new i.Scene,
                        this._viewer = e,
                        this._gemConfig = t,
                        this._mainContainer = new i.Object3D,
                        this._mainContainer.position.set(0, 0, 0),
                        this.maxModelWidth = 0,
                        this.maxModelHeight = 0,
                        this.maxModelZ = 0;
                        var r = new i.Vector2;
                        this._viewer.renderer.getDrawingBufferSize(r),
                        this._camera = new i.PerspectiveCamera(30,r.width / r.height,.05,50),
                        this._diamondMetrics = JSON.parse('[{"diamond":{"gFactor":0.29,"color":16777215,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"round":{"gFactor":0.29,"color":16777215,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"cushion":{"gFactor":0.26,"color":16777215,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"emerald":{"color":16777215,"gFactor":0.19,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"pear":{"color":16777215,"gFactor":0.29,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"oval":{"color":16777215,"gFactor":0.29,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"princess":{"color":16777215,"gFactor":0.22,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1.3,"absFactor":1,"gammaFactor":1},"marquise":{"color":16777215,"gFactor":0.22,"boostFactorX":2.3,"boostFactorY":2.3,"boostFactorZ":2.5,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"heart":{"color":16777215,"gFactor":0.2,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"asscher":{"color":16777215,"gFactor":0.22,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1.3,"absFactor":1,"gammaFactor":1},"radiant":{"color":16777215,"gFactor":0.19,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1},"baguette":{"color":16777215,"gFactor":0.17,"boostFactorX":2.4,"boostFactorY":2.4,"boostFactorZ":2.6,"envMapIntensity":2.2,"refractiveIndex":2.4,"rIndex":0,"squashFactor":1,"absFactor":1,"gammaFactor":1}}]')[0] || {},
                        this._mainContainer.add(this._camera),
                        this._objectContainer = new i.Object3D,
                        this._mainContainer.add(this._objectContainer),
                        this._scene.add(this._mainContainer),
                        this.dirLight = new i.DirectionalLight(16777215,1),
                        this.dirLight.name = "Dir. Light",
                        this.dirLight.position.set(0, -7, 3.5),
                        this.dirLight.castShadow = !0,
                        this.dirLight.shadow.camera.near = 1,
                        this.dirLight.shadow.camera.far = 10,
                        this.dirLight.shadow.camera.right = 15,
                        this.dirLight.shadow.camera.left = -15,
                        this.dirLight.shadow.camera.top = 15,
                        this.dirLight.shadow.camera.bottom = -15,
                        this._ssrPass = new f.SSRPass(this._scene,this._camera),
                        this._pmremGenerator = new i.PMREMGenerator(e.renderer),
                        this._pmremGenerator.compileEquirectangularShader(),
                        this._backgroundManager = new o.BackgroundManager(this._viewer,this._scene),
                        this.initOrbitControls(),
                        this._renderPass = new s.RenderPass(this._scene,this._camera),
                        this._renderPass.clear = !1,
                        this._renderPass.clearDepth = !0,
                        this._viewer.addPass(this._renderPass, 2),
                        this._outlinePass = new p.OutlinePass(new i.Vector2(r.width,r.height),this.scene,this.camera),
                        this._viewer.addPass(this._outlinePass, 5),
                        this._taaPass = new m.TAAPass(this.camera,this._viewer.gbufferPass),
                        this._taaPass.setFeedbackMinMax(new i.Vector2(.7,.8)),
                        this._viewer.addPass(this._taaPass, 6),
                        this._raycaster = new i.Raycaster,
                        this._groundShadows = new c.GroundShadowsPlane(this._viewer.renderer,this._scene,this._camera),
                        this._groundShadows.planeMesh.position.set(0, 10, 3.5),
                        this._groundShadows.onUpdate = function() {
                            return n.setDirty()
                        }
                        ,
                        this._viewer.addPass(this._ssrPass, 7);
                        var a = new i.HemisphereLight(16777215,4473924);
                        a.position.set(0, 20, 0),
                        this._scene.add(a),
                        this.dirLight = new i.DirectionalLight(16777215),
                        this.dirLight.position.set(0, 8, -1.5),
                        this.dirLight.castShadow = !0,
                        this.dirLight.shadow.camera.top = 2,
                        this.dirLight.shadow.camera.bottom = -2,
                        this.dirLight.shadow.camera.left = -2,
                        this.dirLight.shadow.camera.right = 2,
                        this.dirLight.shadow.camera.near = .1,
                        this.dirLight.shadow.camera.far = 40,
                        this.dirLight2 = new i.DirectionalLight(16777215),
                        this.dirLight2.position.set(-20, 8, -1.5),
                        this.dirLight2.castShadow = !0,
                        this.dirLight2.shadow.camera.top = 2,
                        this.dirLight2.shadow.camera.bottom = -2,
                        this.dirLight2.shadow.camera.left = -2,
                        this.dirLight2.shadow.camera.right = 2,
                        this.dirLight2.shadow.camera.near = .1,
                        this.dirLight2.shadow.camera.far = 40,
                        this.lightHolder = new i.Group,
                        this.lightHolder2 = new i.Group,
                        this.lightHolder.add(this.dirLight),
                        this.lightHolder2.add(this.dirLight2),
                        this._scene.add(this.lightHolder);
                        var l = new i.MeshDepthMaterial;
                        l.userData.darkness = {
                            value: 1
                        },
                        l.onBeforeCompile = function(e) {
                            e.uniforms.darkness = l.userData.darkness,
                            e.fragmentShader = "\n\t\t\t\t\t\tuniform float darkness;\n\t\t\t\t\t\t" + e.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );") + "\n\t\t\t\t\t"
                        }
                        ,
                        l.depthTest = !1,
                        l.depthWrite = !1,
                        this.mesh = new i.Mesh(new i.PlaneGeometry(3,3),new i.MeshPhongMaterial({
                            depthWrite: !1,
                            color: 10066329,
                            transparent: !0
                        })),
                        this.mesh.rotation.x = -Math.PI / 2,
                        this.mesh.receiveShadow = !0,
                        this.mesh.position.y = -.017,
                        this.mesh.material.opacity = .15,
                        this.meshHolder = new i.Group,
                        this.meshHolder.add(this.mesh),
                        this.clearAll()
                    }
                    return Object.defineProperty(e.prototype, "enableTAA", {
                        get: function() {
                            return this._taaEnabled
                        },
                        set: function(e) {
                            this._taaEnabled = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.enableTAA_ = function(e) {
                        this._taaPass && (this._taaEnabled && e ? this._taaPass.enabled = !0 : this._taaPass.enabled = !1)
                    }
                    ,
                    e.prototype.setDirty = function() {
                        var e;
                        this._ssrPass && (null === (e = this._ssrPass) || void 0 === e || e.reset()),
                        this.onDirtyCallback_ && this.onDirtyCallback_(),
                        this.enableTAA_(!0)
                    }
                    ,
                    e.prototype.updateLoadedModelDetails = function(e, t, n) {
                        e && (this.loadedModelsDetails.head = e),
                        t && (this.loadedModelsDetails.shank = t),
                        n && (this.loadedModelsDetails.band = n),
                        "OFF" === n && (this.loadedModelsDetails.band = null)
                    }
                    ,
                    Object.defineProperty(e.prototype, "ssrParams", {
                        get: function() {
                            var e, t;
                            return {
                                enabled: this._ssrPass.enabled,
                                intensity: null !== (t = null === (e = this._ssrPass.uniforms.ssReflectivity) || void 0 === e ? void 0 : e.value) && void 0 !== t ? t : 1
                            }
                        },
                        set: function(e) {
                            void 0 !== e.enabled && (this._ssrPass.enabled = e.enabled),
                            void 0 !== e.intensity && (this._ssrPass.uniforms.ssReflectivity.value = e.intensity),
                            e !== {} && this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "outlineParams", {
                        get: function() {
                            return {
                                visibleEdgeColor: this._outlinePass.visibleEdgeColor,
                                hiddenEdgeColor: this._outlinePass.hiddenEdgeColor,
                                edgeGlow: this._outlinePass.edgeGlow,
                                usePatternTexture: this._outlinePass.usePatternTexture,
                                edgeThickness: this._outlinePass.edgeThickness,
                                edgeStrength: this._outlinePass.edgeStrength,
                                downSampleRatio: this._outlinePass.downSampleRatio,
                                pulsePeriod: this._outlinePass.pulsePeriod,
                                patternTexture: this._outlinePass.patternTexture
                            }
                        },
                        set: function(e) {
                            e.visibleEdgeColor && (this._outlinePass.visibleEdgeColor = e.visibleEdgeColor),
                            e.hiddenEdgeColor && (this._outlinePass.hiddenEdgeColor = e.hiddenEdgeColor),
                            e.edgeGlow && (this._outlinePass.edgeGlow = e.edgeGlow),
                            e.usePatternTexture && (this._outlinePass.usePatternTexture = e.usePatternTexture),
                            e.edgeThickness && (this._outlinePass.edgeThickness = e.edgeThickness),
                            e.edgeStrength && (this._outlinePass.edgeStrength = e.edgeStrength),
                            e.downSampleRatio && (this._outlinePass.downSampleRatio = e.downSampleRatio),
                            e.pulsePeriod && (this._outlinePass.pulsePeriod = e.pulsePeriod),
                            e.patternTexture && (this._outlinePass.patternTexture = e.patternTexture),
                            this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.setSize = function(e, t) {
                        this._camera.aspect = e / t,
                        this._camera.updateProjectionMatrix(),
                        this._backgroundManager.refreshSize(),
                        this._viewer.renderer.getPixelRatio(),
                        this._outlinePass.resolution.x = window.innerWidth,
                        this._outlinePass.resolution.y = window.innerHeight
                    }
                    ,
                    e.prototype.highlightObjects = function() {
                        for (var e = [], t = 0; t < arguments.length; t++)
                            e[t] = arguments[t];
                        this._outlinePass.selectedObjects = e,
                        this.setDirty()
                    }
                    ,
                    e.prototype.pickObject = function(e) {
                        this._raycaster.setFromCamera(e, this._camera);
                        for (var t = this._raycaster.intersectObject(this._scene, !0), n = 0; n < t.length; n++)
                            if (this.isSceneObject(t[n].object))
                                return t[n].object;
                        return null
                    }
                    ,
                    e.prototype.pickObjectByNameOrId = function(e) {
                        return ("string" == typeof e ? this._scene.getObjectByName(e) : this._scene.getObjectById(e)) || null
                    }
                    ,
                    Object.defineProperty(e.prototype, "pixelRatio", {
                        get: function() {
                            return this._pixelRatio
                        },
                        set: function(e) {
                            this._pixelRatio = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "groundShadows", {
                        get: function() {
                            return this._groundShadows
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.isSceneObject = function(e) {
                        var t = e.parent;
                        return !!t && (t === this._objectContainer || this.isSceneObject(t))
                    }
                    ,
                    e.prototype.updateDiamondMetrics = function(e) {
                        var t = this;
                        e && e.forEach((function(e, n) {
                            var r, a = e.getMesh().name, o = void 0 === a ? "" : a, s = e.getMesh().material.uniforms;
                            o.toUpperCase().includes("CUSHION") ? (r = t._diamondMetrics.cushion,
                            console.log("CUSHION")) : o.toUpperCase().includes("ROUND") ? r = t._diamondMetrics.diamond : o.toUpperCase().includes("PRINCES") ? r = t._diamondMetrics.princess : o.toUpperCase().includes("PEAR") ? r = t._diamondMetrics.pear : o.toUpperCase().includes("OVAL") ? r = t._diamondMetrics.oval : o.toUpperCase().includes("MARQUISE") ? r = t._diamondMetrics.marquise : o.toUpperCase().includes("EMERALD") ? r = t._diamondMetrics.emerald : o.toUpperCase().includes("BAGUETTE") ? (r = t._diamondMetrics.baguette,
                            console.log("BAGUETTE")) : r = o.toUpperCase().includes("HEART") ? t._diamondMetrics.heart : o.toUpperCase().includes("ASSCHER") ? t._diamondMetrics.asscher : o.toUpperCase().includes("RADIANT") ? t._diamondMetrics.radiant : t._diamondMetrics.diamond,
                            s.geometryFactor.value = r.gFactor,
                            s.colorCorrection.value = new i.Color(r.color);
                            var l = s.boostFactors.value;
                            l.x = r.boostFactorX,
                            l.y = r.boostFactorY,
                            l.z = r.boostFactorZ,
                            s.envMapIntensity.value = r.envMapIntensity,
                            s.refractiveIndex.value = r.refractiveIndex,
                            s.rIndexDelta.value = r.rIndex,
                            s.squashFactor.value = r.squashFactor,
                            s.absorbptionFactor.value = r.absFactor,
                            s.gammaFactor.value = r.gammaFactor;
                            var c = t.cameraParams;
                            t.cameraParams = c
                        }
                        ))
                    }
                    ,
                    e.prototype.addShadow = function() {}
                    ,
                    e.prototype.add = function(e, t, n, a) {
                        var o = this
                          , s = this.initializeDiamonds(e);
                        console.log(n, "jewelType"),
                        l.Object3DUtility.ssrPass = this._ssrPass,
                        [e].forEach(l.Object3DUtility.processImportedObject),
                        l.Object3DUtility.ssrPass = null,
                        console.log(this.currentLoadedData, n, "this.currentLoadedData"),
                        n && n.includes("BAND") ? (console.log(this.currentLoadedData, "this.currentLoadedData"),
                        this.currentLoadedData.BAND ? (this.currentLoadedData.OLD_BAND = r(this.currentLoadedData.BAND),
                        this.currentLoadedData.BAND = [e.id]) : this.currentLoadedData.BAND = [e.id],
                        console.log(this.currentLoadedData.OLD_BAND, this.currentLoadedData.BAND, e, "band de-bug", this.loadedModelsDetails),
                        this.loadedBandObj = [e]) : n && n.includes("HAND") ? this.currentLoadedData.HAND ? (this.currentLoadedData.OLD_HAND = r(this.currentLoadedData.HAND),
                        this.currentLoadedData.HAND = [e.id]) : this.currentLoadedData.HAND = [e.id] : n && n.forEach((function(t) {
                            o.currentLoadedData[t] ? (o.currentLoadedData["OLD_" + t] = o.currentLoadedData[t],
                            o.currentLoadedData[t] = e.id) : o.currentLoadedData[t] = e.id
                        }
                        )),
                        console.log(this.currentLoadedData, "this.currentLoadedData"),
                        this._objectContainer.add.apply(this._objectContainer, [e]);
                        var c = [];
                        return this.sceneObjectsUpdated(),
                        this.updateDiamondMetrics(s),
                        e.traverse((function(e) {
                            if (e.isMesh) {
                                var n = e.geometry;
                                n.computeBoundingBox();
                                var r = n.boundingBox
                                  , a = r.max.x - r.min.x
                                  , s = r.max.y - r.min.y
                                  , l = r.max.z - r.min.z;
                                a > o.maxModelWidth && (o.maxModelWidth = a),
                                s > o.maxModelHeight && (o.maxModelHeight = s),
                                l > o.maxModelZ && (o.maxModelZ = l),
                                -1 !== e.name.toUpperCase().search("METAL") && (e.material.color = new i.Color(t.color),
                                e.material.envMapIntensity = t.envMapIntensity,
                                e.material.emissiveIntensity = 1,
                                e.material.metalness = 1,
                                e.material.roughness = .08,
                                c.push(e),
                                o._materials.push(e))
                            }
                        }
                        )),
                        {
                            diamonds: s,
                            materials: c
                        }
                    }
                    ,
                    e.prototype.remove = function(e) {
                        this._diamonds[e.id] && delete this._diamonds[e.id],
                        this._objectContainer.remove.apply(this._objectContainer, [e]),
                        this.sceneObjectsUpdated()
                    }
                    ,
                    e.prototype.clearAll = function(e) {
                        var t = this
                          , n = [];
                        this._objectContainer.traverse((function(e) {
                            e != t._objectContainer && n.push(e)
                        }
                        )),
                        n.forEach((function(e) {
                            t.remove(e),
                            console.log(e),
                            e && l.Object3DUtility.fullyDisposeObject(e)
                        }
                        )),
                        this._diamonds = [],
                        this._objectContainer.rotation.set(0, 0, 0),
                        !e && this.resetCamera()
                    }
                    ,
                    e.prototype.addBand = function() {
                        this.loadedBandObj && (this._objectContainer.add.apply(this._objectContainer, this.loadedBandObj),
                        this.sceneObjectsUpdated())
                    }
                    ,
                    e.prototype.getHeadPosition = function() {
                        var e = this.currentLoadedData.HEAD
                          , t = this._objectContainer.getObjectById(e)
                          , n = t;
                        if (this._controls && n) {
                            var r = (new i.Box3).setFromObject(n);
                            r.getSize(new i.Vector3).length(),
                            r.getCenter(new i.Vector3),
                            this._controls.minDistance = .5,
                            (new i.Box3).expandByObject(n).getCenter(this._controls.target),
                            this._controls.update()
                        }
                        console.log(t)
                    }
                    ,
                    e.prototype.removeSpecificObject = function(e, t) {
                        var n = this
                          , r = this.currentLoadedData["OLD_" + e]
                          , i = this.currentLoadedData["" + e];
                        console.log(r, i, "band de-bug");
                        var a, o = void 0 !== r ? r : i;
                        if (o && (Array.isArray(o) ? (a = [],
                        o.forEach((function(e) {
                            var t = n._objectContainer.getObjectById(e);
                            a.push(t)
                        }
                        ))) : a = [this._objectContainer.getObjectById(o)],
                        a && (console.log(o, a, "jewelType", "band de-bug"),
                        Array.isArray(a) ? (this._objectContainer.remove.apply(this._objectContainer, a),
                        a.forEach((function(e) {
                            e && l.Object3DUtility.fullyDisposeObject(e),
                            console.log(r, e, "removed model objs", "band de-bug")
                        }
                        ))) : a && (this._objectContainer.remove.apply(this._objectContainer, a),
                        l.Object3DUtility.fullyDisposeObject(a)),
                        "BAND" !== e && "HAND" !== e ? this.currentLoadedData["OLD_" + e] = void 0 : (this.currentLoadedData["OLD_" + e] = void 0,
                        "OFF" === t && (this.currentLoadedData["" + e] = void 0)),
                        console.log(e, this.currentLoadedData, "band de-bugs"),
                        "HAND" === e ? (this.mesh.material.opacity = .2,
                        this.dirLight.intensity = 1,
                        this._controls && (this._controls.minDistance = 3,
                        this._controls.maxDistance = 3.5),
                        this.sceneObjectsUpdated(),
                        this.fixRemoveHandTarget()) : (this.fixOrbitTarget(),
                        this._groundShadows.updateShadows(),
                        this.setDirty()),
                        "OFF" === t))) {
                            var s = document.getElementById("loading-overlay");
                            s && (s.style.display = "none")
                        }
                    }
                    ,
                    e.prototype.resetCamera = function() {
                        var e;
                        this.resetCameraView(),
                        this._camera.lookAt(0, 0, 0),
                        null === (e = this._controls) || void 0 === e || e.update()
                    }
                    ,
                    e.prototype.resetCameraView = function(e, t) {
                        void 0 === e && (e = "z"),
                        void 0 === t && (t = !0),
                        new i.Vector3("x" === e ? 1 : 0,"y" === e ? 1 : 0,"z" === e ? 1 : 0).multiplyScalar(3 * (t ? 1 : -1)),
                        this._camera.position.copy(new i.Vector3(.07082812496547643,1.6961998861110053,4.783653987301882))
                    }
                    ,
                    e.prototype.sceneObjectsUpdated = function() {
                        this.refreshObjectContainerScale(),
                        this.fixOrbitTarget(),
                        this._groundShadows.updateShadows(),
                        this.setDirty(),
                        this.isHandOn && this.fixHandModelTarget()
                    }
                    ,
                    e.prototype.getBoundingBox = function() {
                        return (new i.Box3).expandByObject(this._objectContainer)
                    }
                    ,
                    e.prototype.getBoundingSphere = function() {
                        return this.getBoundingBox().getBoundingSphere(new i.Sphere)
                    }
                    ,
                    e.prototype.getBoundingRadius = function() {
                        return this.getBoundingSphere().radius
                    }
                    ,
                    e.prototype.refreshObjectContainerScale = function() {
                        this._objectContainer.scale.set(1, 1, 1),
                        this._objectContainer.scale.multiplyScalar(1 / this.getBoundingRadius())
                    }
                    ,
                    Object.defineProperty(e.prototype, "cameraParams", {
                        get: function() {
                            var e = {
                                mode: this._controls ? "orbit" : "fixed",
                                fov: this._camera.fov,
                                position: this._camera.position,
                                scale: this._camera.scale,
                                zoom: this._camera.zoom
                            };
                            return this._controls && (e.orbitParams = {
                                minDistance: this._controls.minDistance,
                                maxDistance: this._controls.maxDistance,
                                minAzimuthAngle: this._controls.minAzimuthAngle,
                                maxAzimuthAngle: this._controls.maxAzimuthAngle,
                                minPolarAngle: this._controls.minPolarAngle,
                                maxPolarAngle: this._controls.maxPolarAngle,
                                minZoom: this._controls.minZoom,
                                maxZoom: this._controls.maxZoom,
                                dampingFactor: this._controls.dampingFactor,
                                autoRotate: this._controls.autoRotate,
                                autoRotateSpeed: this._controls.autoRotateSpeed
                            }),
                            e
                        },
                        set: function(e) {
                            var t, n, r, i, a, o, s, l, c, u, h, d, p, f;
                            switch (e.mode) {
                            case "fixed":
                                null === (t = this._controls) || void 0 === t || t.dispose(),
                                this._controls = null;
                                break;
                            case "orbit":
                                this.initOrbitControls()
                            }
                            null === (n = e.position) || void 0 === n || n.copy(this._camera.position),
                            null === (r = e.scale) || void 0 === r || r.copy(this._camera.scale),
                            e.target && this._camera.lookAt(e.target),
                            e.zoom && (this._camera.zoom = e.zoom,
                            this._camera.updateProjectionMatrix()),
                            e.fov && (this._camera.fov = e.fov,
                            this._camera.updateProjectionMatrix()),
                            e.orbitParams && this._controls && (this._controls.minDistance = null !== (i = e.orbitParams.minDistance) && void 0 !== i ? i : this._controls.minDistance,
                            this._controls.maxDistance = null !== (a = e.orbitParams.maxDistance) && void 0 !== a ? a : this._controls.maxDistance,
                            this._controls.minAzimuthAngle = null !== (o = e.orbitParams.minAzimuthAngle) && void 0 !== o ? o : this._controls.minAzimuthAngle,
                            this._controls.minAzimuthAngle = null !== (s = e.orbitParams.minAzimuthAngle) && void 0 !== s ? s : this._controls.minAzimuthAngle,
                            this._controls.minPolarAngle = null !== (l = e.orbitParams.minPolarAngle) && void 0 !== l ? l : this._controls.minPolarAngle,
                            this._controls.maxPolarAngle = null !== (c = e.orbitParams.maxPolarAngle) && void 0 !== c ? c : this._controls.maxPolarAngle,
                            this._controls.minZoom = null !== (u = e.orbitParams.minZoom) && void 0 !== u ? u : this._controls.minZoom,
                            this._controls.maxZoom = null !== (h = e.orbitParams.maxZoom) && void 0 !== h ? h : this._controls.maxZoom,
                            this._controls.dampingFactor = null !== (d = e.orbitParams.dampingFactor) && void 0 !== d ? d : this._controls.dampingFactor,
                            this._controls.autoRotate = null !== (p = e.orbitParams.autoRotate) && void 0 !== p ? p : this._controls.autoRotate,
                            this._controls.autoRotateSpeed = null !== (f = e.orbitParams.autoRotateSpeed) && void 0 !== f ? f : this._controls.autoRotateSpeed,
                            this._controls.update()),
                            this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.initOrbitControls = function() {
                        var e = this;
                        this._controls || (this._controls = new a.OrbitControls(this.camera,this._viewer.renderer.domElement),
                        this._controls.addEventListener("change", (function() {
                            return e.setDirty()
                        }
                        )),
                        this._controls.minDistance = 3,
                        this._controls.maxDistance = 3.5,
                        this._controls.dampingFactor = .1,
                        this._controls.minPolarAngle = 1),
                        this.fixOrbitTarget()
                    }
                    ,
                    Object.defineProperty(e.prototype, "camera", {
                        get: function() {
                            return this._camera
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "scene", {
                        get: function() {
                            return this._scene
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.rotateAround = function(e, t, n, r) {
                        var i = this;
                        void 0 === r && (r = !1),
                        console.log(v.RotationHelper),
                        v.RotationHelper.rotateObject(r ? this._camera : this._objectContainer, t, e, n, !0, (function() {
                            var e;
                            i.setDirty(),
                            r && (null === (e = i._controls) || void 0 === e || e.update())
                        }
                        ), r, (function() {
                            i._groundShadows.updateShadows()
                        }
                        ))
                    }
                    ,
                    e.prototype.resetRotation = function(e, t) {
                        var n = this;
                        void 0 === t && (t = !1);
                        var r = (new i.Quaternion).setFromEuler(new i.Euler(0,0,0));
                        v.RotationHelper.lerpRotateObject(t ? this._camera : this._objectContainer, r, e, (function() {
                            var e;
                            n.setDirty(),
                            t && (null === (e = n._controls) || void 0 === e || e.update())
                        }
                        )).onComplete((function(e) {
                            n._groundShadows.updateShadows()
                        }
                        ))
                    }
                    ,
                    Object.defineProperty(e.prototype, "orientation", {
                        get: function() {
                            return this._mainContainer.rotation.toVector3()
                        },
                        set: function(e) {
                            this._mainContainer.rotation.setFromVector3(e),
                            this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "background", {
                        get: function() {
                            return this._backgroundManager.background
                        },
                        set: function(e) {
                            this._backgroundManager.setBackground(e, {
                                preserveAspect: e instanceof i.Texture
                            }),
                            this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "environment", {
                        get: function() {
                            return this._scene.environment
                        },
                        set: function(e) {
                            this._scene.environment = e,
                            u.DiamondMaterialUtility.refreshDiamondsEnvMap(Object.values(this._diamonds), this._diamondTextureEnvMap),
                            this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.setSceneEnvironment = function(e, t) {
                        if (t.imageBasedLighting) {
                            var n = e;
                            e.isCubeTexture ? (e = this._pmremGenerator.fromCubemap(e).texture,
                            this._diamondTextureEnvMap = n) : (e = this._pmremGenerator.fromEquirectangular(e).texture,
                            this._diamondTextureEnvMap = n),
                            this._imageBasedLighting = !0,
                            this._originalEnvMap = n
                        }
                        t.setBackground && this._backgroundManager.setBackground(e),
                        this.environment = e,
                        this.setDirty()
                    }
                    ,
                    e.prototype.fixHandModelTarget = function() {
                        var e = this.currentLoadedData.HEAD
                          , t = this._objectContainer.getObjectById(e);
                        this._controls && t && (this._controls.minDistance = .5,
                        this._controls.maxDistance = 2.25,
                        (new i.Box3).expandByObject(t).getCenter(this._controls.target),
                        this._controls.update())
                    }
                    ,
                    e.prototype.fixRemoveHandTarget = function() {
                        var e = this.scene;
                        this.isHandOn = !1,
                        this._controls && e && (this._controls.minDistance = 3,
                        this._controls.maxDistance = 3.5,
                        (new i.Box3).expandByObject(e).getCenter(this._controls.target),
                        this.resetCameraView(),
                        this._controls.update())
                    }
                    ,
                    e.prototype.fixOrbitTarget = function() {
                        this._controls && (this.getBoundingBox().getCenter(this._controls.target),
                        this._controls.update(),
                        this.isHandOn && this.fixHandModelTarget())
                    }
                    ,
                    e.prototype.updateCameraState = function(e) {
                        if (!(e <= this._cameraState.time)) {
                            this._cameraState.time = e;
                            var t = this._camera.position.manhattanDistanceTo(this._cameraState.lastPosition) < 1e-4;
                            if (!1 === t && !1 === this._cameraState.fixed) {
                                var n = document.getElementById("helper-popup");
                                n && (n.style.display = "none")
                            }
                            this._cameraState.fixed != t && (t ? this._cameraState.onStop() : this._cameraState.onStart()),
                            t || this.setDirty(),
                            this._cameraState.fixed = t,
                            this._cameraState.lastPosition.copy(this._camera.position)
                        }
                    }
                    ,
                    e.prototype.preRender = function() {
                        if (this.updateCameraState(Date.now()),
                        this._ssrPass) {
                            var e = this._viewer.gbufferPass.getNormalDepthTexture();
                            this._ssrPass.setNormalDepth(e);
                            var t = this.getBoundingSphere()
                              , n = this._camera.position.distanceTo(t.center);
                            this._ssrPass.objectBounds = new i.Vector2(n,t.radius),
                            this._ssrPass.updateUniforms()
                        }
                    }
                    ,
                    e.prototype.postRender = function() {
                        var e, t, n;
                        this._camera.clearViewOffset(),
                        ((null === (e = this._controls) || void 0 === e ? void 0 : e.enableDamping) || (null === (t = this._controls) || void 0 === t ? void 0 : t.autoRotate)) && (null === (n = this._controls) || void 0 === n || n.update()),
                        this.lightHolder.quaternion.copy(this._camera.quaternion)
                    }
                    ,
                    e.prototype.initializeDiamonds = function(e) {
                        var t = u.DiamondMaterialUtility.makeMaterialUserDataMap(e)
                          , n = g.DiamondUtils.processScene(this._viewer.renderer, e, this._gemConfig);
                        return u.DiamondMaterialUtility.applyMaterialUserDataMap(n, t),
                        u.DiamondMaterialUtility.refreshDiamondsEnvMap([n], this._diamondTextureEnvMap),
                        this._diamonds[e.id] = n,
                        n
                    }
                    ,
                    e.prototype.changeModelColor = function(e, t) {
                        var n = this;
                        r(e).forEach((function(e) {
                            e && e.material && e.material.color && (e.material.color = new i.Color(t.color),
                            e.material.envMapIntensity = t.envMapIntensity,
                            n._ssrPass.enabled = !1,
                            n.setDirty(),
                            setTimeout((function() {
                                n._ssrPass.enabled = !0,
                                n.setDirty()
                            }
                            ), 1e3))
                        }
                        ))
                    }
                    ,
                    e.prototype.refreshAllDiamonds = function(e, t) {
                        var n = e;
                        e.isCubeTexture ? (e = this._pmremGenerator.fromCubemap(e).texture,
                        this._diamondTextureEnvMap = n) : (e = this._pmremGenerator.fromEquirectangular(e).texture,
                        this._diamondTextureEnvMap = n),
                        u.DiamondMaterialUtility.refreshDiamondsEnvMap([t], this._diamondTextureEnvMap);
                        var r = this.cameraParams;
                        this.cameraParams = r
                    }
                    ,
                    e.prototype.exportGltf = function() {
                        return h.SceneExporter.exportGltf(this._objectContainer.children, [].concat.apply([], Object.values(this._diamonds)), this)
                    }
                    ,
                    Object.defineProperty(e.prototype, "sceneConfig", {
                        get: function() {
                            return {
                                rotation: this._objectContainer.rotation.toVector3().toArray(),
                                orientation: this.orientation.toArray(),
                                outline: this.outlineParams,
                                camera: this.cameraParams,
                                environment: this._originalEnvMap ? d.TextureExporter.exportTexture(this._originalEnvMap, {
                                    embedImages: !0,
                                    maxTextureSize: 2048
                                }) : null,
                                imageBasedLighting: this._imageBasedLighting,
                                background: this.environment == this.background ? "environment" : this._backgroundManager.toJson()
                            }
                        },
                        set: function(e) {
                            var t = this;
                            this._objectContainer.rotation.fromArray(e.rotation),
                            this.orientation = (new i.Vector3).fromArray(e.rotation),
                            this.outlineParams = e.outline,
                            this.cameraParams = e.camera,
                            null != e.environment && d.TextureExporter.importExported(e.environment).then((function(n) {
                                t.setSceneEnvironment(n, {
                                    setBackground: "environment" == e.background,
                                    imageBasedLighting: e.imageBasedLighting
                                })
                            }
                            )),
                            "object" == typeof e.background && this._backgroundManager.copyFromJson(e.background)
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.onDirty = function(e) {
                        this.onDirtyCallback_ = e
                    }
                    ,
                    Object.defineProperty(e.prototype, "dofParams", {
                        get: function() {
                            return {}
                        },
                        set: function(e) {},
                        enumerable: !1,
                        configurable: !0
                    }),
                    e
                }();
                t.SceneManager = y
            },
            7433: function(e, t, n) {
                "use strict";
                var r = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                ;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.aoApplyShader = void 0;
                var i = r(n(5301))
                  , a = r(n(9474));
                t.aoApplyShader = {
                    uniforms: {
                        tOcclusion: {
                            value: null
                        },
                        tDiffuse: {
                            value: null
                        },
                        useSao: {
                            value: 0
                        }
                    },
                    defines: {
                        PROJECTION_SPHERE_SIZE: 20.000001,
                        PLANER_SIZE_MULTIPLIER: 2.5,
                        MAX_LAYERS: 8
                    },
                    vertexShader: i.default,
                    fragmentShader: a.default
                }
            },
            3372: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.DiamondMaterialUtility = void 0;
                var r = n(2212)
                  , i = function() {
                    function e() {}
                    return e.isDiamondMaterial = function(t) {
                        return !!(t instanceof r.ShaderMaterial && t.uniforms.hasOwnProperty(e.propList[0]))
                    }
                    ,
                    e.absorbptionToColor = function(e) {
                        return "#" + new r.Color(1 - e.x,1 - e.y,1 - e.z).getHexString()
                    }
                    ,
                    e.colorToAbsorbption = function(e) {
                        var t = new r.Color(e);
                        return new r.Vector3(1 - t.r,1 - t.g,1 - t.b)
                    }
                    ,
                    e.getParams = function(e) {
                        for (var t = {}, n = this.getMaterialParams(e), r = 0, i = Object.entries(n); r < i.length; r++) {
                            var a = i[r]
                              , o = a[0]
                              , s = a[1];
                            t[o] = s.value
                        }
                        return {
                            color: this.absorbptionToColor(t.Absorbption),
                            boostFactors: t.boostFactors,
                            envMapIntensity: t.envMapIntensity,
                            refractiveIndex: t.refractiveIndex,
                            geometryFactor: t.geometryFactor,
                            absorbptionFactor: t.absorbptionFactor,
                            gammaFactor: t.gammaFactor,
                            rIndexDelta: t.rIndexDelta,
                            squashFactor: t.squashFactor,
                            isDiamond: !0
                        }
                    }
                    ,
                    e.setParams = function(e, t) {
                        if (!this.isDiamondMaterial(e))
                            return {};
                        var n = Object.assign({}, t);
                        n.color && (n.Absorbption = this.colorToAbsorbption(n.color),
                        delete n.color);
                        for (var r = 0, i = Object.entries(n); r < i.length; r++) {
                            var a = i[r]
                              , o = a[0]
                              , s = a[1];
                            this.setProperty(e, o, s, !1)
                        }
                        return this.refreshUniforms(e),
                        {}
                    }
                    ,
                    e.getMaterialParams = function(e) {
                        return e.userData && e.userData != {} || (e.userData = {
                            gltfExtensions: {}
                        }),
                        e.userData.gltfExtensions
                    }
                    ,
                    e.setMaterialParams = function(e, t) {
                        var n = e.userData.gltfExtensions;
                        n || (n = {});
                        for (var r = 0, i = this.propList; r < i.length; r++) {
                            var a = i[r];
                            void 0 !== t[a] && (n[a] = t[a])
                        }
                        e.userData.gltfExtensions = n,
                        this.refreshUniforms(e)
                    }
                    ,
                    e.processDiamondMaterial = function(e) {
                        var t = this.getMaterialParams(e);
                        t || (t = {});
                        for (var n = 0, r = this.propList; n < r.length; n++) {
                            var i = r[n];
                            t[i] || (t[i] = e.uniforms[i])
                        }
                        this.setMaterialParams(e, t)
                    }
                    ,
                    e.setProperty = function(t, n, r, i) {
                        void 0 === i && (i = !1),
                        t.userData.gltfExtensions.hasOwnProperty(n) && (t.userData.gltfExtensions[n].value = r,
                        i && e.refreshUniforms(t, n))
                    }
                    ,
                    e.refreshUniforms = function(e, t) {
                        void 0 === t && (t = "");
                        for (var n = e.userData.gltfExtensions, r = 0, i = "" !== t ? [[t, n[t]]] : Object.entries(n); r < i.length; r++) {
                            var a = i[r]
                              , o = a[0]
                              , s = a[1];
                            e.uniforms.hasOwnProperty(o) && s && (e.uniforms[o] = s)
                        }
                        e.uniformsNeedUpdate = !0,
                        e.needsUpdate = !0
                    }
                    ,
                    e.makeMaterialUserDataMap = function(t, n) {
                        return void 0 === n && (n = {}),
                        t.traverse((function(r) {
                            if (r != t) {
                                var i = r;
                                i.isMesh ? i.material && i.material.userData && i.material.userData.gltfExtensions && (n[r.id] = i.material.userData) : e.makeMaterialUserDataMap(r, n)
                            }
                        }
                        )),
                        n
                    }
                    ,
                    e.applyMaterialUserDataMap = function(e, t) {
                        e.forEach((function(e) {
                            var n = e.getMesh();
                            n && n.material && (n.material.userData = t[n.id],
                            n.material.uniforms.envMapIntensity.value = 2,
                            n.material.uniforms.boostFactors.value.x = 2,
                            n.material.uniforms.boostFactors.value.y = 2,
                            n.material.uniforms.boostFactors.value.z = 2.2,
                            n.material.needsUpdate = !0)
                        }
                        ))
                    }
                    ,
                    e.refreshDiamondsEnvMap = function(e, t) {
                        if (e && t)
                            for (var n = 0, r = e; n < r.length; n++)
                                r[n].forEach((function(e) {
                                    var n = e.getMesh();
                                    n.material && n.material.uniforms && (n.material.uniforms.envMap.value = t,
                                    n.material.envMap = t,
                                    n.material.needsUpdate = !0)
                                }
                                ))
                    }
                    ,
                    e.propList = ["boostFactors", "envMapIntensity", "geometryFactor", "gammaFactor", "absorbptionFactor", "refractiveIndex", "rIndexDelta", "squashFactor", "Absorbption"],
                    e
                }();
                t.DiamondMaterialUtility = i
            }
            ,
            4506: (e,t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.parseFileExtension = void 0,
                t.parseFileExtension = function(e) {
                    var t;
                    if (!e || "" === e)
                        return "";
                    var n = null !== (t = e.split(/[\\/]/).pop()) && void 0 !== t ? t : ""
                      , r = n.lastIndexOf(".");
                    return "" === n || r < 1 ? "" : n.slice(r + 1)
                }
            }
            ,
            8975: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.MaterialUtils = void 0;
                var r = n(2212)
                  , i = n(3372)
                  , a = n(2049)
                  , o = n(7137)
                  , s = function() {
                    function e() {}
                    return e.setMaterialParams = function(e, t) {
                        if (e.hasOwnProperty("material")) {
                            var n = e.material;
                            t.isDiamond ? i.DiamondMaterialUtility.setParams(n, t) : a.StandardMaterialUtility.setParams(n, t),
                            n.needsUpdate = !0
                        }
                    }
                    ,
                    e.getParams = function(e) {
                        var t = e;
                        return i.DiamondMaterialUtility.isDiamondMaterial(t) ? i.DiamondMaterialUtility.getParams(t) : a.StandardMaterialUtility.getParams(t)
                    }
                    ,
                    e.getMaterialParams = function(e) {
                        if (!e.hasOwnProperty("material"))
                            return {};
                        var t = e.material;
                        return this.getParams(t)
                    }
                    ,
                    e.fullyDisposeMaterial = function(e) {
                        for (var t, n = e, r = 0, i = ["map", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "roughnessMap", "metalnessMap", "alphaMap", "envMap"]; r < i.length; r++) {
                            var a = i[r];
                            n.hasOwnProperty(a) && "function" == typeof (null === (t = n[a]) || void 0 === t ? void 0 : t.dispose) && n[a].dispose()
                        }
                        e.dispose(),
                        e = void 0,
                        n = void 0
                    }
                    ,
                    e.exportMaterialParams = function(e) {
                        return new Promise((function(t, n) {
                            for (var r = {}, i = {
                                k: [],
                                t: []
                            }, a = 0, s = Object.entries(e); a < s.length; a++) {
                                var l = s[a]
                                  , c = l[0]
                                  , u = l[1];
                                u && u.isTexture ? (i.k.push(c),
                                i.t.push(u)) : r[c] = u
                            }
                            if (i.k.length > 0) {
                                var h = new o.TextureExporter
                                  , d = h.exportTextures(i.t, {
                                    embedImages: !0,
                                    maxTextureSize: 2048
                                });
                                h.dispose();
                                for (var p = 0; p < i.k.length; p++)
                                    r[i.k[p]] = d.textures[p];
                                r.images = d.images
                            }
                            t(JSON.stringify(r))
                        }
                        ))
                    }
                    ,
                    e.importMaterialParams = function(e, t) {
                        var n = JSON.parse(e);
                        n.normalScale && (n.normalScale = new r.Vector2(n.normalScale[0],n.normalScale[1]));
                        var i = n.images;
                        return !i || i.length <= 0 ? Promise.resolve(n) : new Promise((function(e, r) {
                            for (var a = [], s = 0, l = i; s < l.length; s++) {
                                var c = l[s]
                                  , u = t.import(c.data, (function(e) {}
                                ), {
                                    extension: c.mimeType
                                });
                                a.push(u)
                            }
                            Promise.all(a).then((function(t) {
                                console.log(t),
                                Object.keys(n).forEach((function(e) {
                                    var r = n[e];
                                    if (r && r.isTexture) {
                                        var i = t[r.source];
                                        o.TextureExporter.applySampler(r.sampler, i),
                                        i.name && (i.name = r.name),
                                        n[e] = i
                                    }
                                }
                                )),
                                delete n.images,
                                e(n)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    e
                }();
                t.MaterialUtils = s
            }
            ,
            8442: (e,t,n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.Object3DUtility = void 0;
                var r = n(3372)
                  , i = n(8975)
                  , a = n(5377)
                  , o = function() {
                    function e() {}
                    return e.processImportedObject = function(t) {
                        e.processMeshesInObject(t)
                    }
                    ,
                    e.processMeshesInObject = function(t) {
                        var n = this;
                        t.traverse((function(r) {
                            var i;
                            r !== t && (r.type.includes("Mesh") && (i = r) ? (i.castShadow = !0,
                            i.receiveShadow = !0,
                            i.material = n.processMaterial(i.material)) : e.processMeshesInObject(r))
                        }
                        ))
                    }
                    ,
                    e.processMaterial = function(t) {
                        var n = Array.isArray(t) ? t[0] : t;
                        if (r.DiamondMaterialUtility.isDiamondMaterial(n))
                            return r.DiamondMaterialUtility.processDiamondMaterial(n),
                            n;
                        var i = {}
                          , o = new a.MeshReflectiveMaterial(i,e.ssrPass);
                        if (n) {
                            for (var s = 0, l = ["userData", "name", "color", "roughness", "metalness", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "normalScale", "displacementMap", "displacementScale", "displacementBias", "roughnessMap", "metalnessMap", "alphaMap", "envMap", "envMapIntensity", "refractionRatio", "wireframe", "wireframeLinewidth", "skinning", "vertexTangents", "morphTargets", "morphNormals"]; s < l.length; s++) {
                                var c = l[s];
                                n.hasOwnProperty(c) && (i[c] = n[c])
                            }
                            n.shininess | n.glossiness && !n.roughness && (i.roughness = 1 - (n.shininess | n.glossiness)),
                            n.dispose()
                        }
                        return o.setValues(i),
                        o
                    }
                    ,
                    e.fullyDisposeObject = function(t) {
                        t.traverse((function(n) {
                            t !== n && e.fullyDisposeObject(n)
                        }
                        ));
                        var n = t;
                        if (n.geometry && (n.geometry.dispose(),
                        n.geometry = void 0),
                        n.material) {
                            if (n.material.length)
                                for (var r = 0; r < n.material.length; ++r)
                                    i.MaterialUtils.fullyDisposeMaterial(n.material[r]),
                                    n.material[r].dispose(),
                                    n.material[r] = void 0,
                                    console.log(n, "disposed mat");
                            else
                                i.MaterialUtils.fullyDisposeMaterial(n.material);
                            n.material = void 0,
                            n = void 0
                        }
                    }
                    ,
                    e.ssrPass = null,
                    e
                }();
                t.Object3DUtility = o
            }
            ,
            4796: function(e, t, n) {
                "use strict";
                var r = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                ;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.RotationHelper = void 0;
                var i = n(2212)
                  , a = r(n(6194))
                  , o = function() {
                    function e() {}
                    return e.rotateObject = function(e, t, n, r, i, a, o, s) {
                        void 0 === i && (i = !0),
                        void 0 === a && (a = function() {}
                        ),
                        void 0 === o && (o = !1);
                        var l = t;
                        o && e.position.applyAxisAngle(n, l),
                        e.rotateOnWorldAxis(n, l),
                        a(),
                        s()
                    }
                    ,
                    e.lerpRotateObject = function(e, t, n, r) {
                        void 0 === r && (r = function() {}
                        );
                        var o = 0
                          , s = (new i.Quaternion).copy(e.quaternion)
                          , l = new a.default.Tween({
                            t: o
                        }).to({
                            t: 1
                        }, 1e3 * n).onUpdate((function(n) {
                            i.Quaternion.slerp(s, t, e.quaternion, n.t),
                            o = n.t,
                            r()
                        }
                        )).onComplete((function(n) {
                            e.quaternion.copy(t)
                        }
                        ));
                        return s && l.start(),
                        l
                    }
                    ,
                    e
                }();
                t.RotationHelper = o
            },
            2592: (e,t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.SnapshotHelper = void 0;
                var n = function() {
                    function e() {}
                    return e.getSnapshotData = function(e, t) {
                        return t = null != t ? t : "image/png",
                        e.domElement.toDataURL(t, 1)
                    }
                    ,
                    e.getSnapshot = function(e, t) {
                        var n, r, i = this.getSnapshotData(e, t.mimeType), a = null !== (n = t.context) && void 0 !== n ? n : null === (r = t.canvas) || void 0 === r ? void 0 : r.getContext("2d");
                        return a ? new Promise((function(e, t) {
                            var n = new Image;
                            n.onload = function() {
                                null == a || a.drawImage(n, 0, 0, a.canvas.width, a.canvas.height),
                                e(i)
                            }
                            ,
                            n.src = i
                        }
                        )) : Promise.resolve(i)
                    }
                    ,
                    e
                }();
                t.SnapshotHelper = n
            }
            ,
            2049: (e,t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.StandardMaterialUtility = void 0;
                var n = function() {
                    function e() {}
                    return e.getParams = function(e) {
                        var t, n, r = e;
                        return {
                            color: "#" + r.color.getHexString(),
                            roughness: null !== (t = r.roughness) && void 0 !== t ? t : 1 - r.glossiness,
                            metalness: null !== (n = r.metalness) && void 0 !== n ? n : 0,
                            map: r.map,
                            lightMap: r.lightMap,
                            lightMapIntensity: r.lightMapIntensity,
                            aoMap: r.aoMap,
                            aoMapIntensity: r.aoMapIntensity,
                            emissive: "#" + r.emissive.getHexString(),
                            emissiveIntensity: r.emissiveIntensity,
                            emissiveMap: r.emissiveMap,
                            bumpMap: r.bumpMap,
                            bumpScale: r.bumpScale,
                            normalMap: r.normalMap,
                            normalScale: r.normalScale.toArray(),
                            displacementMap: r.displacementMap,
                            displacementScale: r.displacementScale,
                            displacementBias: r.displacementBias,
                            roughnessMap: r.roughnessMap,
                            metalnessMap: r.metalnessMap,
                            alphaMap: r.alphaMap,
                            envMap: r.envMap,
                            envMapIntensity: r.envMapIntensity,
                            refractionRatio: r.refractionRatio,
                            wireframe: r.wireframe,
                            wireframeLinewidth: r.wireframeLinewidth,
                            skinning: r.skinning,
                            vertexTangents: r.vertexTangents,
                            morphTargets: r.morphTargets,
                            morphNormals: r.morphNormals
                        }
                    }
                    ,
                    e.setParams = function(e, t) {
                        Array.isArray(t.normalScale) && (void 0 !== t.normalScale[0] && e.normalScale.fromArray(t.normalScale),
                        delete t.normalScale),
                        e.setValues(t),
                        t.normalScale = [e.normalScale.x, e.normalScale.y]
                    }
                    ,
                    e
                }();
                t.StandardMaterialUtility = n
            }
            ,
            1559: function(e, t, n) {
                "use strict";
                var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n),
                    Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n]
                        }
                    })
                }
                : function(e, t, n, r) {
                    void 0 === r && (r = n),
                    e[r] = t[n]
                }
                )
                  , i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                }
                : function(e, t) {
                    e.default = t
                }
                )
                  , a = this && this.__importStar || function(e) {
                    if (e && e.__esModule)
                        return e;
                    var t = {};
                    if (null != e)
                        for (var n in e)
                            "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                    return i(t, e),
                    t
                }
                ;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }),
                t.Viewer = void 0;
                var o = a(n(2212))
                  , s = n(2212)
                  , l = n(2050)
                  , c = n(1334)
                  , u = n(5351)
                  , h = n(7433)
                  , d = n(5980)
                  , p = n(16)
                  , f = n(5268)
                  , m = n(4717)
                  , g = function() {
                    function e(t) {
                        this._ssAccIndex = 0,
                        this.needsUpdate = !0,
                        this._renderEnabled = !0,
                        this._canvas = t.canvas,
                        this._renderer = new o.WebGLRenderer({
                            canvas: t.canvas,
                            antialias: !0,
                            alpha: !0,
                            premultipliedAlpha: !1,
                            preserveDrawingBuffer: !0
                        }),
                        this._renderer.setSize(t.canvas.clientWidth, t.canvas.clientHeight),
                        this._renderer.toneMapping = o.NoToneMapping,
                        this._renderer.toneMappingExposure = 1,
                        this._renderer.outputEncoding = o.sRGBEncoding,
                        this._renderer.shadowMap.enabled = !0,
                        this._renderer.shadowMap.type = o.PCFSoftShadowMap,
                        this._composer = new l.EffectComposer(this._renderer),
                        this._clearPass = new c.ClearPass,
                        this._clearPass.clear = !0,
                        this.addPass(this._clearPass, 0),
                        this._saoPass = new u.SAOPass({
                            falloff: 2,
                            occlusionWorldRadius: 3.09,
                            intensity: .65,
                            bias: .001,
                            blurEnabled: !0
                        }),
                        this._gbufferPass = new p.GBuffer({}),
                        this._ssaoMultiplyPass = new d.ShaderPass(h.aoApplyShader),
                        this.addPass(this._ssaoMultiplyPass, 3),
                        this._superSamplePass = new f.SuperSample,
                        this._superSamplePass.setSize(t.canvas.clientWidth, t.canvas.clientHeight),
                        this.addPass(this._superSamplePass, 6),
                        this._canvas.addEventListener("click", (function() {
                            var e = document.getElementById("helper-popup");
                            e && (e.style.display = "none")
                        }
                        )),
                        this._canvas.addEventListener("dblclick", (function() {
                            var e = document.getElementById("helper-popup");
                            e && (e.style.display = "none")
                        }
                        ));
                        var n = new d.ShaderPass(m.GammaCorrectionShader);
                        n.needsSwap = !1,
                        n.renderToScreen = !0,
                        this.addPass(n, 8),
                        e.initSupersamples()
                    }
                    return Object.defineProperty(e.prototype, "pixelratio", {
                        set: function(e) {
                            this.renderer.setPixelRatio(e),
                            this._composer.setPixelRatio(e)
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "renderEnabled", {
                        get: function() {
                            return this._renderEnabled
                        },
                        set: function(e) {
                            this._renderEnabled = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.setDirty = function() {
                        this._superSamplePass.enabled && (this._superSamplePass.needsUpdate = !0),
                        this._ssAccIndex = 0,
                        this.needsUpdate = !0
                    }
                    ,
                    Object.defineProperty(e.prototype, "exposure", {
                        get: function() {
                            return this._renderer.toneMappingExposure
                        },
                        set: function(e) {
                            this._renderer.toneMappingExposure = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.addPass = function(e, t) {
                        void 0 === t ? this._composer.addPass(e) : this._composer.insertPass(e, t)
                    }
                    ,
                    e.prototype.setSize = function(e, t) {
                        this._renderer.setSize(e, t),
                        this._composer.setSize(e, t),
                        this._gbufferPass.setSize(e, t),
                        this._saoPass.setSize(e, t),
                        this.setDirty()
                    }
                    ,
                    Object.defineProperty(e.prototype, "renderConfig", {
                        get: function() {
                            return {
                                ssao: this.ssaoParams
                            }
                        },
                        set: function(e) {
                            this.ssaoParams = e.ssao
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    Object.defineProperty(e.prototype, "ssaoParams", {
                        get: function() {
                            var e;
                            return {
                                enabled: this._ssaoMultiplyPass.enabled,
                                enableDebug: 1 == this._ssaoMultiplyPass.uniforms.useSao.value,
                                intensity: this._saoPass.intensity,
                                radius: this._saoPass.radius,
                                downscaleLevel: null !== (e = this._saoPass.downscaleLevel_) && void 0 !== e ? e : 1
                            }
                        },
                        set: function(e) {
                            null != e.enabled && (this._saoPass.enabled = e.enabled,
                            this._ssaoMultiplyPass.enabled = e.enabled),
                            null != e.enableDebug && (this._ssaoMultiplyPass.uniforms.useSao.value = e.enableDebug ? 1 : 0),
                            null != e.intensity && (this._saoPass.intensity = e.intensity),
                            null != e.radius && (this._saoPass.radius = e.radius),
                            null != e.downscaleLevel && this._saoPass.setDownscaleLevel(e.downscaleLevel),
                            e !== {} && this.setDirty()
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.preRender = function(e) {
                        if (e.preRender(),
                        !this._renderEnabled)
                            return !1;
                        var t = this._superSamplePass.enabled && !this.isSuperSamplingConverged();
                        return t && this.applyCameraPerturbation(e),
                        t || this.needsUpdate
                    }
                    ,
                    e.prototype.postRender = function(e) {
                        e.postRender(),
                        this.needsUpdate = !1,
                        this._ssAccIndex++
                    }
                    ,
                    e.prototype.render = function(e) {
                        this.preRender(e) && (this._ssaoMultiplyPass.enabled && this.updateSAO(e),
                        this._composer.render(),
                        this.postRender(e))
                    }
                    ,
                    Object.defineProperty(e.prototype, "renderer", {
                        get: function() {
                            return this._renderer
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.prototype.updateSAO = function(e) {
                        this.renderer.autoClear = !0,
                        this._gbufferPass.render(this.renderer, e.scene, e.camera),
                        this._saoPass.render(this.renderer, e.camera, this._gbufferPass),
                        this._ssaoMultiplyPass.uniforms.tOcclusion.value = this._saoPass.getRenderTarget().texture,
                        this.renderer.autoClear = !1
                    }
                    ,
                    e.prototype.applyCameraPerturbation = function(t) {
                        if (this._superSamplePass.enabled) {
                            var n = new s.Vector2;
                            this.renderer.getDrawingBufferSize(n);
                            var r = e._superSamples[this._ssAccIndex % e._superSamples.length];
                            t.camera.setViewOffset(n.width, n.height, r.x, r.y, n.width, n.height)
                        }
                    }
                    ,
                    e.prototype.isSuperSamplingConverged = function() {
                        return this._ssAccIndex / e._superSamples.length >= 1
                    }
                    ,
                    Object.defineProperty(e.prototype, "enableSupersample", {
                        get: function() {
                            return this._superSamplePass.enabled
                        },
                        set: function(e) {
                            console.log("super sample enabled: " + e),
                            this._superSamplePass.enabled = e,
                            this.needsUpdate = !0
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e.initSupersamples = function() {
                        this._superSamples = [],
                        this._superSamples.push(new s.Vector2(0,0)),
                        this._superSamples.push(new s.Vector2(-8,0).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-6,-4).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-3,-2).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-2,-6).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(1,-1).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(2,-5).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(6,-7).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(5,-3).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(4,1).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(7,4).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(3,5).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(0,7).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-1,3).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-4,6).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-7,8).multiplyScalar(1 / 16)),
                        this._superSamples.push(new s.Vector2(-5,2).multiplyScalar(1 / 16))
                    }
                    ,
                    Object.defineProperty(e.prototype, "gbufferPass", {
                        get: function() {
                            return this._gbufferPass
                        },
                        enumerable: !1,
                        configurable: !0
                    }),
                    e._superSamples = [],
                    e
                }();
                t.Viewer = g
            },
            2480: ()=>{}
        }
          , t = {};
        function n(r) {
            var i = t[r];
            if (void 0 !== i)
                return i.exports;
            var a = t[r] = {
                exports: {}
            };
            return e[r].call(a.exports, a, a.exports, n),
            a.exports
        }
        n.d = (e,t)=>{
            for (var r in t)
                n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
                    enumerable: !0,
                    get: t[r]
                })
        }
        ,
        n.g = function() {
            if ("object" == typeof globalThis)
                return globalThis;
            try {
                return this || new Function("return this")()
            } catch (e) {
                if ("object" == typeof window)
                    return window
            }
        }(),
        n.o = (e,t)=>Object.prototype.hasOwnProperty.call(e, t),
        n.r = e=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }),
            Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }
        ;
        var r = {};
        return (()=>{
            "use strict";
            var e = r;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }),
            e.Editor = void 0;
            var t = n(1384);
            Object.defineProperty(e, "Editor", {
                enumerable: !0,
                get: function() {
                    return t.Editor
                }
            })
        }
        )(),
        r
    }
    )()
}
));
